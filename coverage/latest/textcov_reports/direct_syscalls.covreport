_RINvXs_NtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6option6OptionTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReECs4ieSHZHrxF6_15direct_syscalls:
   91|    163|    fn context<C>(self, context: C) -> Result<T, Error>
   92|    163|    where
   93|    163|        C: Display + Send + Sync + 'static,
   94|    163|    {
   95|    163|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|    163|    }
_RINvXs_NtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6option6OptionRINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReECs4ieSHZHrxF6_15direct_syscalls:
   91|    978|    fn context<C>(self, context: C) -> Result<T, Error>
   92|    978|    where
   93|    978|        C: Display + Send + Sync + 'static,
   94|    978|    {
   95|    978|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|    978|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultbNtB5_5ErrorEINtB5_7ContextbB1b_E7contextReECs4ieSHZHrxF6_15direct_syscalls:
   46|    163|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    163|    where
   48|    163|        C: Display + Send + Sync + 'static,
   49|    163|    {
   50|    163|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    163|        // in ext_context.
   52|    163|        match self {
   53|    163|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    163|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamt4HamtINtNtNtCsheoVkkQew6K_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtB1Z_10state_tree10ActorStateENtNtB1f_5error5ErrorEINtB5_7ContextB1a_B4w_E7contextReECs4ieSHZHrxF6_15direct_syscalls:
   46|    163|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    163|    where
   48|    163|        C: Display + Send + Sync + 'static,
   49|    163|    {
   50|    163|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    163|        // in ext_context.
   52|    163|        match self {
   53|    163|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    163|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_ENtB5_5ErrorEINtB5_7ContextB1a_B1L_E7contextNtNtCs9ModpadCpa2_21fvm_integration_tests5error5ErrorECs4ieSHZHrxF6_15direct_syscalls:
   46|    163|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    163|    where
   48|    163|        C: Display + Send + Sync + 'static,
   49|    163|    {
   50|    163|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    163|        // in ext_context.
   52|    163|        match self {
   53|    163|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    163|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultNtNtNtCsheoVkkQew6K_3fvm7machine8manifest8ManifestNtB5_5ErrorEINtB5_7ContextB1a_B1Y_E7contextNtNtCs9ModpadCpa2_21fvm_integration_tests5error5ErrorECsilvC8qPft2D_8fvm_fuzz:
   46|    163|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    163|    where
   48|    163|        C: Display + Send + Sync + 'static,
   49|    163|    {
   50|    163|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    163|        // in ext_context.
   52|    163|        match self {
   53|    163|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    163|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_ENtB5_5ErrorEINtB5_7ContextB1a_B1L_E7contextReECsilvC8qPft2D_8fvm_fuzz:
   46|    163|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    163|    where
   48|    163|        C: Display + Send + Sync + 'static,
   49|    163|    {
   50|    163|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    163|        // in ext_context.
   52|    163|        match self {
   53|    163|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    163|    }
_RINvXs_NtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6option6OptionRINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReECsilvC8qPft2D_8fvm_fuzz:
   91|    978|    fn context<C>(self, context: C) -> Result<T, Error>
   92|    978|    where
   93|    978|        C: Display + Send + Sync + 'static,
   94|    978|    {
   95|    978|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|    978|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultuNtB5_5ErrorEINtB5_7ContextuB1b_E7contextNtNtCs9ModpadCpa2_21fvm_integration_tests5error5ErrorECsilvC8qPft2D_8fvm_fuzz:
   46|    489|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    489|    where
   48|    489|        C: Display + Send + Sync + 'static,
   49|    489|    {
   50|    489|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    489|        // in ext_context.
   52|    489|        match self {
   53|    489|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    489|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_ENtB5_5ErrorEINtB5_7ContextB1a_B1L_E7contextNtNtCs9ModpadCpa2_21fvm_integration_tests5error5ErrorECsilvC8qPft2D_8fvm_fuzz:
   46|    489|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    489|    where
   48|    489|        C: Display + Send + Sync + 'static,
   49|    489|    {
   50|    489|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    489|        // in ext_context.
   52|    489|        match self {
   53|    489|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    489|    }
_RINvXs_NtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6option6OptionRNtNtCsheoVkkQew6K_3fvm10state_tree14StateSnapLayerEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReEB1h_:
   91|    489|    fn context<C>(self, context: C) -> Result<T, Error>
   92|    489|    where
   93|    489|        C: Display + Send + Sync + 'static,
   94|    489|    {
   95|    489|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|    489|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultONtNtBD_3ffi6c_voidNtNtNtNtCs9Er17ssDkOt_6rustix7backend2io5errno5ErrnoEINtB5_7ContextB1a_B1t_E7contextNtNtCs71iYhC60HpU_5alloc6string6StringECsfBAxPD3lkOv_16wasmtime_runtime:
   46|  1.30k|    fn context<C>(self, context: C) -> Result<T, Error>
   47|  1.30k|    where
   48|  1.30k|        C: Display + Send + Sync + 'static,
   49|  1.30k|    {
   50|  1.30k|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|  1.30k|        // in ext_context.
   52|  1.30k|        match self {
   53|  1.30k|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|  1.30k|    }
_RINvXNtCslfc1tI9p8hD_6anyhow7contextINtNtCsdRJjCzU6nMS_4core6result6ResultNtNtCsfBAxPD3lkOv_16wasmtime_runtime4mmap4MmapNtB5_5ErrorEINtB5_7ContextB1a_B1U_E7contextReEB1e_:
   46|    978|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    978|    where
   48|    978|        C: Display + Send + Sync + 'static,
   49|    978|    {
   50|    978|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    978|        // in ext_context.
   52|    978|        match self {
   53|    978|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    978|    }

_RINvCsix46vuaHCJW_9arbitrary16try_create_arrayNCNvXs8_B2_Ahj186a0_NtB2_9Arbitrary9arbitrary0hKBV_ECs4ieSHZHrxF6_15direct_syscalls:
  614|    163|fn try_create_array<F, T, const N: usize>(mut cb: F) -> Result<[T; N]>
  615|    163|where
  616|    163|    F: FnMut(usize) -> Result<T>,
  617|    163|{
  618|    163|    let mut array: mem::MaybeUninit<[T; N]> = mem::MaybeUninit::uninit();
  619|    163|    let array_ptr = array.as_mut_ptr();
  620|    163|    let dst = array_ptr as _;
  621|    163|    let mut guard: ArrayGuard<T, N> = ArrayGuard {
  622|    163|        dst,
  623|    163|        initialized: 0,
  624|    163|    };
  625|       |    unsafe {
  626|  16.3M|        for (idx, value_ptr) in (*array.as_mut_ptr()).iter_mut().enumerate() {
  627|  16.3M|            core::ptr::write(value_ptr, cb(idx)?);
  628|  16.3M|            guard.initialized += 1;
  629|       |        }
  630|    163|        mem::forget(guard);
  631|    163|        Ok(array.assume_init())
  632|       |    }
  633|    163|}
_RINvCsix46vuaHCJW_9arbitrary16try_create_arrayNCNvXs8_B2_Amja_NtB2_9Arbitrary9arbitrary0mKBV_ECs4ieSHZHrxF6_15direct_syscalls:
  614|    163|fn try_create_array<F, T, const N: usize>(mut cb: F) -> Result<[T; N]>
  615|    163|where
  616|    163|    F: FnMut(usize) -> Result<T>,
  617|    163|{
  618|    163|    let mut array: mem::MaybeUninit<[T; N]> = mem::MaybeUninit::uninit();
  619|    163|    let array_ptr = array.as_mut_ptr();
  620|    163|    let dst = array_ptr as _;
  621|    163|    let mut guard: ArrayGuard<T, N> = ArrayGuard {
  622|    163|        dst,
  623|    163|        initialized: 0,
  624|    163|    };
  625|       |    unsafe {
  626|  1.63k|        for (idx, value_ptr) in (*array.as_mut_ptr()).iter_mut().enumerate() {
  627|  1.63k|            core::ptr::write(value_ptr, cb(idx)?);
  628|  1.63k|            guard.initialized += 1;
  629|       |        }
  630|    163|        mem::forget(guard);
  631|    163|        Ok(array.assume_init())
  632|       |    }
  633|    163|}
_RNCNvXs8_Csix46vuaHCJW_9arbitraryAhj186a0_NtB7_9Arbitrary9arbitrary0Cs4ieSHZHrxF6_15direct_syscalls:
  641|  16.3M|        try_create_array(|_| <T as Arbitrary<'a>>::arbitrary(u))
_RNCNvXs8_Csix46vuaHCJW_9arbitraryAmja_NtB7_9Arbitrary9arbitrary0Cs4ieSHZHrxF6_15direct_syscalls:
  641|  1.63k|        try_create_array(|_| <T as Arbitrary<'a>>::arbitrary(u))
_RNvXs8_Csix46vuaHCJW_9arbitraryAhj186a0_NtB5_9Arbitrary9arbitraryCs4ieSHZHrxF6_15direct_syscalls:
  640|    163|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  641|    163|        try_create_array(|_| <T as Arbitrary<'a>>::arbitrary(u))
  642|    163|    }
_RNvXs8_Csix46vuaHCJW_9arbitraryAmja_NtB5_9Arbitrary9arbitraryCs4ieSHZHrxF6_15direct_syscalls:
  640|    163|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  641|    163|        try_create_array(|_| <T as Arbitrary<'a>>::arbitrary(u))
  642|    163|    }
_RNvXsJ_Csix46vuaHCJW_9arbitraryoNtB5_9Arbitrary9arbitrary:
  309|    163|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    163|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    163|                    u.fill_buffer(&mut buf)?;
  312|    163|                    let mut x: $unsigned = 0;
  313|  2.60k|                    for i in 0..mem::size_of::<$ty>() {
  314|  2.60k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  2.60k|                    }
  316|    163|                    Ok(x as $ty)
  317|    163|                }
_RNvXsF_Csix46vuaHCJW_9arbitraryhNtB5_9Arbitrary9arbitrary:
  309|  16.3M|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  16.3M|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  16.3M|                    u.fill_buffer(&mut buf)?;
  312|  16.3M|                    let mut x: $unsigned = 0;
  313|  16.3M|                    for i in 0..mem::size_of::<$ty>() {
  314|  16.3M|                        x |= buf[i] as $unsigned << (i * 8);
  315|  16.3M|                    }
  316|  16.3M|                    Ok(x as $ty)
  317|  16.3M|                }
_RNvXsH_Csix46vuaHCJW_9arbitrarymNtB5_9Arbitrary9arbitrary:
  309|  1.95k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  1.95k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  1.95k|                    u.fill_buffer(&mut buf)?;
  312|  1.95k|                    let mut x: $unsigned = 0;
  313|  7.82k|                    for i in 0..mem::size_of::<$ty>() {
  314|  7.82k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  7.82k|                    }
  316|  1.95k|                    Ok(x as $ty)
  317|  1.95k|                }
_RNvXsI_Csix46vuaHCJW_9arbitraryyNtB5_9Arbitrary9arbitrary:
  309|  1.14k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  1.14k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  1.14k|                    u.fill_buffer(&mut buf)?;
  312|  1.14k|                    let mut x: $unsigned = 0;
  313|  9.12k|                    for i in 0..mem::size_of::<$ty>() {
  314|  9.12k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  9.12k|                    }
  316|  1.14k|                    Ok(x as $ty)
  317|  1.14k|                }
_RNvXsO_Csix46vuaHCJW_9arbitraryxNtB5_9Arbitrary9arbitrary:
  309|    163|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    163|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    163|                    u.fill_buffer(&mut buf)?;
  312|    163|                    let mut x: $unsigned = 0;
  313|  1.30k|                    for i in 0..mem::size_of::<$ty>() {
  314|  1.30k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  1.30k|                    }
  316|    163|                    Ok(x as $ty)
  317|    163|                }

_RINvMNtCsix46vuaHCJW_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryyECs4ieSHZHrxF6_15direct_syscalls:
  167|  1.14k|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|  1.14k|    where
  169|  1.14k|        A: Arbitrary<'a>,
  170|  1.14k|    {
  171|  1.14k|        <A as Arbitrary<'a>>::arbitrary(self)
  172|  1.14k|    }
_RINvMNtCsix46vuaHCJW_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryAhj186a0_ECs4ieSHZHrxF6_15direct_syscalls:
  167|    163|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    163|    where
  169|    163|        A: Arbitrary<'a>,
  170|    163|    {
  171|    163|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    163|    }
_RINvMNtCsix46vuaHCJW_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryAmja_ECs4ieSHZHrxF6_15direct_syscalls:
  167|    163|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    163|    where
  169|    163|        A: Arbitrary<'a>,
  170|    163|    {
  171|    163|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    163|    }
_RINvMNtCsix46vuaHCJW_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryoECs4ieSHZHrxF6_15direct_syscalls:
  167|    163|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    163|    where
  169|    163|        A: Arbitrary<'a>,
  170|    163|    {
  171|    163|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    163|    }
_RINvMNtCsix46vuaHCJW_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryxECs4ieSHZHrxF6_15direct_syscalls:
  167|    163|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    163|    where
  169|    163|        A: Arbitrary<'a>,
  170|    163|    {
  171|    163|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    163|    }
_RINvMNtCsix46vuaHCJW_9arbitrary12unstructuredNtB3_12Unstructured9arbitrarymECs4ieSHZHrxF6_15direct_syscalls:
  167|    326|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    326|    where
  169|    326|        A: Arbitrary<'a>,
  170|    326|    {
  171|    326|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    326|    }
_RNvMNtCsix46vuaHCJW_9arbitrary12unstructuredNtB2_12Unstructured3new:
   85|    163|    pub fn new(data: &'a [u8]) -> Self {
   86|    163|        Unstructured { data }
   87|    163|    }
_RNvMNtCsix46vuaHCJW_9arbitrary12unstructuredNtB2_12Unstructured11fill_buffer:
  521|  16.3M|    pub fn fill_buffer(&mut self, buffer: &mut [u8]) -> Result<()> {
  522|  16.3M|        let n = std::cmp::min(buffer.len(), self.data.len());
  523|  16.3M|        buffer[..n].copy_from_slice(&self.data[..n]);
  524|  16.3M|        for byte in buffer[n..].iter_mut() {
  525|  16.3M|            *byte = 0;
  526|  16.3M|        }
  527|  16.3M|        self.data = &self.data[n..];
  528|  16.3M|        Ok(())
  529|  16.3M|    }

_RINvNvNtCskpYemKvT16c_12blake2b_simd4guts11final_block8as_arrayhEB6_:
   61|    163|            unsafe fn as_array<T>(slice: &[T]) -> &[T; $len] {
   62|    163|                &*(slice.as_ptr() as *const [_; $len])
   63|    163|            }
_RINvNvMCskpYemKvT16c_12blake2b_simdNtB5_6Params8to_words9as_arrayshEB5_:
  143|  1.14k|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|  1.14k|                let mut p = a.as_ptr();
  145|  1.14k|                ( $( {
  146|  1.14k|                    let aref = &*(p as *const [T; $len]);
  147|  1.14k|                    p = p.offset($len as isize);
  148|  1.14k|                    aref
  149|  1.14k|                } ),* )
  150|  1.14k|            }
_RINvNvNtCskpYemKvT16c_12blake2b_simd4avx214compress_block9as_arraysyEB6_:
  240|  1.46k|            unsafe fn as_arrays<T>(a: &mut [T; $( $len + )* 0 ]) -> ( $( &mut [T; $len], )* ) {
  241|  1.46k|                let mut p = a.as_mut_ptr();
  242|  1.46k|                ( $( {
  243|  1.46k|                    let aref = &mut *(p as *mut [T; $len]);
  244|  1.46k|                    p = p.offset($len as isize);
  245|  1.46k|                    aref
  246|  1.46k|                } ),* )
  247|  1.46k|            }
_RINvNvNtCskpYemKvT16c_12blake2b_simd4avx214compress_blocks_9as_arraysyEB6_:
  143|  1.46k|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|  1.46k|                let mut p = a.as_ptr();
  145|  1.46k|                ( $( {
  146|  1.46k|                    let aref = &*(p as *const [T; $len]);
  147|  1.46k|                    p = p.offset($len as isize);
  148|  1.46k|                    aref
  149|  1.46k|                } ),* )
  150|  1.46k|            }
_RINvNvNtCskpYemKvT16c_12blake2b_simd4avx214compress_blocks0_9as_arrayshEB6_:
  143|  1.46k|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|  1.46k|                let mut p = a.as_ptr();
  145|  1.46k|                ( $( {
  146|  1.46k|                    let aref = &*(p as *const [T; $len]);
  147|  1.46k|                    p = p.offset($len as isize);
  148|  1.46k|                    aref
  149|  1.46k|                } ),* )
  150|  1.46k|            }
_RINvNvMCskpYemKvT16c_12blake2b_simdNtB5_6Params8to_wordss_9as_arrayshEB5_:
  143|  1.14k|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|  1.14k|                let mut p = a.as_ptr();
  145|  1.14k|                ( $( {
  146|  1.14k|                    let aref = &*(p as *const [T; $len]);
  147|  1.14k|                    p = p.offset($len as isize);
  148|  1.14k|                    aref
  149|  1.14k|                } ),* )
  150|  1.14k|            }
_RINvNvCskpYemKvT16c_12blake2b_simd20state_words_to_bytes9as_arrayshEB4_:
  240|  1.14k|            unsafe fn as_arrays<T>(a: &mut [T; $( $len + )* 0 ]) -> ( $( &mut [T; $len], )* ) {
  241|  1.14k|                let mut p = a.as_mut_ptr();
  242|  1.14k|                ( $( {
  243|  1.14k|                    let aref = &mut *(p as *mut [T; $len]);
  244|  1.14k|                    p = p.offset($len as isize);
  245|  1.14k|                    aref
  246|  1.14k|                } ),* )
  247|  1.14k|            }

_RNvCs1YYajZBaYdU_4atty2is:
   40|    163|pub fn is(stream: Stream) -> bool {
   41|       |    extern crate libc;
   42|       |
   43|    163|    let fd = match stream {
   44|      0|        Stream::Stdout => libc::STDOUT_FILENO,
   45|    163|        Stream::Stderr => libc::STDERR_FILENO,
   46|      0|        Stream::Stdin => libc::STDIN_FILENO,
   47|       |    };
   48|    163|    unsafe { libc::isatty(fd) != 0 }
   49|    163|}

_RNvMsd_NtNtNtCs9Er17ssDkOt_6rustix7backend2mm5typesNtB5_9ProtFlags4bits:
  545|  1.30k|            pub const fn bits(&self) -> $T {
  546|  1.30k|                self.bits
  547|  1.30k|            }
_RNvXse_NtNtNtCs9Er17ssDkOt_6rustix7backend2mm5typesNtB5_9ProtFlagsNtNtNtCsdRJjCzU6nMS_4core3ops3bit5BitOr5bitor:
  731|    652|            fn bitor(self, other: $BitFlags) -> Self {
  732|    652|                Self { bits: self.bits | other.bits }
  733|    652|            }
_RNvMs13_NtNtNtCs9Er17ssDkOt_6rustix7backend2mm5typesNtB6_8MapFlags4bits:
  545|  1.30k|            pub const fn bits(&self) -> $T {
  546|  1.30k|                self.bits
  547|  1.30k|            }
_RNvMsd_NtNtNtCs9Er17ssDkOt_6rustix7backend2mm5typesNtB5_9ProtFlags5empty:
  526|    652|            pub const fn empty() -> Self {
  527|    652|                Self { bits: 0 }
  528|    652|            }

_RNvNtCskpYemKvT16c_12blake2b_simd4avx25rot63:
  102|  35.2k|unsafe fn rot63(x: __m256i) -> __m256i {
  103|  35.2k|    _mm256_or_si256(_mm256_srli_epi64(x, 63), _mm256_slli_epi64(x, 64 - 63))
  104|  35.2k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx214compress1_loop:
  427|  1.30k|pub unsafe fn compress1_loop(
  428|  1.30k|    input: &[u8],
  429|  1.30k|    words: &mut [Word; 8],
  430|  1.30k|    mut count: Count,
  431|  1.30k|    last_node: LastNode,
  432|  1.30k|    finalize: Finalize,
  433|  1.30k|    stride: Stride,
  434|  1.30k|) {
  435|  1.30k|    input_debug_asserts(input, finalize);
  436|  1.30k|
  437|  1.30k|    let mut local_words = *words;
  438|  1.30k|
  439|  1.30k|    let mut fin_offset = input.len().saturating_sub(1);
  440|  1.30k|    fin_offset -= fin_offset % stride.padded_blockbytes();
  441|  1.30k|    let mut buf = [0; BLOCKBYTES];
  442|  1.30k|    let (fin_block, fin_len, _) = final_block(input, fin_offset, &mut buf, stride);
  443|  1.30k|    let fin_last_block = flag_word(finalize.yes());
  444|  1.30k|    let fin_last_node = flag_word(finalize.yes() && last_node.yes());
  445|       |
  446|  1.30k|    let mut offset = 0;
  447|       |    loop {
  448|       |        let block;
  449|       |        let count_delta;
  450|       |        let last_block;
  451|       |        let last_node;
  452|  1.46k|        if offset == fin_offset {
  453|  1.30k|            block = fin_block;
  454|  1.30k|            count_delta = fin_len;
  455|  1.30k|            last_block = fin_last_block;
  456|  1.30k|            last_node = fin_last_node;
  457|  1.30k|        } else {
  458|    163|            // This unsafe cast avoids bounds checks. There's guaranteed to be
  459|    163|            // enough input because `offset < fin_offset`.
  460|    163|            block = &*(input.as_ptr().add(offset) as *const [u8; BLOCKBYTES]);
  461|    163|            count_delta = BLOCKBYTES;
  462|    163|            last_block = flag_word(false);
  463|    163|            last_node = flag_word(false);
  464|    163|        };
  465|       |
  466|  1.46k|        count = count.wrapping_add(count_delta as Count);
  467|  1.46k|        compress_block(block, &mut local_words, count, last_block, last_node);
  468|  1.46k|
  469|  1.46k|        // Check for termination before bumping the offset, to avoid overflow.
  470|  1.46k|        if offset == fin_offset {
  471|  1.30k|            break;
  472|    163|        }
  473|    163|
  474|    163|        offset += stride.padded_blockbytes();
  475|       |    }
  476|       |
  477|  1.30k|    *words = local_words;
  478|  1.30k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx24set4:
   66|  1.46k|unsafe fn set4(a: u64, b: u64, c: u64, d: u64) -> __m256i {
   67|  1.46k|    _mm256_setr_epi64x(a as i64, b as i64, c as i64, d as i64)
   68|  1.46k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx29loadu_128:
   30|  11.7k|unsafe fn loadu_128(mem_addr: &[u8; 16]) -> __m128i {
   31|  11.7k|    _mm_loadu_si128(mem_addr.as_ptr() as *const __m128i)
   32|  11.7k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx214compress_block:
  146|  1.46k|unsafe fn compress_block(
  147|  1.46k|    block: &[u8; BLOCKBYTES],
  148|  1.46k|    words: &mut [Word; 8],
  149|  1.46k|    count: Count,
  150|  1.46k|    last_block: Word,
  151|  1.46k|    last_node: Word,
  152|  1.46k|) {
  153|  1.46k|    let (words_low, words_high) = mut_array_refs!(words, DEGREE, DEGREE);
  154|  1.46k|    let (iv_low, iv_high) = array_refs!(&IV, DEGREE, DEGREE);
  155|  1.46k|    let mut a = loadu(words_low);
  156|  1.46k|    let mut b = loadu(words_high);
  157|  1.46k|    let mut c = loadu(iv_low);
  158|  1.46k|    let flags = set4(count_low(count), count_high(count), last_block, last_node);
  159|  1.46k|    let mut d = xor(loadu(iv_high), flags);
  160|  1.46k|
  161|  1.46k|    let msg_chunks = array_refs!(block, 16, 16, 16, 16, 16, 16, 16, 16);
  162|  1.46k|    let m0 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.0));
  163|  1.46k|    let m1 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.1));
  164|  1.46k|    let m2 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.2));
  165|  1.46k|    let m3 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.3));
  166|  1.46k|    let m4 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.4));
  167|  1.46k|    let m5 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.5));
  168|  1.46k|    let m6 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.6));
  169|  1.46k|    let m7 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.7));
  170|  1.46k|
  171|  1.46k|    let iv0 = a;
  172|  1.46k|    let iv1 = b;
  173|  1.46k|    let mut t0;
  174|  1.46k|    let mut t1;
  175|  1.46k|    let mut b0;
  176|  1.46k|
  177|  1.46k|    // round 1
  178|  1.46k|    t0 = _mm256_unpacklo_epi64(m0, m1);
  179|  1.46k|    t1 = _mm256_unpacklo_epi64(m2, m3);
  180|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  181|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  182|  1.46k|    t0 = _mm256_unpackhi_epi64(m0, m1);
  183|  1.46k|    t1 = _mm256_unpackhi_epi64(m2, m3);
  184|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  185|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  186|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  187|  1.46k|    t0 = _mm256_unpacklo_epi64(m7, m4);
  188|  1.46k|    t1 = _mm256_unpacklo_epi64(m5, m6);
  189|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  190|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  191|  1.46k|    t0 = _mm256_unpackhi_epi64(m7, m4);
  192|  1.46k|    t1 = _mm256_unpackhi_epi64(m5, m6);
  193|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  194|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  195|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  196|  1.46k|
  197|  1.46k|    // round 2
  198|  1.46k|    t0 = _mm256_unpacklo_epi64(m7, m2);
  199|  1.46k|    t1 = _mm256_unpackhi_epi64(m4, m6);
  200|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  201|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  202|  1.46k|    t0 = _mm256_unpacklo_epi64(m5, m4);
  203|  1.46k|    t1 = _mm256_alignr_epi8(m3, m7, 8);
  204|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  205|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  206|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  207|  1.46k|    t0 = _mm256_unpackhi_epi64(m2, m0);
  208|  1.46k|    t1 = _mm256_blend_epi32(m5, m0, 0x33);
  209|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  210|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  211|  1.46k|    t0 = _mm256_alignr_epi8(m6, m1, 8);
  212|  1.46k|    t1 = _mm256_blend_epi32(m3, m1, 0x33);
  213|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  214|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  215|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  216|  1.46k|
  217|  1.46k|    // round 3
  218|  1.46k|    t0 = _mm256_alignr_epi8(m6, m5, 8);
  219|  1.46k|    t1 = _mm256_unpackhi_epi64(m2, m7);
  220|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  221|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  222|  1.46k|    t0 = _mm256_unpacklo_epi64(m4, m0);
  223|  1.46k|    t1 = _mm256_blend_epi32(m6, m1, 0x33);
  224|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  225|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  226|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  227|  1.46k|    t0 = _mm256_alignr_epi8(m5, m4, 8);
  228|  1.46k|    t1 = _mm256_unpackhi_epi64(m1, m3);
  229|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  230|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  231|  1.46k|    t0 = _mm256_unpacklo_epi64(m2, m7);
  232|  1.46k|    t1 = _mm256_blend_epi32(m0, m3, 0x33);
  233|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  234|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  235|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  236|  1.46k|
  237|  1.46k|    // round 4
  238|  1.46k|    t0 = _mm256_unpackhi_epi64(m3, m1);
  239|  1.46k|    t1 = _mm256_unpackhi_epi64(m6, m5);
  240|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  241|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  242|  1.46k|    t0 = _mm256_unpackhi_epi64(m4, m0);
  243|  1.46k|    t1 = _mm256_unpacklo_epi64(m6, m7);
  244|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  245|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  246|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  247|  1.46k|    t0 = _mm256_alignr_epi8(m1, m7, 8);
  248|  1.46k|    t1 = _mm256_shuffle_epi32(m2, _MM_SHUFFLE!(1, 0, 3, 2));
  249|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  250|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  251|  1.46k|    t0 = _mm256_unpacklo_epi64(m4, m3);
  252|  1.46k|    t1 = _mm256_unpacklo_epi64(m5, m0);
  253|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  254|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  255|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  256|  1.46k|
  257|  1.46k|    // round 5
  258|  1.46k|    t0 = _mm256_unpackhi_epi64(m4, m2);
  259|  1.46k|    t1 = _mm256_unpacklo_epi64(m1, m5);
  260|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  261|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  262|  1.46k|    t0 = _mm256_blend_epi32(m3, m0, 0x33);
  263|  1.46k|    t1 = _mm256_blend_epi32(m7, m2, 0x33);
  264|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  265|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  266|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  267|  1.46k|    t0 = _mm256_alignr_epi8(m7, m1, 8);
  268|  1.46k|    t1 = _mm256_alignr_epi8(m3, m5, 8);
  269|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  270|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  271|  1.46k|    t0 = _mm256_unpackhi_epi64(m6, m0);
  272|  1.46k|    t1 = _mm256_unpacklo_epi64(m6, m4);
  273|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  274|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  275|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  276|  1.46k|
  277|  1.46k|    // round 6
  278|  1.46k|    t0 = _mm256_unpacklo_epi64(m1, m3);
  279|  1.46k|    t1 = _mm256_unpacklo_epi64(m0, m4);
  280|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  281|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  282|  1.46k|    t0 = _mm256_unpacklo_epi64(m6, m5);
  283|  1.46k|    t1 = _mm256_unpackhi_epi64(m5, m1);
  284|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  285|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  286|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  287|  1.46k|    t0 = _mm256_alignr_epi8(m2, m0, 8);
  288|  1.46k|    t1 = _mm256_unpackhi_epi64(m3, m7);
  289|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  290|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  291|  1.46k|    t0 = _mm256_unpackhi_epi64(m4, m6);
  292|  1.46k|    t1 = _mm256_alignr_epi8(m7, m2, 8);
  293|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  294|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  295|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  296|  1.46k|
  297|  1.46k|    // round 7
  298|  1.46k|    t0 = _mm256_blend_epi32(m0, m6, 0x33);
  299|  1.46k|    t1 = _mm256_unpacklo_epi64(m7, m2);
  300|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  301|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  302|  1.46k|    t0 = _mm256_unpackhi_epi64(m2, m7);
  303|  1.46k|    t1 = _mm256_alignr_epi8(m5, m6, 8);
  304|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  305|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  306|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  307|  1.46k|    t0 = _mm256_unpacklo_epi64(m4, m0);
  308|  1.46k|    t1 = _mm256_blend_epi32(m4, m3, 0x33);
  309|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  310|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  311|  1.46k|    t0 = _mm256_unpackhi_epi64(m5, m3);
  312|  1.46k|    t1 = _mm256_shuffle_epi32(m1, _MM_SHUFFLE!(1, 0, 3, 2));
  313|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  314|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  315|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  316|  1.46k|
  317|  1.46k|    // round 8
  318|  1.46k|    t0 = _mm256_unpackhi_epi64(m6, m3);
  319|  1.46k|    t1 = _mm256_blend_epi32(m1, m6, 0x33);
  320|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  321|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  322|  1.46k|    t0 = _mm256_alignr_epi8(m7, m5, 8);
  323|  1.46k|    t1 = _mm256_unpackhi_epi64(m0, m4);
  324|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  325|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  326|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  327|  1.46k|    t0 = _mm256_blend_epi32(m2, m1, 0x33);
  328|  1.46k|    t1 = _mm256_alignr_epi8(m4, m7, 8);
  329|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  330|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  331|  1.46k|    t0 = _mm256_unpacklo_epi64(m5, m0);
  332|  1.46k|    t1 = _mm256_unpacklo_epi64(m2, m3);
  333|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  334|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  335|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  336|  1.46k|
  337|  1.46k|    // round 9
  338|  1.46k|    t0 = _mm256_unpacklo_epi64(m3, m7);
  339|  1.46k|    t1 = _mm256_alignr_epi8(m0, m5, 8);
  340|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  341|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  342|  1.46k|    t0 = _mm256_unpackhi_epi64(m7, m4);
  343|  1.46k|    t1 = _mm256_alignr_epi8(m4, m1, 8);
  344|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  345|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  346|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  347|  1.46k|    t0 = _mm256_unpacklo_epi64(m5, m6);
  348|  1.46k|    t1 = _mm256_unpackhi_epi64(m6, m0);
  349|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  350|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  351|  1.46k|    t0 = _mm256_alignr_epi8(m1, m2, 8);
  352|  1.46k|    t1 = _mm256_alignr_epi8(m2, m3, 8);
  353|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  354|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  355|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  356|  1.46k|
  357|  1.46k|    // round 10
  358|  1.46k|    t0 = _mm256_unpacklo_epi64(m5, m4);
  359|  1.46k|    t1 = _mm256_unpackhi_epi64(m3, m0);
  360|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  361|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  362|  1.46k|    t0 = _mm256_unpacklo_epi64(m1, m2);
  363|  1.46k|    t1 = _mm256_blend_epi32(m2, m3, 0x33);
  364|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  365|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  366|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  367|  1.46k|    t0 = _mm256_unpackhi_epi64(m6, m7);
  368|  1.46k|    t1 = _mm256_unpackhi_epi64(m4, m1);
  369|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  370|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  371|  1.46k|    t0 = _mm256_blend_epi32(m5, m0, 0x33);
  372|  1.46k|    t1 = _mm256_unpacklo_epi64(m7, m6);
  373|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  374|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  375|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  376|  1.46k|
  377|  1.46k|    // round 11
  378|  1.46k|    t0 = _mm256_unpacklo_epi64(m0, m1);
  379|  1.46k|    t1 = _mm256_unpacklo_epi64(m2, m3);
  380|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  381|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  382|  1.46k|    t0 = _mm256_unpackhi_epi64(m0, m1);
  383|  1.46k|    t1 = _mm256_unpackhi_epi64(m2, m3);
  384|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  385|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  386|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  387|  1.46k|    t0 = _mm256_unpacklo_epi64(m7, m4);
  388|  1.46k|    t1 = _mm256_unpacklo_epi64(m5, m6);
  389|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  390|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  391|  1.46k|    t0 = _mm256_unpackhi_epi64(m7, m4);
  392|  1.46k|    t1 = _mm256_unpackhi_epi64(m5, m6);
  393|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  394|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  395|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  396|  1.46k|
  397|  1.46k|    // round 12
  398|  1.46k|    t0 = _mm256_unpacklo_epi64(m7, m2);
  399|  1.46k|    t1 = _mm256_unpackhi_epi64(m4, m6);
  400|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  401|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  402|  1.46k|    t0 = _mm256_unpacklo_epi64(m5, m4);
  403|  1.46k|    t1 = _mm256_alignr_epi8(m3, m7, 8);
  404|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  405|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  406|  1.46k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  407|  1.46k|    t0 = _mm256_unpackhi_epi64(m2, m0);
  408|  1.46k|    t1 = _mm256_blend_epi32(m5, m0, 0x33);
  409|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  410|  1.46k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  411|  1.46k|    t0 = _mm256_alignr_epi8(m6, m1, 8);
  412|  1.46k|    t1 = _mm256_blend_epi32(m3, m1, 0x33);
  413|  1.46k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  414|  1.46k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  415|  1.46k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  416|  1.46k|
  417|  1.46k|    a = xor(a, c);
  418|  1.46k|    b = xor(b, d);
  419|  1.46k|    a = xor(a, iv0);
  420|  1.46k|    b = xor(b, iv1);
  421|  1.46k|
  422|  1.46k|    storeu(a, words_low);
  423|  1.46k|    storeu(b, words_high);
  424|  1.46k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx26storeu:
   24|  2.93k|unsafe fn storeu(src: __m256i, dest: *mut [Word; DEGREE]) {
   25|  2.93k|    // This is an unaligned store, so the pointer cast is allowed.
   26|  2.93k|    _mm256_storeu_si256(dest as *mut __m256i, src)
   27|  2.93k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx213undiagonalize:
  139|  17.6k|unsafe fn undiagonalize(a: &mut __m256i, _b: &mut __m256i, c: &mut __m256i, d: &mut __m256i) {
  140|  17.6k|    *a = _mm256_permute4x64_epi64(*a, _MM_SHUFFLE!(0, 3, 2, 1));
  141|  17.6k|    *d = _mm256_permute4x64_epi64(*d, _MM_SHUFFLE!(1, 0, 3, 2));
  142|  17.6k|    *c = _mm256_permute4x64_epi64(*c, _MM_SHUFFLE!(2, 1, 0, 3));
  143|  17.6k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx25loadu:
   18|  5.86k|unsafe fn loadu(src: *const [Word; DEGREE]) -> __m256i {
   19|  5.86k|    // This is an unaligned load, so the pointer cast is allowed.
   20|  5.86k|    _mm256_loadu_si256(src as *const __m256i)
   21|  5.86k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx23xor:
   56|   148k|unsafe fn xor(a: __m256i, b: __m256i) -> __m256i {
   57|   148k|    _mm256_xor_si256(a, b)
   58|   148k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx211diagonalize:
  132|  17.6k|unsafe fn diagonalize(a: &mut __m256i, _b: &mut __m256i, c: &mut __m256i, d: &mut __m256i) {
  133|  17.6k|    *a = _mm256_permute4x64_epi64(*a, _MM_SHUFFLE!(2, 1, 0, 3));
  134|  17.6k|    *d = _mm256_permute4x64_epi64(*d, _MM_SHUFFLE!(1, 0, 3, 2));
  135|  17.6k|    *c = _mm256_permute4x64_epi64(*c, _MM_SHUFFLE!(0, 3, 2, 1));
  136|  17.6k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx22g2:
  118|  35.2k|unsafe fn g2(a: &mut __m256i, b: &mut __m256i, c: &mut __m256i, d: &mut __m256i, m: &mut __m256i) {
  119|  35.2k|    *a = add(*a, *m);
  120|  35.2k|    *a = add(*a, *b);
  121|  35.2k|    *d = xor(*d, *a);
  122|  35.2k|    *d = rot16(*d);
  123|  35.2k|    *c = add(*c, *d);
  124|  35.2k|    *b = xor(*b, *c);
  125|  35.2k|    *b = rot63(*b);
  126|  35.2k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx23add:
   35|   211k|unsafe fn add(a: __m256i, b: __m256i) -> __m256i {
   36|   211k|    _mm256_add_epi64(a, b)
   37|   211k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx22g1:
  107|  35.2k|unsafe fn g1(a: &mut __m256i, b: &mut __m256i, c: &mut __m256i, d: &mut __m256i, m: &mut __m256i) {
  108|  35.2k|    *a = add(*a, *m);
  109|  35.2k|    *a = add(*a, *b);
  110|  35.2k|    *d = xor(*d, *a);
  111|  35.2k|    *d = rot32(*d);
  112|  35.2k|    *c = add(*c, *d);
  113|  35.2k|    *b = xor(*b, *c);
  114|  35.2k|    *b = rot24(*b);
  115|  35.2k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx25rot16:
   97|  35.2k|unsafe fn rot16(x: __m256i) -> __m256i {
   98|  35.2k|    _mm256_or_si256(_mm256_srli_epi64(x, 16), _mm256_slli_epi64(x, 64 - 16))
   99|  35.2k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx25rot24:
   92|  35.2k|unsafe fn rot24(x: __m256i) -> __m256i {
   93|  35.2k|    _mm256_or_si256(_mm256_srli_epi64(x, 24), _mm256_slli_epi64(x, 64 - 24))
   94|  35.2k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4avx25rot32:
   87|  35.2k|unsafe fn rot32(x: __m256i) -> __m256i {
   88|  35.2k|    _mm256_or_si256(_mm256_srli_epi64(x, 32), _mm256_slli_epi64(x, 64 - 32))
   89|  35.2k|}

_RNvMNtCskpYemKvT16c_12blake2b_simd4gutsNtB2_14Implementation17avx2_if_supported:
   70|  1.14k|    pub fn avx2_if_supported() -> Option<Self> {
   71|       |        // Check whether AVX2 support is assumed by the build.
   72|       |        #[cfg(target_feature = "avx2")]
   73|       |        {
   74|       |            return Some(Implementation(Platform::AVX2));
   75|       |        }
   76|       |        // Otherwise dynamically check for support if we can.
   77|       |        #[cfg(feature = "std")]
   78|       |        {
   79|      0|            if is_x86_feature_detected!("avx2") {
   80|  1.14k|                return Some(Implementation(Platform::AVX2));
   81|      0|            }
   82|      0|        }
   83|      0|        None
   84|  1.14k|    }
_RNvMs0_NtCskpYemKvT16c_12blake2b_simd4gutsNtB5_8Finalize3yes:
  165|  3.91k|    pub fn yes(&self) -> bool {
  166|  3.91k|        match self {
  167|  3.42k|            Finalize::Yes => true,
  168|    489|            Finalize::No => false,
  169|       |        }
  170|  3.91k|    }
_RNvNtCskpYemKvT16c_12blake2b_simd4guts11final_block:
  232|  1.30k|pub fn final_block<'a>(
  233|  1.30k|    input: &'a [u8],
  234|  1.30k|    offset: usize,
  235|  1.30k|    buffer: &'a mut [u8; BLOCKBYTES],
  236|  1.30k|    stride: Stride,
  237|  1.30k|) -> (&'a [u8; BLOCKBYTES], usize, bool) {
  238|  1.30k|    let capped_offset = cmp::min(offset, input.len());
  239|  1.30k|    let offset_slice = &input[capped_offset..];
  240|  1.30k|    if offset_slice.len() >= BLOCKBYTES {
  241|    163|        let block = array_ref!(offset_slice, 0, BLOCKBYTES);
  242|    163|        let should_finalize = offset_slice.len() <= stride.padded_blockbytes();
  243|    163|        (block, BLOCKBYTES, should_finalize)
  244|       |    } else {
  245|       |        // Copy the final block to the front of the block buffer. The rest of
  246|       |        // the buffer is assumed to be initialized to zero.
  247|  1.14k|        buffer[..offset_slice.len()].copy_from_slice(offset_slice);
  248|  1.14k|        (buffer, offset_slice.len(), true)
  249|       |    }
  250|  1.30k|}
_RNvMs2_NtCskpYemKvT16c_12blake2b_simd4gutsNtB5_6Stride17padded_blockbytes:
  196|  1.63k|    pub fn padded_blockbytes(&self) -> usize {
  197|  1.63k|        match self {
  198|  1.63k|            Stride::Serial => BLOCKBYTES,
  199|      0|            Stride::Parallel => blake2bp::DEGREE * BLOCKBYTES,
  200|       |        }
  201|  1.63k|    }
_RNvMNtCskpYemKvT16c_12blake2b_simd4gutsNtB2_14Implementation6detect:
   33|  1.14k|            if let Some(avx2_impl) = Self::avx2_if_supported() {
   34|  1.14k|                return avx2_impl;
   35|      0|            }
   36|       |        }
   37|       |        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
   38|       |        {
   39|      0|            if let Some(sse41_impl) = Self::sse41_if_supported() {
   40|      0|                return sse41_impl;
   41|      0|            }
   42|      0|        }
   43|      0|        Self::portable()
   44|  1.14k|    }
_RNvNtCskpYemKvT16c_12blake2b_simd4guts9flag_word:
  217|  2.93k|pub(crate) fn flag_word(flag: bool) -> Word {
  218|  2.93k|    if flag {
  219|  1.14k|        !0
  220|       |    } else {
  221|  1.79k|        0
  222|       |    }
  223|  2.93k|}
_RNvNtCskpYemKvT16c_12blake2b_simd4guts10count_high:
  208|  1.46k|pub(crate) fn count_high(count: Count) -> Word {
  209|  1.46k|    (count >> 8 * size_of::<Word>()) as Word
  210|  1.46k|}
_RNvMNtCskpYemKvT16c_12blake2b_simd4gutsNtB2_14Implementation14compress1_loop:
   96|  1.30k|    pub fn compress1_loop(
   97|  1.30k|        &self,
   98|  1.30k|        input: &[u8],
   99|  1.30k|        words: &mut [Word; 8],
  100|  1.30k|        count: Count,
  101|  1.30k|        last_node: LastNode,
  102|  1.30k|        finalize: Finalize,
  103|  1.30k|        stride: Stride,
  104|  1.30k|    ) {
  105|  1.30k|        match self.0 {
  106|       |            #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
  107|  1.30k|            Platform::AVX2 => unsafe {
  108|  1.30k|                avx2::compress1_loop(input, words, count, last_node, finalize, stride);
  109|  1.30k|            },
  110|       |            // Note that there's an SSE version of compress1 in the official C
  111|       |            // implementation, but I haven't ported it yet.
  112|      0|            _ => {
  113|      0|                portable::compress1_loop(input, words, count, last_node, finalize, stride);
  114|      0|            }
  115|       |        }
  116|  1.30k|    }
_RNvNtCskpYemKvT16c_12blake2b_simd4guts9count_low:
  204|  1.46k|pub(crate) fn count_low(count: Count) -> Word {
  205|  1.46k|    count as Word
  206|  1.46k|}
_RNvMs1_NtCskpYemKvT16c_12blake2b_simd4gutsNtB5_8LastNode3yes:
  181|  1.14k|    pub fn yes(&self) -> bool {
  182|  1.14k|        match self {
  183|      0|            LastNode::Yes => true,
  184|  1.14k|            LastNode::No => false,
  185|       |        }
  186|  1.14k|    }
_RNvNtCskpYemKvT16c_12blake2b_simd4guts19input_debug_asserts:
  252|  1.30k|pub fn input_debug_asserts(input: &[u8], finalize: Finalize) {
  253|  1.30k|    // If we're not finalizing, the input must not be empty, and it must be an
  254|  1.30k|    // even multiple of the block size.
  255|  1.30k|    if !finalize.yes() {
  256|    163|        debug_assert!(!input.is_empty());
  257|    163|        debug_assert_eq!(0, input.len() % BLOCKBYTES);
  258|  1.14k|    }
  259|  1.30k|}

_RNvMCskpYemKvT16c_12blake2b_simdNtB2_6Params11hash_length:
  238|  1.14k|    pub fn hash_length(&mut self, length: usize) -> &mut Self {
  239|  1.14k|        assert!(
  240|  1.14k|            1 <= length && length <= OUTBYTES,
  241|      0|            "Bad hash length: {}",
  242|       |            length
  243|       |        );
  244|  1.14k|        self.hash_length = length as u8;
  245|  1.14k|        self
  246|  1.14k|    }
_RNvMCskpYemKvT16c_12blake2b_simdNtB2_6Params3new:
  165|  1.14k|    pub fn new() -> Self {
  166|  1.14k|        Self {
  167|  1.14k|            hash_length: OUTBYTES as u8,
  168|  1.14k|            key_length: 0,
  169|  1.14k|            key_block: [0; BLOCKBYTES],
  170|  1.14k|            salt: [0; SALTBYTES],
  171|  1.14k|            personal: [0; PERSONALBYTES],
  172|  1.14k|            // NOTE: fanout and max_depth don't default to zero!
  173|  1.14k|            fanout: 1,
  174|  1.14k|            max_depth: 1,
  175|  1.14k|            max_leaf_length: 0,
  176|  1.14k|            node_offset: 0,
  177|  1.14k|            node_depth: 0,
  178|  1.14k|            inner_hash_length: 0,
  179|  1.14k|            last_node: guts::LastNode::No,
  180|  1.14k|            implementation: guts::Implementation::detect(),
  181|  1.14k|        }
  182|  1.14k|    }
_RNvMs1_CskpYemKvT16c_12blake2b_simdNtB5_5State6update:
  453|  1.14k|    pub fn update(&mut self, mut input: &[u8]) -> &mut Self {
  454|  1.14k|        // If we have a partial buffer, try to complete it.
  455|  1.14k|        self.compress_buffer_if_possible(&mut input);
  456|  1.14k|        // While there's more than a block of input left (which also means we cleared the buffer
  457|  1.14k|        // above), compress blocks directly without copying.
  458|  1.14k|        let mut end = input.len().saturating_sub(1);
  459|  1.14k|        end -= end % BLOCKBYTES;
  460|  1.14k|        if end > 0 {
  461|    163|            self.implementation.compress1_loop(
  462|    163|                &input[..end],
  463|    163|                &mut self.words,
  464|    163|                self.count,
  465|    163|                self.last_node,
  466|    163|                guts::Finalize::No,
  467|    163|                guts::Stride::Serial,
  468|    163|            );
  469|    163|            self.count = self.count.wrapping_add(end as Count);
  470|    163|            input = &input[end..];
  471|    978|        }
  472|       |        // Buffer any remaining input, to be either compressed or finalized in a subsequent call.
  473|       |        // Note that this represents some copying overhead, which in theory we could avoid in
  474|       |        // all-at-once setting. A function hardcoded for exactly BLOCKSIZE input bytes is about 10%
  475|       |        // faster than using this implementation for the same input.
  476|  1.14k|        self.fill_buf(&mut input);
  477|  1.14k|        self
  478|  1.14k|    }
_RNvMs1_CskpYemKvT16c_12blake2b_simdNtB5_5State27compress_buffer_if_possible:
  434|  1.14k|    fn compress_buffer_if_possible(&mut self, input: &mut &[u8]) {
  435|  1.14k|        if self.buflen > 0 {
  436|      0|            self.fill_buf(input);
  437|      0|            if !input.is_empty() {
  438|      0|                self.implementation.compress1_loop(
  439|      0|                    &self.buf,
  440|      0|                    &mut self.words,
  441|      0|                    self.count,
  442|      0|                    self.last_node,
  443|      0|                    guts::Finalize::No,
  444|      0|                    guts::Stride::Serial,
  445|      0|                );
  446|      0|                self.count = self.count.wrapping_add(BLOCKBYTES as Count);
  447|      0|                self.buflen = 0;
  448|      0|            }
  449|  1.14k|        }
  450|  1.14k|    }
_RNvMCskpYemKvT16c_12blake2b_simdNtB2_6Params8to_state:
  230|  1.14k|    pub fn to_state(&self) -> State {
  231|  1.14k|        State::with_params(self)
  232|  1.14k|    }
_RNvMs5_CskpYemKvT16c_12blake2b_simdNtB5_4Hash8as_bytes:
  589|  1.14k|    pub fn as_bytes(&self) -> &[u8] {
  590|  1.14k|        &self.bytes[..self.len as usize]
  591|  1.14k|    }
_RNvMCskpYemKvT16c_12blake2b_simdNtB2_6Params8to_words:
  185|  1.14k|    fn to_words(&self) -> [Word; 8] {
  186|  1.14k|        let (salt_left, salt_right) = array_refs!(&self.salt, SALTBYTES / 2, SALTBYTES / 2);
  187|  1.14k|        let (personal_left, personal_right) =
  188|  1.14k|            array_refs!(&self.personal, PERSONALBYTES / 2, PERSONALBYTES / 2);
  189|  1.14k|        [
  190|  1.14k|            IV[0]
  191|  1.14k|                ^ self.hash_length as u64
  192|  1.14k|                ^ (self.key_length as u64) << 8
  193|  1.14k|                ^ (self.fanout as u64) << 16
  194|  1.14k|                ^ (self.max_depth as u64) << 24
  195|  1.14k|                ^ (self.max_leaf_length as u64) << 32,
  196|  1.14k|            IV[1] ^ self.node_offset,
  197|  1.14k|            IV[2] ^ self.node_depth as u64 ^ (self.inner_hash_length as u64) << 8,
  198|  1.14k|            IV[3],
  199|  1.14k|            IV[4] ^ Word::from_le_bytes(*salt_left),
  200|  1.14k|            IV[5] ^ Word::from_le_bytes(*salt_right),
  201|  1.14k|            IV[6] ^ Word::from_le_bytes(*personal_left),
  202|  1.14k|            IV[7] ^ Word::from_le_bytes(*personal_right),
  203|  1.14k|        ]
  204|  1.14k|    }
_RNvCskpYemKvT16c_12blake2b_simd20state_words_to_bytes:
  529|  1.14k|fn state_words_to_bytes(state_words: &[Word; 8]) -> [u8; OUTBYTES] {
  530|  1.14k|    let mut bytes = [0; OUTBYTES];
  531|  1.14k|    {
  532|  1.14k|        const W: usize = size_of::<Word>();
  533|  1.14k|        let refs = mut_array_refs!(&mut bytes, W, W, W, W, W, W, W, W);
  534|  1.14k|        *refs.0 = state_words[0].to_le_bytes();
  535|  1.14k|        *refs.1 = state_words[1].to_le_bytes();
  536|  1.14k|        *refs.2 = state_words[2].to_le_bytes();
  537|  1.14k|        *refs.3 = state_words[3].to_le_bytes();
  538|  1.14k|        *refs.4 = state_words[4].to_le_bytes();
  539|  1.14k|        *refs.5 = state_words[5].to_le_bytes();
  540|  1.14k|        *refs.6 = state_words[6].to_le_bytes();
  541|  1.14k|        *refs.7 = state_words[7].to_le_bytes();
  542|  1.14k|    }
  543|  1.14k|    bytes
  544|  1.14k|}
_RNvMs1_CskpYemKvT16c_12blake2b_simdNtB5_5State11with_params:
  406|  1.14k|    fn with_params(params: &Params) -> Self {
  407|  1.14k|        let mut state = Self {
  408|  1.14k|            words: params.to_words(),
  409|  1.14k|            count: 0,
  410|  1.14k|            buf: [0; BLOCKBYTES],
  411|  1.14k|            buflen: 0,
  412|  1.14k|            last_node: params.last_node,
  413|  1.14k|            hash_length: params.hash_length,
  414|  1.14k|            implementation: params.implementation,
  415|  1.14k|            is_keyed: params.key_length > 0,
  416|  1.14k|        };
  417|  1.14k|        if state.is_keyed {
  418|      0|            state.buf = params.key_block;
  419|      0|            state.buflen = state.buf.len() as u8;
  420|  1.14k|        }
  421|  1.14k|        state
  422|  1.14k|    }
_RNvMs1_CskpYemKvT16c_12blake2b_simdNtB5_5State8fill_buf:
  424|  1.14k|    fn fill_buf(&mut self, input: &mut &[u8]) {
  425|  1.14k|        let take = cmp::min(BLOCKBYTES - self.buflen as usize, input.len());
  426|  1.14k|        self.buf[self.buflen as usize..self.buflen as usize + take].copy_from_slice(&input[..take]);
  427|  1.14k|        self.buflen += take as u8;
  428|  1.14k|        *input = &input[take..];
  429|  1.14k|    }
_RNvMs1_CskpYemKvT16c_12blake2b_simdNtB5_5State8finalize:
  482|  1.14k|    pub fn finalize(&self) -> Hash {
  483|  1.14k|        let mut words_copy = self.words;
  484|  1.14k|        self.implementation.compress1_loop(
  485|  1.14k|            &self.buf[..self.buflen as usize],
  486|  1.14k|            &mut words_copy,
  487|  1.14k|            self.count,
  488|  1.14k|            self.last_node,
  489|  1.14k|            guts::Finalize::Yes,
  490|  1.14k|            guts::Stride::Serial,
  491|  1.14k|        );
  492|  1.14k|        Hash {
  493|  1.14k|            bytes: state_words_to_bytes(&words_copy),
  494|  1.14k|            len: self.hash_length,
  495|  1.14k|        }
  496|  1.14k|    }

_RNvMs3_Cs6VWP01cbR17_12block_bufferINtB5_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE7get_posCs4ieSHZHrxF6_15direct_syscalls:
  189|    978|    pub fn get_pos(&self) -> usize {
  190|    978|        let pos = self.pos as usize;
  191|    978|        if !Kind::invariant(pos, BlockSize::USIZE) {
  192|      0|            debug_assert!(false);
  193|       |            // SAFETY: `pos` never breaks the invariant
  194|       |            unsafe {
  195|      0|                core::hint::unreachable_unchecked();
  196|       |            }
  197|    978|        }
  198|    978|        pos
  199|    978|    }
_RNvXs1_Cs6VWP01cbR17_12block_bufferINtB5_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCs4ieSHZHrxF6_15direct_syscalls:
   72|    489|    fn default() -> Self {
   73|    489|        Self {
   74|    489|            buffer: Default::default(),
   75|    489|            pos: 0,
   76|    489|            _pd: PhantomData,
   77|    489|        }
   78|    489|    }
_RINvMs4_Cs6VWP01cbR17_12block_bufferINtB6_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE16len64_padding_beNCNvXs3_NtCs7HNaFSx2gxZ_4sha28core_apiNtB3r_13Sha256VarCoreNtNtCsh9D4u1TLtsH_6digest8core_api18VariableOutputCore22finalize_variable_core0ECs4ieSHZHrxF6_15direct_syscalls:
  315|    489|    pub fn len64_padding_be(&mut self, data_len: u64, compress: impl FnMut(&Block<BlockSize>)) {
  316|    489|        self.digest_pad(0x80, &data_len.to_be_bytes(), compress);
  317|    489|    }
_RNvMs3_Cs6VWP01cbR17_12block_bufferINtB5_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE4sizeCs4ieSHZHrxF6_15direct_syscalls:
  220|    978|    pub fn size(&self) -> usize {
  221|    978|        BlockSize::USIZE
  222|    978|    }
_RNvMs3_Cs6VWP01cbR17_12block_bufferINtB5_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE17set_pos_uncheckedCs4ieSHZHrxF6_15direct_syscalls:
  231|    489|    fn set_pos_unchecked(&mut self, pos: usize) {
  232|    489|        debug_assert!(Kind::invariant(pos, BlockSize::USIZE));
  233|    489|        self.pos = pos as u8;
  234|    489|    }
_RINvMs4_Cs6VWP01cbR17_12block_bufferINtB6_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE10digest_padNCNvXs3_NtCs7HNaFSx2gxZ_4sha28core_apiNtB3l_13Sha256VarCoreNtNtCsh9D4u1TLtsH_6digest8core_api18VariableOutputCore22finalize_variable_core0ECs4ieSHZHrxF6_15direct_syscalls:
  284|    489|    pub fn digest_pad(
  285|    489|        &mut self,
  286|    489|        delim: u8,
  287|    489|        suffix: &[u8],
  288|    489|        mut compress: impl FnMut(&Block<BlockSize>),
  289|    489|    ) {
  290|    489|        if suffix.len() > BlockSize::USIZE {
  291|      0|            panic!("suffix is too long");
  292|    489|        }
  293|    489|        let pos = self.get_pos();
  294|    489|        self.buffer[pos] = delim;
  295|  29.8k|        for b in &mut self.buffer[pos + 1..] {
  296|  29.8k|            *b = 0;
  297|  29.8k|        }
  298|       |
  299|    489|        let n = self.size() - suffix.len();
  300|    489|        if self.size() - pos - 1 < suffix.len() {
  301|      0|            compress(&self.buffer);
  302|      0|            let mut block = Block::<BlockSize>::default();
  303|      0|            block[n..].copy_from_slice(suffix);
  304|      0|            compress(&block);
  305|    489|        } else {
  306|    489|            self.buffer[n..].copy_from_slice(suffix);
  307|    489|            compress(&self.buffer);
  308|    489|        }
  309|    489|        self.set_pos_unchecked(0)
  310|    489|    }
_RNvMs3_Cs6VWP01cbR17_12block_bufferINtB5_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE7get_posCs6zZxOXcsMaf_13fvm_ipld_hamt:
  189|    489|    pub fn get_pos(&self) -> usize {
  190|    489|        let pos = self.pos as usize;
  191|    489|        if !Kind::invariant(pos, BlockSize::USIZE) {
  192|      0|            debug_assert!(false);
  193|       |            // SAFETY: `pos` never breaks the invariant
  194|       |            unsafe {
  195|      0|                core::hint::unreachable_unchecked();
  196|       |            }
  197|    489|        }
  198|    489|        pos
  199|    489|    }
_RINvMs3_Cs6VWP01cbR17_12block_bufferINtB6_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE13digest_blocksNCNvXs6_NtNtCsh9D4u1TLtsH_6digest8core_api7wrapperINtB3o_11CoreWrapperINtNtB3q_11ct_variable21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreB1s_NtB5b_9OidSha256EENtB3s_6Update6update0ECs6zZxOXcsMaf_13fvm_ipld_hamt:
  132|    489|    pub fn digest_blocks(
  133|    489|        &mut self,
  134|    489|        mut input: &[u8],
  135|    489|        mut compress: impl FnMut(&[Block<BlockSize>]),
  136|    489|    ) {
  137|    489|        let pos = self.get_pos();
  138|    489|        // using `self.remaining()` for some reason
  139|    489|        // prevents panic elimination
  140|    489|        let rem = self.size() - pos;
  141|    489|        let n = input.len();
  142|    489|        // Note that checking condition `pos + n < BlockSize` is
  143|    489|        // equivalent to checking `n < rem`, where `rem` is equal
  144|    489|        // to `BlockSize - pos`. Using the latter allows us to work
  145|    489|        // around compiler accounting for possible overflow of
  146|    489|        // `pos + n` which results in it inserting unreachable
  147|    489|        // panic branches. Using `unreachable_unchecked` in `get_pos`
  148|    489|        // we convince compiler that `BlockSize - pos` never underflows.
  149|    489|        if Kind::invariant(n, rem) {
  150|       |            // double slicing allows to remove panic branches
  151|    489|            self.buffer[pos..][..n].copy_from_slice(input);
  152|    489|            self.set_pos_unchecked(pos + n);
  153|    489|            return;
  154|      0|        }
  155|      0|        if pos != 0 {
  156|      0|            let (left, right) = input.split_at(rem);
  157|      0|            input = right;
  158|      0|            self.buffer[pos..].copy_from_slice(left);
  159|      0|            compress(slice::from_ref(&self.buffer));
  160|      0|        }
  161|       |
  162|      0|        let (blocks, leftover) = Kind::split_blocks(input);
  163|      0|        if !blocks.is_empty() {
  164|      0|            compress(blocks);
  165|      0|        }
  166|       |
  167|      0|        let n = leftover.len();
  168|      0|        self.buffer[..n].copy_from_slice(leftover);
  169|      0|        self.set_pos_unchecked(n);
  170|    489|    }
_RNvMs3_Cs6VWP01cbR17_12block_bufferINtB5_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE17set_pos_uncheckedCs6zZxOXcsMaf_13fvm_ipld_hamt:
  231|    489|    fn set_pos_unchecked(&mut self, pos: usize) {
  232|    489|        debug_assert!(Kind::invariant(pos, BlockSize::USIZE));
  233|    489|        self.pos = pos as u8;
  234|    489|    }
_RNvMs3_Cs6VWP01cbR17_12block_bufferINtB5_11BlockBufferINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE4sizeCs6zZxOXcsMaf_13fvm_ipld_hamt:
  220|    489|    pub fn size(&self) -> usize {
  221|    489|        BlockSize::USIZE
  222|    489|    }

_RNvXNtCs6VWP01cbR17_12block_buffer6sealedNtB4_5EagerNtB2_6Sealed9invariant:
   16|  2.93k|    fn invariant(pos: usize, block_size: usize) -> bool {
   17|  2.93k|        pos < block_size
   18|  2.93k|    }

_RNvXs0_Cs6XjTfmj6twO_9byteorderNtB5_9BigEndianNtB5_9ByteOrder8read_u64:
 1982|    652|    fn read_u64(buf: &[u8]) -> u64 {
 1983|    652|        u64::from_be_bytes(buf[..8].try_into().unwrap())
 1984|    652|    }
_RNvXs0_Cs6XjTfmj6twO_9byteorderNtB5_9BigEndianNtB5_9ByteOrder9write_u64:
 2032|  1.30k|    fn write_u64(buf: &mut [u8], n: u64) {
 2033|  1.30k|        unsafe_write_num_bytes!(u64, 8, n, buf, to_be);
 2034|  1.30k|    }

_RINvXs8_NtNtCs5rcRHic1w1p_7cbor4ii4core3decINtNtCs71iYhC60HpU_5alloc6borrow3CoweENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  545|  2.44k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  546|  2.44k|        use crate::alloc::borrow::Cow;
  547|  2.44k|
  548|  2.44k|        let mut buf = Vec::new();
  549|  2.44k|        Ok(if let Some(longbuf) = decode_buf(major::STRING, byte, reader, &mut buf)? {
  550|  2.44k|            Cow::Borrowed(core::str::from_utf8(longbuf).map_err(Error::InvalidUtf8)?)
  551|       |        } else {
  552|      0|            let buf = String::from_utf8(buf)
  553|      0|                .map_err(|err| Error::InvalidUtf8(err.utf8_error()))?;
  554|      0|            Cow::Owned(buf)
  555|       |        })
  556|  2.44k|    }
_RINvNtNtCs5rcRHic1w1p_7cbor4ii4core3dec10decode_bufNtNtB4_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  427|  7.49k|fn decode_buf<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R, buf: &mut Vec<u8>)
  428|  7.49k|    -> Result<Option<&'a [u8]>, Error<R::Error>>
  429|  7.49k|{
  430|       |    const CAP_LIMIT: usize = 16 * 1024;
  431|       |
  432|  7.49k|    if let Some(mut len) = decode_len(major, byte, reader)? {
  433|       |        // try long lifetime buffer
  434|  7.49k|        if let Reference::Long(buf) = reader.fill(len)? {
  435|  7.49k|            if buf.len() >= len {
  436|  7.49k|                reader.advance(len);
  437|  7.49k|                return Ok(Some(&buf[..len]));
  438|      0|            }
  439|      0|        }
  440|       |
  441|      0|        buf.reserve(core::cmp::min(len, CAP_LIMIT)); // TODO try_reserve ?
  442|       |
  443|      0|        while len != 0 {
  444|      0|            let readbuf = reader.fill(len)?;
  445|      0|            let readbuf = readbuf.as_ref();
  446|      0|
  447|      0|            if readbuf.is_empty() {
  448|      0|                return Err(Error::Eof);
  449|      0|            }
  450|      0|
  451|      0|            let readlen = core::cmp::min(readbuf.len(), len);
  452|      0|
  453|      0|            buf.extend_from_slice(&readbuf[..readlen]);
  454|      0|            reader.advance(readlen);
  455|      0|            len -= readlen;
  456|       |        }
  457|       |
  458|      0|        Ok(None)
  459|       |    } else {
  460|       |        // bytes sequence
  461|       |        loop {
  462|      0|            let byte = pull_one(reader)?;
  463|       |
  464|      0|            if byte == marker::BREAK {
  465|      0|                break
  466|      0|            }
  467|      0|
  468|      0|            if !reader.step_in() {
  469|      0|                return Err(Error::DepthLimit);
  470|      0|            }
  471|      0|            let mut reader = ScopeGuard(reader, |reader| reader.step_out());
  472|      0|            let reader = &mut *reader;
  473|       |
  474|      0|            if let Some(longbuf) = decode_buf(major, byte, reader, buf)? {
  475|      0|                buf.extend_from_slice(longbuf);
  476|      0|            }
  477|       |        }
  478|       |
  479|      0|        Ok(None)
  480|       |    }
  481|  7.49k|}
_RINvYNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec10ArrayStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
   73|  4.72k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  4.72k|        let byte = pull_one(reader)?;
   75|  4.72k|        Self::decode_with(byte, reader)
   76|  4.72k|    }
_RINvNtNtCs5rcRHic1w1p_7cbor4ii4core3dec8pull_oneNtNtB4_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  125|  24.7k|pub(crate) fn pull_one<'a, R: Read<'a>>(reader: &mut R) -> Result<u8, Error<R::Error>> {
  126|  24.7k|    let b = reader.fill(1)?
  127|  24.7k|        .as_ref()
  128|  24.7k|        .get(0)
  129|  24.7k|        .copied()
  130|  24.7k|        .ok_or(Error::Eof)?;
  131|  24.7k|    reader.advance(1);
  132|  24.7k|    Ok(b)
  133|  24.7k|}
_RINvYINtNtNtCs5rcRHic1w1p_7cbor4ii4core5types5BytesINtNtCs71iYhC60HpU_5alloc6borrow3CowShEENtNtB8_3dec6Decode6decodeNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
   73|  5.05k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  5.05k|        let byte = pull_one(reader)?;
   75|  5.05k|        Self::decode_with(byte, reader)
   76|  5.05k|    }
_RINvXsr_NtNtCs5rcRHic1w1p_7cbor4ii4core3decmNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  252|    163|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    163|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    163|                }
_RINvNtNtCs5rcRHic1w1p_7cbor4ii4core3dec10decode_lenNtNtB4_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  595|  12.2k|fn decode_len<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R)
  596|  12.2k|    -> Result<Option<usize>, Error<R::Error>>
  597|  12.2k|{
  598|  12.2k|    if byte != (marker::START | (major << 5)) {
  599|  12.2k|        let len = TypeNum::new(!(major << 5), byte).decode_u64(reader)?;
  600|  12.2k|        let len = usize::try_from(len).map_err(Error::CastOverflow)?;
  601|  12.2k|        Ok(Some(len))
  602|       |    } else {
  603|      0|        Ok(None)
  604|       |    }
  605|  12.2k|}
_RNvMNtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB2_9Reference6as_ref:
   81|  42.0k|    pub(crate) const fn as_ref(&self) -> &[u8] {
   82|  42.0k|        match self {
   83|  42.0k|            Reference::Long(buf) => buf,
   84|      0|            Reference::Short(buf) => buf
   85|       |        }
   86|  42.0k|    }
_RINvYINtNtCs71iYhC60HpU_5alloc6borrow3CoweENtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec6Decode6decodeNtNtBJ_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
   73|  2.44k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  2.44k|        let byte = pull_one(reader)?;
   75|  2.44k|        Self::decode_with(byte, reader)
   76|  2.44k|    }
_RINvYNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec8TagStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
   73|  3.91k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  3.91k|        let byte = pull_one(reader)?;
   75|  3.91k|        Self::decode_with(byte, reader)
   76|  3.91k|    }
_RINvXss_NtNtCs5rcRHic1w1p_7cbor4ii4core3decyNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  252|    652|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    652|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    652|                }
_RINvXs5_NtNtCs5rcRHic1w1p_7cbor4ii4core3decINtNtB8_5types5BytesINtNtCs71iYhC60HpU_5alloc6borrow3CowShEENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  506|  5.05k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  507|  5.05k|        use crate::alloc::borrow::Cow;
  508|  5.05k|
  509|  5.05k|        let mut buf = Vec::new();
  510|  5.05k|        Ok(types::Bytes(if let Some(longbuf) = decode_buf(major::BYTES, byte, reader, &mut buf)? {
  511|  5.05k|            Cow::Borrowed(longbuf)
  512|       |        } else {
  513|      0|            Cow::Owned(buf)
  514|       |        }))
  515|  5.05k|    }
_RINvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_7TypeNum10decode_u32NtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  204|    163|    fn decode_u32<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u32, Error<R::Error>> {
  205|    163|        match self.byte & self.major_limit {
  206|    163|            x @ 0 ..= 0x17 => Ok(x.into()),
  207|      0|            0x18 => pull_one(reader).map(Into::into),
  208|       |            0x19 => {
  209|      0|                let mut buf = [0; 2];
  210|      0|                pull_exact(reader, &mut buf)?;
  211|      0|                Ok(u16::from_be_bytes(buf).into())
  212|       |            },
  213|       |            0x1a => {
  214|      0|                let mut buf = [0; 4];
  215|      0|                pull_exact(reader, &mut buf)?;
  216|      0|                Ok(u32::from_be_bytes(buf))
  217|       |            }
  218|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  219|       |        }
  220|    163|    }
_RINvYmNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
   73|    163|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    163|        let byte = pull_one(reader)?;
   75|    163|        Self::decode_with(byte, reader)
   76|    163|    }
_RINvXsc_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_10ArrayStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  611|  4.72k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  612|  4.72k|        decode_len(major::ARRAY, byte, reader).map(ArrayStart)
  613|  4.72k|    }
_RNvNtNtCs5rcRHic1w1p_7cbor4ii4core3dec8if_major:
  890|  11.0k|pub fn if_major(byte: u8) -> u8 {
  891|  11.0k|    byte >> 5
  892|  11.0k|}
_RINvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_7TypeNum10decode_u64NtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  223|  16.7k|    pub(crate) fn decode_u64<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u64, Error<R::Error>> {
  224|  16.7k|        match self.byte & self.major_limit {
  225|  16.7k|            x @ 0 ..= 0x17 => Ok(x.into()),
  226|  7.82k|            0x18 => pull_one(reader).map(Into::into),
  227|       |            0x19 => {
  228|      0|                let mut buf = [0; 2];
  229|      0|                pull_exact(reader, &mut buf)?;
  230|      0|                Ok(u16::from_be_bytes(buf).into())
  231|       |            },
  232|       |            0x1a => {
  233|      0|                let mut buf = [0; 4];
  234|      0|                pull_exact(reader, &mut buf)?;
  235|      0|                Ok(u32::from_be_bytes(buf).into())
  236|       |            },
  237|       |            0x1b => {
  238|      0|                let mut buf = [0; 8];
  239|      0|                pull_exact(reader, &mut buf)?;
  240|      0|                Ok(u64::from_be_bytes(buf))
  241|       |            },
  242|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  243|       |        }
  244|  16.7k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB5_7TypeNum3new:
  175|  28.6k|    pub(crate) const fn new(major_limit: u8, byte: u8) -> TypeNum {
  176|  28.6k|        TypeNum { major_limit, byte }
  177|  28.6k|    }
_RINvYyNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
   73|    652|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    652|        let byte = pull_one(reader)?;
   75|    652|        Self::decode_with(byte, reader)
   76|    652|    }
_RINvXsg_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_8TagStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
  703|  3.91k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  704|  3.91k|        TypeNum::new(!(major::TAG << 5), byte).decode_u64(reader).map(TagStart)
  705|  3.91k|    }
_RINvXss_NtNtCs5rcRHic1w1p_7cbor4ii4core3decyNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  252|    163|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    163|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    163|                }
_RINvYINtNtCs71iYhC60HpU_5alloc6borrow3CoweENtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec6Decode6decodeNtNtBJ_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
   73|  2.77k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  2.77k|        let byte = pull_one(reader)?;
   75|  2.77k|        Self::decode_with(byte, reader)
   76|  2.77k|    }
_RINvXs5_NtNtCs5rcRHic1w1p_7cbor4ii4core3decINtNtB8_5types5BytesINtNtCs71iYhC60HpU_5alloc6borrow3CowShEENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  506|  2.77k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  507|  2.77k|        use crate::alloc::borrow::Cow;
  508|  2.77k|
  509|  2.77k|        let mut buf = Vec::new();
  510|  2.77k|        Ok(types::Bytes(if let Some(longbuf) = decode_buf(major::BYTES, byte, reader, &mut buf)? {
  511|  2.77k|            Cow::Borrowed(longbuf)
  512|       |        } else {
  513|      0|            Cow::Owned(buf)
  514|       |        }))
  515|  2.77k|    }
_RINvYINtNtNtCs5rcRHic1w1p_7cbor4ii4core5types5BytesINtNtCs71iYhC60HpU_5alloc6borrow3CowShEENtNtB8_3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
   73|  2.77k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  2.77k|        let byte = pull_one(reader)?;
   75|  2.77k|        Self::decode_with(byte, reader)
   76|  2.77k|    }
_RINvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_7TypeNum10decode_u32NtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  204|    163|    fn decode_u32<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u32, Error<R::Error>> {
  205|    163|        match self.byte & self.major_limit {
  206|    163|            x @ 0 ..= 0x17 => Ok(x.into()),
  207|      0|            0x18 => pull_one(reader).map(Into::into),
  208|       |            0x19 => {
  209|      0|                let mut buf = [0; 2];
  210|      0|                pull_exact(reader, &mut buf)?;
  211|      0|                Ok(u16::from_be_bytes(buf).into())
  212|       |            },
  213|       |            0x1a => {
  214|      0|                let mut buf = [0; 4];
  215|      0|                pull_exact(reader, &mut buf)?;
  216|      0|                Ok(u32::from_be_bytes(buf))
  217|       |            }
  218|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  219|       |        }
  220|    163|    }
_RINvYNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec8TagStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
   73|  2.77k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  2.77k|        let byte = pull_one(reader)?;
   75|  2.77k|        Self::decode_with(byte, reader)
   76|  2.77k|    }
_RINvYNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec10ArrayStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
   73|  2.93k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  2.93k|        let byte = pull_one(reader)?;
   75|  2.93k|        Self::decode_with(byte, reader)
   76|  2.93k|    }
_RINvXsc_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_10ArrayStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  611|  2.93k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  612|  2.93k|        decode_len(major::ARRAY, byte, reader).map(ArrayStart)
  613|  2.93k|    }
_RINvNtNtCs5rcRHic1w1p_7cbor4ii4core3dec10decode_lenNtNtB4_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  595|  8.63k|fn decode_len<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R)
  596|  8.63k|    -> Result<Option<usize>, Error<R::Error>>
  597|  8.63k|{
  598|  8.63k|    if byte != (marker::START | (major << 5)) {
  599|  8.63k|        let len = TypeNum::new(!(major << 5), byte).decode_u64(reader)?;
  600|  8.63k|        let len = usize::try_from(len).map_err(Error::CastOverflow)?;
  601|  8.63k|        Ok(Some(len))
  602|       |    } else {
  603|      0|        Ok(None)
  604|       |    }
  605|  8.63k|}
_RINvYNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec8MapStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
   73|    163|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    163|        let byte = pull_one(reader)?;
   75|    163|        Self::decode_with(byte, reader)
   76|    163|    }
_RINvXse_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_8MapStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  656|    163|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  657|    163|        decode_len(major::MAP, byte, reader).map(MapStart)
  658|    163|    }
_RINvXsr_NtNtCs5rcRHic1w1p_7cbor4ii4core3decmNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  252|    163|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    163|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    163|                }
_RINvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_7TypeNum10decode_u64NtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  223|  11.5k|    pub(crate) fn decode_u64<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u64, Error<R::Error>> {
  224|  11.5k|        match self.byte & self.major_limit {
  225|  11.5k|            x @ 0 ..= 0x17 => Ok(x.into()),
  226|  5.54k|            0x18 => pull_one(reader).map(Into::into),
  227|       |            0x19 => {
  228|      0|                let mut buf = [0; 2];
  229|      0|                pull_exact(reader, &mut buf)?;
  230|      0|                Ok(u16::from_be_bytes(buf).into())
  231|       |            },
  232|       |            0x1a => {
  233|      0|                let mut buf = [0; 4];
  234|      0|                pull_exact(reader, &mut buf)?;
  235|      0|                Ok(u32::from_be_bytes(buf).into())
  236|       |            },
  237|       |            0x1b => {
  238|      0|                let mut buf = [0; 8];
  239|      0|                pull_exact(reader, &mut buf)?;
  240|      0|                Ok(u64::from_be_bytes(buf))
  241|       |            },
  242|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  243|       |        }
  244|  11.5k|    }
_RINvNtNtCs5rcRHic1w1p_7cbor4ii4core3dec10decode_bufNtNtB4_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  427|  5.54k|fn decode_buf<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R, buf: &mut Vec<u8>)
  428|  5.54k|    -> Result<Option<&'a [u8]>, Error<R::Error>>
  429|  5.54k|{
  430|       |    const CAP_LIMIT: usize = 16 * 1024;
  431|       |
  432|  5.54k|    if let Some(mut len) = decode_len(major, byte, reader)? {
  433|       |        // try long lifetime buffer
  434|  5.54k|        if let Reference::Long(buf) = reader.fill(len)? {
  435|  5.54k|            if buf.len() >= len {
  436|  5.54k|                reader.advance(len);
  437|  5.54k|                return Ok(Some(&buf[..len]));
  438|      0|            }
  439|      0|        }
  440|       |
  441|      0|        buf.reserve(core::cmp::min(len, CAP_LIMIT)); // TODO try_reserve ?
  442|       |
  443|      0|        while len != 0 {
  444|      0|            let readbuf = reader.fill(len)?;
  445|      0|            let readbuf = readbuf.as_ref();
  446|      0|
  447|      0|            if readbuf.is_empty() {
  448|      0|                return Err(Error::Eof);
  449|      0|            }
  450|      0|
  451|      0|            let readlen = core::cmp::min(readbuf.len(), len);
  452|      0|
  453|      0|            buf.extend_from_slice(&readbuf[..readlen]);
  454|      0|            reader.advance(readlen);
  455|      0|            len -= readlen;
  456|       |        }
  457|       |
  458|      0|        Ok(None)
  459|       |    } else {
  460|       |        // bytes sequence
  461|       |        loop {
  462|      0|            let byte = pull_one(reader)?;
  463|       |
  464|      0|            if byte == marker::BREAK {
  465|      0|                break
  466|      0|            }
  467|      0|
  468|      0|            if !reader.step_in() {
  469|      0|                return Err(Error::DepthLimit);
  470|      0|            }
  471|      0|            let mut reader = ScopeGuard(reader, |reader| reader.step_out());
  472|      0|            let reader = &mut *reader;
  473|       |
  474|      0|            if let Some(longbuf) = decode_buf(major, byte, reader, buf)? {
  475|      0|                buf.extend_from_slice(longbuf);
  476|      0|            }
  477|       |        }
  478|       |
  479|      0|        Ok(None)
  480|       |    }
  481|  5.54k|}
_RINvNtNtCs5rcRHic1w1p_7cbor4ii4core3dec8pull_oneNtNtB4_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  125|  17.2k|pub(crate) fn pull_one<'a, R: Read<'a>>(reader: &mut R) -> Result<u8, Error<R::Error>> {
  126|  17.2k|    let b = reader.fill(1)?
  127|  17.2k|        .as_ref()
  128|  17.2k|        .get(0)
  129|  17.2k|        .copied()
  130|  17.2k|        .ok_or(Error::Eof)?;
  131|  17.2k|    reader.advance(1);
  132|  17.2k|    Ok(b)
  133|  17.2k|}
_RINvYmNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
   73|    163|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    163|        let byte = pull_one(reader)?;
   75|    163|        Self::decode_with(byte, reader)
   76|    163|    }
_RINvXs8_NtNtCs5rcRHic1w1p_7cbor4ii4core3decINtNtCs71iYhC60HpU_5alloc6borrow3CoweENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  545|  2.77k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  546|  2.77k|        use crate::alloc::borrow::Cow;
  547|  2.77k|
  548|  2.77k|        let mut buf = Vec::new();
  549|  2.77k|        Ok(if let Some(longbuf) = decode_buf(major::STRING, byte, reader, &mut buf)? {
  550|  2.77k|            Cow::Borrowed(core::str::from_utf8(longbuf).map_err(Error::InvalidUtf8)?)
  551|       |        } else {
  552|      0|            let buf = String::from_utf8(buf)
  553|      0|                .map_err(|err| Error::InvalidUtf8(err.utf8_error()))?;
  554|      0|            Cow::Owned(buf)
  555|       |        })
  556|  2.77k|    }
_RINvXsg_NtNtCs5rcRHic1w1p_7cbor4ii4core3decNtB6_8TagStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
  703|  2.77k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  704|  2.77k|        TypeNum::new(!(major::TAG << 5), byte).decode_u64(reader).map(TagStart)
  705|  2.77k|    }
_RINvYyNtNtNtCs5rcRHic1w1p_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
   73|    163|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    163|        let byte = pull_one(reader)?;
   75|    163|        Self::decode_with(byte, reader)
   76|    163|    }

_RINvXsl_NtNtCs5rcRHic1w1p_7cbor4ii4core3encNtNtB8_5types4NullNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
  343|    489|        writer.push(&[marker::NULL])?;
  344|    489|        Ok(())
  345|    489|    }
_RINvXs4_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB6_7TypeNumyENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
   98|  6.35k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   99|  6.35k|        match u32::try_from(self.value) {
  100|  6.35k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
  101|       |            Err(_) => {
  102|      0|                let [x0, x1, x2, x3, x4, x5, x6, x7] = self.value.to_be_bytes();
  103|      0|                writer.push(&[self.type_ | 0x1b, x0, x1, x2, x3, x4, x5, x6, x7])?;
  104|       |            }
  105|       |        }
  106|  6.35k|        Ok(())
  107|  6.35k|    }
_RINvXs3_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB6_7TypeNummENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
   84|  6.35k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   85|  6.35k|        match u16::try_from(self.value) {
   86|  6.35k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   87|       |            Err(_) =>{
   88|      0|                let [x0, x1, x2, x3] = self.value.to_be_bytes();
   89|      0|                writer.push(&[self.type_ | 0x1a, x0, x1, x2, x3])?;
   90|       |            }
   91|       |        }
   92|  6.35k|        Ok(())
   93|  6.35k|    }
_RINvXs7_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtNtB8_5types5BytesRShENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
  209|  2.44k|        TypeNum::new(major::BYTES << 5, self.0.len() as u64).encode(writer)?;
  210|  2.44k|        writer.push(self.0)?;
  211|  2.44k|        Ok(())
  212|  2.44k|    }
_RINvXsi_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtNtB8_5types3TagINtBI_5BytesRShEENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
  317|  1.30k|        TypeNum::new(major::TAG << 5, self.0).encode(writer)?;
  318|  1.30k|        self.1.encode(writer)
  319|  1.30k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB5_7TypeNumyE3newCs4ieSHZHrxF6_15direct_syscalls:
   52|  6.35k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  6.35k|        TypeNum { type_, value }
   54|  6.35k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB5_7TypeNumhE3newCs4ieSHZHrxF6_15direct_syscalls:
   52|  6.35k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  6.35k|        TypeNum { type_, value }
   54|  6.35k|    }
_RINvXsu_NtNtCs5rcRHic1w1p_7cbor4ii4core3encyNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
  159|    652|                fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
  160|    652|                    TypeNum::new(major::UNSIGNED << 5, *self).encode(writer)
  161|    652|                }
_RINvXsd_NtNtCs5rcRHic1w1p_7cbor4ii4core3encNtB6_17ArrayStartBoundedNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
  270|  1.95k|        TypeNum::new(major::ARRAY << 5, self.0 as u64).encode(writer)?;
  271|  1.95k|        Ok(())
  272|  1.95k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB5_7TypeNummE3newCs4ieSHZHrxF6_15direct_syscalls:
   52|  6.35k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  6.35k|        TypeNum { type_, value }
   54|  6.35k|    }
_RINvXs2_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB6_7TypeNumtENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
   70|  6.35k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   71|  6.35k|        match u8::try_from(self.value) {
   72|  6.35k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   73|       |            Err(_) => {
   74|      0|                let [x0, x1] = self.value.to_be_bytes();
   75|      0|                writer.push(&[self.type_ | 0x19, x0, x1])?
   76|       |            }
   77|       |        }
   78|  6.35k|        Ok(())
   79|  6.35k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB5_7TypeNumtE3newCs4ieSHZHrxF6_15direct_syscalls:
   52|  6.35k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  6.35k|        TypeNum { type_, value }
   54|  6.35k|    }
_RINvXs1_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB6_7TypeNumhENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs4ieSHZHrxF6_15direct_syscalls:
   59|  6.35k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   60|  6.35k|        match self.value {
   61|  6.35k|            x @ 0x00 ..= 0x17 => writer.push(&[self.type_ | x])?,
   62|  2.60k|            x => writer.push(&[self.type_ | 0x18, x])?
   63|       |        }
   64|  6.35k|        Ok(())
   65|  6.35k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB5_7TypeNumtE3newCsilvC8qPft2D_8fvm_fuzz:
   52|  2.11k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  2.11k|        TypeNum { type_, value }
   54|  2.11k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB5_7TypeNummE3newCsilvC8qPft2D_8fvm_fuzz:
   52|  2.11k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  2.11k|        TypeNum { type_, value }
   54|  2.11k|    }
_RINvXs9_NtNtCs5rcRHic1w1p_7cbor4ii4core3encReNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
  228|    163|        TypeNum::new(major::STRING << 5, self.len() as u64).encode(writer)?;
  229|    163|        writer.push(self.as_bytes())?;
  230|    163|        Ok(())
  231|    163|    }
_RINvXsd_NtNtCs5rcRHic1w1p_7cbor4ii4core3encNtB6_17ArrayStartBoundedNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
  270|    978|        TypeNum::new(major::ARRAY << 5, self.0 as u64).encode(writer)?;
  271|    978|        Ok(())
  272|    978|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB5_7TypeNumhE3newCsilvC8qPft2D_8fvm_fuzz:
   52|  2.11k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  2.11k|        TypeNum { type_, value }
   54|  2.11k|    }
_RINvXsi_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtNtB8_5types3TagINtBI_5BytesRShEENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
  317|    326|        TypeNum::new(major::TAG << 5, self.0).encode(writer)?;
  318|    326|        self.1.encode(writer)
  319|    326|    }
_RINvXsu_NtNtCs5rcRHic1w1p_7cbor4ii4core3encyNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
  159|    163|                fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
  160|    163|                    TypeNum::new(major::UNSIGNED << 5, *self).encode(writer)
  161|    163|                }
_RINvXs2_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB6_7TypeNumtENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
   70|  2.11k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   71|  2.11k|        match u8::try_from(self.value) {
   72|  2.11k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   73|       |            Err(_) => {
   74|      0|                let [x0, x1] = self.value.to_be_bytes();
   75|      0|                writer.push(&[self.type_ | 0x19, x0, x1])?
   76|       |            }
   77|       |        }
   78|  2.11k|        Ok(())
   79|  2.11k|    }
_RINvXs4_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB6_7TypeNumyENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
   98|  2.11k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   99|  2.11k|        match u32::try_from(self.value) {
  100|  2.11k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
  101|       |            Err(_) => {
  102|      0|                let [x0, x1, x2, x3, x4, x5, x6, x7] = self.value.to_be_bytes();
  103|      0|                writer.push(&[self.type_ | 0x1b, x0, x1, x2, x3, x4, x5, x6, x7])?;
  104|       |            }
  105|       |        }
  106|  2.11k|        Ok(())
  107|  2.11k|    }
_RINvXs7_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtNtB8_5types5BytesRShENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
  209|    489|        TypeNum::new(major::BYTES << 5, self.0.len() as u64).encode(writer)?;
  210|    489|        writer.push(self.0)?;
  211|    489|        Ok(())
  212|    489|    }
_RINvXs1_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB6_7TypeNumhENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
   59|  2.11k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   60|  2.11k|        match self.value {
   61|  2.11k|            x @ 0x00 ..= 0x17 => writer.push(&[self.type_ | x])?,
   62|    815|            x => writer.push(&[self.type_ | 0x18, x])?
   63|       |        }
   64|  2.11k|        Ok(())
   65|  2.11k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB5_7TypeNumyE3newCsilvC8qPft2D_8fvm_fuzz:
   52|  2.11k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  2.11k|        TypeNum { type_, value }
   54|  2.11k|    }
_RINvXs3_NtNtCs5rcRHic1w1p_7cbor4ii4core3encINtB6_7TypeNummENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsilvC8qPft2D_8fvm_fuzz:
   84|  2.11k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   85|  2.11k|        match u16::try_from(self.value) {
   86|  2.11k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   87|       |            Err(_) =>{
   88|      0|                let [x0, x1, x2, x3] = self.value.to_be_bytes();
   89|      0|                writer.push(&[self.type_ | 0x1a, x0, x1, x2, x3])?;
   90|       |            }
   91|       |        }
   92|  2.11k|        Ok(())
   93|  2.11k|    }

_RNvXs_NtNtCs5rcRHic1w1p_7cbor4ii4core5utilsNtB4_9BufWriterNtNtB6_3enc5Write4push:
   40|  12.0k|        self.0.try_reserve(input.len())?;
   41|  12.0k|        self.0.extend_from_slice(input);
   42|  12.0k|        Ok(())
   43|  12.0k|    }
_RNvXs1_NtNtCs5rcRHic1w1p_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read7advance:
   68|  55.5k|    fn advance(&mut self, n: usize) {
   69|  55.5k|        let len = core::cmp::min(self.buf.len(), n);
   70|  55.5k|        self.buf = &self.buf[len..];
   71|  55.5k|    }
_RNvXs1_NtNtCs5rcRHic1w1p_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read4fill:
   62|  67.3k|    fn fill<'b>(&'b mut self, want: usize) -> Result<dec::Reference<'de, 'b>, Self::Error> {
   63|  67.3k|        let len = core::cmp::min(self.buf.len(), want);
   64|  67.3k|        Ok(dec::Reference::Long(&self.buf[..len]))
   65|  67.3k|    }
_RNvXs1_NtNtCs5rcRHic1w1p_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read8step_out:
   84|  12.2k|    fn step_out(&mut self) {
   85|  12.2k|        self.limit += 1;
   86|  12.2k|    }
_RNvXs1_NtNtCs5rcRHic1w1p_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read7step_in:
   75|  12.2k|        if let Some(limit) = self.limit.checked_sub(1) {
   76|  12.2k|            self.limit = limit;
   77|  12.2k|            true
   78|       |        } else {
   79|      0|            false
   80|       |        }
   81|  12.2k|    }
_RNvMNtNtCs5rcRHic1w1p_7cbor4ii4core5utilsNtB2_9BufWriter10into_inner:
   24|  1.14k|    pub fn into_inner(self) -> Vec<u8> {
   25|  1.14k|        self.0
   26|  1.14k|    }
_RNvMs0_NtNtCs5rcRHic1w1p_7cbor4ii4core5utilsNtB5_11SliceReader3new:
   53|  1.14k|    pub fn new(buf: &[u8]) -> SliceReader<'_> {
   54|  1.14k|        SliceReader { buf, limit: 256 }
   55|  1.14k|    }
_RNvMNtNtCs5rcRHic1w1p_7cbor4ii4core5utilsNtB2_9BufWriter3new:
   14|  1.14k|    pub fn new(buf: Vec<u8>) -> Self {
   15|  1.14k|       BufWriter(buf)
   16|  1.14k|    }

_RNvMNtCseVyrqhqyiIX_3cid3cidINtB2_3CidKj40_E8to_bytesCs4ieSHZHrxF6_15direct_syscalls:
  186|  2.44k|    pub fn to_bytes(&self) -> Vec<u8> {
  187|  2.44k|        let mut bytes = Vec::new();
  188|  2.44k|        self.write_bytes(&mut bytes).unwrap();
  189|  2.44k|        bytes
  190|  2.44k|    }
_RNvXsh_NtCseVyrqhqyiIX_3cid3cidINtB5_3CidKj40_ENtNtCsdRJjCzU6nMS_4core5clone5Clone5cloneCs4ieSHZHrxF6_15direct_syscalls:
   64|  1.46k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvXse_NtCseVyrqhqyiIX_3cid3cidINtB5_3CidKj40_ENtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eqCs4ieSHZHrxF6_15direct_syscalls:
   64|    174|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RINvMNtCseVyrqhqyiIX_3cid3cidINtB3_3CidKj40_E10read_bytesQRShECs4ieSHZHrxF6_15direct_syscalls:
  140|  4.89k|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|  4.89k|        let version = varint_read_u64(&mut r)?;
  142|  4.89k|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|  4.89k|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|  4.89k|        }
  151|       |
  152|  4.89k|        let version = Version::try_from(version)?;
  153|  4.89k|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|  4.89k|                let mh = Multihash::read(r)?;
  157|  4.89k|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|  4.89k|    }
_RNvMNtCseVyrqhqyiIX_3cid3cidINtB2_3CidKj40_E12to_string_v1Cs4ieSHZHrxF6_15direct_syscalls:
  200|    163|    fn to_string_v1(&self) -> String {
  201|    163|        multibase::encode(Base::Base32Lower, self.to_bytes().as_slice())
  202|    163|    }
_RNvXs0_NtCseVyrqhqyiIX_3cid3cidINtB5_3CidKj40_ENtNtCsdRJjCzU6nMS_4core3fmt7Display3fmtCs4ieSHZHrxF6_15direct_syscalls:
  248|    163|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
  249|    163|        let output = match self.version {
  250|      0|            Version::V0 => self.to_string_v0(),
  251|    163|            Version::V1 => self.to_string_v1(),
  252|       |        };
  253|    163|        write!(f, "{}", output)
  254|    163|    }
_RNvMNtCseVyrqhqyiIX_3cid3cidINtB2_3CidKj40_E6new_v1Cs4ieSHZHrxF6_15direct_syscalls:
   90|  5.21k|    pub const fn new_v1(codec: u64, hash: Multihash<S>) -> Self {
   91|  5.21k|        Self {
   92|  5.21k|            version: Version::V1,
   93|  5.21k|            codec,
   94|  5.21k|            hash,
   95|  5.21k|        }
   96|  5.21k|    }
_RINvXsk_NtCseVyrqhqyiIX_3cid3cidINtB6_3CidKj40_ENtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECs4ieSHZHrxF6_15direct_syscalls:
   64|  9.29k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RINvMNtCseVyrqhqyiIX_3cid3cidINtB3_3CidKj40_E14write_bytes_v1QINtNtCs71iYhC60HpU_5alloc3vec3VechEECs4ieSHZHrxF6_15direct_syscalls:
  162|  2.44k|    fn write_bytes_v1<W: io::Write>(&self, mut w: W) -> Result<()> {
  163|  2.44k|        let mut version_buf = varint_encode::u64_buffer();
  164|  2.44k|        let version = varint_encode::u64(self.version.into(), &mut version_buf);
  165|  2.44k|
  166|  2.44k|        let mut codec_buf = varint_encode::u64_buffer();
  167|  2.44k|        let codec = varint_encode::u64(self.codec, &mut codec_buf);
  168|  2.44k|
  169|  2.44k|        w.write_all(version)?;
  170|  2.44k|        w.write_all(codec)?;
  171|  2.44k|        self.hash.write(&mut w)?;
  172|  2.44k|        Ok(())
  173|  2.44k|    }
_RNvMNtCseVyrqhqyiIX_3cid3cidINtB2_3CidKj40_E3newCs4ieSHZHrxF6_15direct_syscalls:
   99|  4.89k|    pub const fn new(version: Version, codec: u64, hash: Multihash<S>) -> Result<Self> {
  100|  4.89k|        match version {
  101|       |            Version::V0 => {
  102|      0|                if codec != DAG_PB {
  103|      0|                    return Err(Error::InvalidCidV0Codec);
  104|      0|                }
  105|      0|                Self::new_v0(hash)
  106|       |            }
  107|  4.89k|            Version::V1 => Ok(Self::new_v1(codec, hash)),
  108|       |        }
  109|  4.89k|    }
_RNvXs6_NtCseVyrqhqyiIX_3cid3cidINtB5_3CidKj40_EINtNtCsdRJjCzU6nMS_4core7convert7TryFromRShE8try_fromCs4ieSHZHrxF6_15direct_syscalls:
  333|  4.89k|    fn try_from(mut bytes: &[u8]) -> Result<Self> {
  334|  4.89k|        Self::read_bytes(&mut bytes)
  335|  4.89k|    }
_RINvMNtCseVyrqhqyiIX_3cid3cidINtB3_3CidKj40_E11write_bytesQINtNtCs71iYhC60HpU_5alloc3vec3VechEECs4ieSHZHrxF6_15direct_syscalls:
  176|  2.44k|    pub fn write_bytes<W: io::Write>(&self, w: W) -> Result<()> {
  177|  2.44k|        match self.version {
  178|      0|            Version::V0 => self.hash.write(w)?,
  179|  2.44k|            Version::V1 => self.write_bytes_v1(w)?,
  180|       |        }
  181|  2.44k|        Ok(())
  182|  2.44k|    }
_RINvMNtCseVyrqhqyiIX_3cid3cidINtB3_3CidKj40_E10read_bytesQINtNtNtCslmThs0IH7zH_3std2io6cursor6CursorRINtNtCs71iYhC60HpU_5alloc3vec3VechEEECsilvC8qPft2D_8fvm_fuzz:
  140|  2.77k|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|  2.77k|        let version = varint_read_u64(&mut r)?;
  142|  2.77k|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|  2.77k|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|  2.77k|        }
  151|       |
  152|  2.77k|        let version = Version::try_from(version)?;
  153|  2.77k|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|  2.77k|                let mh = Multihash::read(r)?;
  157|  2.77k|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|  2.77k|    }
_RINvMNtCseVyrqhqyiIX_3cid3cidINtB3_3CidKj40_E14write_bytes_v1QINtNtCs71iYhC60HpU_5alloc3vec3VechEECsilvC8qPft2D_8fvm_fuzz:
  162|    326|    fn write_bytes_v1<W: io::Write>(&self, mut w: W) -> Result<()> {
  163|    326|        let mut version_buf = varint_encode::u64_buffer();
  164|    326|        let version = varint_encode::u64(self.version.into(), &mut version_buf);
  165|    326|
  166|    326|        let mut codec_buf = varint_encode::u64_buffer();
  167|    326|        let codec = varint_encode::u64(self.codec, &mut codec_buf);
  168|    326|
  169|    326|        w.write_all(version)?;
  170|    326|        w.write_all(codec)?;
  171|    326|        self.hash.write(&mut w)?;
  172|    326|        Ok(())
  173|    326|    }
_RINvMNtCseVyrqhqyiIX_3cid3cidINtB3_3CidKj40_E11write_bytesQINtNtCs71iYhC60HpU_5alloc3vec3VechEECsilvC8qPft2D_8fvm_fuzz:
  176|    326|    pub fn write_bytes<W: io::Write>(&self, w: W) -> Result<()> {
  177|    326|        match self.version {
  178|      0|            Version::V0 => self.hash.write(w)?,
  179|    326|            Version::V1 => self.write_bytes_v1(w)?,
  180|       |        }
  181|    326|        Ok(())
  182|    326|    }
_RNvMNtCseVyrqhqyiIX_3cid3cidINtB2_3CidKj40_E6new_v1CsilvC8qPft2D_8fvm_fuzz:
   90|  6.35k|    pub const fn new_v1(codec: u64, hash: Multihash<S>) -> Self {
   91|  6.35k|        Self {
   92|  6.35k|            version: Version::V1,
   93|  6.35k|            codec,
   94|  6.35k|            hash,
   95|  6.35k|        }
   96|  6.35k|    }
_RINvMNtCseVyrqhqyiIX_3cid3cidINtB3_3CidKj40_E10read_bytesQRShECsilvC8qPft2D_8fvm_fuzz:
  140|  2.77k|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|  2.77k|        let version = varint_read_u64(&mut r)?;
  142|  2.77k|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|  2.77k|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|  2.77k|        }
  151|       |
  152|  2.77k|        let version = Version::try_from(version)?;
  153|  2.77k|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|  2.77k|                let mh = Multihash::read(r)?;
  157|  2.77k|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|  2.77k|    }
_RNvMNtCseVyrqhqyiIX_3cid3cidINtB2_3CidKj40_E3newCsilvC8qPft2D_8fvm_fuzz:
   99|  5.54k|    pub const fn new(version: Version, codec: u64, hash: Multihash<S>) -> Result<Self> {
  100|  5.54k|        match version {
  101|       |            Version::V0 => {
  102|      0|                if codec != DAG_PB {
  103|      0|                    return Err(Error::InvalidCidV0Codec);
  104|      0|                }
  105|      0|                Self::new_v0(hash)
  106|       |            }
  107|  5.54k|            Version::V1 => Ok(Self::new_v1(codec, hash)),
  108|       |        }
  109|  5.54k|    }
_RNvXse_NtCseVyrqhqyiIX_3cid3cidINtB5_3CidKj40_ENtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eqCsilvC8qPft2D_8fvm_fuzz:
   64|    161|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvMNtCseVyrqhqyiIX_3cid3cidINtB2_3CidKj40_E8to_bytesCsilvC8qPft2D_8fvm_fuzz:
  186|    326|    pub fn to_bytes(&self) -> Vec<u8> {
  187|    326|        let mut bytes = Vec::new();
  188|    326|        self.write_bytes(&mut bytes).unwrap();
  189|    326|        bytes
  190|    326|    }
_RNvXs6_NtCseVyrqhqyiIX_3cid3cidINtB5_3CidKj40_EINtNtCsdRJjCzU6nMS_4core7convert7TryFromRShE8try_fromCsilvC8qPft2D_8fvm_fuzz:
  333|  2.77k|    fn try_from(mut bytes: &[u8]) -> Result<Self> {
  334|  2.77k|        Self::read_bytes(&mut bytes)
  335|  2.77k|    }
_RINvXsk_NtCseVyrqhqyiIX_3cid3cidINtB6_3CidKj40_ENtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECsilvC8qPft2D_8fvm_fuzz:
   64|  9.29k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvXsh_NtCseVyrqhqyiIX_3cid3cidINtB5_3CidKj40_ENtNtCsdRJjCzU6nMS_4core5clone5Clone5cloneCsheoVkkQew6K_3fvm:
   64|    163|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RINvXsk_NtCseVyrqhqyiIX_3cid3cidINtB6_3CidKj40_ENtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECsf3d0o8dgc6o_19fvm_ipld_blockstore:
   64|  8.96k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvXse_NtCseVyrqhqyiIX_3cid3cidINtB5_3CidKj40_ENtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eqCsf3d0o8dgc6o_19fvm_ipld_blockstore:
   64|  1.54k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]

_RINvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtB8_3cid3CidKj40_ENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   79|  2.93k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   80|  2.93k|    where
   81|  2.93k|        D: de::Deserializer<'de>,
   82|  2.93k|    {
   83|  2.93k|        /// Main visitor to deserialize a CID.
   84|  2.93k|        ///
   85|  2.93k|        /// This visitor has only a single entry point to deserialize CIDs, it's
   86|  2.93k|        /// `visit_new_type_struct()`. This ensures that it isn't accidentally used to decode CIDs
   87|  2.93k|        /// to bytes.
   88|  2.93k|        struct MainEntryVisitor<const SIZE: usize>;
   89|  2.93k|
   90|  2.93k|        impl<'de, const SIZE: usize> de::Visitor<'de> for MainEntryVisitor<SIZE> {
   91|  2.93k|            type Value = CidGeneric<SIZE>;
   92|  2.93k|
   93|  2.93k|            fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   94|  2.93k|                write!(fmt, "a valid CID in bytes, wrapped in an newtype struct")
   95|  2.93k|            }
   96|  2.93k|
   97|  2.93k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  2.93k|            where
   99|  2.93k|                D: de::Deserializer<'de>,
  100|  2.93k|            {
  101|  2.93k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  2.93k|            }
  103|  2.93k|        }
  104|  2.93k|
  105|  2.93k|        deserializer.deserialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, MainEntryVisitor)
  106|  2.93k|    }
_RINvXs_NtCseVyrqhqyiIX_3cid5serdeNtB5_17BytesToCidVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor11visit_bytesNtNtCsb605JUWHIii_12libipld_core5error10SerdeErrorECs4ieSHZHrxF6_15direct_syscalls:
   48|    978|    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
   49|    978|    where
   50|    978|        E: de::Error,
   51|    978|    {
   52|    978|        CidGeneric::<SIZE>::try_from(value)
   53|    978|            .map_err(|err| de::Error::custom(format!("Failed to deserialize CID: {}", err)))
   54|    978|    }
_RINvXNvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtBb_3cid3CidKpENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeINtB3_16MainEntryVisitorKj40_ENtBU_7Visitor20visit_newtype_structNtNtNtCsb605JUWHIii_12libipld_core5serde2de15CidDeserializerECs4ieSHZHrxF6_15direct_syscalls:
   97|    978|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|    978|            where
   99|    978|                D: de::Deserializer<'de>,
  100|    978|            {
  101|    978|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|    978|            }
_RINvXs_NtCseVyrqhqyiIX_3cid5serdeNtB5_17BytesToCidVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor11visit_bytesINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
   48|  3.91k|    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
   49|  3.91k|    where
   50|  3.91k|        E: de::Error,
   51|  3.91k|    {
   52|  3.91k|        CidGeneric::<SIZE>::try_from(value)
   53|  3.91k|            .map_err(|err| de::Error::custom(format!("Failed to deserialize CID: {}", err)))
   54|  3.91k|    }
_RINvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtB8_3cid3CidKj40_ENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
   79|    978|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   80|    978|    where
   81|    978|        D: de::Deserializer<'de>,
   82|    978|    {
   83|    978|        /// Main visitor to deserialize a CID.
   84|    978|        ///
   85|    978|        /// This visitor has only a single entry point to deserialize CIDs, it's
   86|    978|        /// `visit_new_type_struct()`. This ensures that it isn't accidentally used to decode CIDs
   87|    978|        /// to bytes.
   88|    978|        struct MainEntryVisitor<const SIZE: usize>;
   89|    978|
   90|    978|        impl<'de, const SIZE: usize> de::Visitor<'de> for MainEntryVisitor<SIZE> {
   91|    978|            type Value = CidGeneric<SIZE>;
   92|    978|
   93|    978|            fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   94|    978|                write!(fmt, "a valid CID in bytes, wrapped in an newtype struct")
   95|    978|            }
   96|    978|
   97|    978|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|    978|            where
   99|    978|                D: de::Deserializer<'de>,
  100|    978|            {
  101|    978|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|    978|            }
  103|    978|        }
  104|    978|
  105|    978|        deserializer.deserialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, MainEntryVisitor)
  106|    978|    }
_RINvXNtCseVyrqhqyiIX_3cid5serdeINtNtB5_3cid3CidKj40_ENtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   29|  1.30k|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   30|  1.30k|    where
   31|  1.30k|        S: ser::Serializer,
   32|  1.30k|    {
   33|  1.30k|        let value = ByteBuf::from(self.to_bytes());
   34|  1.30k|        serializer.serialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, &value)
   35|  1.30k|    }
_RINvXNvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtBb_3cid3CidKpENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeINtB3_16MainEntryVisitorKj40_ENtBU_7Visitor20visit_newtype_structQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de15CidDeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   97|  2.93k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  2.93k|            where
   99|  2.93k|                D: de::Deserializer<'de>,
  100|  2.93k|            {
  101|  2.93k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  2.93k|            }
_RINvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtB8_3cid3CidKj40_ENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
   79|  2.77k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   80|  2.77k|    where
   81|  2.77k|        D: de::Deserializer<'de>,
   82|  2.77k|    {
   83|  2.77k|        /// Main visitor to deserialize a CID.
   84|  2.77k|        ///
   85|  2.77k|        /// This visitor has only a single entry point to deserialize CIDs, it's
   86|  2.77k|        /// `visit_new_type_struct()`. This ensures that it isn't accidentally used to decode CIDs
   87|  2.77k|        /// to bytes.
   88|  2.77k|        struct MainEntryVisitor<const SIZE: usize>;
   89|  2.77k|
   90|  2.77k|        impl<'de, const SIZE: usize> de::Visitor<'de> for MainEntryVisitor<SIZE> {
   91|  2.77k|            type Value = CidGeneric<SIZE>;
   92|  2.77k|
   93|  2.77k|            fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   94|  2.77k|                write!(fmt, "a valid CID in bytes, wrapped in an newtype struct")
   95|  2.77k|            }
   96|  2.77k|
   97|  2.77k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  2.77k|            where
   99|  2.77k|                D: de::Deserializer<'de>,
  100|  2.77k|            {
  101|  2.77k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  2.77k|            }
  103|  2.77k|        }
  104|  2.77k|
  105|  2.77k|        deserializer.deserialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, MainEntryVisitor)
  106|  2.77k|    }
_RINvXs_NtCseVyrqhqyiIX_3cid5serdeNtB5_17BytesToCidVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor11visit_bytesINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECsilvC8qPft2D_8fvm_fuzz:
   48|  2.77k|    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
   49|  2.77k|    where
   50|  2.77k|        E: de::Error,
   51|  2.77k|    {
   52|  2.77k|        CidGeneric::<SIZE>::try_from(value)
   53|  2.77k|            .map_err(|err| de::Error::custom(format!("Failed to deserialize CID: {}", err)))
   54|  2.77k|    }
_RINvXNvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtBb_3cid3CidKpENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeINtB3_16MainEntryVisitorKj40_ENtBU_7Visitor20visit_newtype_structQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de15CidDeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
   97|  2.77k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  2.77k|            where
   99|  2.77k|                D: de::Deserializer<'de>,
  100|  2.77k|            {
  101|  2.77k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  2.77k|            }
_RINvXNtCseVyrqhqyiIX_3cid5serdeINtNtB5_3cid3CidKj40_ENtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   29|    326|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   30|    326|    where
   31|    326|        S: ser::Serializer,
   32|    326|    {
   33|    326|        let value = ByteBuf::from(self.to_bytes());
   34|    326|        serializer.serialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, &value)
   35|    326|    }

_RNvXs2_NtCseVyrqhqyiIX_3cid7versionNtB5_7VersionNtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eq:
    6|  1.87k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RINvXsa_NtCseVyrqhqyiIX_3cid7versionNtB6_7VersionNtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECs4ieSHZHrxF6_15direct_syscalls:
    6|  9.29k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RINvXsa_NtCseVyrqhqyiIX_3cid7versionNtB6_7VersionNtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECsilvC8qPft2D_8fvm_fuzz:
    6|  9.29k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RINvXsa_NtCseVyrqhqyiIX_3cid7versionNtB6_7VersionNtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECsf3d0o8dgc6o_19fvm_ipld_blockstore:
    6|  8.96k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RNvXs_NtCseVyrqhqyiIX_3cid7versionNtB4_7VersionINtNtCsdRJjCzU6nMS_4core7convert7TryFromyE8try_from:
   34|  10.4k|    fn try_from(raw: u64) -> Result<Self> {
   35|  10.4k|        match raw {
   36|      0|            0 => Ok(Self::V0),
   37|  10.4k|            1 => Ok(Self::V1),
   38|      0|            _ => Err(Error::InvalidCidVersion),
   39|       |        }
   40|  10.4k|    }
_RNvXs0_NtCseVyrqhqyiIX_3cid7versionyINtNtCsdRJjCzU6nMS_4core7convert4FromNtB5_7VersionE4from:
   44|  2.77k|    fn from(ver: Version) -> u64 {
   45|  2.77k|        match ver {
   46|      0|            Version::V0 => 0,
   47|  2.77k|            Version::V1 => 1,
   48|       |        }
   49|  2.77k|    }

_RNvNtNtNtCs7HNaFSx2gxZ_4sha26sha2563x8611shani_cpuid8init_get:
  106|    489|            pub fn init_get() -> (InitToken, bool) {
  107|    489|                let res = $crate::__unless_target_features! {
  108|       |                    $($tf),+ => {
  109|       |                        // Relaxed ordering is fine, as we only have a single atomic variable.
  110|    489|                        let val = STORAGE.load(Relaxed);
  111|    489|
  112|    489|                        if val == UNINIT {
  113|      1|                            let res = $crate::__detect_target_features!($($tf),+);
  114|      1|                            STORAGE.store(res as u8, Relaxed);
  115|      1|                            res
  116|       |                        } else {
  117|    488|                            val == 1
  118|       |                        }
  119|       |                    }
  120|       |                };
  121|       |
  122|    489|                (InitToken(()), res)
  123|    489|            }
_RNvNtNtNtCs7HNaFSx2gxZ_4sha26sha2563x8611shani_cpuid3get:
  135|    489|            pub fn get() -> bool {
  136|    489|                init_get().1
  137|    489|            }

_RNvNvNtNtNtCs7HNaFSx2gxZ_4sha26sha2563x8611shani_cpuid8init_get11cpuid_count:
   51|      1|        unsafe fn cpuid_count(leaf: u32, sub_leaf: u32) -> CpuidResult {
   52|      1|            __cpuid_count(leaf, sub_leaf)
   53|      1|        }
_RNvNvNtNtNtCs7HNaFSx2gxZ_4sha26sha2563x8611shani_cpuid8init_get5cpuid:
   46|      1|        unsafe fn cpuid(leaf: u32) -> CpuidResult {
   47|      1|            __cpuid(leaf)
   48|      1|        }

_RINvNtCs3IsnRjS6uPr_17cranelift_codegen13constant_hash5probeReNtNtNtB4_8settings6detail8TemplateEB4_:
   33|  7.82k|pub fn probe<K: Copy + Eq, T: Table<K> + ?Sized>(
   34|  7.82k|    table: &T,
   35|  7.82k|    key: K,
   36|  7.82k|    hash: usize,
   37|  7.82k|) -> Result<usize, usize> {
   38|  7.82k|    debug_assert!(table.len().is_power_of_two());
   39|  7.82k|    let mask = table.len() - 1;
   40|  7.82k|
   41|  7.82k|    let mut idx = hash;
   42|  7.82k|    let mut step = 0;
   43|       |
   44|       |    loop {
   45|  8.80k|        idx &= mask;
   46|  8.80k|
   47|  8.80k|        match table.key(idx) {
   48|      0|            None => return Err(idx),
   49|  8.80k|            Some(k) if k == key => return Ok(idx),
   50|    978|            _ => {}
   51|    978|        }
   52|    978|
   53|    978|        // Quadratic probing.
   54|    978|        step += 1;
   55|       |
   56|       |        // When `table.len()` is a power of two, it can be proven that `idx` will visit all
   57|       |        // entries. This means that this loop will always terminate if the hash table has even
   58|       |        // one unused entry.
   59|    978|        debug_assert!(step < table.len());
   60|    978|        idx += step;
   61|       |    }
   62|  7.82k|}

_RNvXsc_NtCs3IsnRjS6uPr_17cranelift_codegen3isaNtB5_7BuilderNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  138|    326|#[derive(Clone)]
_RNvMs0_NtCs3IsnRjS6uPr_17cranelift_codegen3isaNtB5_7Builder6finish:
  163|    326|    pub fn finish(self, shared_flags: settings::Flags) -> CodegenResult<Box<dyn TargetIsa>> {
  164|    326|        (self.constructor)(self.triple, shared_flags, self.setup)
  165|    326|    }
_RNvNtCs3IsnRjS6uPr_17cranelift_codegen3isa6lookup:
   93|    326|pub fn lookup(triple: Triple) -> Result<Builder, LookupError> {
   94|    326|    match triple.architecture {
   95|       |        Architecture::X86_64 => {
   96|    326|            isa_builder!(x64, (feature = "x86"), triple)
   97|       |        }
   98|      0|        Architecture::Aarch64 { .. } => isa_builder!(aarch64, (feature = "arm64"), triple),
   99|      0|        Architecture::S390x { .. } => isa_builder!(s390x, (feature = "s390x"), triple),
  100|      0|        _ => Err(LookupError::Unsupported),
  101|       |    }
  102|    326|}
_RNvXs1_NtCs3IsnRjS6uPr_17cranelift_codegen3isaNtB5_7BuilderNtNtB7_8settings12Configurable3set:
  169|  1.30k|    fn set(&mut self, name: &str, value: &str) -> SetResult<()> {
  170|  1.30k|        self.setup.set(name, value)
  171|  1.30k|    }
_RNvXs1_NtCs3IsnRjS6uPr_17cranelift_codegen3isaNtB5_7BuilderNtNtB7_8settings12Configurable6enable:
  173|  4.56k|    fn enable(&mut self, name: &str) -> SetResult<()> {
  174|  4.56k|        self.setup.enable(name)
  175|  4.56k|    }

_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs5xmm14:
  152|    326|pub(crate) fn xmm14() -> Reg {
  153|    326|    fpr(14)
  154|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs5xmm11:
  143|    326|pub(crate) fn xmm11() -> Reg {
  144|    326|    fpr(11)
  145|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm5:
  125|    326|pub(crate) fn xmm5() -> Reg {
  126|    326|    fpr(5)
  127|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3rcx:
   52|    326|pub(crate) fn rcx() -> Reg {
   53|    326|    gpr(ENC_RCX)
   54|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs5xmm13:
  149|    326|pub(crate) fn xmm13() -> Reg {
  150|    326|    fpr(13)
  151|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs2r9:
   61|    326|pub(crate) fn r9() -> Reg {
   62|    326|    gpr(ENC_R9)
   63|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs5xmm10:
  140|    326|pub(crate) fn xmm10() -> Reg {
  141|    326|    fpr(10)
  142|    326|}
_RNvNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs22create_reg_env_systemv4preg:
  161|  9.78k|    fn preg(r: Reg) -> PReg {
  162|  9.78k|        r.to_real_reg().unwrap().into()
  163|  9.78k|    }
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3rdx:
   55|    326|pub(crate) fn rdx() -> Reg {
   56|    326|    gpr(ENC_RDX)
   57|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs22create_reg_env_systemv:
  160|    326|pub(crate) fn create_reg_env_systemv(flags: &settings::Flags) -> MachineEnv {
  161|    326|    fn preg(r: Reg) -> PReg {
  162|    326|        r.to_real_reg().unwrap().into()
  163|    326|    }
  164|    326|
  165|    326|    let mut env = MachineEnv {
  166|    326|        preferred_regs_by_class: [
  167|    326|            // Preferred GPRs: caller-saved in the SysV ABI.
  168|    326|            vec![
  169|    326|                preg(rsi()),
  170|    326|                preg(rdi()),
  171|    326|                preg(rax()),
  172|    326|                preg(rcx()),
  173|    326|                preg(rdx()),
  174|    326|                preg(r8()),
  175|    326|                preg(r9()),
  176|    326|                preg(r10()),
  177|    326|                preg(r11()),
  178|    326|            ],
  179|    326|            // Preferred XMMs: all of them.
  180|    326|            vec![
  181|    326|                preg(xmm0()),
  182|    326|                preg(xmm1()),
  183|    326|                preg(xmm2()),
  184|    326|                preg(xmm3()),
  185|    326|                preg(xmm4()),
  186|    326|                preg(xmm5()),
  187|    326|                preg(xmm6()),
  188|    326|                preg(xmm7()),
  189|    326|                preg(xmm8()),
  190|    326|                preg(xmm9()),
  191|    326|                preg(xmm10()),
  192|    326|                preg(xmm11()),
  193|    326|                preg(xmm12()),
  194|    326|                preg(xmm13()),
  195|    326|                preg(xmm14()),
  196|    326|                preg(xmm15()),
  197|    326|            ],
  198|    326|        ],
  199|    326|        non_preferred_regs_by_class: [
  200|    326|            // Non-preferred GPRs: callee-saved in the SysV ABI.
  201|    326|            vec![preg(rbx()), preg(r12()), preg(r13()), preg(r14())],
  202|    326|            // Non-preferred XMMs: none.
  203|    326|            vec![],
  204|    326|        ],
  205|    326|        fixed_stack_slots: vec![],
  206|    326|    };
  207|       |
  208|    326|    debug_assert_eq!(r15(), pinned_reg());
  209|    326|    if !flags.enable_pinned_reg() {
  210|    326|        env.non_preferred_regs_by_class[0].push(preg(r15()));
  211|    326|    }
  212|       |
  213|    326|    env
  214|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs5xmm12:
  146|    326|pub(crate) fn xmm12() -> Reg {
  147|    326|    fpr(12)
  148|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm3:
  119|    326|pub(crate) fn xmm3() -> Reg {
  120|    326|    fpr(3)
  121|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs10pinned_reg:
   97|    326|pub(crate) fn pinned_reg() -> Reg {
   98|    326|    r15()
   99|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs2r8:
   58|    326|pub(crate) fn r8() -> Reg {
   59|    326|    gpr(ENC_R8)
   60|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3rax:
   49|    326|pub(crate) fn rax() -> Reg {
   50|    326|    gpr(ENC_RAX)
   51|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm7:
  131|    326|pub(crate) fn xmm7() -> Reg {
  132|    326|    fpr(7)
  133|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3rbx:
   79|    326|pub(crate) fn rbx() -> Reg {
   80|    326|    gpr(ENC_RBX)
   81|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3r13:
   73|    326|pub(crate) fn r13() -> Reg {
   74|    326|    gpr(ENC_R13)
   75|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3r10:
   64|    326|pub(crate) fn r10() -> Reg {
   65|    326|    gpr(ENC_R10)
   66|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3gpr:
   35|  5.21k|fn gpr(enc: u8) -> Reg {
   36|  5.21k|    let preg = gpr_preg(enc);
   37|  5.21k|    Reg::from(VReg::new(preg.index(), RegClass::Int))
   38|  5.21k|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3rdi:
   46|    326|pub(crate) fn rdi() -> Reg {
   47|    326|    gpr(ENC_RDI)
   48|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm6:
  128|    326|pub(crate) fn xmm6() -> Reg {
  129|    326|    fpr(6)
  130|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3fpr:
  101|  5.21k|fn fpr(enc: u8) -> Reg {
  102|  5.21k|    let preg = fpr_preg(enc);
  103|  5.21k|    Reg::from(VReg::new(preg.index(), RegClass::Float))
  104|  5.21k|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm0:
  110|    326|pub(crate) fn xmm0() -> Reg {
  111|    326|    fpr(0)
  112|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm9:
  137|    326|pub(crate) fn xmm9() -> Reg {
  138|    326|    fpr(9)
  139|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3r14:
   76|    326|pub(crate) fn r14() -> Reg {
   77|    326|    gpr(ENC_R14)
   78|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs8gpr_preg:
   39|  5.21k|pub(crate) const fn gpr_preg(enc: u8) -> PReg {
   40|  5.21k|    PReg::new(enc as usize, RegClass::Int)
   41|  5.21k|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3r11:
   67|    326|pub(crate) fn r11() -> Reg {
   68|    326|    gpr(ENC_R11)
   69|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm8:
  134|    326|pub(crate) fn xmm8() -> Reg {
  135|    326|    fpr(8)
  136|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs5xmm15:
  155|    326|pub(crate) fn xmm15() -> Reg {
  156|    326|    fpr(15)
  157|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3r15:
   83|    978|pub(crate) fn r15() -> Reg {
   84|    978|    gpr(ENC_R15)
   85|    978|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm2:
  116|    326|pub(crate) fn xmm2() -> Reg {
  117|    326|    fpr(2)
  118|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3r12:
   70|    326|pub(crate) fn r12() -> Reg {
   71|    326|    gpr(ENC_R12)
   72|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs3rsi:
   43|    326|pub(crate) fn rsi() -> Reg {
   44|    326|    gpr(ENC_RSI)
   45|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs8fpr_preg:
  106|  5.21k|pub(crate) const fn fpr_preg(enc: u8) -> PReg {
  107|  5.21k|    PReg::new(enc as usize, RegClass::Float)
  108|  5.21k|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm1:
  113|    326|pub(crate) fn xmm1() -> Reg {
  114|    326|    fpr(1)
  115|    326|}
_RNvNtNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x644inst4regs4xmm4:
  122|    326|pub(crate) fn xmm4() -> Reg {
  123|    326|    fpr(4)
  124|    326|}

_RNvNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x6411isa_builder:
  181|    326|pub(crate) fn isa_builder(triple: Triple) -> IsaBuilder {
  182|    326|    IsaBuilder {
  183|    326|        triple,
  184|    326|        setup: x64_settings::builder(),
  185|    326|        constructor: isa_constructor,
  186|    326|    }
  187|    326|}
_RNvMNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x64NtB2_10X64Backend14new_with_flags:
   38|    326|    fn new_with_flags(triple: Triple, flags: Flags, x64_flags: x64_settings::Flags) -> Self {
   39|    326|        let reg_env = create_reg_env_systemv(&flags);
   40|    326|        Self {
   41|    326|            triple,
   42|    326|            flags,
   43|    326|            x64_flags,
   44|    326|            reg_env,
   45|    326|        }
   46|    326|    }
_RNvNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x6415isa_constructor:
  189|    326|fn isa_constructor(
  190|    326|    triple: Triple,
  191|    326|    shared_flags: Flags,
  192|    326|    builder: shared_settings::Builder,
  193|    326|) -> CodegenResult<Box<dyn TargetIsa>> {
  194|    326|    let isa_flags = x64_settings::Flags::new(&shared_flags, builder);
  195|    326|
  196|    326|    // Check for compatibility between flags and ISA level
  197|    326|    // requested. In particular, SIMD support requires SSE4.2.
  198|    326|    if shared_flags.enable_simd() {
  199|      0|        if !isa_flags.has_sse3()
  200|      0|            || !isa_flags.has_ssse3()
  201|      0|            || !isa_flags.has_sse41()
  202|      0|            || !isa_flags.has_sse42()
  203|       |        {
  204|      0|            return Err(CodegenError::Unsupported(
  205|      0|                "SIMD support requires SSE3, SSSE3, SSE4.1, and SSE4.2 on x86_64.".into(),
  206|      0|            ));
  207|      0|        }
  208|    326|    }
  209|       |
  210|    326|    let backend = X64Backend::new_with_flags(triple, shared_flags, isa_flags);
  211|    326|    Ok(Box::new(backend))
  212|    326|}

_RNvMNtNtCs3IsnRjS6uPr_17cranelift_codegen8machinst3regNtB2_3Reg11to_real_reg:
   55|  9.78k|    pub fn to_real_reg(self) -> Option<RealReg> {
   56|  9.78k|        if pinned_vreg_to_preg(self.0).is_some() {
   57|  9.78k|            Some(RealReg(self.0))
   58|       |        } else {
   59|      0|            None
   60|       |        }
   61|  9.78k|    }
_RNvXsm_NtNtCs3IsnRjS6uPr_17cranelift_codegen8machinst3regNtB5_3RegNtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eq:
   48|    326|#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
_RNvNtNtCs3IsnRjS6uPr_17cranelift_codegen8machinst3reg19pinned_vreg_to_preg:
   25|  9.78k|pub fn pinned_vreg_to_preg(vreg: VReg) -> Option<PReg> {
   26|  9.78k|    if vreg.vreg() < PINNED_VREGS {
   27|  9.78k|        Some(PReg::from_index(vreg.vreg()))
   28|       |    } else {
   29|      0|        None
   30|       |    }
   31|  9.78k|}
_RNvXs5_NtNtCs3IsnRjS6uPr_17cranelift_codegen8machinst3regNtB5_3RegINtNtCsdRJjCzU6nMS_4core7convert4FromNtCsijPsW9w8cJj_9regalloc24VRegE4from:
  195|  10.4k|    fn from(vreg: regalloc2::VReg) -> Reg {
  196|  10.4k|        Reg(vreg)
  197|  10.4k|    }
_RNvXsb_NtNtCs3IsnRjS6uPr_17cranelift_codegen8machinst3regNtCsijPsW9w8cJj_9regalloc24PRegINtNtCsdRJjCzU6nMS_4core7convert4FromNtB5_7RealRegE4from:
  236|  9.78k|    fn from(reg: RealReg) -> regalloc2::PReg {
  237|  9.78k|        PReg::from_index(reg.0.vreg())
  238|  9.78k|    }

_RNvXsh_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_7BuilderNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  148|    652|#[derive(Clone, Hash)]
_RNvXs1_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_7BuilderNtB5_12Configurable3set:
  269|  2.93k|    fn set(&mut self, name: &str, value: &str) -> SetResult<()> {
  270|       |        use self::detail::Detail;
  271|  2.93k|        let (offset, detail) = self.lookup(name)?;
  272|  2.93k|        match detail {
  273|  2.60k|            Detail::Bool { bit } => {
  274|  2.60k|                self.set_bit(offset, bit, parse_bool_value(value)?);
  275|       |            }
  276|      0|            Detail::Num => {
  277|      0|                self.bytes[offset] = value
  278|      0|                    .parse()
  279|      0|                    .map_err(|_| SetError::BadValue("number".to_string()))?;
  280|       |            }
  281|    326|            Detail::Enum { last, enumerators } => {
  282|    326|                self.bytes[offset] =
  283|    326|                    parse_enum_value(value, self.template.enums(last, enumerators))?;
  284|       |            }
  285|      0|            Detail::Preset => return Err(SetError::BadName(name.to_string())),
  286|       |        }
  287|  2.93k|        Ok(())
  288|  2.93k|    }
_RNvXs_NtNtCs3IsnRjS6uPr_17cranelift_codegen8settings6detailNtB4_8TemplateINtNtB8_13constant_hash5TableReE3len:
  406|  16.6k|        fn len(&self) -> usize {
  407|  16.6k|            self.hash_table.len()
  408|  16.6k|        }
_RNvMs0_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_7Builder9state_for:
  164|    652|    pub fn state_for(self, name: &str) -> Box<[u8]> {
  165|    652|        assert_eq!(name, self.template.name);
  166|    652|        self.bytes
  167|    652|    }
_RNvXs1_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_7BuilderNtB5_12Configurable6enable:
  253|  4.89k|    fn enable(&mut self, name: &str) -> SetResult<()> {
  254|       |        use self::detail::Detail;
  255|  4.89k|        let (offset, detail) = self.lookup(name)?;
  256|  4.89k|        match detail {
  257|  4.89k|            Detail::Bool { bit } => {
  258|  4.89k|                self.set_bit(offset, bit, true);
  259|  4.89k|                Ok(())
  260|       |            }
  261|       |            Detail::Preset => {
  262|      0|                self.apply_preset(&self.template.presets[offset..]);
  263|      0|                Ok(())
  264|       |            }
  265|      0|            _ => Err(SetError::BadType),
  266|       |        }
  267|  4.89k|    }
_RNCNvNtCs3IsnRjS6uPr_17cranelift_codegen8settings16parse_enum_value0B5_:
  232|    652|    match choices.iter().position(|&tag| tag == value) {
_RNvMNtNtCs3IsnRjS6uPr_17cranelift_codegen8settings6detailNtB2_8Template5enums:
  373|    326|        pub fn enums(&self, last: u8, enumerators: u16) -> &[&'static str] {
  374|    326|            let from = enumerators as usize;
  375|    326|            let len = usize::from(last) + 1;
  376|    326|            &self.enumerators[from..from + len]
  377|    326|        }
_RNvNtCs3IsnRjS6uPr_17cranelift_codegen8settings16parse_bool_value:
  223|  2.60k|fn parse_bool_value(value: &str) -> SetResult<bool> {
  224|  2.60k|    match value {
  225|  2.60k|        "true" | "on" | "yes" | "1" => Ok(true),
  226|  1.95k|        "false" | "off" | "no" | "0" => Ok(false),
  227|      0|        _ => Err(SetError::BadValue("bool".to_string())),
  228|       |    }
  229|  2.60k|}
_RNvXs_NtNtCs3IsnRjS6uPr_17cranelift_codegen8settings6detailNtB4_8TemplateINtNtB8_13constant_hash5TableReE3key:
  410|  8.80k|        fn key(&self, idx: usize) -> Option<&'a str> {
  411|  8.80k|            let e = self.hash_table[idx] as usize;
  412|  8.80k|            if e < self.descriptors.len() {
  413|  8.80k|                Some(self.descriptors[e].name)
  414|       |            } else {
  415|      0|                None
  416|       |            }
  417|  8.80k|        }
_RNvMs0_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_7Builder7set_bit:
  194|  7.49k|    fn set_bit(&mut self, offset: usize, bit: u8, value: bool) {
  195|  7.49k|        let byte = &mut self.bytes[offset];
  196|  7.49k|        let mask = 1 << bit;
  197|  7.49k|        if value {
  198|  5.54k|            *byte |= mask;
  199|  5.54k|        } else {
  200|  1.95k|            *byte &= !mask;
  201|  1.95k|        }
  202|  7.49k|    }
_RNvMs0_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_7Builder6lookup:
  212|  7.82k|    fn lookup(&self, name: &str) -> SetResult<(usize, detail::Detail)> {
  213|  7.82k|        match probe(self.template, name, simple_hash(name)) {
  214|      0|            Err(_) => Err(SetError::BadName(name.to_string())),
  215|  7.82k|            Ok(entry) => {
  216|  7.82k|                let d = &self.template.descriptors[self.template.hash_table[entry] as usize];
  217|  7.82k|                Ok((d.offset as usize, d.detail))
  218|       |            }
  219|       |        }
  220|  7.82k|    }
_RNvMs0_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_7Builder3new:
  156|    652|    pub fn new(tmpl: &'static detail::Template) -> Self {
  157|    652|        Self {
  158|    652|            template: tmpl,
  159|    652|            bytes: tmpl.defaults.into(),
  160|    652|        }
  161|    652|    }
_RNvNtCs3IsnRjS6uPr_17cranelift_codegen8settings16parse_enum_value:
  231|    326|fn parse_enum_value(value: &str, choices: &[&str]) -> SetResult<u8> {
  232|    326|    match choices.iter().position(|&tag| tag == value) {
  233|    326|        Some(idx) => Ok(idx as u8),
  234|       |        None => {
  235|       |            // TODO: Use `join` instead of this code, once
  236|       |            // https://github.com/rust-lang/rust/issues/27747 is resolved.
  237|      0|            let mut all_choices = String::new();
  238|      0|            let mut first = true;
  239|      0|            for choice in choices {
  240|      0|                if first {
  241|      0|                    first = false
  242|      0|                } else {
  243|      0|                    all_choices += ", ";
  244|      0|                }
  245|      0|                all_choices += choice;
  246|       |            }
  247|      0|            Err(SetError::BadValue(format!("any among {}", all_choices)))
  248|       |        }
  249|       |    }
  250|    326|}

_RNvNtCsea7auODlfNA_24cranelift_codegen_shared13constant_hash11simple_hash:
    4|  7.82k|pub fn simple_hash(s: &str) -> usize {
    5|  7.82k|    let mut h: u32 = 5381;
    6|  87.3k|    for c in s.chars() {
    7|  87.3k|        h = (h ^ c as u32).wrapping_add(h.rotate_right(6));
    8|  87.3k|    }
    9|  7.82k|    h as usize
   10|  7.82k|}

_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity4iterINtB4_4IterNtCs4z64eNW3Ya4_14wasmtime_types10TableIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module9TablePlanENtNtNtNtCsdRJjCzU6nMS_4core4iter6traits8iterator8Iterator4nextCsfBAxPD3lkOv_16wasmtime_runtime:
   32|    652|    fn next(&mut self) -> Option<Self::Item> {
   33|    652|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|    652|    }
_RNCNvXs_NtCsjnlPz0bAqn4_16cranelift_entity4iterINtB6_4IterNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtBW_6GlobalENtNtNtNtCsdRJjCzU6nMS_4core4iter6traits8iterator8Iterator4next0CsfBAxPD3lkOv_16wasmtime_runtime:
   33|    652|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity4iterINtB4_4IterNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtBU_6GlobalENtNtNtNtCsdRJjCzU6nMS_4core4iter6traits8iterator8Iterator4nextCsfBAxPD3lkOv_16wasmtime_runtime:
   32|  2.60k|    fn next(&mut self) -> Option<Self::Item> {
   33|  2.60k|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|  2.60k|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity4iterINtB2_4IterNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanE3newCsfBAxPD3lkOv_16wasmtime_runtime:
   21|  1.63k|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|  1.63k|        Self {
   23|  1.63k|            enumerate: iter.enumerate(),
   24|  1.63k|            unused: PhantomData,
   25|  1.63k|        }
   26|  1.63k|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity4iterINtB4_4IterNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanENtNtNtNtCsdRJjCzU6nMS_4core4iter6traits8iterator8Iterator4nextCsfBAxPD3lkOv_16wasmtime_runtime:
   32|  1.95k|    fn next(&mut self) -> Option<Self::Item> {
   33|  1.95k|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|  1.95k|    }
_RNCNvXs_NtCsjnlPz0bAqn4_16cranelift_entity4iterINtB6_4IterNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanENtNtNtNtCsdRJjCzU6nMS_4core4iter6traits8iterator8Iterator4next0CsfBAxPD3lkOv_16wasmtime_runtime:
   33|    326|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity4iterINtB2_4IterNtCs4z64eNW3Ya4_14wasmtime_types10TableIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module9TablePlanE3newCsfBAxPD3lkOv_16wasmtime_runtime:
   21|    652|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|    652|        Self {
   23|    652|            enumerate: iter.enumerate(),
   24|    652|            unused: PhantomData,
   25|    652|        }
   26|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity4iterINtB2_4IterNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtBS_6GlobalE3newCsfBAxPD3lkOv_16wasmtime_runtime:
   21|  1.95k|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|  1.95k|        Self {
   23|  1.95k|            enumerate: iter.enumerate(),
   24|  1.95k|            unused: PhantomData,
   25|  1.95k|        }
   26|  1.95k|    }

_RNvXs2g_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_11MemoryIndexNtCsjnlPz0bAqn4_16cranelift_entity9EntityRef3new:
   74|    978|            fn new(index: usize) -> Self {
   75|    978|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|    978|                $entity(index as u32)
   77|    978|            }
_RNvMs25_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_11GlobalIndex8from_u32:
  101|    326|            pub fn from_u32(x: u32) -> Self {
  102|    326|                debug_assert!(x < $crate::__core::u32::MAX);
  103|    326|                $entity(x)
  104|    326|            }
_RNvMs2i_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_11MemoryIndex6as_u32:
  109|    326|            pub fn as_u32(self) -> u32 {
  110|    326|                self.0
  111|    326|            }
_RNvMs2i_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_11MemoryIndex8from_u32:
  101|    326|            pub fn from_u32(x: u32) -> Self {
  102|    326|                debug_assert!(x < $crate::__core::u32::MAX);
  103|    326|                $entity(x)
  104|    326|            }
_RNvXs23_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_11GlobalIndexNtCsjnlPz0bAqn4_16cranelift_entity9EntityRef3new:
   74|    978|            fn new(index: usize) -> Self {
   75|    978|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|    978|                $entity(index as u32)
   77|    978|            }
_RNvXs1d_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_18DefinedMemoryIndexNtCsjnlPz0bAqn4_16cranelift_entity9EntityRef5index:
   80|    652|            fn index(self) -> usize {
   81|    652|                self.0 as usize
   82|    652|            }
_RNvXs23_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_11GlobalIndexNtCsjnlPz0bAqn4_16cranelift_entity9EntityRef5index:
   80|  2.28k|            fn index(self) -> usize {
   81|  2.28k|                self.0 as usize
   82|  2.28k|            }
_RNvXs2g_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_11MemoryIndexNtCsjnlPz0bAqn4_16cranelift_entity9EntityRef5index:
   80|  1.30k|            fn index(self) -> usize {
   81|  1.30k|                self.0 as usize
   82|  1.30k|            }
_RNvXs1D_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_18DefinedGlobalIndexNtCsjnlPz0bAqn4_16cranelift_entity9EntityRef3new:
   74|    978|            fn new(index: usize) -> Self {
   75|    978|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|    978|                $entity(index as u32)
   77|    978|            }
_RNvXs1d_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_18DefinedMemoryIndexNtCsjnlPz0bAqn4_16cranelift_entity9EntityRef3new:
   74|    978|            fn new(index: usize) -> Self {
   75|    978|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|    978|                $entity(index as u32)
   77|    978|            }
_RNvMs1f_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_18DefinedMemoryIndex6as_u32:
  109|    652|            pub fn as_u32(self) -> u32 {
  110|    652|                self.0
  111|    652|            }
_RNvMs1F_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_18DefinedGlobalIndex6as_u32:
  109|  1.30k|            pub fn as_u32(self) -> u32 {
  110|  1.30k|                self.0
  111|  1.30k|            }

_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types9FuncIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module12FunctionTypeENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsheoVkkQew6K_3fvm:
  188|    326|    fn default() -> PrimaryMap<K, V> {
  189|    326|        PrimaryMap::new()
  190|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types10TableIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module9TablePlanE3newCsheoVkkQew6K_3fvm:
   45|    326|    pub fn new() -> Self {
   46|    326|        Self {
   47|    326|            elems: Vec::new(),
   48|    326|            unused: PhantomData,
   49|    326|        }
   50|    326|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types10TableIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module9TablePlanENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsheoVkkQew6K_3fvm:
  188|    326|    fn default() -> PrimaryMap<K, V> {
  189|    326|        PrimaryMap::new()
  190|    326|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types9TypeIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10ModuleTypeENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsheoVkkQew6K_3fvm:
  188|    326|    fn default() -> PrimaryMap<K, V> {
  189|    326|        PrimaryMap::new()
  190|    326|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB14_6GlobalENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsheoVkkQew6K_3fvm:
  188|    326|    fn default() -> PrimaryMap<K, V> {
  189|    326|        PrimaryMap::new()
  190|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanE3newCsheoVkkQew6K_3fvm:
   45|    326|    pub fn new() -> Self {
   46|    326|        Self {
   47|    326|            elems: Vec::new(),
   48|    326|            unused: PhantomData,
   49|    326|        }
   50|    326|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsheoVkkQew6K_3fvm:
  188|    326|    fn default() -> PrimaryMap<K, V> {
  189|    326|        PrimaryMap::new()
  190|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types9FuncIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module12FunctionTypeE3newCsheoVkkQew6K_3fvm:
   45|    326|    pub fn new() -> Self {
   46|    326|        Self {
   47|    326|            elems: Vec::new(),
   48|    326|            unused: PhantomData,
   49|    326|        }
   50|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB12_6GlobalE3newCsheoVkkQew6K_3fvm:
   45|    326|    pub fn new() -> Self {
   46|    326|        Self {
   47|    326|            elems: Vec::new(),
   48|    326|            unused: PhantomData,
   49|    326|        }
   50|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types9TypeIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10ModuleTypeE3newCsheoVkkQew6K_3fvm:
   45|    326|    pub fn new() -> Self {
   46|    326|        Self {
   47|    326|            elems: Vec::new(),
   48|    326|            unused: PhantomData,
   49|    326|        }
   50|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanE8next_keyCscE26HxwD491_8wasmtime:
  116|    326|    pub fn next_key(&self) -> K {
  117|    326|        K::new(self.elems.len())
  118|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB12_6GlobalE8next_keyCscE26HxwD491_8wasmtime:
  116|    326|    pub fn next_key(&self) -> K {
  117|    326|        K::new(self.elems.len())
  118|    326|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types16DefinedFuncIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ11compilation12FunctionInfoENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCscE26HxwD491_8wasmtime:
  188|    978|    fn default() -> PrimaryMap<K, V> {
  189|    978|        PrimaryMap::new()
  190|    978|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types16DefinedFuncIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ11compilation12FunctionInfoE3newCscE26HxwD491_8wasmtime:
   45|    978|    pub fn new() -> Self {
   46|    978|        Self {
   47|    978|            elems: Vec::new(),
   48|    978|            unused: PhantomData,
   49|    978|        }
   50|    978|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanE4pushCscE26HxwD491_8wasmtime:
  121|    326|    pub fn push(&mut self, v: V) -> K {
  122|    326|        let k = self.next_key();
  123|    326|        self.elems.push(v);
  124|    326|        k
  125|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB12_6GlobalE4pushCscE26HxwD491_8wasmtime:
  121|    326|    pub fn push(&mut self, v: V) -> K {
  122|    326|        let k = self.next_key();
  123|    326|        self.elems.push(v);
  124|    326|        k
  125|    326|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types17DefinedTableIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime5table5TableENtNtCsdRJjCzU6nMS_4core7default7Default7defaultB1V_:
  188|    326|    fn default() -> PrimaryMap<K, V> {
  189|    326|        PrimaryMap::new()
  190|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanE4iterCsfBAxPD3lkOv_16wasmtime_runtime:
  101|  1.63k|    pub fn iter(&self) -> Iter<K, V> {
  102|  1.63k|        Iter::new(self.elems.iter())
  103|  1.63k|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types10TableIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module9TablePlanE3lenCsfBAxPD3lkOv_16wasmtime_runtime:
   81|  2.60k|    pub fn len(&self) -> usize {
   82|  2.60k|        self.elems.len()
   83|  2.60k|    }
_RNvXs0_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB5_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB15_6GlobalEINtNtNtCsdRJjCzU6nMS_4core3ops5index5IndexB13_E5indexCsfBAxPD3lkOv_16wasmtime_runtime:
  201|    326|    fn index(&self, k: K) -> &V {
  202|    326|        &self.elems[k.index()]
  203|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types10TableIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module9TablePlanE4iterCsfBAxPD3lkOv_16wasmtime_runtime:
  101|    652|    pub fn iter(&self) -> Iter<K, V> {
  102|    652|        Iter::new(self.elems.iter())
  103|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB12_6GlobalE3lenCsfBAxPD3lkOv_16wasmtime_runtime:
   81|    978|    pub fn len(&self) -> usize {
   82|    978|        self.elems.len()
   83|    978|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types18DefinedMemoryIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime6memory6MemoryENtNtCsdRJjCzU6nMS_4core7default7Default7defaultB1W_:
  188|    326|    fn default() -> PrimaryMap<K, V> {
  189|    326|        PrimaryMap::new()
  190|    326|    }
_RNvXs0_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB5_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanEINtNtNtCsdRJjCzU6nMS_4core3ops5index5IndexB13_E5indexCsfBAxPD3lkOv_16wasmtime_runtime:
  201|    652|    fn index(&self, k: K) -> &V {
  202|    652|        &self.elems[k.index()]
  203|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types18DefinedMemoryIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime6memory6MemoryE4pushB1U_:
  121|    326|    pub fn push(&mut self, v: V) -> K {
  122|    326|        let k = self.next_key();
  123|    326|        self.elems.push(v);
  124|    326|        k
  125|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB12_6GlobalE4iterCsfBAxPD3lkOv_16wasmtime_runtime:
  101|  1.95k|    pub fn iter(&self) -> Iter<K, V> {
  102|  1.95k|        Iter::new(self.elems.iter())
  103|  1.95k|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types17DefinedTableIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime5table5TableE13with_capacityB1T_:
   53|    652|    pub fn with_capacity(capacity: usize) -> Self {
   54|    652|        Self {
   55|    652|            elems: Vec::with_capacity(capacity),
   56|    652|            unused: PhantomData,
   57|    652|        }
   58|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanE3lenCsfBAxPD3lkOv_16wasmtime_runtime:
   81|  2.60k|    pub fn len(&self) -> usize {
   82|  2.60k|        self.elems.len()
   83|  2.60k|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types18DefinedMemoryIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime6memory6MemoryE8next_keyB1U_:
  116|    326|    pub fn next_key(&self) -> K {
  117|    326|        K::new(self.elems.len())
  118|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types17DefinedTableIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime5table5TableE3newB1T_:
   45|    326|    pub fn new() -> Self {
   46|    326|        Self {
   47|    326|            elems: Vec::new(),
   48|    326|            unused: PhantomData,
   49|    326|        }
   50|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types18DefinedMemoryIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime6memory6MemoryE3newB1U_:
   45|    326|    pub fn new() -> Self {
   46|    326|        Self {
   47|    326|            elems: Vec::new(),
   48|    326|            unused: PhantomData,
   49|    326|        }
   50|    326|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types18DefinedMemoryIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime6memory6MemoryE13with_capacityB1U_:
   53|    652|    pub fn with_capacity(capacity: usize) -> Self {
   54|    652|        Self {
   55|    652|            elems: Vec::with_capacity(capacity),
   56|    652|            unused: PhantomData,
   57|    652|        }
   58|    652|    }
_RNvXs1_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB5_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types18DefinedMemoryIndexNtNtCsfBAxPD3lkOv_16wasmtime_runtime6memory6MemoryEINtNtNtCsdRJjCzU6nMS_4core3ops5index8IndexMutB13_E9index_mutB1X_:
  211|    326|    fn index_mut(&mut self, k: K) -> &mut V {
  212|    326|        &mut self.elems[k.index()]
  213|    326|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types9FuncIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module12FunctionTypeENtNtCsdRJjCzU6nMS_4core7default7Default7defaultB1M_:
  188|    652|    fn default() -> PrimaryMap<K, V> {
  189|    652|        PrimaryMap::new()
  190|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanE3newB1N_:
   45|    652|    pub fn new() -> Self {
   46|    652|        Self {
   47|    652|            elems: Vec::new(),
   48|    652|            unused: PhantomData,
   49|    652|        }
   50|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types9FuncIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module12FunctionTypeE3newB1K_:
   45|    652|    pub fn new() -> Self {
   46|    652|        Self {
   47|    652|            elems: Vec::new(),
   48|    652|            unused: PhantomData,
   49|    652|        }
   50|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types10TableIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module9TablePlanE3newB1M_:
   45|    652|    pub fn new() -> Self {
   46|    652|        Self {
   47|    652|            elems: Vec::new(),
   48|    652|            unused: PhantomData,
   49|    652|        }
   50|    652|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types9TypeIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10ModuleTypeENtNtCsdRJjCzU6nMS_4core7default7Default7defaultB1M_:
  188|    652|    fn default() -> PrimaryMap<K, V> {
  189|    652|        PrimaryMap::new()
  190|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types9TypeIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10ModuleTypeE3newB1K_:
   45|    652|    pub fn new() -> Self {
   46|    652|        Self {
   47|    652|            elems: Vec::new(),
   48|    652|            unused: PhantomData,
   49|    652|        }
   50|    652|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB12_6GlobalE3newCs7L8xYe2Gdyw_16wasmtime_environ:
   45|    652|    pub fn new() -> Self {
   46|    652|        Self {
   47|    652|            elems: Vec::new(),
   48|    652|            unused: PhantomData,
   49|    652|        }
   50|    652|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11MemoryIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module10MemoryPlanENtNtCsdRJjCzU6nMS_4core7default7Default7defaultB1P_:
  188|    652|    fn default() -> PrimaryMap<K, V> {
  189|    652|        PrimaryMap::new()
  190|    652|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types10TableIndexNtNtCs7L8xYe2Gdyw_16wasmtime_environ6module9TablePlanENtNtCsdRJjCzU6nMS_4core7default7Default7defaultB1O_:
  188|    652|    fn default() -> PrimaryMap<K, V> {
  189|    652|        PrimaryMap::new()
  190|    652|    }
_RNvXs_NtCsjnlPz0bAqn4_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs4z64eNW3Ya4_14wasmtime_types11GlobalIndexNtB14_6GlobalENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCs7L8xYe2Gdyw_16wasmtime_environ:
  188|    652|    fn default() -> PrimaryMap<K, V> {
  189|    652|        PrimaryMap::new()
  190|    652|    }

_RNvMNtCsjnlPz0bAqn4_16cranelift_entity3setINtB2_9EntitySetNtCs4z64eNW3Ya4_14wasmtime_types9DataIndexE13with_capacityCsfBAxPD3lkOv_16wasmtime_runtime:
   37|    978|    pub fn with_capacity(capacity: usize) -> Self {
   38|    978|        Self {
   39|    978|            elems: Vec::with_capacity((capacity + 7) / 8),
   40|    978|            ..Self::new()
   41|    978|        }
   42|    978|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity3setINtB2_9EntitySetNtCs4z64eNW3Ya4_14wasmtime_types9ElemIndexE3newCsfBAxPD3lkOv_16wasmtime_runtime:
   28|    978|    pub fn new() -> Self {
   29|    978|        Self {
   30|    978|            elems: Vec::new(),
   31|    978|            len: 0,
   32|    978|            unused: PhantomData,
   33|    978|        }
   34|    978|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity3setINtB2_9EntitySetNtCs4z64eNW3Ya4_14wasmtime_types9DataIndexE3newCsfBAxPD3lkOv_16wasmtime_runtime:
   28|    978|    pub fn new() -> Self {
   29|    978|        Self {
   30|    978|            elems: Vec::new(),
   31|    978|            len: 0,
   32|    978|            unused: PhantomData,
   33|    978|        }
   34|    978|    }
_RNvMNtCsjnlPz0bAqn4_16cranelift_entity3setINtB2_9EntitySetNtCs4z64eNW3Ya4_14wasmtime_types9ElemIndexE13with_capacityCsfBAxPD3lkOv_16wasmtime_runtime:
   37|    978|    pub fn with_capacity(capacity: usize) -> Self {
   38|    978|        Self {
   39|    978|            elems: Vec::with_capacity((capacity + 7) / 8),
   40|    978|            ..Self::new()
   41|    978|        }
   42|    978|    }

_RNvCs32YCRCGYuqd_16cranelift_native7builder:
   32|    326|pub fn builder() -> Result<isa::Builder, &'static str> {
   33|    326|    builder_with_options(true)
   34|    326|}
_RNvCs32YCRCGYuqd_16cranelift_native20builder_with_options:
   43|    326|pub fn builder_with_options(infer_native_flags: bool) -> Result<isa::Builder, &'static str> {
   44|    326|    let mut isa_builder = isa::lookup(Triple::host()).map_err(|err| match err {
   45|       |        isa::LookupError::SupportDisabled => "support for architecture disabled at compile time",
   46|       |        isa::LookupError::Unsupported => "unsupported architecture",
   47|    326|    })?;
   48|       |
   49|       |    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
   50|       |    {
   51|       |        use cranelift_codegen::settings::Configurable;
   52|       |
   53|    326|        if !std::is_x86_feature_detected!("sse2") {
   54|      0|            return Err("x86 support requires SSE2");
   55|    326|        }
   56|    326|
   57|    326|        if !infer_native_flags {
   58|      0|            return Ok(isa_builder);
   59|    326|        }
   60|    326|
   61|    326|        // These are temporarily enabled by default (see #3810 for
   62|    326|        // more) so that a default-constructed `Flags` can work with
   63|    326|        // default Wasmtime features. Otherwise, the user must
   64|    326|        // explicitly use native flags or turn these on when on x86-64
   65|    326|        // platforms to avoid a configuration panic. In order for the
   66|    326|        // "enable if detected" logic below to work, we must turn them
   67|    326|        // *off* (differing from the default) and then re-enable below
   68|    326|        // if present.
   69|    326|        isa_builder.set("has_sse3", "false").unwrap();
   70|    326|        isa_builder.set("has_ssse3", "false").unwrap();
   71|    326|        isa_builder.set("has_sse41", "false").unwrap();
   72|    326|        isa_builder.set("has_sse42", "false").unwrap();
   73|       |
   74|    326|        if std::is_x86_feature_detected!("sse3") {
   75|    326|            isa_builder.enable("has_sse3").unwrap();
   76|    326|        }
   77|    326|        if std::is_x86_feature_detected!("ssse3") {
   78|    326|            isa_builder.enable("has_ssse3").unwrap();
   79|    326|        }
   80|    326|        if std::is_x86_feature_detected!("sse4.1") {
   81|    326|            isa_builder.enable("has_sse41").unwrap();
   82|    326|        }
   83|    326|        if std::is_x86_feature_detected!("sse4.2") {
   84|    326|            isa_builder.enable("has_sse42").unwrap();
   85|    326|        }
   86|    326|        if std::is_x86_feature_detected!("popcnt") {
   87|    326|            isa_builder.enable("has_popcnt").unwrap();
   88|    326|        }
   89|    326|        if std::is_x86_feature_detected!("avx") {
   90|    326|            isa_builder.enable("has_avx").unwrap();
   91|    326|        }
   92|    326|        if std::is_x86_feature_detected!("avx2") {
   93|    326|            isa_builder.enable("has_avx2").unwrap();
   94|    326|        }
   95|    326|        if std::is_x86_feature_detected!("fma") {
   96|    326|            isa_builder.enable("has_fma").unwrap();
   97|    326|        }
   98|    326|        if std::is_x86_feature_detected!("bmi1") {
   99|    326|            isa_builder.enable("has_bmi1").unwrap();
  100|    326|        }
  101|    326|        if std::is_x86_feature_detected!("bmi2") {
  102|    326|            isa_builder.enable("has_bmi2").unwrap();
  103|    326|        }
  104|      0|        if std::is_x86_feature_detected!("avx512bitalg") {
  105|      0|            isa_builder.enable("has_avx512bitalg").unwrap();
  106|    326|        }
  107|    326|        if std::is_x86_feature_detected!("avx512dq") {
  108|    326|            isa_builder.enable("has_avx512dq").unwrap();
  109|    326|        }
  110|    326|        if std::is_x86_feature_detected!("avx512f") {
  111|    326|            isa_builder.enable("has_avx512f").unwrap();
  112|    326|        }
  113|    326|        if std::is_x86_feature_detected!("avx512vl") {
  114|    326|            isa_builder.enable("has_avx512vl").unwrap();
  115|    326|        }
  116|      0|        if std::is_x86_feature_detected!("avx512vbmi") {
  117|      0|            isa_builder.enable("has_avx512vbmi").unwrap();
  118|    326|        }
  119|    326|        if std::is_x86_feature_detected!("lzcnt") {
  120|    326|            isa_builder.enable("has_lzcnt").unwrap();
  121|    326|        }
  122|       |    }
  123|       |
  124|       |    #[cfg(target_arch = "aarch64")]
  125|       |    {
  126|       |        use cranelift_codegen::settings::Configurable;
  127|       |
  128|       |        if !infer_native_flags {
  129|       |            return Ok(isa_builder);
  130|       |        }
  131|       |
  132|       |        if std::arch::is_aarch64_feature_detected!("lse") {
  133|       |            isa_builder.enable("has_lse").unwrap();
  134|       |        }
  135|       |
  136|       |        if std::arch::is_aarch64_feature_detected!("paca") {
  137|       |            isa_builder.enable("has_pauth").unwrap();
  138|       |        }
  139|       |
  140|       |        if cfg!(target_os = "macos") {
  141|       |            // Pointer authentication is always available on Apple Silicon.
  142|       |            isa_builder.enable("sign_return_address").unwrap();
  143|       |            // macOS enforces the use of the B key for return addresses.
  144|       |            isa_builder.enable("sign_return_address_with_bkey").unwrap();
  145|       |        }
  146|       |    }
  147|       |
  148|       |    // There is no is_s390x_feature_detected macro yet, so for now
  149|       |    // we use getauxval from the libc crate directly.
  150|       |    #[cfg(all(target_arch = "s390x", target_os = "linux"))]
  151|       |    {
  152|       |        use cranelift_codegen::settings::Configurable;
  153|       |
  154|       |        if !infer_native_flags {
  155|       |            return Ok(isa_builder);
  156|       |        }
  157|       |
  158|       |        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };
  159|       |        const HWCAP_S390X_VXRS_EXT2: libc::c_ulong = 32768;
  160|       |        if (v & HWCAP_S390X_VXRS_EXT2) != 0 {
  161|       |            isa_builder.enable("has_vxrs_ext2").unwrap();
  162|       |            // There is no separate HWCAP bit for mie2, so assume
  163|       |            // that any machine with vxrs_ext2 also has mie2.
  164|       |            isa_builder.enable("has_mie2").unwrap();
  165|       |        }
  166|       |    }
  167|       |
  168|       |    // squelch warnings about unused mut/variables on some platforms.
  169|    326|    drop(&mut isa_builder);
  170|    326|    drop(infer_native_flags);
  171|    326|
  172|    326|    Ok(isa_builder)
  173|    326|}

_RINvXsd_NtCsHfZzWSKefx_14cs_serde_bytes7bytebufNtB6_14ByteBufVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor14visit_byte_bufNtNtCsb605JUWHIii_12libipld_core5error10SerdeErrorECs4ieSHZHrxF6_15direct_syscalls:
  208|    489|    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<ByteBuf, E>
  209|    489|    where
  210|    489|        E: Error,
  211|    489|    {
  212|    489|        Ok(ByteBuf::from(v))
  213|    489|    }
_RINvXse_NtCsHfZzWSKefx_14cs_serde_bytes7bytebufNtB6_7ByteBufNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  217|    489|    fn deserialize<D>(deserializer: D) -> Result<ByteBuf, D::Error>
  218|    489|    where
  219|    489|        D: Deserializer<'de>,
  220|    489|    {
  221|    489|        deserializer.deserialize_byte_buf(ByteBufVisitor)
  222|    489|    }
_RINvMNtCsHfZzWSKefx_14cs_serde_bytes7bytebufNtB3_7ByteBuf4fromINtNtCs71iYhC60HpU_5alloc3vec3VechEECs4ieSHZHrxF6_15direct_syscalls:
   58|    489|    pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {
   59|    489|        ByteBuf {
   60|    489|            bytes: bytes.into(),
   61|    489|        }
   62|    489|    }
_RNvMNtCsHfZzWSKefx_14cs_serde_bytes7bytebufNtB2_7ByteBuf8into_vec:
   65|    489|    pub fn into_vec(self) -> Vec<u8> {
   66|    489|        self.bytes
   67|    489|    }

_RINvXs1_NtCsHfZzWSKefx_14cs_serde_bytes2deNtNtB8_7bytebuf7ByteBufNtB6_11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
   59|    489|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   60|    489|    where
   61|    489|        D: Deserializer<'de>,
   62|    489|    {
   63|    489|        // Via the serde::Deserialize impl for ByteBuf.
   64|    489|        serde::Deserialize::deserialize(deserializer)
   65|    489|    }
_RINvXs_NtCsHfZzWSKefx_14cs_serde_bytes2deINtNtCs71iYhC60HpU_5alloc3vec3VechENtB5_11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
   40|    489|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   41|    489|    where
   42|    489|        D: Deserializer<'de>,
   43|    489|    {
   44|    489|        Deserialize::deserialize(deserializer).map(ByteBuf::into_vec)
   45|    489|    }

_RINvCsHfZzWSKefx_14cs_serde_bytes11deserializeINtNtCs71iYhC60HpU_5alloc3vec3VechENtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  102|    489|pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
  103|    489|where
  104|    489|    T: Deserialize<'de>,
  105|    489|    D: Deserializer<'de>,
  106|    489|{
  107|    489|    Deserialize::deserialize(deserializer)
  108|    489|}
_RINvCsHfZzWSKefx_14cs_serde_bytes9serializeINtNtCs71iYhC60HpU_5alloc3vec3VechEQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   76|    489|pub fn serialize<T, S>(bytes: &T, serializer: S) -> Result<S::Ok, S::Error>
   77|    489|where
   78|    489|    T: ?Sized + Serialize,
   79|    489|    S: Serializer,
   80|    489|{
   81|    489|    Serialize::serialize(bytes, serializer)
   82|    489|}

_RINvXs_NtCsHfZzWSKefx_14cs_serde_bytes3serINtNtCs71iYhC60HpU_5alloc3vec3VechENtB5_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   37|    489|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   38|    489|    where
   39|    489|        S: Serializer,
   40|    489|    {
   41|    489|        serializer.serialize_bytes(self)
   42|    489|    }

_RINvCs5FWX6epTL3a_13data_encoding15encode_base_lenNtB2_2N5EB2_:
  481|    978|fn encode_base_len<B: Static<usize>>(bit: B, len: usize) -> usize {
  482|    978|    encode_len(bit, len)
  483|    978|}
_RINvCs5FWX6epTL3a_13data_encoding14encode_pad_lenNtB2_2N5NtB2_2OnEB2_:
  492|    652|fn encode_pad_len<B: Static<usize>, P: Static<Option<u8>>>(bit: B, pad: P, len: usize) -> usize {
  493|    652|    match pad.val() {
  494|    652|        None => encode_base_len(bit, len),
  495|      0|        Some(_) => div_ceil(len, enc(bit.val())) * dec(bit.val()),
  496|       |    }
  497|    652|}
_RNvMs4_Cs5FWX6epTL3a_13data_encodingNtB5_8Encoding10encode_mut:
 1295|    326|    pub fn encode_mut(&self, input: &[u8], output: &mut [u8]) {
 1296|    326|        assert_eq!(output.len(), self.encode_len(input.len()));
 1297|       |        dispatch! {
 1298|    326|            let bit: usize = self.bit();
 1299|    326|            let msb: bool = self.msb();
 1300|    326|            let pad: Option<u8> = self.pad();
 1301|    326|            let wrap: Option<(usize, &[u8])> = self.wrap();
 1302|    326|            encode_wrap_mut(bit, msb, self.sym(), pad, wrap, input, output)
 1303|       |        }
 1304|    326|    }
_RINvCs5FWX6epTL3a_13data_encoding10encode_lenNtB2_2N5EB2_:
  369|  3.26k|fn encode_len<B: Static<usize>>(bit: B, len: usize) -> usize {
  370|  3.26k|    div_ceil(8 * len, bit.val())
  371|  3.26k|}
_RNvXCs5FWX6epTL3a_13data_encodingNtB2_2OnINtB2_6StaticINtNtCsdRJjCzU6nMS_4core6option6OptionhEE3valB2_:
  199|    978|    fn val(self) -> Option<T> {
  200|    978|        None
  201|    978|    }
_RNvXsb_Cs5FWX6epTL3a_13data_encodingNtB5_2BtINtB5_6StaticbE3val:
  179|  1.95k|            fn val(self) -> $type {
  180|  1.95k|                $val
  181|  1.95k|            }
_RINvCs5FWX6epTL3a_13data_encoding12encode_blockNtB2_2N5NtB2_2BtEB2_:
  373|  1.95k|fn encode_block<B: Static<usize>, M: Static<bool>>(
  374|  1.95k|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  375|  1.95k|) {
  376|  1.95k|    debug_assert!(input.len() <= enc(bit.val()));
  377|  1.95k|    debug_assert_eq!(output.len(), encode_len(bit, input.len()));
  378|  1.95k|    let bit = bit.val();
  379|  1.95k|    let msb = msb.val();
  380|  1.95k|    let mut x = 0u64;
  381|  8.80k|    for (i, input) in input.iter().enumerate() {
  382|  8.80k|        x |= u64::from(*input) << (8 * order(msb, enc(bit), i));
  383|  8.80k|    }
  384|  14.1k|    for (i, output) in output.iter_mut().enumerate() {
  385|  14.1k|        let y = x >> (bit * order(msb, dec(bit), i));
  386|  14.1k|        *output = symbols[y as usize % 256];
  387|  14.1k|    }
  388|  1.95k|}
_RNvMs4_Cs5FWX6epTL3a_13data_encodingNtB5_8Encoding4wrap:
 1250|    978|    fn wrap(&self) -> Option<(usize, &[u8])> {
 1251|    978|        if self.0.len() <= 515 {
 1252|    978|            return None;
 1253|      0|        }
 1254|      0|        Some((self.0[514] as usize, &self.0[515 ..]))
 1255|    978|    }
_RNvXCs5FWX6epTL3a_13data_encodingNtB2_2OnINtB2_6StaticINtNtCsdRJjCzU6nMS_4core6option6OptionTjRShEEE3valB2_:
  199|    978|    fn val(self) -> Option<T> {
  200|    978|        None
  201|    978|    }
_RNvXsq_Cs5FWX6epTL3a_13data_encodingNtB5_2N5INtB5_6StaticjE3val:
  179|  8.15k|            fn val(self) -> $type {
  180|  8.15k|                $val
  181|  8.15k|            }
_RINvCs5FWX6epTL3a_13data_encoding9vectorizeNCINvB2_10encode_mutNtB2_2N5NtB2_2BtE0EB2_:
  266|    326|fn vectorize<F: FnMut(usize)>(n: usize, bs: usize, mut f: F) {
  267|    652|    for k in 0 .. n / bs {
  268|  1.30k|        for i in k * bs .. (k + 1) * bs {
  269|  1.30k|            f(i);
  270|  1.30k|        }
  271|       |    }
  272|    326|    for i in floor(n, bs) .. n {
  273|    326|        f(i);
  274|    326|    }
  275|    326|}
_RNvMs4_Cs5FWX6epTL3a_13data_encodingNtB5_8Encoding10encode_len:
 1266|    652|    pub fn encode_len(&self, len: usize) -> usize {
 1267|    652|        dispatch! {
 1268|    652|            let bit: usize = self.bit();
 1269|    652|            let pad: Option<u8> = self.pad();
 1270|    652|            let wrap: Option<(usize, &[u8])> = self.wrap();
 1271|    652|            encode_wrap_len(bit, pad, wrap, len)
 1272|       |        }
 1273|    652|    }
_RINvCs5FWX6epTL3a_13data_encoding15encode_wrap_mutNtB2_2N5NtB2_2BtNtB2_2OnB12_EB2_:
  529|    326|fn encode_wrap_mut<
  530|    326|    'a,
  531|    326|    B: Static<usize>,
  532|    326|    M: Static<bool>,
  533|    326|    P: Static<Option<u8>>,
  534|    326|    W: Static<Option<(usize, &'a [u8])>>,
  535|    326|>(
  536|    326|    bit: B, msb: M, symbols: &[u8; 256], pad: P, wrap: W, input: &[u8], output: &mut [u8],
  537|    326|) {
  538|    326|    let (col, end) = match wrap.val() {
  539|    326|        None => return encode_pad(bit, msb, symbols, pad, input, output),
  540|      0|        Some((col, end)) => (col, end),
  541|       |    };
  542|      0|    debug_assert_eq!(output.len(), encode_wrap_len(bit, pad, wrap, input.len()));
  543|      0|    debug_assert_eq!(col % dec(bit.val()), 0);
  544|      0|    let col = col / dec(bit.val());
  545|      0|    let enc = col * enc(bit.val());
  546|      0|    let dec = col * dec(bit.val()) + end.len();
  547|      0|    let olen = dec - end.len();
  548|      0|    let n = input.len() / enc;
  549|      0|    for i in 0 .. n {
  550|      0|        let input = unsafe { chunk_unchecked(input, enc, i) };
  551|      0|        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  552|      0|        encode_base(bit, msb, symbols, input, &mut output[.. olen]);
  553|      0|        output[olen ..].copy_from_slice(end);
  554|      0|    }
  555|      0|    if input.len() > enc * n {
  556|      0|        let olen = dec * n + encode_pad_len(bit, pad, input.len() - enc * n);
  557|      0|        encode_pad(bit, msb, symbols, pad, &input[enc * n ..], &mut output[dec * n .. olen]);
  558|      0|        output[olen ..].copy_from_slice(end);
  559|      0|    }
  560|    326|}
_RINvCs5FWX6epTL3a_13data_encoding10encode_padNtB2_2N5NtB2_2BtNtB2_2OnEB2_:
  499|    326|fn encode_pad<B: Static<usize>, M: Static<bool>, P: Static<Option<u8>>>(
  500|    326|    bit: B, msb: M, symbols: &[u8; 256], spad: P, input: &[u8], output: &mut [u8],
  501|    326|) {
  502|    326|    let pad = match spad.val() {
  503|    326|        None => return encode_base(bit, msb, symbols, input, output),
  504|      0|        Some(pad) => pad,
  505|       |    };
  506|      0|    debug_assert_eq!(output.len(), encode_pad_len(bit, spad, input.len()));
  507|      0|    let olen = encode_base_len(bit, input.len());
  508|      0|    encode_base(bit, msb, symbols, input, &mut output[.. olen]);
  509|      0|    for output in output.iter_mut().skip(olen) {
  510|      0|        *output = pad;
  511|      0|    }
  512|    326|}
_RNvMs4_Cs5FWX6epTL3a_13data_encodingNtB5_8Encoding3bit:
 1246|    978|    fn bit(&self) -> usize {
 1247|    978|        (self.0[513] & 0x7) as usize
 1248|    978|    }
_RNvCs5FWX6epTL3a_13data_encoding8div_ceil:
  258|  3.26k|fn div_ceil(x: usize, m: usize) -> usize {
  259|  3.26k|    (x + m - 1) / m
  260|  3.26k|}
_RNvCs5FWX6epTL3a_13data_encoding15chunk_unchecked:
  241|  1.63k|unsafe fn chunk_unchecked(x: &[u8], n: usize, i: usize) -> &[u8] {
  242|  1.63k|    debug_assert!((i + 1) * n <= x.len());
  243|  1.63k|    let ptr = x.as_ptr().add(n * i);
  244|  1.63k|    core::slice::from_raw_parts(ptr, n)
  245|  1.63k|}
_RNvCs5FWX6epTL3a_13data_encoding5order:
  347|  22.9k|fn order(msb: bool, n: usize, i: usize) -> usize {
  348|  22.9k|    if msb {
  349|  22.9k|        n - 1 - i
  350|       |    } else {
  351|      0|        i
  352|       |    }
  353|  22.9k|}
_RNvMs4_Cs5FWX6epTL3a_13data_encodingNtB5_8Encoding3msb:
 1242|    326|    fn msb(&self) -> bool {
 1243|    326|        self.0[513] & 0x8 != 0
 1244|    326|    }
_RNvMs4_Cs5FWX6epTL3a_13data_encodingNtB5_8Encoding6encode:
 1343|    326|    pub fn encode(&self, input: &[u8]) -> String {
 1344|    326|        let mut output = vec![0u8; self.encode_len(input.len())];
 1345|    326|        self.encode_mut(input, &mut output);
 1346|    326|        unsafe { String::from_utf8_unchecked(output) }
 1347|    326|    }
_RNvMs4_Cs5FWX6epTL3a_13data_encodingNtB5_8Encoding3pad:
 1230|    978|    fn pad(&self) -> Option<u8> {
 1231|    978|        if self.0[512] < 128 {
 1232|      0|            Some(self.0[512])
 1233|       |        } else {
 1234|    978|            None
 1235|       |        }
 1236|    978|    }
_RNvCs5FWX6epTL3a_13data_encoding8as_array:
  253|    326|unsafe fn as_array(x: &[u8]) -> &[u8; 256] {
  254|    326|    debug_assert_eq!(x.len(), 256);
  255|    326|    &*(x.as_ptr() as *const [u8; 256])
  256|    326|}
_RINvCs5FWX6epTL3a_13data_encoding15encode_wrap_lenNtB2_2N5NtB2_2OnBU_EB2_:
  514|    652|fn encode_wrap_len<
  515|    652|    'a,
  516|    652|    B: Static<usize>,
  517|    652|    P: Static<Option<u8>>,
  518|    652|    W: Static<Option<(usize, &'a [u8])>>,
  519|    652|>(
  520|    652|    bit: B, pad: P, wrap: W, ilen: usize,
  521|    652|) -> usize {
  522|    652|    let olen = encode_pad_len(bit, pad, ilen);
  523|    652|    match wrap.val() {
  524|    652|        None => olen,
  525|      0|        Some((col, end)) => olen + end.len() * div_ceil(olen, col),
  526|       |    }
  527|    652|}
_RINvCs5FWX6epTL3a_13data_encoding10encode_mutNtB2_2N5NtB2_2BtEB2_:
  390|    326|fn encode_mut<B: Static<usize>, M: Static<bool>>(
  391|    326|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  392|    326|) {
  393|    326|    debug_assert_eq!(output.len(), encode_len(bit, input.len()));
  394|    326|    let enc = enc(bit.val());
  395|    326|    let dec = dec(bit.val());
  396|    326|    let n = input.len() / enc;
  397|    326|    let bs = match bit.val() {
  398|    326|        5 => 2,
  399|      0|        6 => 4,
  400|      0|        _ => 1,
  401|       |    };
  402|    326|    vectorize(n, bs, |i| {
  403|       |        let input = unsafe { chunk_unchecked(input, enc, i) };
  404|       |        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  405|       |        encode_block(bit, msb, symbols, input, output);
  406|    326|    });
  407|    326|    encode_block(bit, msb, symbols, &input[enc * n ..], &mut output[dec * n ..]);
  408|    326|}
_RNvCs5FWX6epTL3a_13data_encoding3dec:
  365|  14.5k|fn dec(bit: usize) -> usize {
  366|  14.5k|    enc(bit) * 8 / bit
  367|  14.5k|}
_RINvCs5FWX6epTL3a_13data_encoding11encode_baseNtB2_2N5NtB2_2BtEB2_:
  485|    326|fn encode_base<B: Static<usize>, M: Static<bool>>(
  486|    326|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  487|    326|) {
  488|    326|    debug_assert_eq!(output.len(), encode_base_len(bit, input.len()));
  489|    326|    encode_mut(bit, msb, symbols, input, output);
  490|    326|}
_RNCINvCs5FWX6epTL3a_13data_encoding10encode_mutNtB4_2N5NtB4_2BtE0B4_:
  402|  1.63k|    vectorize(n, bs, |i| {
  403|  1.63k|        let input = unsafe { chunk_unchecked(input, enc, i) };
  404|  1.63k|        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  405|  1.63k|        encode_block(bit, msb, symbols, input, output);
  406|  1.63k|    });
_RNvCs5FWX6epTL3a_13data_encoding5floor:
  262|    326|fn floor(x: usize, m: usize) -> usize {
  263|    326|    x / m * m
  264|    326|}
_RNvCs5FWX6epTL3a_13data_encoding19chunk_mut_unchecked:
  247|  1.63k|unsafe fn chunk_mut_unchecked(x: &mut [u8], n: usize, i: usize) -> &mut [u8] {
  248|  1.63k|    debug_assert!((i + 1) * n <= x.len());
  249|  1.63k|    let ptr = x.as_mut_ptr().add(n * i);
  250|  1.63k|    core::slice::from_raw_parts_mut(ptr, n)
  251|  1.63k|}
_RNvCs5FWX6epTL3a_13data_encoding3enc:
  355|  25.5k|fn enc(bit: usize) -> usize {
  356|  25.5k|    debug_assert!(1 <= bit && bit <= 6);
  357|  25.5k|    match bit {
  358|      0|        1 | 2 | 4 => 1,
  359|      0|        3 | 6 => 3,
  360|  25.5k|        5 => 5,
  361|      0|        _ => unreachable!(),
  362|       |    }
  363|  25.5k|}
_RNvMs4_Cs5FWX6epTL3a_13data_encodingNtB5_8Encoding3sym:
 1222|    326|    fn sym(&self) -> &[u8; 256] {
 1223|    326|        unsafe { as_array(&self.0[0 .. 256]) }
 1224|    326|    }

_RNvXs4_NtNtCsh9D4u1TLtsH_6digest8core_api11ct_variableINtB5_21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB25_IB25_IB25_IB25_IB25_NtB27_5UTermNtNtB29_3bit2B1ENtB3i_2B0EB3w_EB3w_EB3w_EB3w_ENtB1n_9OidSha256ENtB7_15FixedOutputCore19finalize_fixed_coreCs4ieSHZHrxF6_15direct_syscalls:
  114|    489|    fn finalize_fixed_core(
  115|    489|        &mut self,
  116|    489|        buffer: &mut Buffer<Self>,
  117|    489|        out: &mut GenericArray<u8, Self::OutputSize>,
  118|    489|    ) {
  119|    489|        let mut full_res = Default::default();
  120|    489|        self.inner.finalize_variable_core(buffer, &mut full_res);
  121|    489|        let n = out.len();
  122|    489|        let m = full_res.len() - n;
  123|    489|        match T::TRUNC_SIDE {
  124|    489|            TruncSide::Left => out.copy_from_slice(&full_res[..n]),
  125|      0|            TruncSide::Right => out.copy_from_slice(&full_res[m..]),
  126|       |        }
  127|    489|    }
_RNvXs5_NtNtCsh9D4u1TLtsH_6digest8core_api11ct_variableINtB5_21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB25_IB25_IB25_IB25_IB25_NtB27_5UTermNtNtB29_3bit2B1ENtB3i_2B0EB3w_EB3w_EB3w_EB3w_ENtB1n_9OidSha256ENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCs4ieSHZHrxF6_15direct_syscalls:
  139|    489|    fn default() -> Self {
  140|    489|        Self {
  141|    489|            inner: T::new(OutSize::USIZE).unwrap(),
  142|    489|            _out: PhantomData,
  143|    489|        }
  144|    489|    }

_RNvXs8_NtNtCsh9D4u1TLtsH_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtB9_11FixedOutput13finalize_intoCs4ieSHZHrxF6_15direct_syscalls:
  170|    489|    fn finalize_into(mut self, out: &mut Output<Self>) {
  171|    489|        let Self { core, buffer } = &mut self;
  172|    489|        core.finalize_fixed_core(buffer, out);
  173|    489|    }
_RNvXsg_NtNtCsh9D4u1TLtsH_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCs4ieSHZHrxF6_15direct_syscalls:
   23|    489|#[derive(Clone, Default)]
_RNvXs6_NtNtCsh9D4u1TLtsH_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtB9_6Update6updateCs6zZxOXcsMaf_13fvm_ipld_hamt:
  148|    489|    fn update(&mut self, input: &[u8]) {
  149|    489|        let Self { core, buffer } = self;
  150|    489|        buffer.digest_blocks(input, |blocks| core.update_blocks(blocks));
  151|    489|    }

_RNvXNtCsh9D4u1TLtsH_6digest6digestINtNtNtB4_8core_api7wrapper11CoreWrapperINtNtBB_11ct_variable21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB2E_IB2E_IB2E_IB2E_IB2E_NtB2G_5UTermNtNtB2I_3bit2B1ENtB3R_2B0EB45_EB45_EB45_EB45_ENtB1W_9OidSha256EENtB2_6Digest8finalizeCs4ieSHZHrxF6_15direct_syscalls:
   85|    489|    fn finalize(self) -> Output<Self> {
   86|    489|        FixedOutput::finalize_fixed(self)
   87|    489|    }
_RINvXNtCsh9D4u1TLtsH_6digest6digestINtNtNtB5_8core_api7wrapper11CoreWrapperINtNtBC_11ct_variable21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB2F_IB2F_IB2F_IB2F_IB2F_NtB2H_5UTermNtNtB2J_3bit2B1ENtB3S_2B0EB46_EB46_EB46_EB46_ENtB1X_9OidSha256EENtB3_6Digest6updateRShECs6zZxOXcsMaf_13fvm_ipld_hamt:
   74|    489|    fn update(&mut self, data: impl AsRef<[u8]>) {
   75|    489|        Update::update(self, data.as_ref());
   76|    489|    }

_RNvYINtNtNtCsh9D4u1TLtsH_6digest8core_api7wrapper11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCs7HNaFSx2gxZ_4sha28core_api13Sha256VarCoreINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB2s_IB2s_IB2s_IB2s_IB2s_NtB2u_5UTermNtNtB2w_3bit2B1ENtB3F_2B0EB3T_EB3T_EB3T_EB3T_ENtB1K_9OidSha256EENtB9_11FixedOutput14finalize_fixedCs4ieSHZHrxF6_15direct_syscalls:
   99|    489|    fn finalize_fixed(self) -> Output<Self> {
  100|    489|        let mut out = Default::default();
  101|    489|        self.finalize_into(&mut out);
  102|    489|        out
  103|    489|    }

_RNvXs0_NtCsgVqcGLl2G6M_10env_logger6filterNtB5_7BuilderNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  263|    163|    fn default() -> Self {
  264|    163|        Builder::new()
  265|    163|    }
_RNCNvNtCsgVqcGLl2G6M_10env_logger6filter10parse_specs0_0B5_:
  344|    652|                name: name.map(|s| s.to_string()),
_RNvMs_NtCsgVqcGLl2G6M_10env_logger6filterNtB4_7Builder3new:
  173|    163|    pub fn new() -> Builder {
  174|    163|        Builder {
  175|    163|            directives: HashMap::new(),
  176|    163|            filter: None,
  177|    163|            built: false,
  178|    163|        }
  179|    163|    }
_RNCNvNtCsgVqcGLl2G6M_10env_logger6filter10parse_specs_0B5_:
  313|    326|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
_RNCNvMNtCsgVqcGLl2G6M_10env_logger6filterNtB4_6Filter6filter0B6_:
  142|    652|            .map(|d| d.level)
_RNCNCNvMs_NtCsgVqcGLl2G6M_10env_logger6filterNtB8_7Builder5builds_00Ba_:
  249|    812|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
_RNCNvMs_NtCsgVqcGLl2G6M_10env_logger6filterNtB6_7Builder5build0B8_:
  244|    652|                .map(|(name, level)| Directive { name, level })
_RNvMNtCsgVqcGLl2G6M_10env_logger6filterNtB2_6Filter7enabled:
  163|    489|    pub fn enabled(&self, metadata: &Metadata) -> bool {
  164|    489|        let level = metadata.level();
  165|    489|        let target = metadata.target();
  166|    489|
  167|    489|        enabled(&self.directives, level, target)
  168|    489|    }
_RNvMNtCsgVqcGLl2G6M_10env_logger6filterNtB2_6Filter7matches:
  148|    489|    pub fn matches(&self, record: &Record) -> bool {
  149|    489|        if !self.enabled(record.metadata()) {
  150|    163|            return false;
  151|    326|        }
  152|       |
  153|    326|        if let Some(filter) = self.filter.as_ref() {
  154|      0|            if !filter.is_match(&record.args().to_string()) {
  155|      0|                return false;
  156|      0|            }
  157|    326|        }
  158|       |
  159|    326|        true
  160|    489|    }
_RNvMs_NtCsgVqcGLl2G6M_10env_logger6filterNtB4_7Builder5build:
  228|    163|    pub fn build(&mut self) -> Filter {
  229|    163|        assert!(!self.built, "attempt to re-use consumed builder");
  230|    163|        self.built = true;
  231|    163|
  232|    163|        let mut directives = Vec::new();
  233|    163|        if self.directives.is_empty() {
  234|      0|            // Adds the default filter if none exist
  235|      0|            directives.push(Directive {
  236|      0|                name: None,
  237|      0|                level: LevelFilter::Error,
  238|      0|            });
  239|    163|        } else {
  240|    163|            // Consume map of directives.
  241|    163|            let directives_map = mem::take(&mut self.directives);
  242|    163|            directives = directives_map
  243|    163|                .into_iter()
  244|    163|                .map(|(name, level)| Directive { name, level })
  245|    163|                .collect();
  246|    163|            // Sort the directives by length of their name, this allows a
  247|    163|            // little more efficient lookup at runtime.
  248|    163|            directives.sort_by(|a, b| {
  249|       |                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|       |                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|       |                alen.cmp(&blen)
  252|    163|            });
  253|    163|        }
  254|       |
  255|    163|        Filter {
  256|    163|            directives: mem::take(&mut directives),
  257|    163|            filter: mem::replace(&mut self.filter, None),
  258|    163|        }
  259|    163|    }
_RNvMs_NtCsgVqcGLl2G6M_10env_logger6filterNtB4_7Builder5parse:
  216|    163|    pub fn parse(&mut self, filters: &str) -> &mut Self {
  217|    163|        let (directives, filter) = parse_spec(filters);
  218|    163|
  219|    163|        self.filter = filter;
  220|       |
  221|    815|        for directive in directives {
  222|    652|            self.directives.insert(directive.name, directive.level);
  223|    652|        }
  224|    163|        self
  225|    163|    }
_RNvNtCsgVqcGLl2G6M_10env_logger6filter10parse_spec:
  292|    163|fn parse_spec(spec: &str) -> (Vec<Directive>, Option<inner::Filter>) {
  293|    163|    let mut dirs = Vec::new();
  294|    163|
  295|    163|    let mut parts = spec.split('/');
  296|    163|    let mods = parts.next();
  297|    163|    let filter = parts.next();
  298|    163|    if parts.next().is_some() {
  299|      0|        eprintln!(
  300|      0|            "warning: invalid logging spec '{}', \
  301|      0|             ignoring it (too many '/'s)",
  302|      0|            spec
  303|      0|        );
  304|      0|        return (dirs, None);
  305|    163|    }
  306|    163|    if let Some(m) = mods {
  307|    652|        for s in m.split(',').map(|ss| ss.trim()) {
  308|    652|            if s.is_empty() {
  309|      0|                continue;
  310|    652|            }
  311|    652|            let mut parts = s.split('=');
  312|    652|            let (log_level, name) =
  313|    652|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
  314|    326|                    (Some(part0), None, None) => {
  315|    326|                        // if the single argument is a log-level string or number,
  316|    326|                        // treat that as a global fallback
  317|    326|                        match part0.parse() {
  318|      0|                            Ok(num) => (num, None),
  319|    326|                            Err(_) => (LevelFilter::max(), Some(part0)),
  320|       |                        }
  321|       |                    }
  322|    326|                    (Some(part0), Some(""), None) => (LevelFilter::max(), Some(part0)),
  323|    326|                    (Some(part0), Some(part1), None) => match part1.parse() {
  324|    326|                        Ok(num) => (num, Some(part0)),
  325|       |                        _ => {
  326|      0|                            eprintln!(
  327|      0|                                "warning: invalid logging spec '{}', \
  328|      0|                                 ignoring it",
  329|      0|                                part1
  330|      0|                            );
  331|      0|                            continue;
  332|       |                        }
  333|       |                    },
  334|       |                    _ => {
  335|      0|                        eprintln!(
  336|      0|                            "warning: invalid logging spec '{}', \
  337|      0|                             ignoring it",
  338|      0|                            s
  339|      0|                        );
  340|      0|                        continue;
  341|       |                    }
  342|       |                };
  343|    652|            dirs.push(Directive {
  344|    652|                name: name.map(|s| s.to_string()),
  345|    652|                level: log_level,
  346|    652|            });
  347|       |        }
  348|      0|    }
  349|       |
  350|    163|    let filter = filter.and_then(|filter| match inner::Filter::new(filter) {
  351|       |        Ok(re) => Some(re),
  352|       |        Err(e) => {
  353|       |            eprintln!("warning: invalid regex filter - {}", e);
  354|       |            None
  355|       |        }
  356|    163|    });
  357|    163|
  358|    163|    (dirs, filter)
  359|    163|}
_RNCNvNtCsgVqcGLl2G6M_10env_logger6filter10parse_spec0B5_:
  307|    652|        for s in m.split(',').map(|ss| ss.trim()) {
_RNvNtCsgVqcGLl2G6M_10env_logger6filter7enabled:
  362|    489|fn enabled(directives: &[Directive], level: Level, target: &str) -> bool {
  363|       |    // Search for the longest match, the vector is assumed to be pre-sorted.
  364|  1.95k|    for directive in directives.iter().rev() {
  365|  1.95k|        match directive.name {
  366|  1.95k|            Some(ref name) if !target.starts_with(&**name) => {}
  367|    326|            Some(..) | None => return level <= directive.level,
  368|       |        }
  369|       |    }
  370|    163|    false
  371|    489|}
_RNvMNtCsgVqcGLl2G6M_10env_logger6filterNtB2_6Filter6filter:
  139|    163|    pub fn filter(&self) -> LevelFilter {
  140|    163|        self.directives
  141|    163|            .iter()
  142|    163|            .map(|d| d.level)
  143|    163|            .max()
  144|    163|            .unwrap_or(LevelFilter::Off)
  145|    163|    }
_RNCNCNvMs_NtCsgVqcGLl2G6M_10env_logger6filterNtB8_7Builder5builds_0s_0Ba_:
  250|    812|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
_RNCNvMs_NtCsgVqcGLl2G6M_10env_logger6filterNtB6_7Builder5builds_0B8_:
  248|    812|            directives.sort_by(|a, b| {
  249|    812|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|    812|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|    812|                alen.cmp(&blen)
  252|    812|            });

_RNvMNtNtNtCsgVqcGLl2G6M_10env_logger3fmt9humantime3impNtB6_9Formatter17timestamp_seconds:
   43|    326|    pub fn timestamp_seconds(&self) -> Timestamp {
   44|    326|        Timestamp {
   45|    326|            time: SystemTime::now(),
   46|    326|            precision: TimestampPrecision::Seconds,
   47|    326|        }
   48|    326|    }
_RNvXs0_NtNtNtCsgVqcGLl2G6M_10env_logger3fmt9humantime3impNtB5_9TimestampNtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt:
  108|    326|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  109|    326|        let formatter = match self.precision {
  110|    326|            TimestampPrecision::Seconds => format_rfc3339_seconds,
  111|      0|            TimestampPrecision::Millis => format_rfc3339_millis,
  112|      0|            TimestampPrecision::Micros => format_rfc3339_micros,
  113|      0|            TimestampPrecision::Nanos => format_rfc3339_nanos,
  114|       |        };
  115|       |
  116|    326|        formatter(self.time).fmt(f)
  117|    326|    }

_RNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_13DefaultFormat12subtle_style:
  235|    652|    fn subtle_style(&self, text: &'static str) -> SubtleStyle {
  236|    652|        #[cfg(feature = "termcolor")]
  237|    652|        {
  238|    652|            self.buf
  239|    652|                .style()
  240|    652|                .set_color(Color::Black)
  241|    652|                .set_intense(true)
  242|    652|                .clone()
  243|    652|                .into_value(text)
  244|    652|        }
  245|    652|        #[cfg(not(feature = "termcolor"))]
  246|    652|        {
  247|    652|            text
  248|    652|        }
  249|    652|    }
_RNCNvMs3_NtCsgVqcGLl2G6M_10env_logger3fmtNtB7_7Builder5build0B9_:
  187|    326|            Box::new(move |buf, record| {
  188|    326|                let fmt = DefaultFormat {
  189|    326|                    timestamp: built.format_timestamp,
  190|    326|                    module_path: built.format_module_path,
  191|    326|                    target: built.format_target,
  192|    326|                    level: built.format_level,
  193|    326|                    written_header_value: false,
  194|    326|                    indent: built.format_indent,
  195|    326|                    suffix: built.format_suffix,
  196|    326|                    buf,
  197|    326|                };
  198|    326|
  199|    326|                fmt.write(record)
  200|    326|            })
_RNvXNtCsgVqcGLl2G6M_10env_logger3fmtNtB2_18TimestampPrecisionNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   71|    326|    fn default() -> Self {
   72|    326|        TimestampPrecision::Seconds
   73|    326|    }
_RNvMs_NtCsgVqcGLl2G6M_10env_logger3fmtNtB4_9Formatter11write_style:
  110|    325|    pub(crate) fn write_style(&self) -> WriteStyle {
  111|    325|        self.write_style
  112|    325|    }
_RNvXs0_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_9FormatterNtNtCslmThs0IH7zH_3std2io5Write5write:
  124|  4.89k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  125|  4.89k|        self.buf.borrow_mut().write(buf)
  126|  4.89k|    }
_RNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_13DefaultFormat10write_args:
  339|    326|    fn write_args(&mut self, record: &Record) -> io::Result<()> {
  340|    326|        match self.indent {
  341|       |            // Fast path for no indentation
  342|      0|            None => write!(self.buf, "{}{}", record.args(), self.suffix),
  343|       |
  344|    326|            Some(indent_count) => {
  345|    326|                // Create a wrapper around the buffer only if we have to actually indent the message
  346|    326|
  347|    326|                struct IndentWrapper<'a, 'b: 'a> {
  348|    326|                    fmt: &'a mut DefaultFormat<'b>,
  349|    326|                    indent_count: usize,
  350|    326|                }
  351|    326|
  352|    326|                impl<'a, 'b> Write for IndentWrapper<'a, 'b> {
  353|    326|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|    326|                        let mut first = true;
  355|    326|                        for chunk in buf.split(|&x| x == b'\n') {
  356|    326|                            if !first {
  357|    326|                                write!(
  358|    326|                                    self.fmt.buf,
  359|    326|                                    "{}{:width$}",
  360|    326|                                    self.fmt.suffix,
  361|    326|                                    "",
  362|    326|                                    width = self.indent_count
  363|    326|                                )?;
  364|    326|                            }
  365|    326|                            self.fmt.buf.write_all(chunk)?;
  366|    326|                            first = false;
  367|    326|                        }
  368|    326|
  369|    326|                        Ok(buf.len())
  370|    326|                    }
  371|    326|
  372|    326|                    fn flush(&mut self) -> io::Result<()> {
  373|    326|                        self.fmt.buf.flush()
  374|    326|                    }
  375|    326|                }
  376|    326|
  377|    326|                // The explicit scope here is just to make older versions of Rust happy
  378|    326|                {
  379|    326|                    let mut wrapper = IndentWrapper {
  380|    326|                        fmt: self,
  381|    326|                        indent_count,
  382|    326|                    };
  383|    326|                    write!(wrapper, "{}", record.args())?;
  384|       |                }
  385|       |
  386|    326|                write!(self.buf, "{}", self.suffix)?;
  387|       |
  388|    326|                Ok(())
  389|       |            }
  390|       |        }
  391|    326|    }
_RNvMs_NtCsgVqcGLl2G6M_10env_logger3fmtNtB4_9Formatter3new:
  103|      1|    pub(crate) fn new(writer: &Writer) -> Self {
  104|      1|        Formatter {
  105|      1|            buf: Rc::new(RefCell::new(writer.buffer())),
  106|      1|            write_style: writer.write_style(),
  107|      1|        }
  108|      1|    }
_RINvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueReEB8_:
  251|    326|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    326|    where
  253|    326|        T: Display,
  254|    326|    {
  255|    326|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|    326|            write!(self.buf, " {}", value)
  262|       |        }
  263|    326|    }
_RNvMs_NtCsgVqcGLl2G6M_10env_logger3fmtNtB4_9Formatter5clear:
  118|    326|    pub(crate) fn clear(&mut self) {
  119|    326|        self.buf.borrow_mut().clear()
  120|    326|    }
_RINvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtCsdRJjCzU6nMS_4core3fmt9ArgumentsEB8_:
  251|    326|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    326|    where
  253|    326|        T: Display,
  254|    326|    {
  255|    326|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|    326|            write!(self.buf, " {}", value)
  262|       |        }
  263|    326|    }
_RNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_13DefaultFormat5write:
  226|    326|        self.write_timestamp()?;
  227|    326|        self.write_level(record)?;
  228|    326|        self.write_module_path(record)?;
  229|    326|        self.write_target(record)?;
  230|    326|        self.finish_header()?;
  231|       |
  232|    326|        self.write_args(record)
  233|    326|    }
_RNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_13DefaultFormat12write_target:
  319|    326|    fn write_target(&mut self, record: &Record) -> io::Result<()> {
  320|    326|        if !self.target {
  321|      0|            return Ok(());
  322|    326|        }
  323|    326|
  324|    326|        match record.target() {
  325|    326|            "" => Ok(()),
  326|    326|            target => self.write_header_value(target),
  327|       |        }
  328|    326|    }
_RNvMs3_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_7Builder5build:
  173|    163|    pub fn build(&mut self) -> FormatFn {
  174|    163|        assert!(!self.built, "attempt to re-use consumed builder");
  175|       |
  176|    163|        let built = mem::replace(
  177|    163|            self,
  178|    163|            Builder {
  179|    163|                built: true,
  180|    163|                ..Default::default()
  181|    163|            },
  182|    163|        );
  183|       |
  184|    163|        if let Some(fmt) = built.custom_format {
  185|      0|            fmt
  186|       |        } else {
  187|    163|            Box::new(move |buf, record| {
  188|       |                let fmt = DefaultFormat {
  189|       |                    timestamp: built.format_timestamp,
  190|       |                    module_path: built.format_module_path,
  191|       |                    target: built.format_target,
  192|       |                    level: built.format_level,
  193|       |                    written_header_value: false,
  194|       |                    indent: built.format_indent,
  195|       |                    suffix: built.format_suffix,
  196|       |                    buf,
  197|       |                };
  198|       |
  199|       |                fmt.write(record)
  200|    163|            })
  201|       |        }
  202|    163|    }
_RNvXs2_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_7BuilderNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  153|    326|    fn default() -> Self {
  154|    326|        Builder {
  155|    326|            format_timestamp: Some(Default::default()),
  156|    326|            format_module_path: false,
  157|    326|            format_target: true,
  158|    326|            format_level: true,
  159|    326|            format_indent: Some(4),
  160|    326|            custom_format: None,
  161|    326|            format_suffix: "\n",
  162|    326|            built: false,
  163|    326|        }
  164|    326|    }
_RNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_13DefaultFormat15write_timestamp:
  284|    326|    fn write_timestamp(&mut self) -> io::Result<()> {
  285|       |        #[cfg(feature = "humantime")]
  286|       |        {
  287|       |            use self::TimestampPrecision::*;
  288|    326|            let ts = match self.timestamp {
  289|      0|                None => return Ok(()),
  290|    326|                Some(Seconds) => self.buf.timestamp_seconds(),
  291|      0|                Some(Millis) => self.buf.timestamp_millis(),
  292|      0|                Some(Micros) => self.buf.timestamp_micros(),
  293|      0|                Some(Nanos) => self.buf.timestamp_nanos(),
  294|       |            };
  295|       |
  296|    326|            self.write_header_value(ts)
  297|       |        }
  298|       |        #[cfg(not(feature = "humantime"))]
  299|       |        {
  300|       |            // Trick the compiler to think we have used self.timestamp
  301|       |            // Workaround for "field is never used: `timestamp`" compiler nag.
  302|       |            let _ = self.timestamp;
  303|       |            Ok(())
  304|       |        }
  305|    326|    }
_RNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_13DefaultFormat13finish_header:
  330|    326|    fn finish_header(&mut self) -> io::Result<()> {
  331|    326|        if self.written_header_value {
  332|    326|            let close_brace = self.subtle_style("]");
  333|    326|            write!(self.buf, "{} ", close_brace)
  334|       |        } else {
  335|      0|            Ok(())
  336|       |        }
  337|    326|    }
_RNvMs_NtCsgVqcGLl2G6M_10env_logger3fmtNtB4_9Formatter5print:
  114|    326|    pub(crate) fn print(&self, writer: &Writer) -> io::Result<()> {
  115|    326|        writer.print(&self.buf.borrow())
  116|    326|    }
_RINvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtNtB6_9humantime3imp9TimestampEB8_:
  251|    326|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    326|    where
  253|    326|        T: Display,
  254|    326|    {
  255|    326|        if !self.written_header_value {
  256|    326|            self.written_header_value = true;
  257|    326|
  258|    326|            let open_brace = self.subtle_style("[");
  259|    326|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|      0|            write!(self.buf, " {}", value)
  262|       |        }
  263|    326|    }
_RNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_13DefaultFormat17write_module_path:
  307|    326|    fn write_module_path(&mut self, record: &Record) -> io::Result<()> {
  308|    326|        if !self.module_path {
  309|    326|            return Ok(());
  310|      0|        }
  311|       |
  312|      0|        if let Some(module_path) = record.module_path() {
  313|      0|            self.write_header_value(module_path)
  314|       |        } else {
  315|      0|            Ok(())
  316|       |        }
  317|    326|    }
_RNCNvXNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtBa_13DefaultFormat10write_argsNtB4_13IndentWrapperNtNtCslmThs0IH7zH_3std2io5Write5write0Bc_:
  355|  27.7k|                        for chunk in buf.split(|&x| x == b'\n') {
_RNvXNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB8_13DefaultFormat10write_argsNtB2_13IndentWrapperNtNtCslmThs0IH7zH_3std2io5Write5write:
  353|  1.95k|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|  1.95k|                        let mut first = true;
  355|  1.95k|                        for chunk in buf.split(|&x| x == b'\n') {
  356|  1.95k|                            if !first {
  357|      0|                                write!(
  358|      0|                                    self.fmt.buf,
  359|      0|                                    "{}{:width$}",
  360|      0|                                    self.fmt.suffix,
  361|      0|                                    "",
  362|      0|                                    width = self.indent_count
  363|      0|                                )?;
  364|  1.95k|                            }
  365|  1.95k|                            self.fmt.buf.write_all(chunk)?;
  366|  1.95k|                            first = false;
  367|       |                        }
  368|       |
  369|  1.95k|                        Ok(buf.len())
  370|  1.95k|                    }
_RNvMs4_NtCsgVqcGLl2G6M_10env_logger3fmtNtB5_13DefaultFormat11write_level:
  265|    326|    fn write_level(&mut self, record: &Record) -> io::Result<()> {
  266|    326|        if !self.level {
  267|      0|            return Ok(());
  268|    326|        }
  269|    326|
  270|    326|        let level = {
  271|    326|            #[cfg(feature = "termcolor")]
  272|    326|            {
  273|    326|                self.buf.default_styled_level(record.level())
  274|    326|            }
  275|    326|            #[cfg(not(feature = "termcolor"))]
  276|    326|            {
  277|    326|                record.level()
  278|    326|            }
  279|    326|        };
  280|    326|
  281|    326|        self.write_header_value(format_args!("{:<5}", level))
  282|    326|    }

_RNvNtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer4atty3imp9is_stderr:
   16|    163|    pub(in crate::fmt) fn is_stderr() -> bool {
   17|    163|        atty::is(atty::Stream::Stderr)
   18|    163|    }

_RNvMs4_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_6Writer11write_style:
  111|    326|    pub fn write_style(&self) -> WriteStyle {
  112|    326|        self.write_style
  113|    326|    }
_RNvXs3_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   99|    163|    fn default() -> Self {
  100|    163|        WriteStyle::Auto
  101|    163|    }
_RNvMs4_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_6Writer5print:
  119|    326|    pub(super) fn print(&self, buf: &Buffer) -> io::Result<()> {
  120|    326|        self.inner.print(buf)
  121|    326|    }
_RNvXNtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB2_6TargetNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   27|    326|    fn default() -> Self {
   28|    326|        Target::Stderr
   29|    326|    }
_RNvMs4_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_6Writer6buffer:
  115|      1|    pub(super) fn buffer(&self) -> Buffer {
  116|      1|        self.inner.buffer()
  117|      1|    }
_RNvXs6_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_7BuilderNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  207|    163|    fn default() -> Self {
  208|    163|        Builder::new()
  209|    163|    }
_RNvMs5_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_7Builder5build:
  174|    163|    pub(crate) fn build(&mut self) -> Writer {
  175|    163|        assert!(!self.built, "attempt to re-use consumed builder");
  176|    163|        self.built = true;
  177|       |
  178|    163|        let color_choice = match self.write_style {
  179|       |            WriteStyle::Auto => {
  180|    163|                if match &self.target {
  181|    163|                    WritableTarget::Stderr => is_stderr(),
  182|      0|                    WritableTarget::Stdout => is_stdout(),
  183|      0|                    WritableTarget::Pipe(_) => false,
  184|       |                } {
  185|      0|                    WriteStyle::Auto
  186|       |                } else {
  187|    163|                    WriteStyle::Never
  188|       |                }
  189|       |            }
  190|      0|            color_choice => color_choice,
  191|       |        };
  192|       |
  193|    163|        let writer = match mem::take(&mut self.target) {
  194|    163|            WritableTarget::Stderr => BufferWriter::stderr(self.is_test, color_choice),
  195|      0|            WritableTarget::Stdout => BufferWriter::stdout(self.is_test, color_choice),
  196|      0|            WritableTarget::Pipe(pipe) => BufferWriter::pipe(color_choice, pipe),
  197|       |        };
  198|       |
  199|    163|        Writer {
  200|    163|            inner: writer,
  201|    163|            write_style: self.write_style,
  202|    163|        }
  203|    163|    }
_RNvXs0_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_14WritableTargetINtNtCsdRJjCzU6nMS_4core7convert4FromNtB5_6TargetE4from:
   59|    326|    fn from(target: Target) -> Self {
   60|    326|        match target {
   61|      0|            Target::Stdout => Self::Stdout,
   62|    326|            Target::Stderr => Self::Stderr,
   63|      0|            Target::Pipe(pipe) => Self::Pipe(Box::new(Mutex::new(pipe))),
   64|       |        }
   65|    326|    }
_RNvXsf_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eq:
   88|    325|#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
_RNvMs5_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_7Builder3new:
  137|    163|    pub(crate) fn new() -> Self {
  138|    163|        Builder {
  139|    163|            target: Default::default(),
  140|    163|            write_style: Default::default(),
  141|    163|            is_test: false,
  142|    163|            built: false,
  143|    163|        }
  144|    163|    }
_RNvXs1_NtNtCsgVqcGLl2G6M_10env_logger3fmt6writerNtB5_14WritableTargetNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   69|    326|    fn default() -> Self {
   70|    326|        Self::from(Target::default())
   71|    326|    }

_RNCNvXs8_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueNtCs5Em8znMBCBW_3log5LevelENtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt0Bf_:
  466|    326|impl_styled_value_fmt!(
  467|    326|    fmt::Debug,
  468|    326|    fmt::Display,
  469|    326|    fmt::Pointer,
  470|    326|    fmt::Octal,
  471|    326|    fmt::Binary,
  472|    326|    fmt::UpperHex,
  473|    326|    fmt::LowerHex,
  474|    326|    fmt::UpperExp,
  475|    326|    fmt::LowerExp
  476|    326|);
_RINvMs3_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueNtCs5Em8znMBCBW_3log5LevelE9write_fmtNCNvXs8_B6_B13_NtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt0EBe_:
  434|    326|        self.style
  435|    326|            .buf
  436|    326|            .borrow_mut()
  437|    326|            .set_color(&self.style.spec)
  438|    326|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|    326|        let write = f();
  442|    326|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|    326|
  444|    326|        write.and(reset)
  445|    326|    }
_RNvMNtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter20default_styled_level:
   67|    326|    pub fn default_styled_level(&self, level: Level) -> StyledValue<'static, Level> {
   68|    326|        self.default_level_style(level).into_value(level)
   69|    326|    }
_RNvMs_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter5print:
  124|    326|        if let Some(target) = &self.uncolored_target {
  125|       |            // This impl uses the `eprint` and `print` macros
  126|       |            // instead of `termcolor`'s buffer.
  127|       |            // This is so their output can be captured by `cargo test`
  128|      0|            let log = String::from_utf8_lossy(buf.bytes());
  129|      0|
  130|      0|            match target {
  131|      0|                WritableTarget::Stderr => eprint!("{}", log),
  132|      0|                WritableTarget::Stdout => print!("{}", log),
  133|      0|                WritableTarget::Pipe(pipe) => write!(pipe.lock().unwrap(), "{}", log)?,
  134|       |            }
  135|       |
  136|      0|            Ok(())
  137|       |        } else {
  138|    326|            self.inner.print(&buf.inner)
  139|       |        }
  140|    326|    }
_RNvMs0_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5reset:
  169|    978|    fn reset(&mut self) -> io::Result<()> {
  170|    978|        // Ignore styles for test captured logs because they can't be printed
  171|    978|        if !self.has_uncolored_target {
  172|    978|            self.inner.reset()
  173|       |        } else {
  174|      0|            Ok(())
  175|       |        }
  176|    978|    }
_RNvMNtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter19default_level_style:
   52|    326|    pub fn default_level_style(&self, level: Level) -> Style {
   53|    326|        let mut level_style = self.style();
   54|    326|        match level {
   55|    163|            Level::Trace => level_style.set_color(Color::Cyan),
   56|    163|            Level::Debug => level_style.set_color(Color::Blue),
   57|      0|            Level::Info => level_style.set_color(Color::Green),
   58|      0|            Level::Warn => level_style.set_color(Color::Yellow),
   59|      0|            Level::Error => level_style.set_color(Color::Red).set_bold(true),
   60|       |        };
   61|    326|        level_style
   62|    326|    }
_RNCNvXs8_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueReENtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt0Bf_:
  466|    652|impl_styled_value_fmt!(
  467|    652|    fmt::Debug,
  468|    652|    fmt::Display,
  469|    652|    fmt::Pointer,
  470|    652|    fmt::Octal,
  471|    652|    fmt::Binary,
  472|    652|    fmt::UpperHex,
  473|    652|    fmt::LowerHex,
  474|    652|    fmt::UpperExp,
  475|    652|    fmt::LowerExp
  476|    652|);
_RNvXs8_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueNtCs5Em8znMBCBW_3log5LevelENtNtCsdRJjCzU6nMS_4core3fmt7Display3fmtBd_:
  458|    326|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|    326|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|    326|                }
_RNvMs1_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB9_10WriteStyle17into_color_choice:
  180|    163|    fn into_color_choice(self) -> ColorChoice {
  181|    163|        match self {
  182|      0|            WriteStyle::Always => ColorChoice::Always,
  183|      0|            WriteStyle::Auto => ColorChoice::Auto,
  184|    163|            WriteStyle::Never => ColorChoice::Never,
  185|       |        }
  186|    163|    }
_RNvMs5_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB5_5Color14into_termcolor:
  518|    978|    fn into_termcolor(self) -> termcolor::Color {
  519|    978|        match self {
  520|    652|            Color::Black => termcolor::Color::Black,
  521|    163|            Color::Blue => termcolor::Color::Blue,
  522|      0|            Color::Green => termcolor::Color::Green,
  523|      0|            Color::Red => termcolor::Color::Red,
  524|    163|            Color::Cyan => termcolor::Color::Cyan,
  525|      0|            Color::Magenta => termcolor::Color::Magenta,
  526|      0|            Color::Yellow => termcolor::Color::Yellow,
  527|      0|            Color::White => termcolor::Color::White,
  528|      0|            Color::Ansi256(value) => termcolor::Color::Ansi256(value),
  529|      0|            Color::Rgb(r, g, b) => termcolor::Color::Rgb(r, g, b),
  530|       |        }
  531|    978|    }
_RNvXs6_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB5_5StyleNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  241|    652|#[derive(Clone)]
_RNvXs8_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueReENtNtCsdRJjCzU6nMS_4core3fmt7Display3fmtBd_:
  458|    652|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|    652|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|    652|                }
_RINvMs2_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueReEBe_:
  421|    652|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|    652|        StyledValue {
  423|    652|            style: Cow::Owned(self),
  424|    652|            value,
  425|    652|        }
  426|    652|    }
_RNvMs0_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer9set_color:
  160|    978|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
  161|    978|        // Ignore styles for test captured logs because they can't be printed
  162|    978|        if !self.has_uncolored_target {
  163|    978|            self.inner.set_color(spec)
  164|       |        } else {
  165|      0|            Ok(())
  166|       |        }
  167|    978|    }
_RNvMs2_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB5_5Style11set_intense:
  332|    652|    pub fn set_intense(&mut self, yes: bool) -> &mut Style {
  333|    652|        self.spec.set_intense(yes);
  334|    652|        self
  335|    652|    }
_RINvMs3_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueReE9write_fmtNCNvXs8_B6_B13_NtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt0EBe_:
  434|    652|        self.style
  435|    652|            .buf
  436|    652|            .borrow_mut()
  437|    652|            .set_color(&self.style.spec)
  438|    652|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|    652|        let write = f();
  442|    652|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|    652|
  444|    652|        write.and(reset)
  445|    652|    }
_RNvMs2_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB5_5Style9set_color:
  278|    978|    pub fn set_color(&mut self, color: Color) -> &mut Style {
  279|    978|        self.spec.set_fg(Some(color.into_termcolor()));
  280|    978|        self
  281|    978|    }
_RNvMs_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6stderr:
   83|    163|    pub(in crate::fmt::writer) fn stderr(is_test: bool, write_style: WriteStyle) -> Self {
   84|    163|        BufferWriter {
   85|    163|            inner: termcolor::BufferWriter::stderr(write_style.into_color_choice()),
   86|    163|            uncolored_target: if is_test {
   87|      0|                Some(WritableTarget::Stderr)
   88|       |            } else {
   89|    163|                None
   90|       |            },
   91|       |        }
   92|    163|    }
_RNvMs0_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5clear:
  144|    326|    pub(in crate::fmt) fn clear(&mut self) {
  145|    326|        self.inner.clear()
  146|    326|    }
_RINvMs2_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueNtCs5Em8znMBCBW_3log5LevelEBe_:
  421|    326|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|    326|        StyledValue {
  423|    326|            style: Cow::Owned(self),
  424|    326|            value,
  425|    326|        }
  426|    326|    }
_RNvMs_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6buffer:
  116|      1|    pub(in crate::fmt::writer) fn buffer(&self) -> Buffer {
  117|      1|        Buffer {
  118|      1|            inner: self.inner.buffer(),
  119|      1|            has_uncolored_target: self.uncolored_target.is_some(),
  120|      1|        }
  121|      1|    }
_RNvMs0_NtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5write:
  148|  4.89k|    pub(in crate::fmt) fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  149|  4.89k|        self.inner.write(buf)
  150|  4.89k|    }
_RNvMNtNtNtNtCsgVqcGLl2G6M_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter5style:
   42|    978|    pub fn style(&self) -> Style {
   43|    978|        Style {
   44|    978|            buf: self.buf.clone(),
   45|    978|            spec: ColorSpec::new(),
   46|    978|        }
   47|    978|    }

_RINvMCsgVqcGLl2G6M_10env_loggerNtB3_7Builder8from_envNtB3_3EnvEB3_:
  443|    163|    pub fn from_env<'a, E>(env: E) -> Self
  444|    163|    where
  445|    163|        E: Into<Env<'a>>,
  446|    163|    {
  447|    163|        let mut builder = Builder::new();
  448|    163|        builder.parse_env(env);
  449|    163|        builder
  450|    163|    }
_RNvMCsgVqcGLl2G6M_10env_loggerNtB2_7Builder8try_init:
  792|    163|    pub fn try_init(&mut self) -> Result<(), SetLoggerError> {
  793|    163|        let logger = self.build();
  794|    163|
  795|    163|        let max_level = logger.filter();
  796|    163|        let r = log::set_boxed_logger(Box::new(logger));
  797|    163|
  798|    163|        if r.is_ok() {
  799|      1|            log::set_max_level(max_level);
  800|    162|        }
  801|       |
  802|    163|        r
  803|    163|    }
_RNCNvNvNvXs0_CsgVqcGLl2G6M_10env_loggerNtBb_6LoggerNtCs5Em8znMBCBW_3log3Log3log9FORMATTER7___getit0Bb_:
  918|      1|            thread_local! {
  919|      1|                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|      1|            }
_RINvCsgVqcGLl2G6M_10env_logger17try_init_from_envNtB2_3EnvEB2_:
 1185|    163|pub fn try_init_from_env<'a, E>(env: E) -> Result<(), SetLoggerError>
 1186|    163|where
 1187|    163|    E: Into<Env<'a>>,
 1188|    163|{
 1189|    163|    let mut builder = Builder::from_env(env);
 1190|    163|
 1191|    163|    builder.try_init()
 1192|    163|}
_RNvXs7_CsgVqcGLl2G6M_10env_loggerNtB5_7BuilderNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  376|    163|#[derive(Default)]
_RNCNvXs0_CsgVqcGLl2G6M_10env_loggerNtB7_6LoggerNtCs5Em8znMBCBW_3log3Log3log0B7_:
  922|    326|            let print = |formatter: &mut Formatter, record: &Record| {
  923|    326|                let _ =
  924|    326|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|    326|
  926|    326|                // Always clear the buffer afterwards
  927|    326|                formatter.clear();
  928|    326|            };
_RNvMs2_CsgVqcGLl2G6M_10env_loggerNtB5_3Var3get:
 1080|    326|    fn get(&self) -> Option<String> {
 1081|    326|        env::var(&*self.name)
 1082|    326|            .ok()
 1083|    326|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
 1084|    326|    }
_RINvMCsgVqcGLl2G6M_10env_loggerNtB3_7Builder9parse_envNtB3_3EnvEB3_:
  488|    163|    pub fn parse_env<'a, E>(&mut self, env: E) -> &mut Self
  489|    163|    where
  490|    163|        E: Into<Env<'a>>,
  491|    163|    {
  492|    163|        let env = env.into();
  493|       |
  494|    163|        if let Some(s) = env.get_filter() {
  495|    163|            self.parse_filters(&s);
  496|    163|        }
  497|       |
  498|    163|        if let Some(s) = env.get_write_style() {
  499|      0|            self.parse_write_style(&s);
  500|    163|        }
  501|       |
  502|    163|        self
  503|    163|    }
_RNCNvMs2_CsgVqcGLl2G6M_10env_loggerNtB7_3Var3get0B7_:
 1083|    163|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
_RNvXs4_CsgVqcGLl2G6M_10env_loggerNtB5_3EnvNtNtCsdRJjCzU6nMS_4core7default7Default7default:
 1097|    163|    fn default() -> Self {
 1098|    163|        Env {
 1099|    163|            filter: Var::new(DEFAULT_FILTER_ENV),
 1100|    163|            write_style: Var::new(DEFAULT_WRITE_STYLE_ENV),
 1101|    163|        }
 1102|    163|    }
_RNvMs1_CsgVqcGLl2G6M_10env_loggerNtB5_3Env10get_filter:
 1014|    163|    fn get_filter(&self) -> Option<String> {
 1015|    163|        self.filter.get()
 1016|    163|    }
_RNvMs_CsgVqcGLl2G6M_10env_loggerNtB4_6Logger7matches:
  897|    489|    pub fn matches(&self, record: &Record) -> bool {
  898|    489|        self.filter.matches(record)
  899|    489|    }
_RNvMs_CsgVqcGLl2G6M_10env_loggerNtB4_6Logger6filter:
  892|    163|    pub fn filter(&self) -> LevelFilter {
  893|    163|        self.filter.filter()
  894|    163|    }
_RNvCsgVqcGLl2G6M_10env_logger8try_init:
 1140|    163|pub fn try_init() -> Result<(), SetLoggerError> {
 1141|    163|    try_init_from_env(Env::default())
 1142|    163|}
_RNCNvXs0_CsgVqcGLl2G6M_10env_loggerNtB7_6LoggerNtCs5Em8znMBCBW_3log3Log3logs_0B7_:
  931|    326|                .try_with(|tl_buf| {
  932|    326|                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|    326|                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|    325|                            Some(ref mut formatter) => {
  937|    325|                                // Check the buffer style. If it's different from the logger's
  938|    325|                                // style then drop the buffer and recreate it.
  939|    325|                                if formatter.write_style() != self.writer.write_style() {
  940|      0|                                    *formatter = Formatter::new(&self.writer);
  941|    325|                                }
  942|       |
  943|    325|                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|      1|                            None => {
  947|      1|                                let mut formatter = Formatter::new(&self.writer);
  948|      1|                                print(&mut formatter, record);
  949|      1|
  950|      1|                                *tl_buf = Some(formatter);
  951|      1|                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|      0|                        Err(_) => {
  955|      0|                            print(&mut Formatter::new(&self.writer), record);
  956|      0|                        }
  957|       |                    }
  958|    326|                })
_RNCNCNvXs0_CsgVqcGLl2G6M_10env_loggerNtB9_6LoggerNtCs5Em8znMBCBW_3log3Log3log00B9_:
  924|    326|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
_RNvMs1_CsgVqcGLl2G6M_10env_loggerNtB5_3Env15get_write_style:
 1053|    163|    fn get_write_style(&self) -> Option<String> {
 1054|    163|        self.write_style.get()
 1055|    163|    }
_RNvXs0_CsgVqcGLl2G6M_10env_loggerNtB5_6LoggerNtCs5Em8znMBCBW_3log3Log3log:
  907|    489|    fn log(&self, record: &Record) {
  908|    489|        if self.matches(record) {
  909|       |            // Log records are written to a thread-local buffer before being printed
  910|       |            // to the terminal. We clear these buffers afterwards, but they aren't shrinked
  911|       |            // so will always at least have capacity for the largest log record formatted
  912|       |            // on that thread.
  913|       |            //
  914|       |            // If multiple `Logger`s are used by the same threads then the thread-local
  915|       |            // formatter might have different color support. If this is the case the
  916|       |            // formatter and its buffer are discarded and recreated.
  917|       |
  918|       |            thread_local! {
  919|       |                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|       |            }
  921|       |
  922|    326|            let print = |formatter: &mut Formatter, record: &Record| {
  923|       |                let _ =
  924|       |                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|       |
  926|       |                // Always clear the buffer afterwards
  927|       |                formatter.clear();
  928|       |            };
  929|       |
  930|    326|            let printed = FORMATTER
  931|    326|                .try_with(|tl_buf| {
  932|       |                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|       |                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|       |                            Some(ref mut formatter) => {
  937|       |                                // Check the buffer style. If it's different from the logger's
  938|       |                                // style then drop the buffer and recreate it.
  939|       |                                if formatter.write_style() != self.writer.write_style() {
  940|       |                                    *formatter = Formatter::new(&self.writer);
  941|       |                                }
  942|       |
  943|       |                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|       |                            None => {
  947|       |                                let mut formatter = Formatter::new(&self.writer);
  948|       |                                print(&mut formatter, record);
  949|       |
  950|       |                                *tl_buf = Some(formatter);
  951|       |                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|       |                        Err(_) => {
  955|       |                            print(&mut Formatter::new(&self.writer), record);
  956|       |                        }
  957|       |                    }
  958|    326|                })
  959|    326|                .is_ok();
  960|    326|
  961|    326|            if !printed {
  962|      0|                // The thread-local storage was not available (because its
  963|      0|                // destructor has already run). Create a new single-use
  964|      0|                // Formatter on the stack for this call.
  965|      0|                print(&mut Formatter::new(&self.writer), record);
  966|    326|            }
  967|    163|        }
  968|    489|    }
_RINvMs2_CsgVqcGLl2G6M_10env_loggerNtB6_3Var3newReEB6_:
 1059|    326|    fn new<E>(name: E) -> Self
 1060|    326|    where
 1061|    326|        E: Into<Cow<'a, str>>,
 1062|    326|    {
 1063|    326|        Var {
 1064|    326|            name: name.into(),
 1065|    326|            default: None,
 1066|    326|        }
 1067|    326|    }
_RNvMCsgVqcGLl2G6M_10env_loggerNtB2_7Builder13parse_filters:
  716|    163|    pub fn parse_filters(&mut self, filters: &str) -> &mut Self {
  717|    163|        self.filter.parse(filters);
  718|    163|        self
  719|    163|    }
_RNvMCsgVqcGLl2G6M_10env_loggerNtB2_7Builder3new:
  411|    163|    pub fn new() -> Builder {
  412|    163|        Default::default()
  413|    163|    }
_RNvMCsgVqcGLl2G6M_10env_loggerNtB2_7Builder5build:
  823|    163|    pub fn build(&mut self) -> Logger {
  824|    163|        assert!(!self.built, "attempt to re-use consumed builder");
  825|    163|        self.built = true;
  826|    163|
  827|    163|        Logger {
  828|    163|            writer: self.writer.build(),
  829|    163|            filter: self.filter.build(),
  830|    163|            format: self.format.build(),
  831|    163|        }
  832|    163|    }

_RNCINvXNvNtCs1RjYuNghyhv_17forest_hash_utils3keys_1__NtB7_8BytesKeyNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldE0Cs4ieSHZHrxF6_15direct_syscalls:
   10|    489|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RINvXNvNtCs1RjYuNghyhv_17forest_hash_utils3key1__NtB5_8BytesKeyNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   10|    489|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RINvXs_NtCs1RjYuNghyhv_17forest_hash_utils3keyNtB5_8BytesKeyNtB7_4Hash4hashNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt14hash_algorithm17Sha2HasherWrapperECs4ieSHZHrxF6_15direct_syscalls:
   21|    489|    fn hash<H: Hasher>(&self, state: &mut H) {
   22|    489|        state.write(&self.0);
   23|    489|    }
_RINvXNvNtCs1RjYuNghyhv_17forest_hash_utils3keys_1__NtB5_8BytesKeyNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
   10|    489|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RNvXs3_NtCs1RjYuNghyhv_17forest_hash_utils3keyNtB5_8BytesKeyINtNtCsdRJjCzU6nMS_4core7convert4FromINtNtCs71iYhC60HpU_5alloc3vec3VechEE4from:
   46|    489|    fn from(bz: Vec<u8>) -> Self {
   47|    489|        BytesKey(bz)
   48|    489|    }

_RNCNvNtCsgtagClrasaP_16futures_executor5enter5enter0B5_:
   56|    163|    ENTERED.with(|c| {
   57|    163|        if c.get() {
   58|      0|            Err(EnterError { _priv: () })
   59|       |        } else {
   60|    163|            c.set(true);
   61|    163|
   62|    163|            Ok(Enter { _priv: () })
   63|       |        }
   64|    163|    })
_RNCNvNvNtCsgtagClrasaP_16futures_executor5enter7ENTERED7___getit0B7_:
    4|      1|thread_local!(static ENTERED: Cell<bool> = Cell::new(false));
_RNvXs2_NtCsgtagClrasaP_16futures_executor5enterNtB5_5EnterNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
   74|    163|    fn drop(&mut self) {
   75|    163|        ENTERED.with(|c| {
   76|       |            assert!(c.get());
   77|       |            c.set(false);
   78|    163|        });
   79|    163|    }
_RNvNtCsgtagClrasaP_16futures_executor5enter5enter:
   55|    163|pub fn enter() -> Result<Enter, EnterError> {
   56|    163|    ENTERED.with(|c| {
   57|       |        if c.get() {
   58|       |            Err(EnterError { _priv: () })
   59|       |        } else {
   60|       |            c.set(true);
   61|       |
   62|       |            Ok(Enter { _priv: () })
   63|       |        }
   64|    163|    })
   65|    163|}
_RNCNvXs2_NtCsgtagClrasaP_16futures_executor5enterNtB7_5EnterNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop0B9_:
   75|    163|        ENTERED.with(|c| {
   76|    163|            assert!(c.get());
   77|    163|            c.set(false);
   78|    163|        });

_RNCINvNtCsgtagClrasaP_16futures_executor10local_pool8block_onNCINvNtCs9ModpadCpa2_21fvm_integration_tests6bundle13import_bundleNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0CsilvC8qPft2D_8fvm_fuzz:
  317|    163|    run_executor(|cx| f.as_mut().poll(cx))
_RNCNvNvNtCsgtagClrasaP_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY7___getit0CsilvC8qPft2D_8fvm_fuzz:
   56|      1|thread_local! {
   57|      1|    static CURRENT_THREAD_NOTIFY: Arc<ThreadNotify> = Arc::new(ThreadNotify {
   58|      1|        thread: thread::current(),
   59|      1|        unparked: AtomicBool::new(false),
   60|      1|    });
   61|      1|}
_RINvNtCsgtagClrasaP_16futures_executor10local_pool8block_onNCINvNtCs9ModpadCpa2_21fvm_integration_tests6bundle13import_bundleNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0ECsilvC8qPft2D_8fvm_fuzz:
  315|    163|pub fn block_on<F: Future>(f: F) -> F::Output {
  316|    163|    pin_mut!(f);
  317|    163|    run_executor(|cx| f.as_mut().poll(cx))
  318|    163|}
_RNCINvNtCsgtagClrasaP_16futures_executor10local_pool12run_executorINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtNtCs2NnW6XqvVM8_12fvm_ipld_car5error5ErrorENCINvB4_8block_onNCINvNtCs9ModpadCpa2_21fvm_integration_tests6bundle13import_bundleNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0E0CsilvC8qPft2D_8fvm_fuzz:
   86|    163|    CURRENT_THREAD_NOTIFY.with(|thread_notify| {
   87|    163|        let waker = waker_ref(thread_notify);
   88|    163|        let mut cx = Context::from_waker(&waker);
   89|       |        loop {
   90|    163|            if let Poll::Ready(t) = f(&mut cx) {
   91|    163|                return t;
   92|      0|            }
   93|       |
   94|       |            // Wait for a wakeup.
   95|      0|            while !thread_notify.unparked.swap(false, Ordering::Acquire) {
   96|      0|                // No wakeup occurred. It may occur now, right before parking,
   97|      0|                // but in that case the token made available by `unpark()`
   98|      0|                // is guaranteed to still be available and `park()` is a no-op.
   99|      0|                thread::park();
  100|      0|            }
  101|       |        }
  102|    163|    })
_RINvNtCsgtagClrasaP_16futures_executor10local_pool12run_executorINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtNtCs2NnW6XqvVM8_12fvm_ipld_car5error5ErrorENCINvB2_8block_onNCINvNtCs9ModpadCpa2_21fvm_integration_tests6bundle13import_bundleNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0ECsilvC8qPft2D_8fvm_fuzz:
   80|    163|fn run_executor<T, F: FnMut(&mut Context<'_>) -> Poll<T>>(mut f: F) -> T {
   81|    163|    let _enter = enter().expect(
   82|    163|        "cannot execute `LocalPool` executor from within \
   83|    163|         another executor",
   84|    163|    );
   85|    163|
   86|    163|    CURRENT_THREAD_NOTIFY.with(|thread_notify| {
   87|       |        let waker = waker_ref(thread_notify);
   88|       |        let mut cx = Context::from_waker(&waker);
   89|       |        loop {
   90|       |            if let Poll::Ready(t) = f(&mut cx) {
   91|       |                return t;
   92|       |            }
   93|       |
   94|       |            // Wait for a wakeup.
   95|       |            while !thread_notify.unparked.swap(false, Ordering::Acquire) {
   96|       |                // No wakeup occurred. It may occur now, right before parking,
   97|       |                // but in that case the token made available by `unpark()`
   98|       |                // is guaranteed to still be available and `park()` is a no-op.
   99|       |                thread::park();
  100|       |            }
  101|       |        }
  102|    163|    })
  103|    163|}

_RNvXs_NtCse0WcpsHYUGS_10futures_io6if_stdQRShNtB4_9AsyncRead9poll_readCsilvC8qPft2D_8fvm_fuzz:
  302|  11.2k|            fn poll_read(
  303|  11.2k|                mut self: Pin<&mut Self>,
  304|  11.2k|                cx: &mut Context<'_>,
  305|  11.2k|                buf: &mut [u8],
  306|  11.2k|            ) -> Poll<Result<usize>> {
  307|  11.2k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  11.2k|            }
_RNvXs_NtCse0WcpsHYUGS_10futures_io6if_stdQQRShNtB4_9AsyncRead9poll_readCsilvC8qPft2D_8fvm_fuzz:
  302|  8.15k|            fn poll_read(
  303|  8.15k|                mut self: Pin<&mut Self>,
  304|  8.15k|                cx: &mut Context<'_>,
  305|  8.15k|                buf: &mut [u8],
  306|  8.15k|            ) -> Poll<Result<usize>> {
  307|  8.15k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  8.15k|            }
_RNvXs_NtCse0WcpsHYUGS_10futures_io6if_stdQINtNtNtCsll4ISZbKcbA_12futures_util2io4take4TakeQRShENtB4_9AsyncRead9poll_readCsilvC8qPft2D_8fvm_fuzz:
  302|  6.03k|            fn poll_read(
  303|  6.03k|                mut self: Pin<&mut Self>,
  304|  6.03k|                cx: &mut Context<'_>,
  305|  6.03k|                buf: &mut [u8],
  306|  6.03k|            ) -> Poll<Result<usize>> {
  307|  6.03k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  6.03k|            }
_RNvXs1_NtCse0WcpsHYUGS_10futures_io6if_stdRShNtB5_9AsyncRead9poll_read:
  352|  11.2k|            fn poll_read(
  353|  11.2k|                mut self: Pin<&mut Self>,
  354|  11.2k|                _: &mut Context<'_>,
  355|  11.2k|                buf: &mut [u8],
  356|  11.2k|            ) -> Poll<Result<usize>> {
  357|  11.2k|                Poll::Ready(io::Read::read(&mut *self, buf))
  358|  11.2k|            }

_RINvNtCs14BYbBdrNhq_12futures_task5waker12waker_vtableNtNtCsgtagClrasaP_16futures_executor10local_pool12ThreadNotifyECsilvC8qPft2D_8fvm_fuzz:
    6|    163|pub(super) fn waker_vtable<W: ArcWake>() -> &'static RawWakerVTable {
    7|    163|    &RawWakerVTable::new(
    8|    163|        clone_arc_raw::<W>,
    9|    163|        wake_arc_raw::<W>,
   10|    163|        wake_by_ref_arc_raw::<W>,
   11|    163|        drop_arc_raw::<W>,
   12|    163|    )
   13|    163|}

_RINvNtCs14BYbBdrNhq_12futures_task9waker_ref9waker_refNtNtCsgtagClrasaP_16futures_executor10local_pool12ThreadNotifyECsilvC8qPft2D_8fvm_fuzz:
   55|    163|pub fn waker_ref<W>(wake: &Arc<W>) -> WakerRef<'_>
   56|    163|where
   57|    163|    W: ArcWake,
   58|    163|{
   59|    163|    // simply copy the pointer instead of using Arc::into_raw,
   60|    163|    // as we don't actually keep a refcount by using ManuallyDrop.<
   61|    163|    let ptr = Arc::as_ptr(wake).cast::<()>();
   62|    163|
   63|    163|    let waker =
   64|    163|        ManuallyDrop::new(unsafe { Waker::from_raw(RawWaker::new(ptr, waker_vtable::<W>())) });
   65|    163|    WakerRef::new_unowned(waker)
   66|    163|}
_RNvMNtCs14BYbBdrNhq_12futures_task9waker_refNtB2_8WakerRef11new_unowned:
   36|    163|    pub fn new_unowned(waker: ManuallyDrop<Waker>) -> Self {
   37|    163|        Self { waker, _marker: PhantomData }
   38|    163|    }
_RNvXs_NtCs14BYbBdrNhq_12futures_task9waker_refNtB4_8WakerRefNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref:
   45|    163|    fn deref(&self) -> &Waker {
   46|    163|        &self.waker
   47|    163|    }

_RINvNtCsll4ISZbKcbA_12futures_util6future13assert_futureINtNtCsdRJjCzU6nMS_4core6result6ResultjNtNtNtCslmThs0IH7zH_3std2io5error5ErrorEINtNtNtB4_2io11read_to_end9ReadToEndINtNtB2e_4take4TakeQRShEEECsilvC8qPft2D_8fvm_fuzz:
  126|  2.93k|pub(crate) fn assert_future<T, F>(future: F) -> F
  127|  2.93k|where
  128|  2.93k|    F: Future<Output = T>,
  129|  2.93k|{
  130|  2.93k|    future
  131|  2.93k|}
_RINvNtCsll4ISZbKcbA_12futures_util6future13assert_futureINtNtCsdRJjCzU6nMS_4core6result6ResultjNtNtNtCslmThs0IH7zH_3std2io5error5ErrorEINtNtNtB4_2io4read4ReadQRShEECsilvC8qPft2D_8fvm_fuzz:
  126|  8.15k|pub(crate) fn assert_future<T, F>(future: F) -> F
  127|  8.15k|where
  128|  8.15k|    F: Future<Output = T>,
  129|  8.15k|{
  130|  8.15k|    future
  131|  8.15k|}

_RNvYQRShNtNtCsll4ISZbKcbA_12futures_util2io12AsyncReadExt4takeCsilvC8qPft2D_8fvm_fuzz:
  375|  2.93k|    fn take(self, limit: u64) -> Take<Self>
  376|  2.93k|    where
  377|  2.93k|        Self: Sized,
  378|  2.93k|    {
  379|  2.93k|        assert_read(Take::new(self, limit))
  380|  2.93k|    }
_RNvYINtNtNtCsll4ISZbKcbA_12futures_util2io4take4TakeQRShENtB7_12AsyncReadExt11read_to_endCsilvC8qPft2D_8fvm_fuzz:
  286|  2.93k|    fn read_to_end<'a>(&'a mut self, buf: &'a mut Vec<u8>) -> ReadToEnd<'a, Self>
  287|  2.93k|    where
  288|  2.93k|        Self: Unpin,
  289|  2.93k|    {
  290|  2.93k|        assert_future::<Result<usize>, _>(ReadToEnd::new(self, buf))
  291|  2.93k|    }
_RINvNtCsll4ISZbKcbA_12futures_util2io10initializeINtNtCsdRJjCzU6nMS_4core3pin3PinQQINtNtB2_4take4TakeQRShEEECsilvC8qPft2D_8fvm_fuzz:
   41|  5.86k|unsafe fn initialize<R: AsyncRead>(_reader: &R, buf: &mut [u8]) {
   42|  5.86k|    ptr::write_bytes(buf.as_mut_ptr(), 0, buf.len())
   43|  5.86k|}
_RINvNtCsll4ISZbKcbA_12futures_util2io11assert_readINtNtB2_4take4TakeQRShEECsilvC8qPft2D_8fvm_fuzz:
  828|  2.93k|pub(crate) fn assert_read<R>(reader: R) -> R
  829|  2.93k|where
  830|  2.93k|    R: AsyncRead,
  831|  2.93k|{
  832|  2.93k|    reader
  833|  2.93k|}
_RNvYQRShNtNtCsll4ISZbKcbA_12futures_util2io12AsyncReadExt4readCsilvC8qPft2D_8fvm_fuzz:
  204|  8.15k|    fn read<'a>(&'a mut self, buf: &'a mut [u8]) -> Read<'a, Self>
  205|  8.15k|    where
  206|  8.15k|        Self: Unpin,
  207|  8.15k|    {
  208|  8.15k|        assert_future::<Result<usize>, _>(Read::new(self, buf))
  209|  8.15k|    }

_RNvXs0_NtNtCsll4ISZbKcbA_12futures_util2io4readINtB5_4ReadQRShENtNtNtCsdRJjCzU6nMS_4core6future6future6Future4pollCsilvC8qPft2D_8fvm_fuzz:
   26|  8.15k|    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
   27|  8.15k|        let this = &mut *self;
   28|  8.15k|        Pin::new(&mut this.reader).poll_read(cx, this.buf)
   29|  8.15k|    }
_RNvMs_NtNtCsll4ISZbKcbA_12futures_util2io4readINtB4_4ReadQRShE3newCsilvC8qPft2D_8fvm_fuzz:
   18|  8.15k|    pub(super) fn new(reader: &'a mut R, buf: &'a mut [u8]) -> Self {
   19|  8.15k|        Self { reader, buf }
   20|  8.15k|    }

_RINvNtNtCsll4ISZbKcbA_12futures_util2io11read_to_end20read_to_end_internalQINtNtB4_4take4TakeQRShEECsilvC8qPft2D_8fvm_fuzz:
   49|  2.93k|pub(super) fn read_to_end_internal<R: AsyncRead + ?Sized>(
   50|  2.93k|    mut rd: Pin<&mut R>,
   51|  2.93k|    cx: &mut Context<'_>,
   52|  2.93k|    buf: &mut Vec<u8>,
   53|  2.93k|    start_len: usize,
   54|  2.93k|) -> Poll<io::Result<usize>> {
   55|  2.93k|    let mut g = Guard { len: buf.len(), buf };
   56|  6.03k|    loop {
   57|  6.03k|        if g.len == g.buf.len() {
   58|  5.86k|            unsafe {
   59|  5.86k|                g.buf.reserve(32);
   60|  5.86k|                let capacity = g.buf.capacity();
   61|  5.86k|                g.buf.set_len(capacity);
   62|  5.86k|                super::initialize(&rd, &mut g.buf[g.len..]);
   63|  5.86k|            }
   64|    163|        }
   65|       |
   66|  6.03k|        let buf = &mut g.buf[g.len..];
   67|  6.03k|        match ready!(rd.as_mut().poll_read(cx, buf)) {
   68|  2.93k|            Ok(0) => return Poll::Ready(Ok(g.len - start_len)),
   69|  3.09k|            Ok(n) => {
   70|  3.09k|                // We can't allow bogus values from read. If it is too large, the returned vec could have its length
   71|  3.09k|                // set past its capacity, or if it overflows the vec could be shortened which could create an invalid
   72|  3.09k|                // string if this is called via read_to_string.
   73|  3.09k|                assert!(n <= buf.len());
   74|  3.09k|                g.len += n;
   75|       |            }
   76|      0|            Err(e) => return Poll::Ready(Err(e)),
   77|       |        }
   78|       |    }
   79|  2.93k|}
_RNvXs1_NtNtCsll4ISZbKcbA_12futures_util2io11read_to_endINtB5_9ReadToEndINtNtB7_4take4TakeQRShEENtNtNtCsdRJjCzU6nMS_4core6future6future6Future4pollCsilvC8qPft2D_8fvm_fuzz:
   87|  2.93k|    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
   88|  2.93k|        let this = &mut *self;
   89|  2.93k|        read_to_end_internal(Pin::new(&mut this.reader), cx, this.buf, this.start_len)
   90|  2.93k|    }
_RNvMs_NtNtCsll4ISZbKcbA_12futures_util2io11read_to_endINtB4_9ReadToEndINtNtB6_4take4TakeQRShEE3newCsilvC8qPft2D_8fvm_fuzz:
   21|  2.93k|    pub(super) fn new(reader: &'a mut R, buf: &'a mut Vec<u8>) -> Self {
   22|  2.93k|        let start_len = buf.len();
   23|  2.93k|        Self { reader, buf, start_len }
   24|  2.93k|    }
_RNvXs0_NtNtCsll4ISZbKcbA_12futures_util2io11read_to_endNtB5_5GuardNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
   33|  2.93k|    fn drop(&mut self) {
   34|  2.93k|        unsafe {
   35|  2.93k|            self.buf.set_len(self.len);
   36|  2.93k|        }
   37|  2.93k|    }

_RNvMNtNtCsll4ISZbKcbA_12futures_util2io4takeINtB2_4TakeQRShE3newCsilvC8qPft2D_8fvm_fuzz:
   20|  2.93k|    pub(super) fn new(inner: R, limit: u64) -> Self {
   21|  2.93k|        Self { inner, limit }
   22|  2.93k|    }
_RNvXs_NtNtCsll4ISZbKcbA_12futures_util2io4takeINtB4_4TakeQRShENtNtCse0WcpsHYUGS_10futures_io6if_std9AsyncRead9poll_readCsilvC8qPft2D_8fvm_fuzz:
   85|  6.03k|    fn poll_read(
   86|  6.03k|        self: Pin<&mut Self>,
   87|  6.03k|        cx: &mut Context<'_>,
   88|  6.03k|        buf: &mut [u8],
   89|  6.03k|    ) -> Poll<Result<usize, io::Error>> {
   90|  6.03k|        let this = self.project();
   91|  6.03k|
   92|  6.03k|        if *this.limit == 0 {
   93|  2.93k|            return Poll::Ready(Ok(0));
   94|  3.09k|        }
   95|  3.09k|
   96|  3.09k|        let max = cmp::min(buf.len() as u64, *this.limit) as usize;
   97|  3.09k|        let n = ready!(this.inner.poll_read(cx, &mut buf[..max]))?;
   98|  3.09k|        *this.limit -= n as u64;
   99|  3.09k|        Poll::Ready(Ok(n))
  100|  6.03k|    }

_RNCNvXNtCscr71fdudY79_13generic_array5implsINtB6_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2e_2B0EB2s_EB2s_EB2s_EB2s_EENtNtCsdRJjCzU6nMS_4core7default7Default7default0Cs4ieSHZHrxF6_15direct_syscalls:
   17|  31.2k|        Self::generate(|_| T::default())
_RNvXNtCscr71fdudY79_13generic_array5implsINtB4_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBZ_IBZ_IBZ_IBZ_IBZ_IBZ_NtB11_5UTermNtNtB13_3bit2B1ENtB2b_2B0EB2p_EB2p_EB2p_EB2p_EB2p_EENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCs4ieSHZHrxF6_15direct_syscalls:
   16|    489|    fn default() -> Self {
   17|    489|        Self::generate(|_| T::default())
   18|    489|    }
_RNCNvXNtCscr71fdudY79_13generic_array5implsINtB6_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2j_2B0EB2x_EB2x_EB2x_EB2x_EB2x_EENtNtCsdRJjCzU6nMS_4core7default7Default7default0Cs4ieSHZHrxF6_15direct_syscalls:
   17|  31.2k|        Self::generate(|_| T::default())
_RNvXNtCscr71fdudY79_13generic_array5implsINtB4_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBZ_IBZ_IBZ_IBZ_IBZ_NtB11_5UTermNtNtB13_3bit2B1ENtB27_2B0EB2l_EB2l_EB2l_EB2l_EENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCs4ieSHZHrxF6_15direct_syscalls:
   16|    978|    fn default() -> Self {
   17|    978|        Self::generate(|_| T::default())
   18|    978|    }
_RNvXs3c_NtCscr71fdudY79_13generic_array5implsAhj20_INtNtCsdRJjCzU6nMS_4core7convert4FromINtB8_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB1K_IB1K_IB1K_IB1K_IB1K_NtB1M_5UTermNtNtB1O_3bit2B1ENtB2X_2B0EB3b_EB3b_EB3b_EB3b_EEE4fromCs4ieSHZHrxF6_15direct_syscalls:
  139|    489|                fn from(sel: GenericArray<T, $ty>) -> [T; $n] {
  140|    489|                    unsafe { $crate::transmute(sel) }
  141|    489|                }

_RINvXsg_Cscr71fdudY79_13generic_arrayINtB6_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBV_IBV_IBV_IBV_IBV_IBV_NtBX_5UTermNtNtBZ_3bit2B1ENtB26_2B0EB2j_EB2j_EB2j_EB2j_EB2j_EEINtNtB6_8sequence15GenericSequencehE8generateNCNvXNtB6_5implsBz_NtNtCsdRJjCzU6nMS_4core7default7Default7default0ECs4ieSHZHrxF6_15direct_syscalls:
  379|    489|    fn generate<F>(mut f: F) -> GenericArray<T, N>
  380|    489|    where
  381|    489|        F: FnMut(usize) -> T,
  382|    489|    {
  383|    489|        unsafe {
  384|    489|            let mut destination = ArrayBuilder::new();
  385|    489|
  386|    489|            {
  387|    489|                let (destination_iter, position) = destination.iter_position();
  388|    489|
  389|    489|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|       |                    ptr::write(dst, f(i));
  391|       |
  392|       |                    *position += 1;
  393|    489|                });
  394|    489|            }
  395|    489|
  396|    489|            destination.into_inner()
  397|    489|        }
  398|    489|    }
_RNvXs8_Cscr71fdudY79_13generic_arrayINtB5_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EENtNtNtCsdRJjCzU6nMS_4core3ops5deref8DerefMut9deref_mutCs4ieSHZHrxF6_15direct_syscalls:
  202|  1.95k|    fn deref_mut(&mut self) -> &mut [T] {
  203|  1.95k|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|  1.95k|    }
_RNvMs9_Cscr71fdudY79_13generic_arrayINtB5_12ArrayBuilderhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE13iter_positionCs4ieSHZHrxF6_15direct_syscalls:
  234|    978|    pub unsafe fn iter_position(&mut self) -> (slice::IterMut<T>, &mut usize) {
  235|    978|        ((&mut *self.array.as_mut_ptr()).iter_mut(), &mut self.position)
  236|    978|    }
_RNvMs9_Cscr71fdudY79_13generic_arrayINtB5_12ArrayBuilderhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE3newCs4ieSHZHrxF6_15direct_syscalls:
  221|    978|    pub unsafe fn new() -> ArrayBuilder<T, N> {
  222|    978|        ArrayBuilder {
  223|    978|            array: MaybeUninit::uninit(),
  224|    978|            position: 0,
  225|    978|        }
  226|    978|    }
_RNCINvXsg_Cscr71fdudY79_13generic_arrayINtB8_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBX_IBX_IBX_IBX_IBX_NtBZ_5UTermNtNtB11_3bit2B1ENtB24_2B0EB2i_EB2i_EB2i_EB2i_EEINtNtB8_8sequence15GenericSequencehE8generateNCNvXNtB8_5implsBB_NtNtCsdRJjCzU6nMS_4core7default7Default7default0E0Cs4ieSHZHrxF6_15direct_syscalls:
  389|  31.2k|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|  31.2k|                    ptr::write(dst, f(i));
  391|  31.2k|
  392|  31.2k|                    *position += 1;
  393|  31.2k|                });
_RNvMs9_Cscr71fdudY79_13generic_arrayINtB5_12ArrayBuilderhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE10into_innerCs4ieSHZHrxF6_15direct_syscalls:
  242|    978|    pub unsafe fn into_inner(self) -> GenericArray<T, N> {
  243|    978|        let array = ptr::read(&self.array);
  244|    978|
  245|    978|        mem::forget(self);
  246|    978|
  247|    978|        array.assume_init()
  248|    978|    }
_RNvXs7_Cscr71fdudY79_13generic_arrayINtB5_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EENtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5derefCs4ieSHZHrxF6_15direct_syscalls:
  192|  1.46k|    fn deref(&self) -> &[T] {
  193|  1.46k|        unsafe { slice::from_raw_parts(self as *const Self as *const T, N::USIZE) }
  194|  1.46k|    }
_RINvCscr71fdudY79_13generic_array9transmuteINtB2_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2e_2B0EB2s_EB2s_EB2s_EB2s_EEAhj20_ECs4ieSHZHrxF6_15direct_syscalls:
  642|    489|pub unsafe fn transmute<A, B>(a: A) -> B {
  643|    489|    let a = ManuallyDrop::new(a);
  644|    489|    ::core::ptr::read(&*a as *const A as *const B)
  645|    489|}
_RNvMs9_Cscr71fdudY79_13generic_arrayINtB5_12ArrayBuilderhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE3newCs4ieSHZHrxF6_15direct_syscalls:
  221|    489|    pub unsafe fn new() -> ArrayBuilder<T, N> {
  222|    489|        ArrayBuilder {
  223|    489|            array: MaybeUninit::uninit(),
  224|    489|            position: 0,
  225|    489|        }
  226|    489|    }
_RNvMs9_Cscr71fdudY79_13generic_arrayINtB5_12ArrayBuilderhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE10into_innerCs4ieSHZHrxF6_15direct_syscalls:
  242|    489|    pub unsafe fn into_inner(self) -> GenericArray<T, N> {
  243|    489|        let array = ptr::read(&self.array);
  244|    489|
  245|    489|        mem::forget(self);
  246|    489|
  247|    489|        array.assume_init()
  248|    489|    }
_RNCINvXsg_Cscr71fdudY79_13generic_arrayINtB8_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBX_IBX_IBX_IBX_IBX_IBX_NtBZ_5UTermNtNtB11_3bit2B1ENtB28_2B0EB2m_EB2m_EB2m_EB2m_EB2m_EEINtNtB8_8sequence15GenericSequencehE8generateNCNvXNtB8_5implsBB_NtNtCsdRJjCzU6nMS_4core7default7Default7default0E0Cs4ieSHZHrxF6_15direct_syscalls:
  389|  31.2k|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|  31.2k|                    ptr::write(dst, f(i));
  391|  31.2k|
  392|  31.2k|                    *position += 1;
  393|  31.2k|                });
_RNvXs8_Cscr71fdudY79_13generic_arrayINtB5_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EENtNtNtCsdRJjCzU6nMS_4core3ops5deref8DerefMut9deref_mutCs4ieSHZHrxF6_15direct_syscalls:
  202|  1.95k|    fn deref_mut(&mut self) -> &mut [T] {
  203|  1.95k|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|  1.95k|    }
_RNvMs9_Cscr71fdudY79_13generic_arrayINtB5_12ArrayBuilderhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE13iter_positionCs4ieSHZHrxF6_15direct_syscalls:
  234|    489|    pub unsafe fn iter_position(&mut self) -> (slice::IterMut<T>, &mut usize) {
  235|    489|        ((&mut *self.array.as_mut_ptr()).iter_mut(), &mut self.position)
  236|    489|    }
_RINvXsg_Cscr71fdudY79_13generic_arrayINtB6_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBV_IBV_IBV_IBV_IBV_NtBX_5UTermNtNtBZ_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EEINtNtB6_8sequence15GenericSequencehE8generateNCNvXNtB6_5implsBz_NtNtCsdRJjCzU6nMS_4core7default7Default7default0ECs4ieSHZHrxF6_15direct_syscalls:
  379|    978|    fn generate<F>(mut f: F) -> GenericArray<T, N>
  380|    978|    where
  381|    978|        F: FnMut(usize) -> T,
  382|    978|    {
  383|    978|        unsafe {
  384|    978|            let mut destination = ArrayBuilder::new();
  385|    978|
  386|    978|            {
  387|    978|                let (destination_iter, position) = destination.iter_position();
  388|    978|
  389|    978|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|       |                    ptr::write(dst, f(i));
  391|       |
  392|       |                    *position += 1;
  393|    978|                });
  394|    978|            }
  395|    978|
  396|    978|            destination.into_inner()
  397|    978|        }
  398|    978|    }
_RNvXs8_Cscr71fdudY79_13generic_arrayINtB5_12GenericArrayhINtNtCs9bmGGqyhwTa_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EENtNtNtCsdRJjCzU6nMS_4core3ops5deref8DerefMut9deref_mutCs6zZxOXcsMaf_13fvm_ipld_hamt:
  202|    489|    fn deref_mut(&mut self) -> &mut [T] {
  203|    489|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|    489|    }

_RNvCseVusAHRTHxo_9getrandom9getrandom:
  286|      1|pub fn getrandom(dest: &mut [u8]) -> Result<(), Error> {
  287|      1|    if dest.is_empty() {
  288|      0|        return Ok(());
  289|      1|    }
  290|      1|    imp::getrandom_inner(dest)
  291|      1|}

_RNCNvNtCseVusAHRTHxo_9getrandom3imp15getrandom_inner0B5_:
   20|      1|        sys_fill_exact(dest, |buf| unsafe {
   21|      1|            getrandom(buf.as_mut_ptr() as *mut libc::c_void, buf.len(), 0)
   22|      1|        })
_RNvNtCseVusAHRTHxo_9getrandom3imp22is_getrandom_available:
   28|      1|fn is_getrandom_available() -> bool {
   29|      1|    let res = unsafe { getrandom(core::ptr::null_mut(), 0, libc::GRND_NONBLOCK) };
   30|      1|    if res < 0 {
   31|      0|        match last_os_error().raw_os_error() {
   32|      0|            Some(libc::ENOSYS) => false, // No kernel support
   33|      0|            Some(libc::EPERM) => false,  // Blocked by seccomp
   34|      0|            _ => true,
   35|       |        }
   36|       |    } else {
   37|      1|        true
   38|       |    }
   39|      1|}
_RNvNtCseVusAHRTHxo_9getrandom3imp15getrandom_inner:
   16|      1|pub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {
   17|      1|    // getrandom(2) was introduced in Linux 3.17
   18|      1|    static HAS_GETRANDOM: LazyBool = LazyBool::new();
   19|      1|    if HAS_GETRANDOM.unsync_init(is_getrandom_available) {
   20|      1|        sys_fill_exact(dest, |buf| unsafe {
   21|       |            getrandom(buf.as_mut_ptr() as *mut libc::c_void, buf.len(), 0)
   22|      1|        })
   23|       |    } else {
   24|      0|        use_file::getrandom_inner(dest)
   25|       |    }
   26|      1|}
_RNvNtCseVusAHRTHxo_9getrandom3imp9getrandom:
   41|      2|unsafe fn getrandom(
   42|      2|    buf: *mut libc::c_void,
   43|      2|    buflen: libc::size_t,
   44|      2|    flags: libc::c_uint,
   45|      2|) -> libc::ssize_t {
   46|      2|    libc::syscall(libc::SYS_getrandom, buf, buflen, flags) as libc::ssize_t
   47|      2|}

_RNCINvMs_NtCseVusAHRTHxo_9getrandom4utilNtB7_8LazyBool11unsync_initNvNtB9_3imp22is_getrandom_availableE0B9_:
   62|      1|        self.0.unsync_init(|| init() as usize) != 0
_RINvMs_NtCseVusAHRTHxo_9getrandom4utilNtB5_8LazyBool11unsync_initNvNtB7_3imp22is_getrandom_availableEB7_:
   61|      1|    pub fn unsync_init(&self, init: impl FnOnce() -> bool) -> bool {
   62|      1|        self.0.unsync_init(|| init() as usize) != 0
   63|      1|    }
_RINvMNtCseVusAHRTHxo_9getrandom4utilNtB3_9LazyUsize11unsync_initNCINvMs_B3_NtB3_8LazyBool11unsync_initNvNtB5_3imp22is_getrandom_availableE0EB5_:
   42|      1|    pub fn unsync_init(&self, init: impl FnOnce() -> usize) -> usize {
   43|      1|        // Relaxed ordering is fine, as we only have a single atomic variable.
   44|      1|        let mut val = self.0.load(Relaxed);
   45|      1|        if val == Self::UNINIT {
   46|      1|            val = init();
   47|      1|            self.0.store(val, Relaxed);
   48|      1|        }
   49|      1|        val
   50|      1|    }

_RINvNtCseVusAHRTHxo_9getrandom9util_libc14sys_fill_exactNCNvNtB4_3imp15getrandom_inner0EB4_:
   61|      1|pub fn sys_fill_exact(
   62|      1|    mut buf: &mut [u8],
   63|      1|    sys_fill: impl Fn(&mut [u8]) -> libc::ssize_t,
   64|      1|) -> Result<(), Error> {
   65|      2|    while !buf.is_empty() {
   66|      1|        let res = sys_fill(buf);
   67|      1|        if res < 0 {
   68|      0|            let err = last_os_error();
   69|      0|            // We should try again if the call was interrupted.
   70|      0|            if err.raw_os_error() != Some(libc::EINTR) {
   71|      0|                return Err(err);
   72|      0|            }
   73|      1|        } else {
   74|      1|            // We don't check for EOF (ret = 0) as the data we are reading
   75|      1|            // should be an infinite stream of random bytes.
   76|      1|            buf = &mut buf[(res as usize)..];
   77|      1|        }
   78|       |    }
   79|      1|    Ok(())
   80|      1|}

_RNvXNtNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner5alloc5innerNtB2_6GlobalNtB2_9Allocator10deallocate:
   50|    652|        unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
   51|    652|            dealloc(ptr.as_ptr(), layout);
   52|    652|        }
_RNvXNtNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner5alloc5innerNtB2_6GlobalNtB2_9Allocator8allocate:
   46|    652|        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {
   47|    652|            unsafe { NonNull::new(alloc(layout)).ok_or(()) }
   48|    652|        }
_RNvXs1_NtNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner5alloc5innerNtB5_6GlobalNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   42|    652|    #[derive(Copy, Clone)]
_RINvNtNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner5alloc5inner8do_allocNtB2_6GlobalECscE26HxwD491_8wasmtime:
   61|    652|    pub fn do_alloc<A: Allocator>(alloc: &A, layout: Layout) -> Result<NonNull<u8>, ()> {
   62|    652|        alloc.allocate(layout)
   63|    652|    }

_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner7bitmaskNtB2_7BitMask22lowest_set_bit_nonzero:
   73|  1.30k|    pub unsafe fn lowest_set_bit_nonzero(self) -> usize {
   74|  1.30k|        self.trailing_zeros()
   75|  1.30k|    }
_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner7bitmaskNtB2_7BitMask14lowest_set_bit:
   56|  1.95k|    pub fn lowest_set_bit(self) -> Option<usize> {
   57|  1.95k|        if self.0 == 0 {
   58|    652|            None
   59|       |        } else {
   60|  1.30k|            Some(unsafe { self.lowest_set_bit_nonzero() })
   61|       |        }
   62|  1.95k|    }
_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner7bitmaskNtB2_7BitMask14trailing_zeros:
   79|  1.30k|    pub fn trailing_zeros(self) -> usize {
   80|       |        // ARM doesn't have a trailing_zeroes instruction, and instead uses
   81|       |        // reverse_bits (RBIT) + leading_zeroes (CLZ). However older ARM
   82|       |        // versions (pre-ARMv7) don't have RBIT and need to emulate it
   83|       |        // instead. Since we only have 1 bit set in each byte on ARM, we can
   84|       |        // use swap_bytes (REV) + leading_zeroes instead.
   85|      0|        if cfg!(target_arch = "arm") && BITMASK_STRIDE % 8 == 0 {
   86|      0|            self.0.swap_bytes().leading_zeros() as usize / BITMASK_STRIDE
   87|       |        } else {
   88|  1.30k|            self.0.trailing_zeros() as usize / BITMASK_STRIDE
   89|       |        }
   90|  1.30k|    }
_RNvXs0_NtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner7bitmaskNtB5_11BitMaskIterNtNtNtNtCsdRJjCzU6nMS_4core4iter6traits8iterator8Iterator4next:
  117|    652|    fn next(&mut self) -> Option<usize> {
  118|    652|        let bit = self.0.lowest_set_bit()?;
  119|      0|        self.0 = self.0.remove_lowest_bit();
  120|      0|        Some(bit)
  121|    652|    }
_RNvXs_NtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner7bitmaskNtB4_7BitMaskNtNtNtNtCsdRJjCzU6nMS_4core4iter6traits7collect12IntoIterator9into_iter:
  104|    652|    fn into_iter(self) -> BitMaskIter {
  105|    652|        BitMaskIter(self)
  106|    652|    }
_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner7bitmaskNtB2_7BitMask11any_bit_set:
   50|    652|    pub fn any_bit_set(self) -> bool {
   51|    652|        self.0 != 0
   52|    652|    }

_RNvMs0_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerNtB5_11TableLayout20calculate_layout_for:
  242|  1.30k|    fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {
  243|  1.30k|        debug_assert!(buckets.is_power_of_two());
  244|       |
  245|  1.30k|        let TableLayout { size, ctrl_align } = self;
  246|       |        // Manual layout calculation since Layout methods are not yet stable.
  247|  1.30k|        let ctrl_offset =
  248|  1.30k|            size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);
  249|  1.30k|        let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;
  250|       |
  251|  1.30k|        Some((
  252|  1.30k|            unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },
  253|  1.30k|            ctrl_offset,
  254|  1.30k|        ))
  255|  1.30k|    }
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner23bucket_mask_to_capacity:
  212|  1.30k|fn bucket_mask_to_capacity(bucket_mask: usize) -> usize {
  213|  1.30k|    if bucket_mask < 8 {
  214|       |        // For tables with 1/2/4/8 buckets, we always reserve one empty slot.
  215|       |        // Keep in mind that the bucket mask is one less than the bucket count.
  216|  1.30k|        bucket_mask
  217|       |    } else {
  218|       |        // For larger tables we reserve 12.5% of the slots as empty.
  219|      0|        ((bucket_mask + 1) / 8) * 7
  220|       |    }
  221|  1.30k|}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner19capacity_to_buckets:
  185|    652|fn capacity_to_buckets(cap: usize) -> Option<usize> {
  186|    652|    debug_assert_ne!(cap, 0);
  187|       |
  188|       |    // For small tables we require at least 1 empty bucket so that lookups are
  189|       |    // guaranteed to terminate if an element doesn't exist in the table.
  190|    652|    if cap < 8 {
  191|       |        // We don't bother with a table size of 2 buckets since that can only
  192|       |        // hold a single element. Instead we skip directly to a 4 bucket table
  193|       |        // which can hold 3 elements.
  194|    652|        return Some(if cap < 4 { 4 } else { 8 });
  195|      0|    }
  196|       |
  197|       |    // Otherwise require 1/8 buckets to be empty (87.5% load)
  198|       |    //
  199|       |    // Be careful when modifying this, calculate_layout relies on the
  200|       |    // overflow check here.
  201|      0|    let adjusted_cap = cap.checked_mul(8)? / 7;
  202|       |
  203|       |    // Any overflows will have been caught by the checked_mul. Also, any
  204|       |    // rounding errors from the division above will be cleaned up by
  205|       |    // next_power_of_two (which can't overflow because of the previous division).
  206|      0|    Some(adjusted_cap.next_power_of_two())
  207|    652|}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner2h1:
  132|  1.95k|fn h1(hash: u64) -> usize {
  133|  1.95k|    // On 32-bit platforms we simply ignore the higher hash bits.
  134|  1.95k|    hash as usize
  135|  1.95k|}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner2h2:
  140|  1.30k|fn h2(hash: u64) -> u8 {
  141|  1.30k|    // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit
  142|  1.30k|    // value, some hash functions (such as FxHash) produce a usize result
  143|  1.30k|    // instead, which means that the top 32 bits are 0 on 32-bit platforms.
  144|  1.30k|    let hash_len = usize::min(mem::size_of::<usize>(), mem::size_of::<u64>());
  145|  1.30k|    let top7 = hash >> (hash_len * 8 - 7);
  146|  1.30k|    (top7 & 0x7f) as u8 // truncation
  147|  1.30k|}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner6likely:
   57|    652|fn likely(b: bool) -> bool {
   58|    652|    if !b {
   59|      0|        cold();
   60|    652|    }
   61|    652|    b
   62|    652|}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner4cold:
   53|    652|fn cold() {}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner8unlikely:
   65|  1.95k|fn unlikely(b: bool) -> bool {
   66|  1.95k|    if b {
   67|    652|        cold();
   68|  1.30k|    }
   69|  1.95k|    b
   70|  1.95k|}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner10is_special:
  118|  1.30k|fn is_special(ctrl: u8) -> bool {
  119|  1.30k|    ctrl & 0x80 != 0
  120|  1.30k|}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner7is_full:
  112|  1.95k|fn is_full(ctrl: u8) -> bool {
  113|  1.95k|    ctrl & 0x80 == 0
  114|  1.95k|}
_RNvNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner16special_is_empty:
  124|  1.30k|fn special_is_empty(ctrl: u8) -> bool {
  125|  1.30k|    debug_assert!(is_special(ctrl));
  126|  1.30k|    ctrl & 0x01 != 0
  127|  1.30k|}
_RNvMs8_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE6new_inCsheoVkkQew6K_3fvm:
 1043|    326|    const fn new_in(alloc: A) -> Self {
 1044|    326|        Self {
 1045|    326|            // Be careful to cast the entire slice to a raw pointer.
 1046|    326|            ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
 1047|    326|            bucket_mask: 0,
 1048|    326|            items: 0,
 1049|    326|            growth_left: 0,
 1050|    326|            alloc,
 1051|    326|        }
 1052|    326|    }
_RNvMs4_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejE3newCsheoVkkQew6K_3fvm:
  394|    326|    pub const fn new() -> Self {
  395|    326|        Self {
  396|    326|            table: RawTableInner::new_in(Global),
  397|    326|            marker: PhantomData,
  398|    326|        }
  399|    326|    }
_RINvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB6_8RawTablejE7reserveNCINvNtNtCs3F2gpvdZd7c_8indexmap3map4core8get_hashNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE0ECscE26HxwD491_8wasmtime:
  643|    652|    pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {
  644|    652|        if additional > self.table.growth_left {
  645|       |            // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
  646|    652|            if self
  647|    652|                .reserve_rehash(additional, hasher, Fallibility::Infallible)
  648|    652|                .is_err()
  649|       |            {
  650|      0|                unsafe { hint::unreachable_unchecked() }
  651|    652|            }
  652|      0|        }
  653|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE17new_uninitializedCscE26HxwD491_8wasmtime:
 1057|    652|    unsafe fn new_uninitialized(
 1058|    652|        alloc: A,
 1059|    652|        table_layout: TableLayout,
 1060|    652|        buckets: usize,
 1061|    652|        fallibility: Fallibility,
 1062|    652|    ) -> Result<Self, TryReserveError> {
 1063|    652|        debug_assert!(buckets.is_power_of_two());
 1064|       |
 1065|       |        // Avoid `Option::ok_or_else` because it bloats LLVM IR.
 1066|    652|        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(buckets) {
 1067|    652|            Some(lco) => lco,
 1068|      0|            None => return Err(fallibility.capacity_overflow()),
 1069|       |        };
 1070|       |
 1071|       |        // We need an additional check to ensure that the allocation doesn't
 1072|       |        // exceed `isize::MAX`. We can skip this check on 64-bit systems since
 1073|       |        // such allocations will never succeed anyways.
 1074|       |        //
 1075|       |        // This mirrors what Vec does in the standard library.
 1076|    652|        if mem::size_of::<usize>() < 8 && layout.size() > isize::MAX as usize {
 1077|      0|            return Err(fallibility.capacity_overflow());
 1078|    652|        }
 1079|       |
 1080|    652|        let ptr: NonNull<u8> = match do_alloc(&alloc, layout) {
 1081|    652|            Ok(block) => block.cast(),
 1082|      0|            Err(_) => return Err(fallibility.alloc_err(layout)),
 1083|       |        };
 1084|       |
 1085|    652|        let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));
 1086|    652|        Ok(Self {
 1087|    652|            ctrl,
 1088|    652|            bucket_mask: buckets - 1,
 1089|    652|            items: 0,
 1090|    652|            growth_left: bucket_mask_to_capacity(buckets - 1),
 1091|    652|            alloc,
 1092|    652|        })
 1093|    652|    }
_RNvMs3_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_6BucketjE6as_ptrCscE26HxwD491_8wasmtime:
  314|    652|    pub fn as_ptr(&self) -> *mut T {
  315|    652|        if mem::size_of::<T>() == 0 {
  316|       |            // Just return an arbitrary ZST pointer which is properly aligned
  317|      0|            mem::align_of::<T>() as *mut T
  318|       |        } else {
  319|    652|            unsafe { self.ptr.as_ptr().sub(1) }
  320|       |        }
  321|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE9probe_seqCscE26HxwD491_8wasmtime:
 1241|  1.95k|    fn probe_seq(&self, hash: u64) -> ProbeSeq {
 1242|  1.95k|        ProbeSeq {
 1243|  1.95k|            pos: h1(hash) & self.bucket_mask,
 1244|  1.95k|            stride: 0,
 1245|  1.95k|        }
 1246|  1.95k|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE8set_ctrlCscE26HxwD491_8wasmtime:
 1295|    652|    unsafe fn set_ctrl(&self, index: usize, ctrl: u8) {
 1296|    652|        // Replicate the first Group::WIDTH control bytes at the end of
 1297|    652|        // the array without using a branch:
 1298|    652|        // - If index >= Group::WIDTH then index == index2.
 1299|    652|        // - Otherwise index2 == self.bucket_mask + 1 + index.
 1300|    652|        //
 1301|    652|        // The very last replicated control byte is never actually read because
 1302|    652|        // we mask the initial index for unaligned loads, but we write it
 1303|    652|        // anyways because it makes the set_ctrl implementation simpler.
 1304|    652|        //
 1305|    652|        // If there are fewer buckets than Group::WIDTH then this code will
 1306|    652|        // replicate the buckets at the end of the trailing group. For example
 1307|    652|        // with 2 buckets and a group size of 4, the control bytes will look
 1308|    652|        // like this:
 1309|    652|        //
 1310|    652|        //     Real    |             Replicated
 1311|    652|        // ---------------------------------------------
 1312|    652|        // | [A] | [B] | [EMPTY] | [EMPTY] | [A] | [B] |
 1313|    652|        // ---------------------------------------------
 1314|    652|        let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;
 1315|    652|
 1316|    652|        *self.ctrl(index) = ctrl;
 1317|    652|        *self.ctrl(index2) = ctrl;
 1318|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE12free_bucketsCscE26HxwD491_8wasmtime:
 1549|    652|    unsafe fn free_buckets(&mut self, table_layout: TableLayout) {
 1550|       |        // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
 1551|    652|        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {
 1552|    652|            Some(lco) => lco,
 1553|      0|            None => hint::unreachable_unchecked(),
 1554|       |        };
 1555|    652|        self.alloc.deallocate(
 1556|    652|            NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)),
 1557|    652|            layout,
 1558|    652|        );
 1559|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE11set_ctrl_h2CscE26HxwD491_8wasmtime:
 1281|    652|    unsafe fn set_ctrl_h2(&self, index: usize, hash: u64) {
 1282|    652|        self.set_ctrl(index, h2(hash));
 1283|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE14num_ctrl_bytesCscE26HxwD491_8wasmtime:
 1333|  7.17k|    fn num_ctrl_bytes(&self) -> usize {
 1334|  7.17k|        self.bucket_mask + 1 + Group::WIDTH
 1335|  7.17k|    }
_RINvMs0_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerNtB6_11TableLayout3newjECscE26HxwD491_8wasmtime:
  233|  1.30k|    fn new<T>() -> Self {
  234|  1.30k|        let layout = Layout::new::<T>();
  235|  1.30k|        Self {
  236|  1.30k|            size: layout.size(),
  237|  1.30k|            ctrl_align: usize::max(layout.align(), Group::WIDTH),
  238|  1.30k|        }
  239|  1.30k|    }
_RNvXse_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejENtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4dropCscE26HxwD491_8wasmtime:
 1815|    978|    fn drop(&mut self) {
 1816|    978|        if !self.table.is_empty_singleton() {
 1817|    652|            unsafe {
 1818|    652|                self.drop_elements();
 1819|    652|                self.free_buckets();
 1820|    652|            }
 1821|    326|        }
 1822|    978|    }
_RNvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejE7bucketsCscE26HxwD491_8wasmtime:
  927|    652|    pub fn buckets(&self) -> usize {
  928|    652|        self.table.bucket_mask + 1
  929|    652|    }
_RINvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB6_8RawTablejE3getNCINvNtNtCs3F2gpvdZd7c_8indexmap3map4core10equivalentNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexB1U_E0ECscE26HxwD491_8wasmtime:
  829|    652|    pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {
  830|    652|        // Avoid `Option::map` because it bloats LLVM IR.
  831|    652|        match self.find(hash, eq) {
  832|      0|            Some(bucket) => Some(unsafe { bucket.as_ref() }),
  833|    652|            None => None,
  834|       |        }
  835|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE4ctrlCscE26HxwD491_8wasmtime:
 1322|  6.52k|    unsafe fn ctrl(&self, index: usize) -> *mut u8 {
 1323|  6.52k|        debug_assert!(index < self.num_ctrl_bytes());
 1324|  6.52k|        self.ctrl.as_ptr().add(index)
 1325|  6.52k|    }
_RINvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB6_8RawTablejE14reserve_rehashNCINvNtNtCs3F2gpvdZd7c_8indexmap3map4core8get_hashNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE0ECscE26HxwD491_8wasmtime:
  681|    652|                additional,
  682|    652|                &|table, index| hasher(table.bucket::<T>(index).as_ref()),
  683|    652|                fallibility,
  684|    652|                TableLayout::new::<T>(),
  685|    652|                if mem::needs_drop::<T>() {
  686|      0|                    Some(mem::transmute(ptr::drop_in_place::<T> as unsafe fn(*mut T)))
  687|       |                } else {
  688|    652|                    None
  689|       |                },
  690|       |            )
  691|       |        }
  692|    652|    }
_RNvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejE13drop_elementsCscE26HxwD491_8wasmtime:
  595|    652|    unsafe fn drop_elements(&mut self) {
  596|    652|        if mem::needs_drop::<T>() && !self.is_empty() {
  597|      0|            for item in self.iter() {
  598|      0|                item.drop();
  599|      0|            }
  600|    652|        }
  601|    652|    }
_RINvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB6_8RawTablejE4findNCINvNtNtCs3F2gpvdZd7c_8indexmap3map4core10equivalentNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexB1V_E0ECscE26HxwD491_8wasmtime:
  815|    652|    pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {
  816|    652|        let result = self.table.find_inner(hash, &mut |index| unsafe {
  817|       |            eq(self.bucket(index).as_ref())
  818|    652|        });
  819|    652|
  820|    652|        // Avoid `Option::map` because it bloats LLVM IR.
  821|    652|        match result {
  822|      0|            Some(index) => Some(unsafe { self.bucket(index) }),
  823|    652|            None => None,
  824|       |        }
  825|    652|    }
_RINvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB6_8RawTablejE6insertNCINvNtNtCs3F2gpvdZd7c_8indexmap3map4core8get_hashNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE0ECscE26HxwD491_8wasmtime:
  716|    652|    pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {
  717|    652|        unsafe {
  718|    652|            let mut index = self.table.find_insert_slot(hash);
  719|    652|
  720|    652|            // We can avoid growing the table once we have reached our load
  721|    652|            // factor if we are replacing a tombstone. This works since the
  722|    652|            // number of EMPTY slots does not change in this case.
  723|    652|            let old_ctrl = *self.table.ctrl(index);
  724|    652|            if unlikely(self.table.growth_left == 0 && special_is_empty(old_ctrl)) {
  725|    652|                self.reserve(1, hasher);
  726|    652|                index = self.table.find_insert_slot(hash);
  727|    652|            }
  728|       |
  729|    652|            self.table.record_item_insert_at(index, old_ctrl, hash);
  730|    652|
  731|    652|            let bucket = self.bucket(index);
  732|    652|            bucket.write(value);
  733|    652|            bucket
  734|    652|        }
  735|    652|    }
_RNCNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB7_13RawTableInnerNtNtNtB7_5alloc5inner6GlobalE14prepare_resize0CscE26HxwD491_8wasmtime:
 1368|    652|        Ok(guard(new_table, move |self_| {
 1369|    652|            if !self_.is_empty_singleton() {
 1370|      0|                self_.free_buckets(table_layout);
 1371|    652|            }
 1372|    652|        }))
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE10find_innerCscE26HxwD491_8wasmtime:
 1169|    652|    fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {
 1170|    652|        let h2_hash = h2(hash);
 1171|    652|        let mut probe_seq = self.probe_seq(hash);
 1172|       |
 1173|       |        loop {
 1174|    652|            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
 1175|       |
 1176|    652|            for bit in group.match_byte(h2_hash) {
 1177|      0|                let index = (probe_seq.pos + bit) & self.bucket_mask;
 1178|      0|
 1179|      0|                if likely(eq(index)) {
 1180|      0|                    return Some(index);
 1181|      0|                }
 1182|       |            }
 1183|       |
 1184|    652|            if likely(group.match_empty().any_bit_set()) {
 1185|    652|                return None;
 1186|      0|            }
 1187|      0|
 1188|      0|            probe_seq.move_next(self.bucket_mask);
 1189|       |        }
 1190|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE16find_insert_slotCscE26HxwD491_8wasmtime:
 1134|  1.30k|    fn find_insert_slot(&self, hash: u64) -> usize {
 1135|  1.30k|        let mut probe_seq = self.probe_seq(hash);
 1136|       |        loop {
 1137|       |            unsafe {
 1138|  1.30k|                let group = Group::load(self.ctrl(probe_seq.pos));
 1139|  1.30k|                if let Some(bit) = group.match_empty_or_deleted().lowest_set_bit() {
 1140|  1.30k|                    let result = (probe_seq.pos + bit) & self.bucket_mask;
 1141|  1.30k|
 1142|  1.30k|                    // In tables smaller than the group width, trailing control
 1143|  1.30k|                    // bytes outside the range of the table are filled with
 1144|  1.30k|                    // EMPTY entries. These will unfortunately trigger a
 1145|  1.30k|                    // match, but once masked may point to a full bucket that
 1146|  1.30k|                    // is already occupied. We detect this situation here and
 1147|  1.30k|                    // perform a second scan starting at the beginning of the
 1148|  1.30k|                    // table. This second scan is guaranteed to find an empty
 1149|  1.30k|                    // slot (due to the load factor) before hitting the trailing
 1150|  1.30k|                    // control bytes (containing EMPTY).
 1151|  1.30k|                    if unlikely(is_full(*self.ctrl(result))) {
 1152|      0|                        debug_assert!(self.bucket_mask < Group::WIDTH);
 1153|      0|                        debug_assert_ne!(probe_seq.pos, 0);
 1154|      0|                        return Group::load_aligned(self.ctrl(0))
 1155|      0|                            .match_empty_or_deleted()
 1156|      0|                            .lowest_set_bit_nonzero();
 1157|  1.30k|                    }
 1158|  1.30k|
 1159|  1.30k|                    return result;
 1160|      0|                }
 1161|      0|            }
 1162|      0|            probe_seq.move_next(self.bucket_mask);
 1163|       |        }
 1164|  1.30k|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE18is_empty_singletonCscE26HxwD491_8wasmtime:
 1338|  1.63k|    fn is_empty_singleton(&self) -> bool {
 1339|  1.63k|        self.bucket_mask == 0
 1340|  1.63k|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE12resize_innerCscE26HxwD491_8wasmtime:
 1419|    652|    unsafe fn resize_inner(
 1420|    652|        &mut self,
 1421|    652|        capacity: usize,
 1422|    652|        hasher: &dyn Fn(&mut Self, usize) -> u64,
 1423|    652|        fallibility: Fallibility,
 1424|    652|        layout: TableLayout,
 1425|    652|    ) -> Result<(), TryReserveError> {
 1426|    652|        let mut new_table = self.prepare_resize(layout, capacity, fallibility)?;
 1427|       |
 1428|       |        // Copy all elements to the new table.
 1429|    652|        for i in 0..self.buckets() {
 1430|    652|            if !is_full(*self.ctrl(i)) {
 1431|    652|                continue;
 1432|      0|            }
 1433|      0|
 1434|      0|            // This may panic.
 1435|      0|            let hash = hasher(self, i);
 1436|      0|
 1437|      0|            // We can use a simpler version of insert() here since:
 1438|      0|            // - there are no DELETED entries.
 1439|      0|            // - we know there is enough space in the table.
 1440|      0|            // - all elements are unique.
 1441|      0|            let (index, _) = new_table.prepare_insert_slot(hash);
 1442|      0|
 1443|      0|            ptr::copy_nonoverlapping(
 1444|      0|                self.bucket_ptr(i, layout.size),
 1445|      0|                new_table.bucket_ptr(index, layout.size),
 1446|      0|                layout.size,
 1447|      0|            );
 1448|       |        }
 1449|       |
 1450|       |        // We successfully copied all elements without panicking. Now replace
 1451|       |        // self with the new table. The old table will have its memory freed but
 1452|       |        // the items will not be dropped (since they have been moved into the
 1453|       |        // new table).
 1454|    652|        mem::swap(self, &mut new_table);
 1455|    652|
 1456|    652|        Ok(())
 1457|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE20reserve_rehash_innerCscE26HxwD491_8wasmtime:
 1381|    652|    unsafe fn reserve_rehash_inner(
 1382|    652|        &mut self,
 1383|    652|        additional: usize,
 1384|    652|        hasher: &dyn Fn(&mut Self, usize) -> u64,
 1385|    652|        fallibility: Fallibility,
 1386|    652|        layout: TableLayout,
 1387|    652|        drop: Option<fn(*mut u8)>,
 1388|    652|    ) -> Result<(), TryReserveError> {
 1389|       |        // Avoid `Option::ok_or_else` because it bloats LLVM IR.
 1390|    652|        let new_items = match self.items.checked_add(additional) {
 1391|    652|            Some(new_items) => new_items,
 1392|      0|            None => return Err(fallibility.capacity_overflow()),
 1393|       |        };
 1394|    652|        let full_capacity = bucket_mask_to_capacity(self.bucket_mask);
 1395|    652|        if new_items <= full_capacity / 2 {
 1396|       |            // Rehash in-place without re-allocating if we have plenty of spare
 1397|       |            // capacity that is locked up due to DELETED entries.
 1398|      0|            self.rehash_in_place(hasher, layout.size, drop);
 1399|      0|            Ok(())
 1400|       |        } else {
 1401|       |            // Otherwise, conservatively resize to at least the next size up
 1402|       |            // to avoid churning deletes into frequent rehashes.
 1403|    652|            self.resize_inner(
 1404|    652|                usize::max(new_items, full_capacity + 1),
 1405|    652|                hasher,
 1406|    652|                fallibility,
 1407|    652|                layout,
 1408|    652|            )
 1409|       |        }
 1410|    652|    }
_RNvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejE8capacityCscE26HxwD491_8wasmtime:
  909|    652|    pub fn capacity(&self) -> usize {
  910|    652|        self.table.items + self.table.growth_left
  911|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE14prepare_resizeCscE26HxwD491_8wasmtime:
 1344|    652|    unsafe fn prepare_resize(
 1345|    652|        &self,
 1346|    652|        table_layout: TableLayout,
 1347|    652|        capacity: usize,
 1348|    652|        fallibility: Fallibility,
 1349|    652|    ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self)>, TryReserveError> {
 1350|    652|        debug_assert!(self.items <= capacity);
 1351|       |
 1352|       |        // Allocate and initialize the new table.
 1353|    652|        let mut new_table = RawTableInner::fallible_with_capacity(
 1354|    652|            self.alloc.clone(),
 1355|    652|            table_layout,
 1356|    652|            capacity,
 1357|    652|            fallibility,
 1358|    652|        )?;
 1359|    652|        new_table.growth_left -= self.items;
 1360|    652|        new_table.items = self.items;
 1361|    652|
 1362|    652|        // The hash function may panic, in which case we simply free the new
 1363|    652|        // table without dropping any elements that may have been copied into
 1364|    652|        // it.
 1365|    652|        //
 1366|    652|        // This guard is also used to free the old table on success, see
 1367|    652|        // the comment at the bottom of this function.
 1368|    652|        Ok(guard(new_table, move |self_| {
 1369|       |            if !self_.is_empty_singleton() {
 1370|       |                self_.free_buckets(table_layout);
 1371|       |            }
 1372|    652|        }))
 1373|    652|    }
_RNvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejE6bucketCscE26HxwD491_8wasmtime:
  520|    652|    pub unsafe fn bucket(&self, index: usize) -> Bucket<T> {
  521|    652|        debug_assert_ne!(self.table.bucket_mask, 0);
  522|    652|        debug_assert!(index < self.buckets());
  523|    652|        Bucket::from_base_index(self.data_end(), index)
  524|    652|    }
_RNvMs3_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_6BucketjE5writeCscE26HxwD491_8wasmtime:
  342|    652|    pub unsafe fn write(&self, val: T) {
  343|    652|        self.as_ptr().write(val);
  344|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE21record_item_insert_atCscE26HxwD491_8wasmtime:
 1264|    652|    unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: u8, hash: u64) {
 1265|    652|        self.growth_left -= usize::from(special_is_empty(old_ctrl));
 1266|    652|        self.set_ctrl_h2(index, hash);
 1267|    652|        self.items += 1;
 1268|    652|    }
_RNvMs3_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_6BucketjE15from_base_indexCscE26HxwD491_8wasmtime:
  294|    652|    unsafe fn from_base_index(base: NonNull<T>, index: usize) -> Self {
  295|    652|        let ptr = if mem::size_of::<T>() == 0 {
  296|       |            // won't overflow because index must be less than length
  297|      0|            (index + 1) as *mut T
  298|       |        } else {
  299|    652|            base.as_ptr().sub(index)
  300|       |        };
  301|    652|        Self {
  302|    652|            ptr: NonNull::new_unchecked(ptr),
  303|    652|        }
  304|    652|    }
_RNvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejE8data_endCscE26HxwD491_8wasmtime:
  501|    652|    pub unsafe fn data_end(&self) -> NonNull<T> {
  502|    652|        NonNull::new_unchecked(self.table.ctrl.as_ptr().cast())
  503|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE22fallible_with_capacityCscE26HxwD491_8wasmtime:
 1096|    652|    fn fallible_with_capacity(
 1097|    652|        alloc: A,
 1098|    652|        table_layout: TableLayout,
 1099|    652|        capacity: usize,
 1100|    652|        fallibility: Fallibility,
 1101|    652|    ) -> Result<Self, TryReserveError> {
 1102|    652|        if capacity == 0 {
 1103|      0|            Ok(Self::new_in(alloc))
 1104|       |        } else {
 1105|       |            unsafe {
 1106|    652|                let buckets =
 1107|    652|                    capacity_to_buckets(capacity).ok_or_else(|| fallibility.capacity_overflow())?;
 1108|       |
 1109|    652|                let result = Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;
 1110|    652|                result.ctrl(0).write_bytes(EMPTY, result.num_ctrl_bytes());
 1111|    652|
 1112|    652|                Ok(result)
 1113|       |            }
 1114|       |        }
 1115|    652|    }
_RNvMs5_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejE12free_bucketsCscE26HxwD491_8wasmtime:
  495|    652|    unsafe fn free_buckets(&mut self) {
  496|    652|        self.table.free_buckets(TableLayout::new::<T>());
  497|    652|    }
_RNvMs9_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE7bucketsCscE26HxwD491_8wasmtime:
 1328|  1.30k|    fn buckets(&self) -> usize {
 1329|  1.30k|        self.bucket_mask + 1
 1330|  1.30k|    }
_RNvMs4_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_8RawTablejE3newCs7L8xYe2Gdyw_16wasmtime_environ:
  394|    652|    pub const fn new() -> Self {
  395|    652|        Self {
  396|    652|            table: RawTableInner::new_in(Global),
  397|    652|            marker: PhantomData,
  398|    652|        }
  399|    652|    }
_RNvMs8_NtNtCs2Sob2MrKNwt_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE6new_inCs7L8xYe2Gdyw_16wasmtime_environ:
 1043|    652|    const fn new_in(alloc: A) -> Self {
 1044|    652|        Self {
 1045|    652|            // Be careful to cast the entire slice to a raw pointer.
 1046|    652|            ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
 1047|    652|            bucket_mask: 0,
 1048|    652|            items: 0,
 1049|    652|            growth_left: 0,
 1050|    652|            alloc,
 1051|    652|        }
 1052|    652|    }

_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner4sse2NtB2_5Group22match_empty_or_deleted:
  101|  1.30k|    pub fn match_empty_or_deleted(self) -> BitMask {
  102|  1.30k|        #[allow(
  103|  1.30k|            // byte: i32 as u16
  104|  1.30k|            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the
  105|  1.30k|            //   upper 16-bits of the i32 are zeroed:
  106|  1.30k|            clippy::cast_sign_loss,
  107|  1.30k|            clippy::cast_possible_truncation
  108|  1.30k|        )]
  109|  1.30k|        unsafe {
  110|  1.30k|            // A byte is EMPTY or DELETED iff the high bit is set
  111|  1.30k|            BitMask(x86::_mm_movemask_epi8(self.0) as u16)
  112|  1.30k|        }
  113|  1.30k|    }
_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner4sse2NtB2_5Group12static_empty:
   33|    978|    pub const fn static_empty() -> &'static [u8; Group::WIDTH] {
   34|    978|        #[repr(C)]
   35|    978|        struct AlignedBytes {
   36|    978|            _align: [Group; 0],
   37|    978|            bytes: [u8; Group::WIDTH],
   38|    978|        }
   39|    978|        const ALIGNED_BYTES: AlignedBytes = AlignedBytes {
   40|    978|            _align: [],
   41|    978|            bytes: [EMPTY; Group::WIDTH],
   42|    978|        };
   43|    978|        &ALIGNED_BYTES.bytes
   44|    978|    }
_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner4sse2NtB2_5Group4load:
   49|  1.95k|    pub unsafe fn load(ptr: *const u8) -> Self {
   50|  1.95k|        Group(x86::_mm_loadu_si128(ptr.cast()))
   51|  1.95k|    }
_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner4sse2NtB2_5Group10match_byte:
   76|  1.30k|    pub fn match_byte(self, byte: u8) -> BitMask {
   77|  1.30k|        #[allow(
   78|  1.30k|            clippy::cast_possible_wrap, // byte: u8 as i8
   79|  1.30k|            // byte: i32 as u16
   80|  1.30k|            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the
   81|  1.30k|            //   upper 16-bits of the i32 are zeroed:
   82|  1.30k|            clippy::cast_sign_loss,
   83|  1.30k|            clippy::cast_possible_truncation
   84|  1.30k|        )]
   85|  1.30k|        unsafe {
   86|  1.30k|            let cmp = x86::_mm_cmpeq_epi8(self.0, x86::_mm_set1_epi8(byte as i8));
   87|  1.30k|            BitMask(x86::_mm_movemask_epi8(cmp) as u16)
   88|  1.30k|        }
   89|  1.30k|    }
_RNvMNtNtNtCs2Sob2MrKNwt_9hashbrown3raw5inner4sse2NtB2_5Group11match_empty:
   94|    652|    pub fn match_empty(self) -> BitMask {
   95|    652|        self.match_byte(EMPTY)
   96|    652|    }

_RINvNtCs2Sob2MrKNwt_9hashbrown10scopeguard5guardINtNtNtB4_3raw5inner13RawTableInnerNtNtNtBN_5alloc5inner6GlobalENCNvMs9_BN_BK_14prepare_resize0ECscE26HxwD491_8wasmtime:
   17|    652|pub fn guard<T, F>(value: T, dropfn: F) -> ScopeGuard<T, F>
   18|    652|where
   19|    652|    F: FnMut(&mut T),
   20|    652|{
   21|    652|    ScopeGuard { dropfn, value }
   22|    652|}
_RNvXs0_NtCs2Sob2MrKNwt_9hashbrown10scopeguardINtB5_10ScopeGuardINtNtNtB7_3raw5inner13RawTableInnerNtNtNtB12_5alloc5inner6GlobalENCNvMs9_B12_BZ_14prepare_resize0ENtNtNtCsdRJjCzU6nMS_4core3ops5deref8DerefMut9deref_mutCscE26HxwD491_8wasmtime:
   61|    652|    fn deref_mut(&mut self) -> &mut T {
   62|    652|        &mut self.value
   63|    652|    }
_RNvXs1_NtCs2Sob2MrKNwt_9hashbrown10scopeguardINtB5_10ScopeGuardINtNtNtB7_3raw5inner13RawTableInnerNtNtNtB12_5alloc5inner6GlobalENCNvMs9_B12_BZ_14prepare_resize0ENtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4dropCscE26HxwD491_8wasmtime:
   71|    652|    fn drop(&mut self) {
   72|    652|        (self.dropfn)(&mut self.value);
   73|    652|    }

_RNvXs1_NtCsjEfFpLggf07_9humantime4dateNtB5_16Rfc3339TimestampNtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt:
  251|    326|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  252|    326|        use self::Precision::*;
  253|    326|
  254|    326|        let dur = self.0.duration_since(UNIX_EPOCH)
  255|    326|            .expect("all times should be after the epoch");
  256|    326|        let secs_since_epoch = dur.as_secs();
  257|    326|        let nanos = dur.subsec_nanos();
  258|    326|
  259|    326|        if secs_since_epoch >= 253_402_300_800 { // year 9999
  260|      0|            return Err(fmt::Error);
  261|    326|        }
  262|    326|
  263|    326|        /* 2000-03-01 (mod 400 year, immediately after feb29 */
  264|    326|        const LEAPOCH: i64 = 11017;
  265|    326|        const DAYS_PER_400Y: i64 = 365*400 + 97;
  266|    326|        const DAYS_PER_100Y: i64 = 365*100 + 24;
  267|    326|        const DAYS_PER_4Y: i64 = 365*4 + 1;
  268|    326|
  269|    326|        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;
  270|    326|        let secs_of_day = secs_since_epoch % 86400;
  271|    326|
  272|    326|        let mut qc_cycles = days / DAYS_PER_400Y;
  273|    326|        let mut remdays = days % DAYS_PER_400Y;
  274|    326|
  275|    326|        if remdays < 0 {
  276|      0|            remdays += DAYS_PER_400Y;
  277|      0|            qc_cycles -= 1;
  278|    326|        }
  279|       |
  280|    326|        let mut c_cycles = remdays / DAYS_PER_100Y;
  281|    326|        if c_cycles == 4 { c_cycles -= 1; }
  282|    326|        remdays -= c_cycles * DAYS_PER_100Y;
  283|    326|
  284|    326|        let mut q_cycles = remdays / DAYS_PER_4Y;
  285|    326|        if q_cycles == 25 { q_cycles -= 1; }
  286|    326|        remdays -= q_cycles * DAYS_PER_4Y;
  287|    326|
  288|    326|        let mut remyears = remdays / 365;
  289|    326|        if remyears == 4 { remyears -= 1; }
  290|    326|        remdays -= remyears * 365;
  291|    326|
  292|    326|        let mut year = 2000 +
  293|    326|            remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;
  294|    326|
  295|    326|        let months = [31,30,31,30,31,31,30,31,30,31,31,29];
  296|    326|        let mut mon = 0;
  297|  3.26k|        for mon_len in months.iter() {
  298|  3.26k|            mon += 1;
  299|  3.26k|            if remdays < *mon_len {
  300|    326|                break;
  301|  2.93k|            }
  302|  2.93k|            remdays -= *mon_len;
  303|       |        }
  304|    326|        let mday = remdays+1;
  305|    326|        let mon = if mon + 2 > 12 {
  306|      0|            year += 1;
  307|      0|            mon - 10
  308|       |        } else {
  309|    326|            mon + 2
  310|       |        };
  311|       |
  312|    326|        let mut buf: [u8; 30] = [
  313|    326|            // Too long to write as: b"0000-00-00T00:00:00.000000000Z"
  314|    326|            b'0', b'0', b'0', b'0', b'-', b'0', b'0', b'-', b'0', b'0', b'T',
  315|    326|            b'0', b'0', b':', b'0', b'0', b':', b'0', b'0',
  316|    326|            b'.', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'Z',
  317|    326|        ];
  318|    326|        buf[0] = b'0' + (year / 1000) as u8;
  319|    326|        buf[1] = b'0' + (year / 100 % 10) as u8;
  320|    326|        buf[2] = b'0' + (year / 10 % 10) as u8;
  321|    326|        buf[3] = b'0' + (year % 10) as u8;
  322|    326|        buf[5] = b'0' + (mon / 10) as u8;
  323|    326|        buf[6] = b'0' + (mon % 10) as u8;
  324|    326|        buf[8] = b'0' + (mday / 10) as u8;
  325|    326|        buf[9] = b'0' + (mday % 10) as u8;
  326|    326|        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;
  327|    326|        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;
  328|    326|        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;
  329|    326|        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;
  330|    326|        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;
  331|    326|        buf[18] = b'0' + (secs_of_day % 10) as u8;
  332|       |
  333|    326|        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {
  334|    326|            buf[19] = b'Z';
  335|    326|            19
  336|      0|        } else if self.1 == Millis {
  337|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  338|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  339|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  340|      0|            buf[23] = b'Z';
  341|      0|            23
  342|      0|        } else if self.1 == Micros {
  343|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  344|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  345|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  346|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  347|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  348|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  349|      0|            buf[26] = b'Z';
  350|      0|            26
  351|       |        } else {
  352|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  353|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  354|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  355|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  356|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  357|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  358|      0|            buf[26] = b'0' + (nanos / 100 % 10) as u8;
  359|      0|            buf[27] = b'0' + (nanos / 10 % 10) as u8;
  360|      0|            buf[28] = b'0' + (nanos / 1 % 10) as u8;
  361|      0|            // 29th is 'Z'
  362|      0|            29
  363|       |        };
  364|       |
  365|       |        // we know our chars are all ascii
  366|    326|        f.write_str(str::from_utf8(&buf[..=offset]).expect("Conversion to utf8 failed"))
  367|    326|    }
_RNvXsa_NtCsjEfFpLggf07_9humantime4dateNtB5_9PrecisionNtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eq:
   58|    326|#[derive(Debug, Clone, PartialEq, Eq)]
_RNvNtCsjEfFpLggf07_9humantime4date22format_rfc3339_seconds:
  212|    326|pub fn format_rfc3339_seconds(system_time: SystemTime) -> Rfc3339Timestamp {
  213|    326|    Rfc3339Timestamp(system_time, Precision::Seconds)
  214|    326|}

_RNvMCs3F2gpvdZd7c_8indexmapNtB2_9HashValue3get:
  123|  1.30k|    fn get(self) -> u64 {
  124|  1.30k|        self.0 as u64
  125|  1.30k|    }

_RNvMs2_NtCs3F2gpvdZd7c_8indexmap3mapINtB5_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE11with_hasherCsheoVkkQew6K_3fvm:
  182|    326|    pub const fn with_hasher(hash_builder: S) -> Self {
  183|    326|        IndexMap {
  184|    326|            core: IndexMapCore::new(),
  185|    326|            hash_builder,
  186|    326|        }
  187|    326|    }
_RNvXs12_NtCs3F2gpvdZd7c_8indexmap3mapINtB6_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsheoVkkQew6K_3fvm:
 1495|    326|    fn default() -> Self {
 1496|    326|        Self::with_capacity_and_hasher(0, S::default())
 1497|    326|    }
_RNvMs2_NtCs3F2gpvdZd7c_8indexmap3mapINtB5_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE24with_capacity_and_hasherCsheoVkkQew6K_3fvm:
  167|    326|    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {
  168|    326|        if n == 0 {
  169|    326|            Self::with_hasher(hash_builder)
  170|       |        } else {
  171|      0|            IndexMap {
  172|      0|                core: IndexMapCore::with_capacity(n),
  173|      0|                hash_builder,
  174|      0|            }
  175|       |        }
  176|    326|    }
_RNvMs3_NtCs3F2gpvdZd7c_8indexmap3mapINtB5_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE11insert_fullCscE26HxwD491_8wasmtime:
  381|    652|    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>) {
  382|    652|        let hash = self.hash(&key);
  383|    652|        self.core.insert_full(hash, key, value)
  384|    652|    }
_RNvMs3_NtCs3F2gpvdZd7c_8indexmap3mapINtB5_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE6insertCscE26HxwD491_8wasmtime:
  364|    652|    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
  365|    652|        self.insert_full(key, value).1
  366|    652|    }
_RINvMs3_NtCs3F2gpvdZd7c_8indexmap3mapINtB6_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE4hashBO_ECscE26HxwD491_8wasmtime:
  345|    652|    fn hash<Q: ?Sized + Hash>(&self, key: &Q) -> HashValue {
  346|    652|        let mut h = self.hash_builder.build_hasher();
  347|    652|        key.hash(&mut h);
  348|    652|        HashValue(h.finish() as usize)
  349|    652|    }
_RNvMs2_NtCs3F2gpvdZd7c_8indexmap3mapINtB5_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE11with_hasherCs7L8xYe2Gdyw_16wasmtime_environ:
  182|    652|    pub const fn with_hasher(hash_builder: S) -> Self {
  183|    652|        IndexMap {
  184|    652|            core: IndexMapCore::new(),
  185|    652|            hash_builder,
  186|    652|        }
  187|    652|    }
_RNvMs2_NtCs3F2gpvdZd7c_8indexmap3mapINtB5_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE24with_capacity_and_hasherCs7L8xYe2Gdyw_16wasmtime_environ:
  167|    652|    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {
  168|    652|        if n == 0 {
  169|    652|            Self::with_hasher(hash_builder)
  170|       |        } else {
  171|      0|            IndexMap {
  172|      0|                core: IndexMapCore::with_capacity(n),
  173|      0|                hash_builder,
  174|      0|            }
  175|       |        }
  176|    652|    }
_RNvXs12_NtCs3F2gpvdZd7c_8indexmap3mapINtB6_8IndexMapNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCs7L8xYe2Gdyw_16wasmtime_environ:
 1495|    652|    fn default() -> Self {
 1496|    652|        Self::with_capacity_and_hasher(0, S::default())
 1497|    652|    }

_RNvMs1_NtNtCs3F2gpvdZd7c_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE3newCsheoVkkQew6K_3fvm:
  124|    326|    pub(crate) const fn new() -> Self {
  125|    326|        IndexMapCore {
  126|    326|            indices: RawTable::new(),
  127|    326|            entries: Vec::new(),
  128|    326|        }
  129|    326|    }
_RINvNtNtCs3F2gpvdZd7c_8indexmap3map4core10equivalentNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexBO_ECscE26HxwD491_8wasmtime:
   38|    652|fn equivalent<'a, K, V, Q: ?Sized + Equivalent<K>>(
   39|    652|    key: &'a Q,
   40|    652|    entries: &'a [Bucket<K, V>],
   41|    652|) -> impl Fn(&usize) -> bool + 'a {
   42|       |    move |&i| Q::equivalent(key, &entries[i].key)
   43|    652|}
_RNvMs1_NtNtCs3F2gpvdZd7c_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE15reserve_entriesCscE26HxwD491_8wasmtime:
  200|    652|    fn reserve_entries(&mut self) {
  201|    652|        let additional = self.indices.capacity() - self.entries.len();
  202|    652|        self.entries.reserve_exact(additional);
  203|    652|    }
_RINvNtNtCs3F2gpvdZd7c_8indexmap3map4core8get_hashNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexECscE26HxwD491_8wasmtime:
   33|    652|fn get_hash<K, V>(entries: &[Bucket<K, V>]) -> impl Fn(&usize) -> u64 + '_ {
   34|       |    move |&i| entries[i].hash.get()
   35|    652|}
_RINvMs1_NtNtCs3F2gpvdZd7c_8indexmap3map4coreINtB6_12IndexMapCoreNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE12get_index_ofB10_ECscE26HxwD491_8wasmtime:
  238|    652|    pub(crate) fn get_index_of<Q>(&self, hash: HashValue, key: &Q) -> Option<usize>
  239|    652|    where
  240|    652|        Q: ?Sized + Equivalent<K>,
  241|    652|    {
  242|    652|        let eq = equivalent(key, &self.entries);
  243|    652|        self.indices.get(hash.get(), eq).copied()
  244|    652|    }
_RNvMs1_NtNtCs3F2gpvdZd7c_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE4pushCscE26HxwD491_8wasmtime:
  225|    652|    fn push(&mut self, hash: HashValue, key: K, value: V) -> usize {
  226|    652|        let i = self.entries.len();
  227|    652|        self.indices.insert(hash.get(), i, get_hash(&self.entries));
  228|    652|        if i == self.entries.capacity() {
  229|    652|            // Reserve our own capacity synced to the indices,
  230|    652|            // rather than letting `Vec::push` just double it.
  231|    652|            self.reserve_entries();
  232|    652|        }
  233|    652|        self.entries.push(Bucket { hash, key, value });
  234|    652|        i
  235|    652|    }
_RNvMs1_NtNtCs3F2gpvdZd7c_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE11insert_fullCscE26HxwD491_8wasmtime:
  246|    652|    pub(crate) fn insert_full(&mut self, hash: HashValue, key: K, value: V) -> (usize, Option<V>)
  247|    652|    where
  248|    652|        K: Eq,
  249|    652|    {
  250|    652|        match self.get_index_of(hash, &key) {
  251|      0|            Some(i) => (i, Some(replace(&mut self.entries[i].value, value))),
  252|    652|            None => (self.push(hash, key, value), None),
  253|       |        }
  254|    652|    }
_RNvMs1_NtNtCs3F2gpvdZd7c_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs71iYhC60HpU_5alloc6string6StringNtCs4z64eNW3Ya4_14wasmtime_types11EntityIndexE3newCs7L8xYe2Gdyw_16wasmtime_environ:
  124|    652|    pub(crate) const fn new() -> Self {
  125|    652|        IndexMapCore {
  126|    652|            indices: RawTable::new(),
  127|    652|            entries: Vec::new(),
  128|    652|        }
  129|    652|    }

_RNvXs1_NtCsbrMwQtGEu9e_16integer_encoding6readerNtB5_15VarIntProcessorNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   34|  3.09k|#[derive(Default)]
_RINvXs2_NtCsbrMwQtGEu9e_16integer_encoding6readerQRShNtB6_17VarIntAsyncReader17read_varint_asyncjECsilvC8qPft2D_8fvm_fuzz:
   70|  3.09k|    async fn read_varint_async<VI: VarInt>(&mut self) -> Result<VI> {
_RINvMNtCsbrMwQtGEu9e_16integer_encoding6readerNtB3_15VarIntProcessor3newjECsilvC8qPft2D_8fvm_fuzz:
   42|  3.09k|    fn new<VI: VarIntMaxSize>() -> VarIntProcessor {
   43|  3.09k|        VarIntProcessor {
   44|  3.09k|            maxsize: VI::varint_max_size(),
   45|  3.09k|            ..VarIntProcessor::default()
   46|  3.09k|        }
   47|  3.09k|    }
_RINvMNtCsbrMwQtGEu9e_16integer_encoding6readerNtB3_15VarIntProcessor6decodejECsilvC8qPft2D_8fvm_fuzz:
   62|  2.93k|    fn decode<VI: VarInt>(&self) -> Option<VI> {
   63|  2.93k|        Some(VI::decode_var(&self.buf[0..self.i])?.0)
   64|  2.93k|    }
_RNCINvXs2_NtCsbrMwQtGEu9e_16integer_encoding6readerQRShNtB8_17VarIntAsyncReader17read_varint_asyncjE0CsilvC8qPft2D_8fvm_fuzz:
   70|  3.09k|    async fn read_varint_async<VI: VarInt>(&mut self) -> Result<VI> {
   71|  3.09k|        let mut buf = [0 as u8; 1];
   72|  3.09k|        let mut p = VarIntProcessor::new::<VI>();
   73|       |
   74|  11.0k|        while !p.finished() {
   75|  8.15k|            let read = self.read(&mut buf).await?;
   76|       |
   77|       |            // EOF
   78|  8.15k|            if read == 0 && p.i == 0 {
   79|    163|                return Err(io::Error::new(io::ErrorKind::UnexpectedEof, "Reached EOF"));
   80|  7.98k|            }
   81|  7.98k|            if read == 0 {
   82|      0|                break;
   83|  7.98k|            }
   84|  7.98k|
   85|  7.98k|            p.push(buf[0])?;
   86|       |        }
   87|       |
   88|  2.93k|        p.decode()
   89|  2.93k|            .ok_or_else(|| io::Error::new(io::ErrorKind::UnexpectedEof, "Reached EOF"))
   90|  6.19k|    }
_RNvMNtCsbrMwQtGEu9e_16integer_encoding6readerNtB2_15VarIntProcessor8finished:
   59|  11.0k|    fn finished(&self) -> bool {
   60|  11.0k|        self.i > 0 && (self.buf[self.i - 1] & MSB == 0)
   61|  11.0k|    }
_RNvMNtCsbrMwQtGEu9e_16integer_encoding6readerNtB2_15VarIntProcessor4push:
   48|  7.98k|    fn push(&mut self, b: u8) -> Result<()> {
   49|  7.98k|        if self.i >= self.maxsize {
   50|      0|            return Err(io::Error::new(
   51|      0|                io::ErrorKind::InvalidData,
   52|      0|                "Unterminated varint",
   53|      0|            ));
   54|  7.98k|        }
   55|  7.98k|        self.buf[self.i] = b;
   56|  7.98k|        self.i += 1;
   57|  7.98k|        Ok(())
   58|  7.98k|    }

_RNvXNtCsbrMwQtGEu9e_16integer_encoding6varintjNtB2_13VarIntMaxSize15varint_max_sizeCsilvC8qPft2D_8fvm_fuzz:
   74|  3.09k|    fn varint_max_size() -> usize {
   75|  3.09k|        (size_of::<VI>() * 8 + 7) / 7
   76|  3.09k|    }
_RNvXs_NtCsbrMwQtGEu9e_16integer_encoding6varintyNtB4_6VarInt10decode_var:
  133|  2.93k|    fn decode_var(src: &[u8]) -> Option<(Self, usize)> {
  134|  2.93k|        let mut result: u64 = 0;
  135|  2.93k|        let mut shift = 0;
  136|  2.93k|
  137|  2.93k|        let mut success = false;
  138|  7.98k|        for b in src.iter() {
  139|  7.98k|            let msb_dropped = b & DROP_MSB;
  140|  7.98k|            result |= (msb_dropped as u64) << shift;
  141|  7.98k|            shift += 7;
  142|  7.98k|
  143|  7.98k|            if b & MSB == 0 || shift > (9 * 7) {
  144|  2.93k|                success = b & MSB == 0;
  145|  2.93k|                break;
  146|  5.05k|            }
  147|       |        }
  148|       |
  149|  2.93k|        if success {
  150|  2.93k|            Some((result, shift / 7 as usize))
  151|       |        } else {
  152|      0|            None
  153|       |        }
  154|  2.93k|    }
_RNvXs1_NtCsbrMwQtGEu9e_16integer_encoding6varintjNtB5_6VarInt10decode_var:
   86|  2.93k|            fn decode_var(src: &[u8]) -> Option<(Self, usize)> {
   87|  2.93k|                let (n, s) = u64::decode_var(src)?;
   88|  2.93k|                Some((n as Self, s))
   89|  2.93k|            }

_RNCINvMNtCsl5HOiQ10F7b_11lazy_static4lazyINtB5_4LazyNtNtNtCsheoVkkQew6K_3fvm3gas10price_list9PriceListE3getNvNvXs5_BQ_NtBQ_12HYGGE_PRICESNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref23___static_ref_initializeE0BU_:
   30|      1|        self.1.call_once(|| {
   31|      1|            self.0.set(Some(f()));
   32|      1|        });
_RINvMNtCsl5HOiQ10F7b_11lazy_static4lazyINtB3_4LazyNtNtNtCsheoVkkQew6K_3fvm3gas10price_list9PriceListE3getNvNvXs5_BO_NtBO_12HYGGE_PRICESNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref23___static_ref_initializeEBS_:
   26|    326|    pub fn get<F>(&'static self, f: F) -> &T
   27|    326|    where
   28|    326|        F: FnOnce() -> T,
   29|    326|    {
   30|    326|        self.1.call_once(|| {
   31|       |            self.0.set(Some(f()));
   32|    326|        });
   33|    326|
   34|    326|        // `self.0` is guaranteed to be `Some` by this point
   35|    326|        // The `Once` will catch and propagate panics
   36|    326|        unsafe {
   37|    326|            match *self.0.as_ptr() {
   38|    326|                Some(ref x) => x,
   39|       |                None => {
   40|      0|                    debug_assert!(false, "attempted to derefence an uninitialized lazy static. This is a bug");
   41|       |
   42|      0|                    unreachable_unchecked()
   43|       |                },
   44|       |            }
   45|       |        }
   46|    326|    }
_RNCINvMNtCsl5HOiQ10F7b_11lazy_static4lazyINtB5_4LazyNtNtCsgTTZuTcaXZ2_10fvm_shared4econ11TokenAmountE3getNvNvXs_BS_NtBS_14TOTAL_FILECOINNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref23___static_ref_initializeE0BS_:
   30|      1|        self.1.call_once(|| {
   31|      1|            self.0.set(Some(f()));
   32|      1|        });
_RINvMNtCsl5HOiQ10F7b_11lazy_static4lazyINtB3_4LazyNtNtCsgTTZuTcaXZ2_10fvm_shared4econ11TokenAmountE3getNvNvXs_BQ_NtBQ_14TOTAL_FILECOINNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref23___static_ref_initializeEBQ_:
   26|    163|    pub fn get<F>(&'static self, f: F) -> &T
   27|    163|    where
   28|    163|        F: FnOnce() -> T,
   29|    163|    {
   30|    163|        self.1.call_once(|| {
   31|       |            self.0.set(Some(f()));
   32|    163|        });
   33|    163|
   34|    163|        // `self.0` is guaranteed to be `Some` by this point
   35|    163|        // The `Once` will catch and propagate panics
   36|    163|        unsafe {
   37|    163|            match *self.0.as_ptr() {
   38|    163|                Some(ref x) => x,
   39|       |                None => {
   40|      0|                    debug_assert!(false, "attempted to derefence an uninitialized lazy static. This is a bug");
   41|       |
   42|      0|                    unreachable_unchecked()
   43|       |                },
   44|       |            }
   45|       |        }
   46|    163|    }

_RNvXs5_NtNtCsheoVkkQew6K_3fvm3gas10price_listNtB5_12HYGGE_PRICESNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref:
  135|    326|            fn deref(&self) -> &$T {
  136|    326|                #[inline(always)]
  137|    326|                fn __static_ref_initialize() -> $T { $e }
  138|    326|
  139|    326|                #[inline(always)]
  140|    326|                fn __stability() -> &'static $T {
  141|    326|                    __lazy_static_create!(LAZY, $T);
  142|    326|                    LAZY.get(__static_ref_initialize)
  143|    326|                }
  144|    326|                __stability()
  145|    326|            }
_RNvNvXs5_NtNtCsheoVkkQew6K_3fvm3gas10price_listNtB7_12HYGGE_PRICESNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref23___static_ref_initialize:
  137|      1|                fn __static_ref_initialize() -> $T { $e }
_RNvNvXs5_NtNtCsheoVkkQew6K_3fvm3gas10price_listNtB7_12HYGGE_PRICESNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref11___stability:
  140|    326|                fn __stability() -> &'static $T {
  141|    326|                    __lazy_static_create!(LAZY, $T);
  142|    326|                    LAZY.get(__static_ref_initialize)
  143|    326|                }
_RNvNvXs_CsgTTZuTcaXZ2_10fvm_sharedNtB6_14TOTAL_FILECOINNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref11___stability:
  140|    163|                fn __stability() -> &'static $T {
  141|    163|                    __lazy_static_create!(LAZY, $T);
  142|    163|                    LAZY.get(__static_ref_initialize)
  143|    163|                }
_RNvNvXs_CsgTTZuTcaXZ2_10fvm_sharedNtB6_14TOTAL_FILECOINNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref23___static_ref_initialize:
  137|      1|                fn __static_ref_initialize() -> $T { $e }
_RNvXs_CsgTTZuTcaXZ2_10fvm_sharedNtB4_14TOTAL_FILECOINNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref:
  135|    163|            fn deref(&self) -> &$T {
  136|    163|                #[inline(always)]
  137|    163|                fn __static_ref_initialize() -> $T { $e }
  138|    163|
  139|    163|                #[inline(always)]
  140|    163|                fn __stability() -> &'static $T {
  141|    163|                    __lazy_static_create!(LAZY, $T);
  142|    163|                    LAZY.get(__static_ref_initialize)
  143|    163|                }
  144|    163|                __stability()
  145|    163|            }

rust_fuzzer_test_input:
  215|    163|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  216|       |                    use std::io::Write;
  217|      0|                    let mut file = std::fs::File::create(path)
  218|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  219|      0|                    writeln!(&mut file, "{:?}", bytes)
  220|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  221|      0|                    return 0;
  222|    163|                }
  223|    163|
  224|    163|                run(bytes);
  225|    163|                0
  226|    163|            }
_RNvNvCs4ieSHZHrxF6_15direct_syscalls1__3run:
  241|    163|            fn run($bytes: &[u8]) {
  242|    163|                $body
  243|    163|            }
LLVMFuzzerTestOneInput:
   58|    163|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|    163|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|    163|    });
   63|    163|
   64|    163|    match test_input {
   65|    163|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|    163|}
_RNCNvCskPqKiqLweb6_13libfuzzer_sys15test_input_wrap0B3_:
   59|    163|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|    163|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|    163|        rust_fuzzer_test_input(data_slice)
   62|    163|    });
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}

_RINvXNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor10visit_noneINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
  138|    489|            fn visit_none<E>(self) -> Result<Self::Value, E>
  139|    489|            where
  140|    489|                E: de::Error,
  141|    489|            {
  142|    489|                Ok(Ipld::Null)
  143|    489|            }
_RINvXs4_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEEECs4ieSHZHrxF6_15direct_syscalls:
  627|    978|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    978|    where
  629|    978|        T: de::DeserializeSeed<'de>,
  630|    978|    {
  631|    978|        match self.iter.next() {
  632|    489|            Some(value) => seed.deserialize(value).map(Some),
  633|    489|            None => Ok(None),
  634|       |        }
  635|    978|    }
_RINvXNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor9visit_u64INtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
   98|    489|            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
   99|    489|            where
  100|    489|                E: de::Error,
  101|    489|            {
  102|    489|                Ok(Ipld::Integer(v.into()))
  103|    489|            }
_RINvXs4_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEECs4ieSHZHrxF6_15direct_syscalls:
  627|    489|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    489|    where
  629|    489|        T: de::DeserializeSeed<'de>,
  630|    489|    {
  631|    489|        match self.iter.next() {
  632|    489|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    489|    }
_RINvXs4_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyEECs4ieSHZHrxF6_15direct_syscalls:
  627|    489|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    489|    where
  629|    489|        T: de::DeserializeSeed<'de>,
  630|    489|    {
  631|    489|        match self.iter.next() {
  632|    489|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    489|    }
_RINvNtNtCsb605JUWHIii_12libipld_core5serde2de9visit_seqNtNvXNvNvXsa_NtCsheoVkkQew6K_3fvm10state_treeNtB14_10ActorStateNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize1__NtBY_5InnerB1S_11deserialize9___VisitorECs4ieSHZHrxF6_15direct_syscalls:
  552|    489|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    489|where
  554|    489|    V: de::Visitor<'de>,
  555|    489|{
  556|    489|    let mut deserializer = SeqDeserializer::new(list);
  557|    489|    visitor.visit_seq(&mut deserializer)
  558|    489|}
_RINvXNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor20visit_newtype_structQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de15CidDeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  175|    978|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
  176|    978|            where
  177|    978|                D: de::Deserializer<'de>,
  178|    978|            {
  179|    978|                deserializer
  180|    978|                    .deserialize_bytes(BytesToCidVisitor)
  181|    978|                    .map(Ipld::Link)
  182|    978|            }
_RINvNtNtCsb605JUWHIii_12libipld_core5serde2de9visit_seqINtNvXNvCs6zZxOXcsMaf_13fvm_ipld_hamts_1__INtBZ_12KeyValuePairppENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize9___VisitorNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEECs4ieSHZHrxF6_15direct_syscalls:
  552|    489|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    489|where
  554|    489|    V: de::Visitor<'de>,
  555|    489|{
  556|    489|    let mut deserializer = SeqDeserializer::new(list);
  557|    489|    visitor.visit_seq(&mut deserializer)
  558|    489|}
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB14_5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtB14_11Deserialize11deserialize10VecVisitorINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEEECs4ieSHZHrxF6_15direct_syscalls:
  386|    489|    fn deserialize_seq<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  387|    489|        match self {
  388|    489|            Self::List(list) => visit_seq(list, visitor),
  389|      0|            _ => error(format!(
  390|      0|                "Only `Ipld::List` can be deserialized to sequence, input was `{:#?}`",
  391|      0|                self
  392|      0|            )),
  393|       |        }
  394|    489|    }
_RINvXNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor11visit_bytesINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
   82|    978|            fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   83|    978|            where
   84|    978|                E: de::Error,
   85|    978|            {
   86|    978|                self.visit_byte_buf(v.to_owned())
   87|    978|            }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer20deserialize_byte_bufNtNtCsHfZzWSKefx_14cs_serde_bytes7bytebuf14ByteBufVisitorECs4ieSHZHrxF6_15direct_syscalls:
  373|    489|    fn deserialize_byte_buf<V: de::Visitor<'de>>(
  374|    489|        self,
  375|    489|        visitor: V,
  376|    489|    ) -> Result<V::Value, Self::Error> {
  377|    489|        match self {
  378|    489|            Self::Bytes(bytes) => visitor.visit_byte_buf(bytes),
  379|      0|            _ => error(format!(
  380|      0|                "Only `Ipld::Bytes` can be deserialized to bytes, input was `{:#?}`",
  381|      0|                self
  382|      0|            )),
  383|       |        }
  384|    489|    }
_RINvXs4_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtB26_6option6OptionNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressEEECs4ieSHZHrxF6_15direct_syscalls:
  627|    489|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    489|    where
  629|    489|        T: de::DeserializeSeed<'de>,
  630|    489|    {
  631|    489|        match self.iter.next() {
  632|    489|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    489|    }
_RINvNtNtCsb605JUWHIii_12libipld_core5serde2de9visit_seqINtNvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtB12_11Deserialize11deserialize10VecVisitorINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEEECs4ieSHZHrxF6_15direct_syscalls:
  552|    489|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    489|where
  554|    489|    V: de::Visitor<'de>,
  555|    489|{
  556|    489|    let mut deserializer = SeqDeserializer::new(list);
  557|    489|    visitor.visit_seq(&mut deserializer)
  558|    489|}
_RINvXNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  146|  1.46k|            fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  147|  1.46k|            where
  148|  1.46k|                V: de::SeqAccess<'de>,
  149|  1.46k|            {
  150|  1.46k|                let mut vec = Vec::with_capacity(visitor.size_hint().unwrap_or(0));
  151|       |
  152|  5.37k|                while let Some(elem) = visitor.next_element()? {
  153|  3.91k|                    vec.push(elem);
  154|  3.91k|                }
  155|       |
  156|  1.46k|                Ok(Ipld::List(vec))
  157|  1.46k|            }
_RINvXs4_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDatayEECs4ieSHZHrxF6_15direct_syscalls:
  627|    489|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    489|    where
  629|    489|        T: de::DeserializeSeed<'de>,
  630|    489|    {
  631|    489|        match self.iter.next() {
  632|    489|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    489|    }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXsa_NtCsheoVkkQew6K_3fvm10state_treeNtB2k_10ActorStateNtB14_11Deserialize11deserialize1__NtB2e_5InnerB38_11deserialize9___VisitorECs4ieSHZHrxF6_15direct_syscalls:
  416|    489|    fn deserialize_tuple_struct<V: de::Visitor<'de>>(
  417|    489|        self,
  418|    489|        _name: &str,
  419|    489|        len: usize,
  420|    489|        visitor: V,
  421|    489|    ) -> Result<V::Value, Self::Error> {
  422|    489|        self.deserialize_tuple(len, visitor)
  423|    489|    }
_RINvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtB7_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   60|  4.40k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   61|  4.40k|    where
   62|  4.40k|        D: de::Deserializer<'de>,
   63|  4.40k|    {
   64|  4.40k|        struct IpldVisitor;
   65|  4.40k|
   66|  4.40k|        impl<'de> de::Visitor<'de> for IpldVisitor {
   67|  4.40k|            type Value = Ipld;
   68|  4.40k|
   69|  4.40k|            fn expecting(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
   70|  4.40k|                fmt.write_str("any valid IPLD kind")
   71|  4.40k|            }
   72|  4.40k|
   73|  4.40k|            #[inline]
   74|  4.40k|            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
   75|  4.40k|            where
   76|  4.40k|                E: de::Error,
   77|  4.40k|            {
   78|  4.40k|                Ok(Ipld::String(String::from(value)))
   79|  4.40k|            }
   80|  4.40k|
   81|  4.40k|            #[inline]
   82|  4.40k|            fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   83|  4.40k|            where
   84|  4.40k|                E: de::Error,
   85|  4.40k|            {
   86|  4.40k|                self.visit_byte_buf(v.to_owned())
   87|  4.40k|            }
   88|  4.40k|
   89|  4.40k|            #[inline]
   90|  4.40k|            fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
   91|  4.40k|            where
   92|  4.40k|                E: de::Error,
   93|  4.40k|            {
   94|  4.40k|                Ok(Ipld::Bytes(v))
   95|  4.40k|            }
   96|  4.40k|
   97|  4.40k|            #[inline]
   98|  4.40k|            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
   99|  4.40k|            where
  100|  4.40k|                E: de::Error,
  101|  4.40k|            {
  102|  4.40k|                Ok(Ipld::Integer(v.into()))
  103|  4.40k|            }
  104|  4.40k|
  105|  4.40k|            #[inline]
  106|  4.40k|            fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>
  107|  4.40k|            where
  108|  4.40k|                E: de::Error,
  109|  4.40k|            {
  110|  4.40k|                Ok(Ipld::Integer(v.into()))
  111|  4.40k|            }
  112|  4.40k|
  113|  4.40k|            #[inline]
  114|  4.40k|            fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>
  115|  4.40k|            where
  116|  4.40k|                E: de::Error,
  117|  4.40k|            {
  118|  4.40k|                Ok(Ipld::Integer(v))
  119|  4.40k|            }
  120|  4.40k|
  121|  4.40k|            #[inline]
  122|  4.40k|            fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E>
  123|  4.40k|            where
  124|  4.40k|                E: de::Error,
  125|  4.40k|            {
  126|  4.40k|                Ok(Ipld::Float(v))
  127|  4.40k|            }
  128|  4.40k|
  129|  4.40k|            #[inline]
  130|  4.40k|            fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>
  131|  4.40k|            where
  132|  4.40k|                E: de::Error,
  133|  4.40k|            {
  134|  4.40k|                Ok(Ipld::Bool(v))
  135|  4.40k|            }
  136|  4.40k|
  137|  4.40k|            #[inline]
  138|  4.40k|            fn visit_none<E>(self) -> Result<Self::Value, E>
  139|  4.40k|            where
  140|  4.40k|                E: de::Error,
  141|  4.40k|            {
  142|  4.40k|                Ok(Ipld::Null)
  143|  4.40k|            }
  144|  4.40k|
  145|  4.40k|            #[inline]
  146|  4.40k|            fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  147|  4.40k|            where
  148|  4.40k|                V: de::SeqAccess<'de>,
  149|  4.40k|            {
  150|  4.40k|                let mut vec = Vec::with_capacity(visitor.size_hint().unwrap_or(0));
  151|  4.40k|
  152|  4.40k|                while let Some(elem) = visitor.next_element()? {
  153|  4.40k|                    vec.push(elem);
  154|  4.40k|                }
  155|  4.40k|
  156|  4.40k|                Ok(Ipld::List(vec))
  157|  4.40k|            }
  158|  4.40k|
  159|  4.40k|            #[inline]
  160|  4.40k|            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  161|  4.40k|            where
  162|  4.40k|                V: de::MapAccess<'de>,
  163|  4.40k|            {
  164|  4.40k|                let mut values = BTreeMap::new();
  165|  4.40k|
  166|  4.40k|                while let Some((key, value)) = visitor.next_entry()? {
  167|  4.40k|                    values.insert(key, value);
  168|  4.40k|                }
  169|  4.40k|
  170|  4.40k|                Ok(Ipld::Map(values))
  171|  4.40k|            }
  172|  4.40k|
  173|  4.40k|            /// Newtype structs are only used to deserialize CIDs.
  174|  4.40k|            #[inline]
  175|  4.40k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
  176|  4.40k|            where
  177|  4.40k|                D: de::Deserializer<'de>,
  178|  4.40k|            {
  179|  4.40k|                deserializer
  180|  4.40k|                    .deserialize_bytes(BytesToCidVisitor)
  181|  4.40k|                    .map(Ipld::Link)
  182|  4.40k|            }
  183|  4.40k|        }
  184|  4.40k|
  185|  4.40k|        deserializer.deserialize_any(IpldVisitor)
  186|  4.40k|    }
_RINvXs4_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
  627|    978|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    978|    where
  629|    978|        T: de::DeserializeSeed<'de>,
  630|    978|    {
  631|    978|        match self.iter.next() {
  632|    978|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    978|    }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_bytesNtNvXs0_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc6borrow3CowShENtB28_11Deserialize11deserialize10CowVisitorECs4ieSHZHrxF6_15direct_syscalls:
  363|    489|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  364|    489|        match self {
  365|    489|            Self::Bytes(bytes) => visitor.visit_bytes(&bytes),
  366|      0|            _ => error(format!(
  367|      0|                "Only `Ipld::Bytes` can be deserialized to bytes, input was `{:#?}`",
  368|      0|                self
  369|      0|            )),
  370|       |        }
  371|    489|    }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_tupleINtNvXNvCs6zZxOXcsMaf_13fvm_ipld_hamts_1__INtB28_12KeyValuePairppENtB14_11Deserialize11deserialize9___VisitorNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEECs4ieSHZHrxF6_15direct_syscalls:
  396|    489|    fn deserialize_tuple<V: de::Visitor<'de>>(
  397|    489|        self,
  398|    489|        len: usize,
  399|    489|        visitor: V,
  400|    489|    ) -> Result<V::Value, Self::Error> {
  401|    489|        match self {
  402|    489|            Self::List(list) => {
  403|    489|                if len == list.len() {
  404|    489|                    visit_seq(list, visitor)
  405|       |                } else {
  406|      0|                    error(format!("The tuple size must match the length of the `Ipld::List`, tuple size: {}, `Ipld::List` length: {}", len, list.len()))
  407|       |                }
  408|       |            }
  409|      0|            _ => error(format!(
  410|      0|                "Only `Ipld::List` can be deserialized to tuple, input was `{:#?}`",
  411|      0|                self
  412|      0|            )),
  413|       |        }
  414|    489|    }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_u64NtNvXsX_NtB14_5implsyNtB14_11Deserialize11deserialize16PrimitiveVisitorECs4ieSHZHrxF6_15direct_syscalls:
  191|    489|        fn $deserialize<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  192|    489|            match self {
  193|    489|                Self::Integer(integer) => match $ty::try_from(integer) {
  194|    489|                    Ok(int) => visitor.$visit(int),
  195|      0|                    Err(_) => error(format!(
  196|      0|                        "`Ipld::Integer` value was bigger than `{}`",
  197|      0|                        stringify!($ty)
  198|      0|                    )),
  199|       |                },
  200|      0|                _ => error(format!(
  201|      0|                    "Only `Ipld::Integer` can be deserialized to `{}`, input was `{:#?}`",
  202|      0|                    stringify!($ty),
  203|      0|                    self
  204|      0|                )),
  205|       |            }
  206|    489|        }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer24deserialize_tuple_structINtNvXNvCs6zZxOXcsMaf_13fvm_ipld_hamts_1__INtB2f_12KeyValuePairppENtB14_11Deserialize11deserialize9___VisitorNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEECs4ieSHZHrxF6_15direct_syscalls:
  416|    489|    fn deserialize_tuple_struct<V: de::Visitor<'de>>(
  417|    489|        self,
  418|    489|        _name: &str,
  419|    489|        len: usize,
  420|    489|        visitor: V,
  421|    489|    ) -> Result<V::Value, Self::Error> {
  422|    489|        self.deserialize_tuple(len, visitor)
  423|    489|    }
_RINvXs4_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCsgTTZuTcaXZ2_10fvm_shared4econ11TokenAmountEECs4ieSHZHrxF6_15direct_syscalls:
  627|    489|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    489|    where
  629|    489|        T: de::DeserializeSeed<'de>,
  630|    489|    {
  631|    489|        match self.iter.next() {
  632|    489|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    489|    }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_tupleNtNvXNvNvXsa_NtCsheoVkkQew6K_3fvm10state_treeNtB2d_10ActorStateNtB14_11Deserialize11deserialize1__NtB27_5InnerB31_11deserialize9___VisitorECs4ieSHZHrxF6_15direct_syscalls:
  396|    489|    fn deserialize_tuple<V: de::Visitor<'de>>(
  397|    489|        self,
  398|    489|        len: usize,
  399|    489|        visitor: V,
  400|    489|    ) -> Result<V::Value, Self::Error> {
  401|    489|        match self {
  402|    489|            Self::List(list) => {
  403|    489|                if len == list.len() {
  404|    489|                    visit_seq(list, visitor)
  405|       |                } else {
  406|      0|                    error(format!("The tuple size must match the length of the `Ipld::List`, tuple size: {}, `Ipld::List` length: {}", len, list.len()))
  407|       |                }
  408|       |            }
  409|      0|            _ => error(format!(
  410|      0|                "Only `Ipld::List` can be deserialized to tuple, input was `{:#?}`",
  411|      0|                self
  412|      0|            )),
  413|       |        }
  414|    489|    }
_RINvXNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor14visit_byte_bufINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
   90|    978|            fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
   91|    978|            where
   92|    978|                E: de::Error,
   93|    978|            {
   94|    978|                Ok(Ipld::Bytes(v))
   95|    978|            }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer26deserialize_newtype_structINtNvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtB2k_3cid3CidKpENtB14_11Deserialize11deserialize16MainEntryVisitorKj40_EECs4ieSHZHrxF6_15direct_syscalls:
  471|    978|    fn deserialize_newtype_struct<V: de::Visitor<'de>>(
  472|    978|        self,
  473|    978|        name: &str,
  474|    978|        visitor: V,
  475|    978|    ) -> Result<V::Value, Self::Error> {
  476|    978|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  477|    978|            match self {
  478|    978|                Ipld::Link(cid) => visitor.visit_newtype_struct(CidDeserializer(cid)),
  479|      0|                _ => error(format!(
  480|      0|                    "Only `Ipld::Link`s can be deserialized to CIDs, input was `{:#?}`",
  481|      0|                    self
  482|      0|                )),
  483|       |            }
  484|       |        } else {
  485|      0|            visitor.visit_newtype_struct(self)
  486|       |        }
  487|    978|    }
_RINvXs_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB5_15CidDeserializerNtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_bytesNtNtCseVyrqhqyiIX_3cid5serde17BytesToCidVisitorECs4ieSHZHrxF6_15direct_syscalls:
  224|    978|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  225|    978|        visitor.visit_bytes(&self.0.to_bytes())
  226|    978|    }
_RINvXs0_NtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de12Deserializer18deserialize_optionINtNtB14_5impls13OptionVisitorNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressEECs4ieSHZHrxF6_15direct_syscalls:
  536|    489|    fn deserialize_option<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  537|    489|        match self {
  538|    489|            Self::Null => visitor.visit_none(),
  539|      0|            _ => visitor.visit_some(self),
  540|       |        }
  541|    489|    }
_RNvMs3_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB5_15SeqDeserializer3new:
  617|  1.46k|    fn new(vec: Vec<Ipld>) -> Self {
  618|  1.46k|        Self {
  619|  1.46k|            iter: vec.into_iter(),
  620|  1.46k|        }
  621|  1.46k|    }
_RNvXs4_NtNtCsb605JUWHIii_12libipld_core5serde2deNtB5_15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess9size_hint:
  638|    489|        match self.iter.size_hint() {
  639|    489|            (lower, Some(upper)) if lower == upper => Some(upper),
  640|      0|            _ => None,
  641|       |        }
  642|    489|    }

_RNvCs5Em8znMBCBW_3log9max_level:
 1383|    489|pub fn max_level() -> LevelFilter {
 1384|    489|    // Since `LevelFilter` is `repr(usize)`,
 1385|    489|    // this transmute is sound if and only if `MAX_LOG_LEVEL_FILTER`
 1386|    489|    // is set to a usize that is a valid discriminant for `LevelFilter`.
 1387|    489|    // Since `MAX_LOG_LEVEL_FILTER` is private, the only time it's set
 1388|    489|    // is by `set_max_level` above, i.e. by casting a `LevelFilter` to `usize`.
 1389|    489|    // So any usize stored in `MAX_LOG_LEVEL_FILTER` is a valid discriminant.
 1390|    489|    unsafe { mem::transmute(MAX_LOG_LEVEL_FILTER.load(Ordering::Relaxed)) }
 1391|    489|}
_RNvXs2_Cs5Em8znMBCBW_3logNtB5_5LevelINtNtCsdRJjCzU6nMS_4core3cmp10PartialOrdNtB5_11LevelFilterE2le:
  511|  1.30k|    fn le(&self, other: &LevelFilter) -> bool {
  512|  1.30k|        *self as usize <= *other as usize
  513|  1.30k|    }
_RNvMsh_Cs5Em8znMBCBW_3logNtB5_6Record4args:
  910|    326|    pub fn args(&self) -> &fmt::Arguments<'a> {
  911|    326|        &self.args
  912|    326|    }
_RNvMsf_Cs5Em8znMBCBW_3logNtB5_11LevelFilter3max:
  774|    326|    pub fn max() -> LevelFilter {
  775|    326|        LevelFilter::Trace
  776|    326|    }
_RNvXsc_Cs5Em8znMBCBW_3logNtB5_11LevelFilterNtNtCsdRJjCzU6nMS_4core3cmp3Ord3cmp:
  735|    489|    fn cmp(&self, other: &LevelFilter) -> cmp::Ordering {
  736|    489|        (*self as usize).cmp(&(*other as usize))
  737|    489|    }
_RNvMsj_Cs5Em8znMBCBW_3logNtB5_8Metadata6target:
 1204|    815|    pub fn target(&self) -> &'a str {
 1205|    815|        self.target
 1206|    815|    }
_RNvCs5Em8znMBCBW_3log13set_max_level:
 1365|      1|pub fn set_max_level(level: LevelFilter) {
 1366|      1|    MAX_LOG_LEVEL_FILTER.store(level as usize, Ordering::Relaxed)
 1367|      1|}
_RNvMsh_Cs5Em8znMBCBW_3logNtB5_6Record6target:
  928|    326|    pub fn target(&self) -> &'a str {
  929|    326|        self.metadata.target()
  930|    326|    }
_RNvMsj_Cs5Em8znMBCBW_3logNtB5_8Metadata5level:
 1198|    815|    pub fn level(&self) -> Level {
 1199|    815|        self.level
 1200|    815|    }
_RNvMsh_Cs5Em8znMBCBW_3logNtB5_6Record5level:
  922|    326|    pub fn level(&self) -> Level {
  923|    326|        self.metadata.level()
  924|    326|    }
_RNvMsh_Cs5Em8znMBCBW_3logNtB5_6Record8metadata:
  916|    489|    pub fn metadata(&self) -> &Metadata<'a> {
  917|    489|        &self.metadata
  918|    489|    }
_RNvNvCs5Em8znMBCBW_3log20eq_ignore_ascii_case18to_ascii_uppercase:
  542|  4.23k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  4.23k|        if c >= b'a' && c <= b'z' {
  544|  2.11k|            c - b'a' + b'A'
  545|       |        } else {
  546|  2.11k|            c
  547|       |        }
  548|  4.23k|    }
_RNvXsN_Cs5Em8znMBCBW_3logNtB5_6RecordNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  873|    489|#[derive(Clone, Debug)]
_RNvMsi_Cs5Em8znMBCBW_3logNtB5_13RecordBuilder3new:
 1053|    489|    pub fn new() -> RecordBuilder<'a> {
 1054|    489|        RecordBuilder {
 1055|    489|            record: Record {
 1056|    489|                args: format_args!(""),
 1057|    489|                metadata: Metadata::builder().build(),
 1058|    489|                module_path: None,
 1059|    489|                file: None,
 1060|    489|                line: None,
 1061|    489|                #[cfg(feature = "kv_unstable")]
 1062|    489|                key_values: KeyValues(&Option::None::<(kv::Key, kv::Value)>),
 1063|    489|            },
 1064|    489|        }
 1065|    489|    }
_RNCNvXsd_Cs5Em8znMBCBW_3logNtB7_11LevelFilterNtNtNtCsdRJjCzU6nMS_4core3str6traits7FromStr8from_str0B7_:
  746|  3.74k|                .position(|&name| eq_ignore_ascii_case(name, level))
_RNvMsj_Cs5Em8znMBCBW_3logNtB5_8Metadata7builder:
 1192|    489|    pub fn builder() -> MetadataBuilder<'a> {
 1193|    489|        MetadataBuilder::new()
 1194|    489|    }
_RNvCs5Em8znMBCBW_3log20eq_ignore_ascii_case:
  541|  3.74k|fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {
  542|  3.74k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  3.74k|        if c >= b'a' && c <= b'z' {
  544|  3.74k|            c - b'a' + b'A'
  545|  3.74k|        } else {
  546|  3.74k|            c
  547|  3.74k|        }
  548|  3.74k|    }
  549|  3.74k|
  550|  3.74k|    if a.len() == b.len() {
  551|    815|        a.bytes()
  552|    815|            .zip(b.bytes())
  553|    815|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
  554|       |    } else {
  555|  2.93k|        false
  556|       |    }
  557|  3.74k|}
_RNvCs5Em8znMBCBW_3log6logger:
 1573|    489|pub fn logger() -> &'static dyn Log {
 1574|    489|    if STATE.load(Ordering::SeqCst) != INITIALIZED {
 1575|       |        static NOP: NopLogger = NopLogger;
 1576|      0|        &NOP
 1577|       |    } else {
 1578|    489|        unsafe { LOGGER }
 1579|       |    }
 1580|    489|}
_RNvCs5Em8znMBCBW_3log16set_boxed_logger:
 1407|    163|pub fn set_boxed_logger(logger: Box<dyn Log>) -> Result<(), SetLoggerError> {
 1408|    163|    set_logger_inner(|| Box::leak(logger))
 1409|    163|}
_RNCNvCs5Em8znMBCBW_3log16set_boxed_logger0B3_:
 1408|      1|    set_logger_inner(|| Box::leak(logger))
_RNvMsk_Cs5Em8znMBCBW_3logNtB5_15MetadataBuilder5build:
 1263|    489|    pub fn build(&self) -> Metadata<'a> {
 1264|    489|        self.metadata.clone()
 1265|    489|    }
_RNvMsh_Cs5Em8znMBCBW_3logNtB5_6Record7builder:
  904|    489|    pub fn builder() -> RecordBuilder<'a> {
  905|    489|        RecordBuilder::new()
  906|    489|    }
_RNvMsi_Cs5Em8znMBCBW_3logNtB5_13RecordBuilder11file_static:
 1118|    489|    pub fn file_static(&mut self, file: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1119|    489|        self.record.file = file.map(MaybeStaticStr::Static);
 1120|    489|        self
 1121|    489|    }
_RNvXCs5Em8znMBCBW_3logNtB2_5LevelNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  453|    978|    fn clone(&self) -> Level {
  454|    978|        *self
  455|    978|    }
_RNvMsi_Cs5Em8znMBCBW_3logNtB5_13RecordBuilder5build:
 1140|    489|    pub fn build(&self) -> Record<'a> {
 1141|    489|        self.record.clone()
 1142|    489|    }
_RNvXs5_Cs5Em8znMBCBW_3logNtB5_5LevelNtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt:
  576|    326|    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
  577|    326|        fmt.pad(self.as_str())
  578|    326|    }
_RNCNvCs5Em8znMBCBW_3log20eq_ignore_ascii_case0B3_:
  553|  2.11k|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
_RNvXsd_Cs5Em8znMBCBW_3logNtB5_11LevelFilterNtNtNtCsdRJjCzU6nMS_4core3str6traits7FromStr8from_str:
  742|    652|    fn from_str(level: &str) -> Result<LevelFilter, Self::Err> {
  743|    652|        ok_or(
  744|    652|            LOG_LEVEL_NAMES
  745|    652|                .iter()
  746|    652|                .position(|&name| eq_ignore_ascii_case(name, level))
  747|    652|                .map(|p| LevelFilter::from_usize(p).unwrap()),
  748|    652|            ParseLevelError(()),
  749|    652|        )
  750|    652|    }
_RNvMsk_Cs5Em8znMBCBW_3logNtB5_15MetadataBuilder3new:
 1238|    489|    pub fn new() -> MetadataBuilder<'a> {
 1239|    489|        MetadataBuilder {
 1240|    489|            metadata: Metadata {
 1241|    489|                level: Level::Info,
 1242|    489|                target: "",
 1243|    489|            },
 1244|    489|        }
 1245|    489|    }
_RNvMsi_Cs5Em8znMBCBW_3logNtB5_13RecordBuilder4line:
 1125|    489|    pub fn line(&mut self, line: Option<u32>) -> &mut RecordBuilder<'a> {
 1126|    489|        self.record.line = line;
 1127|    489|        self
 1128|    489|    }
_RINvCs5Em8znMBCBW_3log16set_logger_innerNCNvB2_16set_boxed_logger0EB2_:
 1470|    163|fn set_logger_inner<F>(make_logger: F) -> Result<(), SetLoggerError>
 1471|    163|where
 1472|    163|    F: FnOnce() -> &'static dyn Log,
 1473|    163|{
 1474|    163|    let old_state = match STATE.compare_exchange(
 1475|    163|        UNINITIALIZED,
 1476|    163|        INITIALIZING,
 1477|    163|        Ordering::SeqCst,
 1478|    163|        Ordering::SeqCst,
 1479|    163|    ) {
 1480|    163|        Ok(s) | Err(s) => s,
 1481|    163|    };
 1482|    163|    match old_state {
 1483|       |        UNINITIALIZED => {
 1484|      1|            unsafe {
 1485|      1|                LOGGER = make_logger();
 1486|      1|            }
 1487|      1|            STATE.store(INITIALIZED, Ordering::SeqCst);
 1488|      1|            Ok(())
 1489|       |        }
 1490|       |        INITIALIZING => {
 1491|      0|            while STATE.load(Ordering::SeqCst) == INITIALIZING {
 1492|      0|                // TODO: replace with `hint::spin_loop` once MSRV is 1.49.0.
 1493|      0|                #[allow(deprecated)]
 1494|      0|                std::sync::atomic::spin_loop_hint();
 1495|      0|            }
 1496|      0|            Err(SetLoggerError(()))
 1497|       |        }
 1498|    162|        _ => Err(SetLoggerError(())),
 1499|       |    }
 1500|    163|}
_RNvMsi_Cs5Em8znMBCBW_3logNtB5_13RecordBuilder6target:
 1090|    489|    pub fn target(&mut self, target: &'a str) -> &mut RecordBuilder<'a> {
 1091|    489|        self.record.metadata.target = target;
 1092|    489|        self
 1093|    489|    }
_RNvXsQ_Cs5Em8znMBCBW_3logNtB5_8MetadataNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
 1183|    978|#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvMsi_Cs5Em8znMBCBW_3logNtB5_13RecordBuilder4args:
 1069|    489|    pub fn args(&mut self, args: fmt::Arguments<'a>) -> &mut RecordBuilder<'a> {
 1070|    489|        self.record.args = args;
 1071|    489|        self
 1072|    489|    }
_RNvMsi_Cs5Em8znMBCBW_3logNtB5_13RecordBuilder5level:
 1083|    489|    pub fn level(&mut self, level: Level) -> &mut RecordBuilder<'a> {
 1084|    489|        self.record.metadata.level = level;
 1085|    489|        self
 1086|    489|    }
_RNvMs6_Cs5Em8znMBCBW_3logNtB5_5Level6as_str:
  608|    326|    pub fn as_str(&self) -> &'static str {
  609|    326|        LOG_LEVEL_NAMES[*self as usize]
  610|    326|    }
_RNCNvXsd_Cs5Em8znMBCBW_3logNtB7_11LevelFilterNtNtNtCsdRJjCzU6nMS_4core3str6traits7FromStr8from_strs_0B7_:
  747|    326|                .map(|p| LevelFilter::from_usize(p).unwrap()),
_RNvMsf_Cs5Em8znMBCBW_3logNtB5_11LevelFilter10from_usize:
  760|    326|    fn from_usize(u: usize) -> Option<LevelFilter> {
  761|    326|        match u {
  762|      0|            0 => Some(LevelFilter::Off),
  763|      0|            1 => Some(LevelFilter::Error),
  764|      0|            2 => Some(LevelFilter::Warn),
  765|      0|            3 => Some(LevelFilter::Info),
  766|    163|            4 => Some(LevelFilter::Debug),
  767|    163|            5 => Some(LevelFilter::Trace),
  768|      0|            _ => None,
  769|       |        }
  770|    326|    }
_RNvXsE_Cs5Em8znMBCBW_3logNtB5_14MaybeStaticStrNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  812|    978|#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvCs5Em8znMBCBW_3log17___private_api_log:
 1591|    489|    if kvs.is_some() {
 1592|      0|        panic!(
 1593|      0|            "key-value support is experimental and must be enabled using the `kv_unstable` feature"
 1594|      0|        )
 1595|    489|    }
 1596|    489|
 1597|    489|    logger().log(
 1598|    489|        &Record::builder()
 1599|    489|            .args(args)
 1600|    489|            .level(level)
 1601|    489|            .target(target)
 1602|    489|            .module_path_static(Some(module_path))
 1603|    489|            .file_static(Some(file))
 1604|    489|            .line(Some(line))
 1605|    489|            .build(),
 1606|    489|    );
 1607|    489|}
_RNvMsi_Cs5Em8znMBCBW_3logNtB5_13RecordBuilder18module_path_static:
 1104|    489|    pub fn module_path_static(&mut self, path: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1105|    489|        self.record.module_path = path.map(MaybeStaticStr::Static);
 1106|    489|        self
 1107|    489|    }
_RINvCs5Em8znMBCBW_3log5ok_orNtB2_11LevelFilterNtB2_15ParseLevelErrorEB2_:
  533|    652|fn ok_or<T, E>(t: Option<T>, e: E) -> Result<T, E> {
  534|    652|    match t {
  535|    326|        Some(t) => Ok(t),
  536|    326|        None => Err(e),
  537|       |    }
  538|    652|}

_RNvMNtCsb65tUIcjYgD_8minstant7instantNtB2_7Instant3now:
   25|    163|    pub fn now() -> Instant {
   26|    163|        Instant(crate::current_cycle())
   27|    163|    }

_RNvCsb65tUIcjYgD_8minstant13current_cycle:
   58|    163|pub(crate) fn current_cycle() -> u64 {
   59|    163|    #[cfg(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64")))]
   60|    163|    if is_tsc_available() {
   61|    163|        tsc_now::current_cycle()
   62|       |    } else {
   63|      0|        coarse_now::current_cycle()
   64|       |    }
   65|       |    #[cfg(not(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64"))))]
   66|       |    {
   67|       |        coarse_now::current_cycle()
   68|       |    }
   69|    163|}
_RNvCsb65tUIcjYgD_8minstant16is_tsc_available:
   46|    163|pub fn is_tsc_available() -> bool {
   47|    163|    #[cfg(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64")))]
   48|    163|    {
   49|    163|        tsc_now::is_tsc_available()
   50|    163|    }
   51|    163|    #[cfg(not(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64"))))]
   52|    163|    {
   53|    163|        false
   54|    163|    }
   55|    163|}

_RNvNtCsb65tUIcjYgD_8minstant7tsc_now16is_tsc_available:
   45|    163|pub(crate) fn is_tsc_available() -> bool {
   46|    163|    unsafe { *TSC_STATE.is_tsc_available.get() }
   47|    163|}
_RNvNtCsb65tUIcjYgD_8minstant7tsc_now13current_cycle:
   55|    163|pub(crate) fn current_cycle() -> u64 {
   56|    163|    match unsafe { &*TSC_STATE.tsc_level.get() } {
   57|       |        TSCLevel::Stable {
   58|    163|            cycles_from_anchor, ..
   59|    163|        } => tsc().wrapping_sub(*cycles_from_anchor),
   60|       |        TSCLevel::PerCPUStable {
   61|      0|            cycles_from_anchor, ..
   62|      0|        } => {
   63|      0|            let (tsc, cpuid) = tsc_with_cpuid();
   64|      0|            let anchor = cycles_from_anchor[cpuid];
   65|      0|            tsc.wrapping_sub(anchor)
   66|       |        }
   67|      0|        TSCLevel::Unstable => panic!("tsc is unstable"),
   68|       |    }
   69|    163|}
_RNvNtCsb65tUIcjYgD_8minstant7tsc_now3tsc:
  270|   847k|fn tsc() -> u64 {
  271|   847k|    #[cfg(target_arch = "x86")]
  272|   847k|    use core::arch::x86::_rdtsc;
  273|   847k|    #[cfg(target_arch = "x86_64")]
  274|   847k|    use core::arch::x86_64::_rdtsc;
  275|   847k|
  276|   847k|    unsafe { _rdtsc() }
  277|   847k|}
_RNvNtCsb65tUIcjYgD_8minstant7tsc_now13is_tsc_stable:
  182|      2|fn is_tsc_stable() -> bool {
  183|      2|    let clock_source =
  184|      2|        read_to_string("/sys/devices/system/clocksource/clocksource0/available_clocksource");
  185|      2|
  186|      2|    clock_source.map(|s| s.contains("tsc")).unwrap_or(false)
  187|      2|}
_RNCNvNtCsb65tUIcjYgD_8minstant7tsc_now13is_tsc_stable0B5_:
  186|      2|    clock_source.map(|s| s.contains("tsc")).unwrap_or(false)
_RNvNtCsb65tUIcjYgD_8minstant7tsc_now18monotonic_with_tsc:
  265|   847k|fn monotonic_with_tsc() -> (Instant, u64) {
  266|   847k|    (Instant::now(), tsc())
  267|   847k|}
_RNvNtCsb65tUIcjYgD_8minstant7tsc_now14cycles_per_sec:
  224|      2|fn cycles_per_sec(anchor: Instant) -> (u64, u64) {
  225|      2|    let (cps, last_monotonic, last_tsc) = _cycles_per_sec();
  226|      2|    let nanos_from_anchor = (last_monotonic - anchor).as_nanos();
  227|      2|    let cycles_flied = cps as f64 * nanos_from_anchor as f64 / 1_000_000_000.0;
  228|      2|    let cycles_from_anchor = last_tsc - cycles_flied.ceil() as u64;
  229|      2|
  230|      2|    (cps, cycles_from_anchor)
  231|      2|}
_RNvMs_NtCsb65tUIcjYgD_8minstant7tsc_nowNtB4_8TSCLevel17cycles_per_second:
  166|      2|    fn cycles_per_second(&self) -> u64 {
  167|      2|        match self {
  168|       |            TSCLevel::Stable {
  169|      2|                cycles_per_second, ..
  170|      2|            } => *cycles_per_second,
  171|       |            TSCLevel::PerCPUStable {
  172|      0|                cycles_per_second, ..
  173|      0|            } => *cycles_per_second,
  174|      0|            TSCLevel::Unstable => panic!("tsc is unstable"),
  175|       |        }
  176|      2|    }
_RNvNtCsb65tUIcjYgD_8minstant7tsc_now15__cycles_per_sec:
  234|      2|fn _cycles_per_sec() -> (u64, Instant, u64) {
  235|      2|    let mut cycles_per_sec;
  236|      2|    let mut last_monotonic;
  237|      2|    let mut last_tsc;
  238|      2|    let mut old_cycles = 0.0;
  239|       |
  240|       |    loop {
  241|      5|        let (t1, tsc1) = monotonic_with_tsc();
  242|   847k|        loop {
  243|   847k|            let (t2, tsc2) = monotonic_with_tsc();
  244|   847k|            last_monotonic = t2;
  245|   847k|            last_tsc = tsc2;
  246|   847k|            let elapsed_nanos = (t2 - t1).as_nanos();
  247|   847k|            if elapsed_nanos > 10_000_000 {
  248|      5|                cycles_per_sec = (tsc2 - tsc1) as f64 * 1_000_000_000.0 / elapsed_nanos as f64;
  249|      5|                break;
  250|   847k|            }
  251|       |        }
  252|      5|        let delta = f64::abs(cycles_per_sec - old_cycles);
  253|      5|        if delta / cycles_per_sec < 0.00001 {
  254|      2|            break;
  255|      3|        }
  256|      3|        old_cycles = cycles_per_sec;
  257|       |    }
  258|       |
  259|      2|    (cycles_per_sec.round() as u64, last_monotonic, last_tsc)
  260|      2|}
_RNvMs_NtCsb65tUIcjYgD_8minstant7tsc_nowNtB4_8TSCLevel3get:
   84|      2|    fn get() -> TSCLevel {
   85|      2|        let anchor = Instant::now();
   86|      2|        if is_tsc_stable() {
   87|      2|            let (cps, cfa) = cycles_per_sec(anchor);
   88|      2|            return TSCLevel::Stable {
   89|      2|                cycles_per_second: cps,
   90|      2|                cycles_from_anchor: cfa,
   91|      2|            };
   92|      0|        }
   93|      0|
   94|      0|        if is_tsc_percpu_stable() {
   95|       |            // Retrieve the IDs of all active CPUs.
   96|      0|            let cpuids = if let Ok(cpuids) = available_cpus() {
   97|      0|                if cpuids.is_empty() {
   98|      0|                    return TSCLevel::Unstable;
   99|      0|                }
  100|      0|
  101|      0|                cpuids
  102|       |            } else {
  103|      0|                return TSCLevel::Unstable;
  104|       |            };
  105|       |
  106|      0|            let max_cpu_id = *cpuids.iter().max().unwrap();
  107|      0|
  108|      0|            // Spread the threads to all CPUs and calculate
  109|      0|            // cycles from anchor separately
  110|      0|            let handles = cpuids.into_iter().map(|id| {
  111|       |                std::thread::spawn(move || {
  112|       |                    set_affinity(id).unwrap();
  113|       |
  114|       |                    // check if cpu id matches IA32_TSC_AUX
  115|       |                    let (_, cpuid) = tsc_with_cpuid();
  116|       |                    assert_eq!(cpuid, id);
  117|       |
  118|       |                    let (cps, cfa) = cycles_per_sec(anchor);
  119|       |
  120|       |                    (id, cps, cfa)
  121|       |                })
  122|      0|            });
  123|      0|
  124|      0|            // Block and wait for all threads finished
  125|      0|            let results = handles.map(|h| h.join()).collect::<Result<Vec<_>, _>>();
  126|       |
  127|      0|            let results = if let Ok(results) = results {
  128|      0|                results
  129|       |            } else {
  130|      0|                return TSCLevel::Unstable;
  131|       |            };
  132|       |
  133|       |            // Indexed by CPU ID
  134|      0|            let mut cycles_from_anchor = vec![0; max_cpu_id + 1];
  135|      0|
  136|      0|            // Rates of TSCs on different CPUs won't be a big gap
  137|      0|            // or it's unstable.
  138|      0|            let mut max_cps = std::u64::MIN;
  139|      0|            let mut min_cps = std::u64::MAX;
  140|      0|            let mut sum_cps = 0;
  141|      0|            let len = results.len();
  142|      0|            for (cpuid, cps, cfa) in results {
  143|      0|                if cps > max_cps {
  144|      0|                    max_cps = cps;
  145|      0|                }
  146|      0|                if cps < min_cps {
  147|      0|                    min_cps = cps;
  148|      0|                }
  149|      0|                sum_cps += cps;
  150|      0|                cycles_from_anchor[cpuid] = cfa;
  151|       |            }
  152|      0|            if (max_cps - min_cps) as f64 / min_cps as f64 > 0.0005 {
  153|      0|                return TSCLevel::Unstable;
  154|      0|            }
  155|      0|
  156|      0|            return TSCLevel::PerCPUStable {
  157|      0|                cycles_per_second: sum_cps / len as u64,
  158|      0|                cycles_from_anchor,
  159|      0|            };
  160|      0|        }
  161|      0|
  162|      0|        TSCLevel::Unstable
  163|      2|    }
_RNvNtCsb65tUIcjYgD_8minstant7tsc_now4init:
   29|      2|unsafe fn init() {
   30|      2|    let tsc_level = TSCLevel::get();
   31|      2|    let is_tsc_available = match &tsc_level {
   32|      2|        TSCLevel::Stable { .. } => true,
   33|      0|        TSCLevel::PerCPUStable { .. } => true,
   34|      0|        TSCLevel::Unstable => false,
   35|       |    };
   36|      2|    if is_tsc_available {
   37|      2|        *TSC_STATE.nanos_per_cycle.get() = 1_000_000_000.0 / tsc_level.cycles_per_second() as f64;
   38|      2|    }
   39|      2|    *TSC_STATE.is_tsc_available.get() = is_tsc_available;
   40|      2|    *TSC_STATE.tsc_level.get() = tsc_level;
   41|      2|    std::sync::atomic::fence(std::sync::atomic::Ordering::SeqCst);
   42|      2|}
_RNvNvNtCsb65tUIcjYgD_8minstant7tsc_now23init___rust_ctor___ctor23init___rust_ctor___ctor:
   28|      2|#[ctor::ctor]

_RINvMNtCs7gPi1FoENCg_9multibase4baseNtB3_4Base6encodeRShECs4ieSHZHrxF6_15direct_syscalls:
   34|    326|            pub fn encode<I: AsRef<[u8]>>(&self, input: I) -> String {
   35|    326|                match self {
   36|      0|                    $( Self::$base => $base::encode(input), )*
   37|       |                }
   38|    326|            }
_RNvMNtCs7gPi1FoENCg_9multibase4baseNtB2_4Base4code:
   27|    326|            pub fn code(&self) -> char {
   28|    326|                match self {
   29|       |                    $( Self::$base => $code, )*
   30|       |                }
   31|    326|            }

_RINvXsc_NtCs7gPi1FoENCg_9multibase5implsNtB6_11Base32LowerNtB6_9BaseCodec6encodeRShECs4ieSHZHrxF6_15direct_syscalls:
   15|    326|                fn encode<I: AsRef<[u8]>>(input: I) -> String {
   16|    326|                    $encoding.encode(input.as_ref())
   17|    326|                }

_RINvCs7gPi1FoENCg_9multibase6encodeAhj10_ECs4ieSHZHrxF6_15direct_syscalls:
   51|    163|pub fn encode<T: AsRef<[u8]>>(base: Base, input: T) -> String {
   52|    163|    let input = input.as_ref();
   53|    163|    let mut encoded = base.encode(input.as_ref());
   54|    163|    encoded.insert(0, base.code());
   55|    163|    encoded
   56|    163|}
_RINvCs7gPi1FoENCg_9multibase6encodeRShECs4ieSHZHrxF6_15direct_syscalls:
   51|    163|pub fn encode<T: AsRef<[u8]>>(base: Base, input: T) -> String {
   52|    163|    let input = input.as_ref();
   53|    163|    let mut encoded = base.encode(input.as_ref());
   54|    163|    encoded.insert(0, base.code());
   55|    163|    encoded
   56|    163|}

_RNvXNtNtCsfosZzS9GNaO_9multihash11hasher_impl7blake2bINtB2_13Blake2bHasherKj20_ENtNtCsdRJjCzU6nMS_4core7default7Default7defaultB6_:
   35|  1.14k|            fn default() -> Self {
   36|  1.14k|                let mut params = $module::Params::new();
   37|  1.14k|                params.hash_length(S);
   38|  1.14k|                Self {
   39|  1.14k|                    state: params.to_state(),
   40|  1.14k|                    digest: [0; S],
   41|  1.14k|                }
   42|  1.14k|            }
_RNvXs_NtNtCsfosZzS9GNaO_9multihash11hasher_impl7blake2bINtB4_13Blake2bHasherKj20_ENtNtB8_6hasher6Hasher6updateB8_:
   46|  1.14k|            fn update(&mut self, input: &[u8]) {
   47|  1.14k|                self.state.update(input);
   48|  1.14k|            }
_RNvXs_NtNtCsfosZzS9GNaO_9multihash11hasher_impl7blake2bINtB4_13Blake2bHasherKj20_ENtNtB8_6hasher6Hasher8finalizeB8_:
   50|  1.14k|            fn finalize(&mut self) -> &[u8] {
   51|  1.14k|                let digest = self.state.finalize();
   52|  1.14k|                let digest_bytes = digest.as_bytes();
   53|  1.14k|                let digest_out = &mut self.digest[..digest_bytes.len().max(S)];
   54|  1.14k|                digest_out.copy_from_slice(digest_bytes);
   55|  1.14k|                digest_out
   56|  1.14k|            }

_RINvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB5_9MultihashKj40_E5writeQQINtNtCs71iYhC60HpU_5alloc3vec3VechEECs4ieSHZHrxF6_15direct_syscalls:
  163|  2.44k|    pub fn write<W: io::Write>(&self, w: W) -> Result<(), Error> {
  164|  2.44k|        write_multihash(w, self.code(), self.size(), self.digest())
  165|  2.44k|    }
_RINvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB5_9MultihashKj40_E4readQRShECs4ieSHZHrxF6_15direct_syscalls:
  135|  4.89k|    pub fn read<R: io::Read>(r: R) -> Result<Self, Error>
  136|  4.89k|    where
  137|  4.89k|        Self: Sized,
  138|  4.89k|    {
  139|  4.89k|        let (code, size, digest) = read_multihash(r)?;
  140|  4.89k|        Ok(Self { code, size, digest })
  141|  4.89k|    }
_RNvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB4_9MultihashKj40_E4sizeCs4ieSHZHrxF6_15direct_syscalls:
  125|  2.44k|    pub const fn size(&self) -> u8 {
  126|  2.44k|        self.size
  127|  2.44k|    }
_RNvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB4_9MultihashKj40_E4codeCs4ieSHZHrxF6_15direct_syscalls:
  120|  2.44k|    pub const fn code(&self) -> u64 {
  121|  2.44k|        self.code
  122|  2.44k|    }
_RINvXs0_NtCsfosZzS9GNaO_9multihash9multihashINtB6_9MultihashKj40_ENtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECs4ieSHZHrxF6_15direct_syscalls:
  239|  9.29k|    fn hash<T: core::hash::Hasher>(&self, state: &mut T) {
  240|  9.29k|        self.code.hash(state);
  241|  9.29k|        self.digest().hash(state);
  242|  9.29k|    }
_RINvNtCsfosZzS9GNaO_9multihash9multihash14read_multihashQRShKj40_ECs4ieSHZHrxF6_15direct_syscalls:
  318|  4.89k|pub fn read_multihash<R, const S: usize>(mut r: R) -> Result<(u64, u8, [u8; S]), Error>
  319|  4.89k|where
  320|  4.89k|    R: io::Read,
  321|  4.89k|{
  322|  4.89k|    let code = read_u64(&mut r)?;
  323|  4.89k|    let size = read_u64(&mut r)?;
  324|       |
  325|  4.89k|    if size > S as u64 || size > u8::MAX as u64 {
  326|      0|        return Err(Error::InvalidSize(size));
  327|  4.89k|    }
  328|  4.89k|
  329|  4.89k|    let mut digest = [0; S];
  330|  4.89k|    r.read_exact(&mut digest[..size as usize])?;
  331|  4.89k|    Ok((code, size as u8, digest))
  332|  4.89k|}
_RNvXs2_NtCsfosZzS9GNaO_9multihash9multihashINtB5_9MultihashKj40_ENtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eqCs4ieSHZHrxF6_15direct_syscalls:
  253|    174|    fn eq(&self, other: &Multihash<B>) -> bool {
  254|    174|        // NOTE: there's no need to explicitly check the sizes, that's implicit in the digest.
  255|    174|        self.code == other.code && self.digest() == other.digest()
  256|    174|    }
_RINvNtCsfosZzS9GNaO_9multihash9multihash15write_multihashQQINtNtCs71iYhC60HpU_5alloc3vec3VechEECs4ieSHZHrxF6_15direct_syscalls:
  296|  2.44k|pub fn write_multihash<W>(mut w: W, code: u64, size: u8, digest: &[u8]) -> Result<(), Error>
  297|  2.44k|where
  298|  2.44k|    W: io::Write,
  299|  2.44k|{
  300|  2.44k|    let mut code_buf = varint_encode::u64_buffer();
  301|  2.44k|    let code = varint_encode::u64(code, &mut code_buf);
  302|  2.44k|
  303|  2.44k|    let mut size_buf = varint_encode::u8_buffer();
  304|  2.44k|    let size = varint_encode::u8(size, &mut size_buf);
  305|  2.44k|
  306|  2.44k|    w.write_all(code)?;
  307|  2.44k|    w.write_all(size)?;
  308|  2.44k|    w.write_all(digest)?;
  309|  2.44k|    Ok(())
  310|  2.44k|}
_RNvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB4_9MultihashKj40_E6digestCs4ieSHZHrxF6_15direct_syscalls:
  130|  12.0k|    pub fn digest(&self) -> &[u8] {
  131|  12.0k|        &self.digest[..self.size as usize]
  132|  12.0k|    }
_RINvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB5_9MultihashKj40_E4readQRShECsilvC8qPft2D_8fvm_fuzz:
  135|  2.77k|    pub fn read<R: io::Read>(r: R) -> Result<Self, Error>
  136|  2.77k|    where
  137|  2.77k|        Self: Sized,
  138|  2.77k|    {
  139|  2.77k|        let (code, size, digest) = read_multihash(r)?;
  140|  2.77k|        Ok(Self { code, size, digest })
  141|  2.77k|    }
_RINvNtCsfosZzS9GNaO_9multihash9multihash14read_multihashQINtNtNtCslmThs0IH7zH_3std2io6cursor6CursorRINtNtCs71iYhC60HpU_5alloc3vec3VechEEKj40_ECsilvC8qPft2D_8fvm_fuzz:
  318|  2.77k|pub fn read_multihash<R, const S: usize>(mut r: R) -> Result<(u64, u8, [u8; S]), Error>
  319|  2.77k|where
  320|  2.77k|    R: io::Read,
  321|  2.77k|{
  322|  2.77k|    let code = read_u64(&mut r)?;
  323|  2.77k|    let size = read_u64(&mut r)?;
  324|       |
  325|  2.77k|    if size > S as u64 || size > u8::MAX as u64 {
  326|      0|        return Err(Error::InvalidSize(size));
  327|  2.77k|    }
  328|  2.77k|
  329|  2.77k|    let mut digest = [0; S];
  330|  2.77k|    r.read_exact(&mut digest[..size as usize])?;
  331|  2.77k|    Ok((code, size as u8, digest))
  332|  2.77k|}
_RINvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB5_9MultihashKj40_E4readQINtNtNtCslmThs0IH7zH_3std2io6cursor6CursorRINtNtCs71iYhC60HpU_5alloc3vec3VechEEECsilvC8qPft2D_8fvm_fuzz:
  135|  2.77k|    pub fn read<R: io::Read>(r: R) -> Result<Self, Error>
  136|  2.77k|    where
  137|  2.77k|        Self: Sized,
  138|  2.77k|    {
  139|  2.77k|        let (code, size, digest) = read_multihash(r)?;
  140|  2.77k|        Ok(Self { code, size, digest })
  141|  2.77k|    }
_RINvNtCsfosZzS9GNaO_9multihash9multihash15write_multihashQQINtNtCs71iYhC60HpU_5alloc3vec3VechEECsilvC8qPft2D_8fvm_fuzz:
  296|    326|pub fn write_multihash<W>(mut w: W, code: u64, size: u8, digest: &[u8]) -> Result<(), Error>
  297|    326|where
  298|    326|    W: io::Write,
  299|    326|{
  300|    326|    let mut code_buf = varint_encode::u64_buffer();
  301|    326|    let code = varint_encode::u64(code, &mut code_buf);
  302|    326|
  303|    326|    let mut size_buf = varint_encode::u8_buffer();
  304|    326|    let size = varint_encode::u8(size, &mut size_buf);
  305|    326|
  306|    326|    w.write_all(code)?;
  307|    326|    w.write_all(size)?;
  308|    326|    w.write_all(digest)?;
  309|    326|    Ok(())
  310|    326|}
_RNvXs2_NtCsfosZzS9GNaO_9multihash9multihashINtB5_9MultihashKj40_ENtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eqCsilvC8qPft2D_8fvm_fuzz:
  253|    161|    fn eq(&self, other: &Multihash<B>) -> bool {
  254|    161|        // NOTE: there's no need to explicitly check the sizes, that's implicit in the digest.
  255|    161|        self.code == other.code && self.digest() == other.digest()
  256|    161|    }
_RNvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB4_9MultihashKj40_E6digestCsilvC8qPft2D_8fvm_fuzz:
  130|  9.93k|    pub fn digest(&self) -> &[u8] {
  131|  9.93k|        &self.digest[..self.size as usize]
  132|  9.93k|    }
_RINvXs0_NtCsfosZzS9GNaO_9multihash9multihashINtB6_9MultihashKj40_ENtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECsilvC8qPft2D_8fvm_fuzz:
  239|  9.29k|    fn hash<T: core::hash::Hasher>(&self, state: &mut T) {
  240|  9.29k|        self.code.hash(state);
  241|  9.29k|        self.digest().hash(state);
  242|  9.29k|    }
_RINvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB5_9MultihashKj40_E5writeQQINtNtCs71iYhC60HpU_5alloc3vec3VechEECsilvC8qPft2D_8fvm_fuzz:
  163|    326|    pub fn write<W: io::Write>(&self, w: W) -> Result<(), Error> {
  164|    326|        write_multihash(w, self.code(), self.size(), self.digest())
  165|    326|    }
_RNvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB4_9MultihashKj40_E4codeCsilvC8qPft2D_8fvm_fuzz:
  120|    326|    pub const fn code(&self) -> u64 {
  121|    326|        self.code
  122|    326|    }
_RNvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB4_9MultihashKj40_E4sizeCsilvC8qPft2D_8fvm_fuzz:
  125|    326|    pub const fn size(&self) -> u8 {
  126|    326|        self.size
  127|    326|    }
_RINvNtCsfosZzS9GNaO_9multihash9multihash14read_multihashQRShKj40_ECsilvC8qPft2D_8fvm_fuzz:
  318|  2.77k|pub fn read_multihash<R, const S: usize>(mut r: R) -> Result<(u64, u8, [u8; S]), Error>
  319|  2.77k|where
  320|  2.77k|    R: io::Read,
  321|  2.77k|{
  322|  2.77k|    let code = read_u64(&mut r)?;
  323|  2.77k|    let size = read_u64(&mut r)?;
  324|       |
  325|  2.77k|    if size > S as u64 || size > u8::MAX as u64 {
  326|      0|        return Err(Error::InvalidSize(size));
  327|  2.77k|    }
  328|  2.77k|
  329|  2.77k|    let mut digest = [0; S];
  330|  2.77k|    r.read_exact(&mut digest[..size as usize])?;
  331|  2.77k|    Ok((code, size as u8, digest))
  332|  2.77k|}
_RNvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB4_9MultihashKj40_E6digestCsf3d0o8dgc6o_19fvm_ipld_blockstore:
  130|  11.8k|    pub fn digest(&self) -> &[u8] {
  131|  11.8k|        &self.digest[..self.size as usize]
  132|  11.8k|    }
_RNvXs2_NtCsfosZzS9GNaO_9multihash9multihashINtB5_9MultihashKj40_ENtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eqCsf3d0o8dgc6o_19fvm_ipld_blockstore:
  253|  1.44k|    fn eq(&self, other: &Multihash<B>) -> bool {
  254|  1.44k|        // NOTE: there's no need to explicitly check the sizes, that's implicit in the digest.
  255|  1.44k|        self.code == other.code && self.digest() == other.digest()
  256|  1.44k|    }
_RINvXs0_NtCsfosZzS9GNaO_9multihash9multihashINtB6_9MultihashKj40_ENtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECsf3d0o8dgc6o_19fvm_ipld_blockstore:
  239|  8.96k|    fn hash<T: core::hash::Hasher>(&self, state: &mut T) {
  240|  8.96k|        self.code.hash(state);
  241|  8.96k|        self.digest().hash(state);
  242|  8.96k|    }
_RNvMs_NtCsfosZzS9GNaO_9multihash9multihashINtB4_9MultihashKj40_E4wrapB6_:
  101|  1.14k|    pub const fn wrap(code: u64, input_digest: &[u8]) -> Result<Self, Error> {
  102|  1.14k|        if input_digest.len() > S {
  103|      0|            return Err(Error::InvalidSize(input_digest.len() as _));
  104|  1.14k|        }
  105|  1.14k|        let size = input_digest.len();
  106|  1.14k|        let mut digest = [0; S];
  107|  1.14k|        let mut i = 0;
  108|  37.6k|        while i < size {
  109|  36.5k|            digest[i] = input_digest[i];
  110|  36.5k|            i += 1;
  111|  36.5k|        }
  112|  1.14k|        Ok(Self {
  113|  1.14k|            code,
  114|  1.14k|            size: size as u8,
  115|  1.14k|            digest,
  116|  1.14k|        })
  117|  1.14k|    }

_RNvXs3_NtCsfosZzS9GNaO_9multihash14multihash_implNtB5_4CodeINtNtB7_9multihash15MultihashDigestKj40_E6digest:
   11|  1.14k|#[derive(Copy, Clone, Debug, Eq, Multihash, PartialEq)]

_RNvXs5_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigIntNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  134|    489|    fn default() -> BigInt {
  135|    489|        Zero::zero()
  136|    489|    }
_RNvXse_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigIntNtNtCsfVZxj7gvuuV_10num_traits10identities4Zero4zero:
  213|  1.14k|    fn zero() -> BigInt {
  214|  1.14k|        BigInt {
  215|  1.14k|            sign: NoSign,
  216|  1.14k|            data: BigUint::zero(),
  217|  1.14k|        }
  218|  1.14k|    }
_RNvMsm_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigInt11to_bytes_be:
  731|    489|    pub fn to_bytes_be(&self) -> (Sign, Vec<u8>) {
  732|    489|        (self.sign, self.data.to_bytes_be())
  733|    489|    }
_RNvXso_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_4SignNtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eq:
   40|  1.30k|#[derive(PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash)]
_RNvXs_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB4_6BigIntNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   71|  1.46k|    fn clone(&self) -> Self {
   72|  1.46k|        BigInt {
   73|  1.46k|            sign: self.sign,
   74|  1.46k|            data: self.data.clone(),
   75|  1.46k|        }
   76|  1.46k|    }
_RNvMsm_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigInt12from_biguint:
  582|    490|    pub fn from_biguint(mut sign: Sign, mut data: BigUint) -> BigInt {
  583|    490|        if sign == NoSign {
  584|      0|            data.assign_from_slice(&[]);
  585|    490|        } else if data.is_zero() {
  586|    326|            sign = NoSign;
  587|    326|        }
  588|       |
  589|    490|        BigInt { sign, data }
  590|    490|    }
_RNvXsg_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigIntNtNtCsfVZxj7gvuuV_10num_traits4sign6Signed3abs:
  255|    326|    fn abs(&self) -> BigInt {
  256|    326|        match self.sign {
  257|    326|            Plus | NoSign => self.clone(),
  258|      0|            Minus => BigInt::from(self.data.clone()),
  259|       |        }
  260|    326|    }
_RNvXsg_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigIntNtNtCsfVZxj7gvuuV_10num_traits4sign6Signed11is_negative:
  286|    652|    fn is_negative(&self) -> bool {
  287|    652|        self.sign == Minus
  288|    652|    }
_RNvXsj_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigIntNtCsczAYc7pH3nB_11num_integer7Integer7div_rem:
  356|    163|    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {
  357|    163|        // r.sign == self.sign
  358|    163|        let (d_ui, r_ui) = self.data.div_rem(&other.data);
  359|    163|        let d = BigInt::from_biguint(self.sign, d_ui);
  360|    163|        let r = BigInt::from_biguint(self.sign, r_ui);
  361|    163|        if other.is_negative() {
  362|      0|            (-d, r)
  363|       |        } else {
  364|    163|            (d, r)
  365|       |        }
  366|    163|    }
_RNvMsm_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigInt12to_str_radix:
  870|    326|    pub fn to_str_radix(&self, radix: u32) -> String {
  871|    326|        let mut v = to_str_radix_reversed(&self.data, radix);
  872|    326|
  873|    326|        if self.is_negative() {
  874|      0|            v.push(b'-');
  875|    326|        }
  876|       |
  877|    326|        v.reverse();
  878|    326|        unsafe { String::from_utf8_unchecked(v) }
  879|    326|    }
_RNvXse_NtCsjt7ToAeDLbB_10num_bigint6bigintNtB5_6BigIntNtNtCsfVZxj7gvuuV_10num_traits10identities4Zero7is_zero:
  227|    163|    fn is_zero(&self) -> bool {
  228|    163|        self.sign == NoSign
  229|    163|    }

_RNvXNtNtCsjt7ToAeDLbB_10num_bigint6bigint7convertNtB4_6BigIntNtNtNtCsdRJjCzU6nMS_4core3str6traits7FromStr8from_str:
   19|    163|    fn from_str(s: &str) -> Result<BigInt, ParseBigIntError> {
   20|    163|        BigInt::from_str_radix(s, 10)
   21|    163|    }
_RNvXs4_NtNtCsjt7ToAeDLbB_10num_bigint6bigint7convertNtB7_6BigIntINtNtCsdRJjCzU6nMS_4core7convert4FromyE4from:
  228|    327|    fn from(n: u64) -> Self {
  229|    327|        if n > 0 {
  230|    327|            BigInt {
  231|    327|                sign: Plus,
  232|    327|                data: BigUint::from(n),
  233|    327|            }
  234|       |        } else {
  235|      0|            BigInt::zero()
  236|       |        }
  237|    327|    }
_RNvXs_NtNtCsjt7ToAeDLbB_10num_bigint6bigint7convertNtB6_6BigIntNtCsfVZxj7gvuuV_10num_traits3Num14from_str_radix:
   29|    163|    fn from_str_radix(mut s: &str, radix: u32) -> Result<BigInt, ParseBigIntError> {
   30|    163|        let sign = if s.starts_with('-') {
   31|      0|            let tail = &s[1..];
   32|      0|            if !tail.starts_with('+') {
   33|      0|                s = tail
   34|      0|            }
   35|      0|            Minus
   36|       |        } else {
   37|    163|            Plus
   38|       |        };
   39|    163|        let bu = BigUint::from_str_radix(s, radix)?;
   40|    163|        Ok(BigInt::from_biguint(sign, bu))
   41|    163|    }
_RNvXs2_NtNtCsjt7ToAeDLbB_10num_bigint6bigint7convertNtB7_6BigIntINtNtCsdRJjCzU6nMS_4core7convert4FromxE4from:
  182|      1|    fn from(n: i64) -> Self {
  183|      1|        if n >= 0 {
  184|      1|            BigInt::from(n as u64)
  185|       |        } else {
  186|      0|            let u = core::u64::MAX - (n as u64) + 1;
  187|      0|            BigInt {
  188|      0|                sign: Minus,
  189|      0|                data: BigUint::from(u),
  190|      0|            }
  191|       |        }
  192|      1|    }

_RNvXs1_NtNtCsjt7ToAeDLbB_10num_bigint6bigint14multiplicationNtB7_6BigIntINtNtNtCsdRJjCzU6nMS_4core3ops5arith3MulyE3mul:
   97|      1|    fn mul(self, other: u64) -> BigInt {
   98|      1|        BigInt::from_biguint(self.sign, self.data * other)
   99|      1|    }

_RNvMsg_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB5_7BigUint11to_bytes_le:
  695|    489|    pub fn to_bytes_le(&self) -> Vec<u8> {
  696|    489|        if self.is_zero() {
  697|    489|            vec![0]
  698|       |        } else {
  699|      0|            convert::to_bitwise_digits_le(self, 8)
  700|       |        }
  701|    489|    }
_RNvMsg_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB5_7BigUint11to_bytes_be:
  678|    489|    pub fn to_bytes_be(&self) -> Vec<u8> {
  679|    489|        let mut v = self.to_bytes_le();
  680|    489|        v.reverse();
  681|    489|        v
  682|    489|    }
_RNvMsg_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB5_7BigUint9normalize:
  848|    326|    fn normalize(&mut self) {
  849|    326|        if let Some(&0) = self.data.last() {
  850|    326|            let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);
  851|    326|            self.data.truncate(len);
  852|    326|        }
  853|    326|        if self.data.len() < self.data.capacity() / 4 {
  854|      0|            self.data.shrink_to_fit();
  855|    326|        }
  856|    326|    }
_RNvXsb_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB5_7BigUintNtNtCsfVZxj7gvuuV_10num_traits10identities4Zero7is_zero:
  158|  2.12k|    fn is_zero(&self) -> bool {
  159|  2.12k|        self.data.is_empty()
  160|  2.12k|    }
_RNvXsb_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB5_7BigUintNtNtCsfVZxj7gvuuV_10num_traits10identities4Zero4zero:
  148|  1.63k|    fn zero() -> BigUint {
  149|  1.63k|        BigUint { data: Vec::new() }
  150|  1.63k|    }
_RNvXNtCsjt7ToAeDLbB_10num_bigint7biguintNtB2_7BigUintNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   46|  1.79k|    fn clone(&self) -> Self {
   47|  1.79k|        BigUint {
   48|  1.79k|            data: self.data.clone(),
   49|  1.79k|        }
   50|  1.79k|    }
_RNvMsg_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB5_7BigUint4bits:
  837|    163|    pub fn bits(&self) -> u64 {
  838|    163|        if self.is_zero() {
  839|      0|            return 0;
  840|    163|        }
  841|    163|        let zeros: u64 = self.data.last().unwrap().leading_zeros().into();
  842|    163|        self.data.len() as u64 * u64::from(big_digit::BITS) - zeros
  843|    163|    }
_RNvMsg_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB5_7BigUint10normalized:
  860|    326|    fn normalized(mut self) -> BigUint {
  861|    326|        self.normalize();
  862|    326|        self
  863|    326|    }
_RNvXse_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB5_7BigUintNtCsczAYc7pH3nB_11num_integer7Integer7div_rem:
  185|    163|    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {
  186|    163|        division::div_rem_ref(self, other)
  187|    163|    }
_RNCNvMsg_NtCsjt7ToAeDLbB_10num_bigint7biguintNtB7_7BigUint9normalize0B9_:
  850|    326|            let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);
_RNvNtCsjt7ToAeDLbB_10num_bigint7biguint16biguint_from_vec:
  514|    163|pub(crate) fn biguint_from_vec(digits: Vec<BigDigit>) -> BigUint {
  515|    163|    BigUint { data: digits }.normalized()
  516|    163|}

_RNvXs2_NtNtCsjt7ToAeDLbB_10num_bigint7biguint7convertNtB7_7BigUintINtNtCsdRJjCzU6nMS_4core7convert4FromyE4from:
  476|    490|    fn from(mut n: u64) -> Self {
  477|    490|        let mut ret: BigUint = Zero::zero();
  478|       |
  479|    980|        while n != 0 {
  480|    490|            ret.data.push(n as BigDigit);
  481|    490|            // don't overflow if BITS is 64:
  482|    490|            n = (n >> 1) >> (big_digit::BITS - 1);
  483|    490|        }
  484|       |
  485|    490|        ret
  486|    490|    }
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint7convert14get_radix_base:
  757|    326|fn get_radix_base(radix: u32, bits: u8) -> (BigDigit, usize) {
  758|       |    mod gen {
  759|       |        include! { concat!(env!("OUT_DIR"), "/radix_bases.rs") }
  760|       |    }
  761|       |
  762|       |    debug_assert!(
  763|    326|        2 <= radix && radix <= 256,
  764|       |        "The radix must be within 2...256"
  765|       |    );
  766|    326|    debug_assert!(!radix.is_power_of_two());
  767|    326|    debug_assert!(bits <= big_digit::BITS);
  768|       |
  769|    326|    match bits {
  770|       |        16 => {
  771|      0|            let (base, power) = gen::BASES_16[radix as usize];
  772|      0|            (base as BigDigit, power)
  773|       |        }
  774|       |        32 => {
  775|    163|            let (base, power) = gen::BASES_32[radix as usize];
  776|    163|            (base as BigDigit, power)
  777|       |        }
  778|       |        64 => {
  779|    163|            let (base, power) = gen::BASES_64[radix as usize];
  780|    163|            (base as BigDigit, power)
  781|       |        }
  782|      0|        _ => panic!("Invalid bigdigit size"),
  783|       |    }
  784|    326|}
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint7convert20from_radix_digits_be:
  101|    163|fn from_radix_digits_be(v: &[u8], radix: u32) -> BigUint {
  102|    163|    debug_assert!(!v.is_empty() && !radix.is_power_of_two());
  103|    163|    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));
  104|       |
  105|       |    #[cfg(feature = "std")]
  106|    163|    let radix_log2 = f64::from(radix).log2();
  107|    163|    #[cfg(not(feature = "std"))]
  108|    163|    let radix_log2 = ilog2(radix.next_power_of_two()) as f64;
  109|    163|
  110|    163|    // Estimate how big the result will be, so we can pre-allocate it.
  111|    163|    let bits = radix_log2 * v.len() as f64;
  112|    163|    let big_digits = (bits / big_digit::BITS as f64).ceil();
  113|    163|    let mut data = Vec::with_capacity(big_digits.to_usize().unwrap_or(0));
  114|    163|
  115|    163|    let (base, power) = get_radix_base(radix, big_digit::BITS);
  116|    163|    let radix = radix as BigDigit;
  117|    163|
  118|    163|    let r = v.len() % power;
  119|    163|    let i = if r == 0 { power } else { r };
  120|    163|    let (head, tail) = v.split_at(i);
  121|    163|
  122|    163|    let first = head
  123|    163|        .iter()
  124|    163|        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
  125|    163|    data.push(first);
  126|       |
  127|    163|    debug_assert!(tail.len() % power == 0);
  128|    163|    for chunk in tail.chunks(power) {
  129|      0|        if data.last() != Some(&0) {
  130|      0|            data.push(0);
  131|      0|        }
  132|       |
  133|      0|        let mut carry = 0;
  134|      0|        for d in data.iter_mut() {
  135|      0|            *d = mac_with_carry(0, *d, base, &mut carry);
  136|      0|        }
  137|      0|        debug_assert!(carry == 0);
  138|       |
  139|      0|        let n = chunk
  140|      0|            .iter()
  141|      0|            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
  142|      0|        add2(&mut data, &[n]);
  143|       |    }
  144|       |
  145|    163|    biguint_from_vec(data)
  146|    163|}
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint7convert21to_str_radix_reversed:
  734|    326|pub(crate) fn to_str_radix_reversed(u: &BigUint, radix: u32) -> Vec<u8> {
  735|    326|    assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
  736|       |
  737|    326|    if u.is_zero() {
  738|    163|        return vec![b'0'];
  739|    163|    }
  740|    163|
  741|    163|    let mut res = to_radix_le(u, radix);
  742|       |
  743|       |    // Now convert everything to ASCII digits.
  744|    652|    for r in &mut res {
  745|    489|        debug_assert!(u32::from(*r) < radix);
  746|    489|        if *r < 10 {
  747|    489|            *r += b'0';
  748|    489|        } else {
  749|      0|            *r += b'a' - 10;
  750|      0|        }
  751|       |    }
  752|    163|    res
  753|    326|}
_RNCNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint7convert20from_radix_digits_be0B7_:
  124|    163|        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
_RNCNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint7convert20from_radix_digits_bes0_0B7_:
  103|    163|    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint7convert18to_radix_digits_le:
  646|    163|pub(super) fn to_radix_digits_le(u: &BigUint, radix: u32) -> Vec<u8> {
  647|    163|    debug_assert!(!u.is_zero() && !radix.is_power_of_two());
  648|       |
  649|       |    #[cfg(feature = "std")]
  650|    163|    let radix_log2 = f64::from(radix).log2();
  651|    163|    #[cfg(not(feature = "std"))]
  652|    163|    let radix_log2 = ilog2(radix) as f64;
  653|    163|
  654|    163|    // Estimate how big the result will be, so we can pre-allocate it.
  655|    163|    let radix_digits = ((u.bits() as f64) / radix_log2).ceil();
  656|    163|    let mut res = Vec::with_capacity(radix_digits.to_usize().unwrap_or(0));
  657|    163|
  658|    163|    let mut digits = u.clone();
  659|    163|
  660|    163|    let (base, power) = get_radix_base(radix, big_digit::HALF_BITS);
  661|    163|    let radix = radix as BigDigit;
  662|    163|
  663|    163|    // For very large numbers, the O(n²) loop of repeated `div_rem_digit` dominates the
  664|    163|    // performance. We can mitigate this by dividing into chunks of a larger base first.
  665|    163|    // The threshold for this was chosen by anecdotal performance measurements to
  666|    163|    // approximate where this starts to make a noticeable difference.
  667|    163|    if digits.data.len() >= 64 {
  668|      0|        let mut big_base = BigUint::from(base * base);
  669|      0|        let mut big_power = 2usize;
  670|      0|
  671|      0|        // Choose a target base length near √n.
  672|      0|        let target_len = digits.data.len().sqrt();
  673|      0|        while big_base.data.len() < target_len {
  674|      0|            big_base = &big_base * &big_base;
  675|      0|            big_power *= 2;
  676|      0|        }
  677|       |
  678|       |        // This outer loop will run approximately √n times.
  679|      0|        while digits > big_base {
  680|       |            // This is still the dominating factor, with n digits divided by √n digits.
  681|      0|            let (q, mut big_r) = digits.div_rem(&big_base);
  682|      0|            digits = q;
  683|      0|
  684|      0|            // This inner loop now has O(√n²)=O(n) behavior altogether.
  685|      0|            for _ in 0..big_power {
  686|      0|                let (q, mut r) = div_rem_digit(big_r, base);
  687|      0|                big_r = q;
  688|      0|                for _ in 0..power {
  689|      0|                    res.push((r % radix) as u8);
  690|      0|                    r /= radix;
  691|      0|                }
  692|       |            }
  693|       |        }
  694|    163|    }
  695|       |
  696|    163|    while digits.data.len() > 1 {
  697|      0|        let (q, mut r) = div_rem_digit(digits, base);
  698|      0|        for _ in 0..power {
  699|      0|            res.push((r % radix) as u8);
  700|      0|            r /= radix;
  701|      0|        }
  702|      0|        digits = q;
  703|       |    }
  704|       |
  705|    163|    let mut r = digits.data[0];
  706|    652|    while r != 0 {
  707|    489|        res.push((r % radix) as u8);
  708|    489|        r /= radix;
  709|    489|    }
  710|       |
  711|    163|    res
  712|    163|}
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint7convert11to_radix_le:
  714|    163|pub(super) fn to_radix_le(u: &BigUint, radix: u32) -> Vec<u8> {
  715|    163|    if u.is_zero() {
  716|      0|        vec![0]
  717|    163|    } else if radix.is_power_of_two() {
  718|       |        // Powers of two can use bitwise masks and shifting instead of division
  719|      0|        let bits = ilog2(radix);
  720|      0|        if big_digit::BITS % bits == 0 {
  721|      0|            to_bitwise_digits_le(u, bits)
  722|       |        } else {
  723|      0|            to_inexact_bitwise_digits_le(u, bits)
  724|       |        }
  725|    163|    } else if radix == 10 {
  726|       |        // 10 is so common that it's worth separating out for const-propagation.
  727|       |        // Optimizers can often turn constant division into a faster multiplication.
  728|    163|        to_radix_digits_le(u, 10)
  729|       |    } else {
  730|      0|        to_radix_digits_le(u, radix)
  731|       |    }
  732|    163|}
_RNvXs_NtNtCsjt7ToAeDLbB_10num_bigint7biguint7convertNtB6_7BigUintNtCsfVZxj7gvuuV_10num_traits3Num14from_str_radix:
  214|    163|    fn from_str_radix(s: &str, radix: u32) -> Result<BigUint, ParseBigIntError> {
  215|    163|        assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
  216|    163|        let mut s = s;
  217|    163|        if s.starts_with('+') {
  218|      0|            let tail = &s[1..];
  219|      0|            if !tail.starts_with('+') {
  220|      0|                s = tail
  221|      0|            }
  222|    163|        }
  223|       |
  224|    163|        if s.is_empty() {
  225|      0|            return Err(ParseBigIntError::empty());
  226|    163|        }
  227|    163|
  228|    163|        if s.starts_with('_') {
  229|       |            // Must lead with a real digit!
  230|      0|            return Err(ParseBigIntError::invalid());
  231|    163|        }
  232|    163|
  233|    163|        // First normalize all characters to plain digit values
  234|    163|        let mut v = Vec::with_capacity(s.len());
  235|    163|        for b in s.bytes() {
  236|    163|            let d = match b {
  237|    163|                b'0'..=b'9' => b - b'0',
  238|      0|                b'a'..=b'z' => b - b'a' + 10,
  239|      0|                b'A'..=b'Z' => b - b'A' + 10,
  240|      0|                b'_' => continue,
  241|      0|                _ => core::u8::MAX,
  242|       |            };
  243|    163|            if d < radix as u8 {
  244|    163|                v.push(d);
  245|    163|            } else {
  246|      0|                return Err(ParseBigIntError::invalid());
  247|       |            }
  248|       |        }
  249|       |
  250|    163|        let res = if radix.is_power_of_two() {
  251|       |            // Powers of two can use bitwise masks and shifting instead of multiplication
  252|      0|            let bits = ilog2(radix);
  253|      0|            v.reverse();
  254|      0|            if big_digit::BITS % bits == 0 {
  255|      0|                from_bitwise_digits_le(&v, bits)
  256|       |            } else {
  257|      0|                from_inexact_bitwise_digits_le(&v, bits)
  258|       |            }
  259|       |        } else {
  260|    163|            from_radix_digits_be(&v, radix)
  261|       |        };
  262|    163|        Ok(res)
  263|    163|    }

_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint8division11div_rem_ref:
  166|    163|pub(super) fn div_rem_ref(u: &BigUint, d: &BigUint) -> (BigUint, BigUint) {
  167|    163|    if d.is_zero() {
  168|      0|        panic!("attempt to divide by zero")
  169|    163|    }
  170|    163|    if u.is_zero() {
  171|      0|        return (Zero::zero(), Zero::zero());
  172|    163|    }
  173|    163|
  174|    163|    if d.data.len() == 1 {
  175|    163|        if d.data == [1] {
  176|      0|            return (u.clone(), Zero::zero());
  177|    163|        }
  178|    163|
  179|    163|        let (div, rem) = div_rem_digit(u.clone(), d.data[0]);
  180|    163|        return (div, rem.into());
  181|      0|    }
  182|      0|
  183|      0|    // Required or the q_len calculation below can underflow:
  184|      0|    match u.cmp(d) {
  185|      0|        Less => return (Zero::zero(), u.clone()),
  186|      0|        Equal => return (One::one(), Zero::zero()),
  187|      0|        Greater => {} // Do nothing
  188|      0|    }
  189|      0|
  190|      0|    // This algorithm is from Knuth, TAOCP vol 2 section 4.3, algorithm D:
  191|      0|    //
  192|      0|    // First, normalize the arguments so the highest bit in the highest digit of the divisor is
  193|      0|    // set: the main loop uses the highest digit of the divisor for generating guesses, so we
  194|      0|    // want it to be the largest number we can efficiently divide by.
  195|      0|    //
  196|      0|    let shift = d.data.last().unwrap().leading_zeros() as usize;
  197|      0|
  198|      0|    if shift == 0 {
  199|       |        // no need to clone d
  200|      0|        div_rem_core(u.clone(), &d.data)
  201|       |    } else {
  202|      0|        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
  203|      0|        // renormalize the remainder
  204|      0|        (q, r >> shift)
  205|       |    }
  206|    163|}
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint8division8div_wide:
   22|    163|fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
   23|    163|    debug_assert!(hi < divisor);
   24|       |
   25|    163|    let lhs = big_digit::to_doublebigdigit(hi, lo);
   26|    163|    let rhs = DoubleBigDigit::from(divisor);
   27|    163|    ((lhs / rhs) as BigDigit, (lhs % rhs) as BigDigit)
   28|    163|}
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint8division13div_rem_digit:
   43|    163|pub(super) fn div_rem_digit(mut a: BigUint, b: BigDigit) -> (BigUint, BigDigit) {
   44|    163|    if b == 0 {
   45|      0|        panic!("attempt to divide by zero")
   46|    163|    }
   47|    163|
   48|    163|    let mut rem = 0;
   49|    163|
   50|    163|    if b <= big_digit::HALF {
   51|      0|        for d in a.data.iter_mut().rev() {
   52|      0|            let (q, r) = div_half(rem, *d, b);
   53|      0|            *d = q;
   54|      0|            rem = r;
   55|      0|        }
   56|       |    } else {
   57|    163|        for d in a.data.iter_mut().rev() {
   58|    163|            let (q, r) = div_wide(rem, *d, b);
   59|    163|            *d = q;
   60|    163|            rem = r;
   61|    163|        }
   62|       |    }
   63|       |
   64|    163|    (a.normalized(), rem)
   65|    163|}

_RNvXs1_NtNtCsjt7ToAeDLbB_10num_bigint7biguint14multiplicationNtB7_7BigUintINtNtNtCsdRJjCzU6nMS_4core3ops5arith9MulAssignyE10mul_assign:
  500|      1|    fn mul_assign(&mut self, other: u64) {
  501|      1|        scalar_mul(self, other);
  502|      1|    }
_RNvXs0_NtNtCsjt7ToAeDLbB_10num_bigint7biguint14multiplicationNtB7_7BigUintINtNtNtCsdRJjCzU6nMS_4core3ops5arith3MulyE3mul:
  481|      1|    fn mul(mut self, other: u64) -> BigUint {
  482|      1|        self *= other;
  483|      1|        self
  484|      1|    }
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint14multiplication14mul_with_carry:
   31|      1|fn mul_with_carry(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
   32|      1|    *acc += DoubleBigDigit::from(a) * DoubleBigDigit::from(b);
   33|      1|    let lo = *acc as BigDigit;
   34|      1|    *acc >>= big_digit::BITS;
   35|      1|    lo
   36|      1|}
_RNvNtNtCsjt7ToAeDLbB_10num_bigint7biguint14multiplication10scalar_mul:
  360|      1|fn scalar_mul(a: &mut BigUint, b: BigDigit) {
  361|      1|    match b {
  362|      0|        0 => a.set_zero(),
  363|      0|        1 => {}
  364|       |        _ => {
  365|      1|            if b.is_power_of_two() {
  366|      0|                *a <<= b.trailing_zeros();
  367|      0|            } else {
  368|      1|                let mut carry = 0;
  369|      1|                for a in a.data.iter_mut() {
  370|      1|                    *a = mul_with_carry(*a, b, &mut carry);
  371|      1|                }
  372|      1|                if carry != 0 {
  373|      1|                    a.data.push(carry as BigDigit);
  374|      1|                }
  375|       |            }
  376|       |        }
  377|       |    }
  378|      1|}

_RNvNtCsjt7ToAeDLbB_10num_bigint9big_digit17to_doublebigdigit:
  291|    163|    pub(crate) fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {
  292|    163|        DoubleBigDigit::from(lo) | (DoubleBigDigit::from(hi) << BITS)
  293|    163|    }

_RNvXse_NtCsfVZxj7gvuuV_10num_traits4castdNtB5_11ToPrimitive8to_usize:
  344|    326|        fn $method(&self) -> Option<$u> {
  345|    326|            // Float as int truncates toward zero, so we want to allow values
  346|    326|            // in the exclusive range `(-1, MAX+1)`.
  347|    326|            if size_of::<$f>() > size_of::<$u>() {
  348|       |                // With a larger size, we can represent the range exactly.
  349|       |                const MAX_P1: $f = $u::MAX as $f + 1.0;
  350|      0|                if *self > -1.0 && *self < MAX_P1 {
  351|      0|                    return Some(float_to_int_unchecked!(*self => $u));
  352|      0|                }
  353|       |            } else {
  354|       |                // We can't represent `MAX` exactly, but it will round up to exactly
  355|       |                // `MAX+1` (a power of two) when we cast it.
  356|       |                // (`u128::MAX as f32` is infinity, but this is still ok.)
  357|       |                const MAX_P1: $f = $u::MAX as $f;
  358|    326|                if *self > -1.0 && *self < MAX_P1 {
  359|    326|                    return Some(float_to_int_unchecked!(*self => $u));
  360|      0|                }
  361|       |            }
  362|      0|            None
  363|    326|        }

_RNvMs2_NtCs2Fkrr4NdoaA_9once_cell3impINtB5_8OnceCellNtNtCs71iYhC60HpU_5alloc6string6StringE14is_initializedCs4ieSHZHrxF6_15direct_syscalls:
   59|    163|    pub(crate) fn is_initialized(&self) -> bool {
   60|    163|        // An `Acquire` load is enough because that makes all the initialization
   61|    163|        // operations visible to us, and, this being a fast path, weaker
   62|    163|        // ordering helps with performance. This `Acquire` synchronizes with
   63|    163|        // `SeqCst` operations on the slow path.
   64|    163|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   65|    163|    }
_RNvMs2_NtCs2Fkrr4NdoaA_9once_cell3impINtB5_8OnceCellNtNtCsdRJjCzU6nMS_4core4time8DurationE3newCsheoVkkQew6K_3fvm:
   41|    163|    pub(crate) const fn new() -> OnceCell<T> {
   42|    163|        OnceCell {
   43|    163|            queue: AtomicPtr::new(INCOMPLETE_PTR),
   44|    163|            _marker: PhantomData,
   45|    163|            value: UnsafeCell::new(None),
   46|    163|        }
   47|    163|    }
_RNvMs2_NtCs2Fkrr4NdoaA_9once_cell3impINtB5_8OnceCellINtNtCsdRJjCzU6nMS_4core6result6ResultuNtNtCs71iYhC60HpU_5alloc6string6StringEE3newCscE26HxwD491_8wasmtime:
   41|    326|    pub(crate) const fn new() -> OnceCell<T> {
   42|    326|        OnceCell {
   43|    326|            queue: AtomicPtr::new(INCOMPLETE_PTR),
   44|    326|            _marker: PhantomData,
   45|    326|            value: UnsafeCell::new(None),
   46|    326|        }
   47|    326|    }

_RNvMs4_NtCs2Fkrr4NdoaA_9once_cell4syncINtB5_8OnceCellNtNtCs71iYhC60HpU_5alloc6string6StringE3getCs4ieSHZHrxF6_15direct_syscalls:
  922|    163|        pub fn get(&self) -> Option<&T> {
  923|    163|            if self.0.is_initialized() {
  924|       |                // Safe b/c value is initialized.
  925|      0|                Some(unsafe { self.get_unchecked() })
  926|       |            } else {
  927|    163|                None
  928|       |            }
  929|    163|        }
_RNvMs4_NtCs2Fkrr4NdoaA_9once_cell4syncINtB5_8OnceCellNtNtCsdRJjCzU6nMS_4core4time8DurationE3newCsheoVkkQew6K_3fvm:
  909|    163|        pub const fn new() -> OnceCell<T> {
  910|    163|            OnceCell(Imp::new())
  911|    163|        }
_RNvXNtCs2Fkrr4NdoaA_9once_cell4syncINtB2_8OnceCellNtNtCsdRJjCzU6nMS_4core4time8DurationENtNtBQ_7default7Default7defaultCsheoVkkQew6K_3fvm:
  863|    163|        fn default() -> OnceCell<T> {
  864|    163|            OnceCell::new()
  865|    163|        }
_RNvMs4_NtCs2Fkrr4NdoaA_9once_cell4syncINtB5_8OnceCellINtNtCsdRJjCzU6nMS_4core6result6ResultuNtNtCs71iYhC60HpU_5alloc6string6StringEE3newCscE26HxwD491_8wasmtime:
  909|    326|        pub const fn new() -> OnceCell<T> {
  910|    326|            OnceCell(Imp::new())
  911|    326|        }

_RNvMNvNtNtCsll4ISZbKcbA_12futures_util2io4take1__INtB4_4TakeQRShE7projectCsilvC8qPft2D_8fvm_fuzz:
  926|  6.03k|        $proj_vis fn $method_ident<'__pin>(
  927|  6.03k|            self: $crate::__private::Pin<&'__pin $($mut)? Self>,
  928|  6.03k|        ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
  929|  6.03k|            unsafe {
  930|  6.03k|                let Self { $($field),* } = self.$get_method();
  931|  6.03k|                $proj_ty_ident {
  932|  6.03k|                    $(
  933|  6.03k|                        $field: $crate::__pin_project_make_unsafe_field_proj!(
  934|  6.03k|                            $(#[$pin])? $field
  935|  6.03k|                        )
  936|  6.03k|                    ),+
  937|  6.03k|                }
  938|  6.03k|            }
  939|  6.03k|        }

_RNvMNtCsbdpQ9YC9ceY_10ppv_lite864softINtB2_2x2INtNtNtNtB4_6x86_644sse24avx212u32x4x2_avx2NtBP_4NoNIENtBN_2G0E3newCs9wbMZuYrb6S_11rand_chacha:
   13|  5.61k|    pub fn new(xs: [W; 2]) -> Self {
   14|  5.61k|        x2(xs, PhantomData)
   15|  5.61k|    }
_RNvXsG_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtNtCsdRJjCzU6nMS_4core3ops3bit6BitXor6bitxorCs9wbMZuYrb6S_11rand_chacha:
   22|  1.96k|            fn $fn(self, rhs: Self) -> Self::Output {
   23|  1.96k|                x2::new([self.0[0].$fn(rhs.0[0]), self.0[1].$fn(rhs.0[1])])
   24|  1.96k|            }
_RNvXs_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right16Cs9wbMZuYrb6S_11rand_chacha:
   42|    492|        fn $fn(self) -> Self {
   43|    492|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    492|        }
_RNvXs_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right25Cs9wbMZuYrb6S_11rand_chacha:
   42|    492|        fn $fn(self) -> Self {
   43|    492|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    492|        }
_RNvXs_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right24Cs9wbMZuYrb6S_11rand_chacha:
   42|    492|        fn $fn(self) -> Self {
   43|    492|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    492|        }
_RNvXsM_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtNtCsdRJjCzU6nMS_4core3ops5arith9AddAssign10add_assignCs9wbMZuYrb6S_11rand_chacha:
   32|  1.96k|            fn $fn_assign(&mut self, rhs: Self) {
   33|  1.96k|                (self.0[0]).$fn_assign(rhs.0[0]);
   34|  1.96k|                (self.0[1]).$fn_assign(rhs.0[1]);
   35|  1.96k|            }
_RNvXsg_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words3012Cs9wbMZuYrb6S_11rand_chacha:
  215|    492|    fn shuffle_lane_words3012(self) -> Self {
  216|    492|        Self::new([
  217|    492|            self.0[0].shuffle_lane_words3012(),
  218|    492|            self.0[1].shuffle_lane_words3012(),
  219|    492|        ])
  220|    492|    }
_RNvXs_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right20Cs9wbMZuYrb6S_11rand_chacha:
   42|    492|        fn $fn(self) -> Self {
   43|    492|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    492|        }
_RNvXsg_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words2301Cs9wbMZuYrb6S_11rand_chacha:
  201|    492|    fn shuffle_lane_words2301(self) -> Self {
  202|    492|        Self::new([
  203|    492|            self.0[0].shuffle_lane_words2301(),
  204|    492|            self.0[1].shuffle_lane_words2301(),
  205|    492|        ])
  206|    492|    }
_RNvXsg_NtCsbdpQ9YC9ceY_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words1230Cs9wbMZuYrb6S_11rand_chacha:
  208|    492|    fn shuffle_lane_words1230(self) -> Self {
  209|    492|        Self::new([
  210|    492|            self.0[0].shuffle_lane_words1230(),
  211|    492|            self.0[1].shuffle_lane_words1230(),
  212|    492|        ])
  213|    492|    }

_RINvYINtNtCsbdpQ9YC9ceY_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine6unpackNtB6_14vec128_storageINtNtB6_4sse210u32x4_sse2NtB6_5YesS3NtB6_5YesS4BS_EECs9wbMZuYrb6S_11rand_chacha:
  246|    369|    fn unpack<S, V: Store<S>>(self, s: S) -> V {
  247|    369|        unsafe { V::unpack(s) }
  248|    369|    }
_RINvYINtNtCsbdpQ9YC9ceY_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine3vecINtNtB6_4sse210u32x4_sse2NtB6_5YesS3NtB6_5YesS4BS_EAmj4_ECs9wbMZuYrb6S_11rand_chacha:
  251|     41|    fn vec<V, A>(self, a: A) -> V
  252|     41|    where
  253|     41|        V: MultiLane<A>,
  254|     41|    {
  255|     41|        V::from_lanes(a)
  256|     41|    }
_RINvYINtNtCsbdpQ9YC9ceY_10ppv_lite866x86_6410SseMachineNtB6_5YesS3NtB6_5YesS4NtB6_4NoNIENtNtB8_5types7Machine7read_leINtNtB6_4sse210u32x4_sse2BR_B12_B1d_EECs9wbMZuYrb6S_11rand_chacha:
  259|      2|    fn read_le<V>(self, input: &[u8]) -> V
  260|      2|    where
  261|      2|        V: StoreBytes,
  262|      2|    {
  263|      2|        unsafe { V::unsafe_read_le(input) }
  264|      2|    }
_RINvYINtNtCsbdpQ9YC9ceY_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine6unpackNtB6_14vec512_storageINtNtB8_4soft2x2INtNtNtB6_4sse24avx212u32x4x2_avx2BS_ENtB2b_2G0EECs9wbMZuYrb6S_11rand_chacha:
  246|     41|    fn unpack<S, V: Store<S>>(self, s: S) -> V {
  247|     41|        unsafe { V::unpack(s) }
  248|     41|    }

_RNvNvNtCs9wbMZuYrb6S_11rand_chacha4guts11refill_wide9impl_avx2:
  255|     41|            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {
  256|     41|                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);
  257|     41|                _mm256_zeroupper();
  258|     41|                ret
  259|     41|            }
_RNvXs2_NtCsbdpQ9YC9ceY_10ppv_lite866x86_64NtB5_14vec128_storageINtNtCsdRJjCzU6nMS_4core7convert4FromAmj4_E4from:
  130|      1|    fn from(u32x4: [u32; 4]) -> Self {
  131|      1|        vec128_storage { u32x4 }
  132|      1|    }
_RNvNtCs9wbMZuYrb6S_11rand_chacha4guts11init_chacha:
  333|      1|        $($pub $(($krate))*)* fn $name($($arg: $argty),*) -> $ret {
  334|       |            #[inline(always)]
  335|       |            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body
  336|       |            use std::arch::x86_64::*;
  337|       |            #[target_feature(enable = "avx")]
  338|       |            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  339|       |                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)
  340|       |            }
  341|       |            #[target_feature(enable = "sse2")]
  342|       |            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {
  343|       |                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)
  344|       |            }
  345|       |            unsafe {
  346|      0|                if is_x86_feature_detected!("avx") {
  347|      1|                    impl_avx($($arg),*)
  348|      0|                } else if is_x86_feature_detected!("sse2") {
  349|      0|                    impl_sse2($($arg),*)
  350|       |                } else {
  351|      0|                    unimplemented!()
  352|       |                }
  353|       |            }
  354|      1|        }
_RNvXNtCsbdpQ9YC9ceY_10ppv_lite866x86_64INtB2_10SseMachineNtB2_5YesS3NtB2_5YesS4NtB2_4NoNIENtNtB4_5types7Machine8instanceCs9wbMZuYrb6S_11rand_chacha:
   64|      1|    unsafe fn instance() -> Self {
   65|      1|        SseMachine(PhantomData)
   66|      1|    }
_RNvXs_NtCsbdpQ9YC9ceY_10ppv_lite866x86_64INtB4_11Avx2MachineNtB4_4NoNIENtNtB6_5types7Machine8instanceCs9wbMZuYrb6S_11rand_chacha:
   92|     41|    unsafe fn instance() -> Self {
   93|     41|        Avx2Machine(PhantomData)
   94|     41|    }
_RNvNvNtCs9wbMZuYrb6S_11rand_chacha4guts11init_chacha8impl_avx:
  338|      1|            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  339|      1|                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)
  340|      1|            }
_RNvNtCs9wbMZuYrb6S_11rand_chacha4guts11refill_wide:
  250|     41|        $($pub$(($krate))*)* fn $name($($arg: $argty),*) -> $ret {
  251|       |            #[inline(always)]
  252|       |            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body
  253|       |            use std::arch::x86_64::*;
  254|       |            #[target_feature(enable = "avx2")]
  255|       |            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {
  256|       |                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);
  257|       |                _mm256_zeroupper();
  258|       |                ret
  259|       |            }
  260|       |            #[target_feature(enable = "avx")]
  261|       |            #[target_feature(enable = "sse4.1")]
  262|       |            #[target_feature(enable = "ssse3")]
  263|       |            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  264|       |                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);
  265|       |                _mm256_zeroupper();
  266|       |                ret
  267|       |            }
  268|       |            #[target_feature(enable = "sse4.1")]
  269|       |            #[target_feature(enable = "ssse3")]
  270|       |            unsafe fn impl_sse41($($arg: $argty),*) -> $ret {
  271|       |                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)
  272|       |            }
  273|       |            #[target_feature(enable = "ssse3")]
  274|       |            unsafe fn impl_ssse3($($arg: $argty),*) -> $ret {
  275|       |                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)
  276|       |            }
  277|       |            #[target_feature(enable = "sse2")]
  278|       |            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {
  279|       |                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)
  280|       |            }
  281|       |            unsafe {
  282|      0|                if is_x86_feature_detected!("avx2") {
  283|     41|                    impl_avx2($($arg),*)
  284|      0|                } else if is_x86_feature_detected!("avx") {
  285|      0|                    impl_avx($($arg),*)
  286|      0|                } else if is_x86_feature_detected!("sse4.1") {
  287|      0|                    impl_sse41($($arg),*)
  288|      0|                } else if is_x86_feature_detected!("ssse3") {
  289|      0|                    impl_ssse3($($arg),*)
  290|      0|                } else if is_x86_feature_detected!("sse2") {
  291|      0|                    impl_sse2($($arg),*)
  292|       |                } else {
  293|      0|                    unimplemented!()
  294|       |                }
  295|       |            }
  296|     41|        }

_RNvXsc_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words1230Cs9wbMZuYrb6S_11rand_chacha:
 1582|    984|        fn shuffle_lane_words1230(self) -> Self {
 1583|    984|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b1001_0011) })
 1584|    984|        }
_RNvXs10_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtBa_5types10StoreBytes8write_leCs9wbMZuYrb6S_11rand_chacha:
   89|    656|            fn write_le(self, out: &mut [u8]) {
   90|    656|                assert_eq!(out.len(), 16);
   91|    656|                unsafe { _mm_storeu_si128(out.as_mut_ptr() as *mut _, self.x) }
   92|    656|            }
_RNvXs6_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right20Cs9wbMZuYrb6S_11rand_chacha:
 1480|    984|            fn $name(self) -> Self {
 1481|    984|                Self::new(unsafe {
 1482|    984|                    _mm256_or_si256(
 1483|    984|                        _mm256_srli_epi32(self.x, $i as i32),
 1484|    984|                        _mm256_slli_epi32(self.x, 32 - $i as i32),
 1485|    984|                    )
 1486|    984|                })
 1487|    984|            }
_RNvXsc_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words2301Cs9wbMZuYrb6S_11rand_chacha:
 1586|    984|        fn shuffle_lane_words2301(self) -> Self {
 1587|    984|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b0100_1110) })
 1588|    984|        }
_RNvXs6_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right25Cs9wbMZuYrb6S_11rand_chacha:
 1480|    984|            fn $name(self) -> Self {
 1481|    984|                Self::new(unsafe {
 1482|    984|                    _mm256_or_si256(
 1483|    984|                        _mm256_srli_epi32(self.x, $i as i32),
 1484|    984|                        _mm256_slli_epi32(self.x, 32 - $i as i32),
 1485|    984|                    )
 1486|    984|                })
 1487|    984|            }
_RNvXsv_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCsdRJjCzU6nMS_4core3ops5arith3Add3addCs9wbMZuYrb6S_11rand_chacha:
 1543|  3.93k|                fn $op_fn(self, rhs: Self) -> Self::Output {
 1544|  3.93k|                    Self::new(unsafe { $impl_fn(self.x, rhs.x) })
 1545|  3.93k|                }
_RNvMNtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB2_12u32x4x2_avx2NtB6_4NoNIE3newCs9wbMZuYrb6S_11rand_chacha:
 1394|  15.1k|        fn new(x: __m256i) -> Self {
 1395|  15.1k|            Self { x, ni: PhantomData }
 1396|  15.1k|        }
_RNvXsc_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words3012Cs9wbMZuYrb6S_11rand_chacha:
 1590|    984|        fn shuffle_lane_words3012(self) -> Self {
 1591|    984|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b0011_1001) })
 1592|    984|        }
_RNvXs6_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right24Cs9wbMZuYrb6S_11rand_chacha:
 1470|    984|            fn $name(self) -> Self {
 1471|    984|                Self::new(unsafe {
 1472|    984|                    _mm256_shuffle_epi8(self.x, _mm256_set_epi64x($k0, $k1, $k0, $k1))
 1473|    984|                })
 1474|    984|            }
_RNvXsf_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1s_Ej4_E10from_lanesCs9wbMZuYrb6S_11rand_chacha:
 1617|    164|        fn from_lanes(x: [u32x4_sse2<YesS3, YesS4, NI>; 4]) -> Self {
 1618|    164|            let ab = u32x4x2_avx2::from_lanes([x[0], x[1]]);
 1619|    164|            let cd = u32x4x2_avx2::from_lanes([x[2], x[3]]);
 1620|    164|            Self::new([ab, cd])
 1621|    164|        }
_RNvXse_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types5StoreNtB9_14vec512_storageE6unpackCs9wbMZuYrb6S_11rand_chacha:
 1602|     41|        unsafe fn unpack(p: vec512_storage) -> Self {
 1603|     41|            Self::new([
 1604|     41|                u32x4x2_avx2::unpack(p.avx[0]),
 1605|     41|                u32x4x2_avx2::unpack(p.avx[1]),
 1606|     41|            ])
 1607|     41|        }
_RNvXs1R_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtNtCsdRJjCzU6nMS_4core3ops5arith3Add3addCs9wbMZuYrb6S_11rand_chacha:
   18|    656|            fn $fn(self, rhs: Self) -> Self::Output {
   19|    656|                Self::new(unsafe { $impl_fn(self.x, rhs.x) })
   20|    656|            }
_RNvXsX_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types5StoreNtB7_14vec128_storageE6unpackCs9wbMZuYrb6S_11rand_chacha:
   52|    369|            unsafe fn unpack(x: vec128_storage) -> Self {
   53|    369|                Self::new(x.sse2)
   54|    369|            }
_RNvXsl_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types4Vec4mE7extractCs9wbMZuYrb6S_11rand_chacha:
  519|    164|    fn extract(self, i: u32) -> u32 {
  520|    164|        self.to_lanes()[i as usize]
  521|    164|    }
_RNvXsj_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2NtB9_14vec512_storageINtNtCsdRJjCzU6nMS_4core7convert4FromINtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EE4fromCs9wbMZuYrb6S_11rand_chacha:
 1683|     41|        fn from(x: u32x4x4_avx2<NI>) -> Self {
 1684|     41|            Self {
 1685|     41|                avx: [
 1686|     41|                    vec256_storage { avx: x.0[0].x },
 1687|     41|                    vec256_storage { avx: x.0[1].x },
 1688|     41|                ],
 1689|     41|            }
 1690|     41|        }
_RNvXs2_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1c_Ej2_E8to_lanesCs9wbMZuYrb6S_11rand_chacha:
 1430|    328|        fn to_lanes(self) -> [u32x4_sse2<YesS3, YesS4, NI>; 2] {
 1431|    328|            unsafe {
 1432|    328|                [
 1433|    328|                    u32x4_sse2::new(_mm256_extracti128_si256(self.x, 0)),
 1434|    328|                    u32x4_sse2::new(_mm256_extracti128_si256(self.x, 1)),
 1435|    328|                ]
 1436|    328|            }
 1437|    328|        }
_RNvMsZ_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIE3newCs9wbMZuYrb6S_11rand_chacha:
   64|  2.29k|            fn new(x: __m128i) -> Self {
   65|  2.29k|                $vec {
   66|  2.29k|                    x,
   67|  2.29k|                    s3: PhantomData,
   68|  2.29k|                    s4: PhantomData,
   69|  2.29k|                    ni: PhantomData,
   70|  2.29k|                }
   71|  2.29k|            }
_RNvXs6_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right16Cs9wbMZuYrb6S_11rand_chacha:
 1470|    984|            fn $name(self) -> Self {
 1471|    984|                Self::new(unsafe {
 1472|    984|                    _mm256_shuffle_epi8(self.x, _mm256_set_epi64x($k0, $k1, $k0, $k1))
 1473|    984|                })
 1474|    984|            }
_RNvXsf_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1s_Ej4_E8to_lanesCs9wbMZuYrb6S_11rand_chacha:
 1611|    164|        fn to_lanes(self) -> [u32x4_sse2<YesS3, YesS4, NI>; 4] {
 1612|    164|            let [a, b] = self.0[0].to_lanes();
 1613|    164|            let [c, d] = self.0[1].to_lanes();
 1614|    164|            [a, b, c, d]
 1615|    164|        }
_RNvXs10_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtBa_5types10StoreBytes14unsafe_read_leCs9wbMZuYrb6S_11rand_chacha:
   79|      2|            unsafe fn unsafe_read_le(input: &[u8]) -> Self {
   80|      2|                assert_eq!(input.len(), 16);
   81|      2|                Self::new(_mm_loadu_si128(input.as_ptr() as *const _))
   82|      2|            }
_RNvXs6_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types9MultiLaneAmj4_E10from_lanesCs9wbMZuYrb6S_11rand_chacha:
  331|     41|    fn from_lanes(xs: [u32; 4]) -> Self {
  332|     41|        unsafe {
  333|     41|            let mut x = _mm_cvtsi64_si128((xs[0] as u64 | ((xs[1] as u64) << 32)) as i64);
  334|     41|            x = _mm_insert_epi64(x, (xs[2] as u64 | ((xs[3] as u64) << 32)) as i64, 1);
  335|     41|            Self::new(x)
  336|     41|        }
  337|     41|    }
_RNvXsr_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCsdRJjCzU6nMS_4core3ops3bit6BitXor6bitxorCs9wbMZuYrb6S_11rand_chacha:
 1543|  3.93k|                fn $op_fn(self, rhs: Self) -> Self::Output {
 1544|  3.93k|                    Self::new(unsafe { $impl_fn(self.x, rhs.x) })
 1545|  3.93k|                }
_RNvXsl_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types4Vec4mE6insertCs9wbMZuYrb6S_11rand_chacha:
  523|    574|    fn insert(self, v: u32, i: u32) -> Self {
  524|    574|        Self::new(unsafe {
  525|    574|            match i {
  526|    287|                0 => _mm_insert_epi32(self.x, v as i32, 0),
  527|    287|                1 => _mm_insert_epi32(self.x, v as i32, 1),
  528|      0|                2 => _mm_insert_epi32(self.x, v as i32, 2),
  529|      0|                3 => _mm_insert_epi32(self.x, v as i32, 3),
  530|      0|                _ => unreachable!(),
  531|       |            }
  532|       |        })
  533|    574|    }
_RNvXsY_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2NtB7_14vec128_storageINtNtCsdRJjCzU6nMS_4core7convert4FromINtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEE4fromCs9wbMZuYrb6S_11rand_chacha:
   58|     43|            fn from(x: $vec<S3, S4, NI>) -> Self {
   59|     43|                vec128_storage { sse2: x.x }
   60|     43|            }
_RNvXs6_NtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types9MultiLaneAmj4_E8to_lanesCs9wbMZuYrb6S_11rand_chacha:
  323|    164|    fn to_lanes(self) -> [u32; 4] {
  324|    164|        unsafe {
  325|    164|            let x = _mm_cvtsi128_si64(self.x) as u64;
  326|    164|            let y = _mm_extract_epi64(self.x, 1) as u64;
  327|    164|            [x as u32, (x >> 32) as u32, y as u32, (y >> 32) as u32]
  328|    164|        }
  329|    164|    }
_RNvXs2_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1c_Ej2_E10from_lanesCs9wbMZuYrb6S_11rand_chacha:
 1439|    328|        fn from_lanes(x: [u32x4_sse2<YesS3, YesS4, NI>; 2]) -> Self {
 1440|    328|            Self::new(unsafe { _mm256_setr_m128i(x[0].x, x[1].x) })
 1441|    328|        }
_RNvXsq_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCsdRJjCzU6nMS_4core3ops5arith9AddAssign10add_assignCs9wbMZuYrb6S_11rand_chacha:
 1527|  3.93k|                fn $assign_fn(&mut self, rhs: Self) {
 1528|  3.93k|                    *self = self.$bin_fn(rhs);
 1529|  3.93k|                }
_RNvXs0_NtNtNtCsbdpQ9YC9ceY_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types5StoreNtB9_14vec256_storageE6unpackCs9wbMZuYrb6S_11rand_chacha:
 1402|     82|        unsafe fn unpack(p: vec256_storage) -> Self {
 1403|     82|            Self::new(p.avx)
 1404|     82|        }

_RINvXNtNtCsiyHrXHpLjPA_4rand13distributions7integerNtB5_8StandardINtNtB5_12distribution12DistributionhE6sampleNtNtNtB7_4rngs6thread9ThreadRngECs4ieSHZHrxF6_15direct_syscalls:
   23|  2.60k|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8 {
   24|  2.60k|        rng.next_u32() as u8
   25|  2.60k|    }

_RINvXsB_NtNtCsiyHrXHpLjPA_4rand13distributions5otherNtB8_8StandardINtNtB8_12distribution12DistributionAhj10_E6sampleNtNtNtBa_4rngs6thread9ThreadRngECs4ieSHZHrxF6_15direct_syscalls:
  217|    163|            fn sample<R: Rng + ?Sized>(&self, _rng: &mut R) -> [T; $n] {
  218|    163|                [_rng.gen::<$t>(), $(_rng.gen::<$ts>()),*]
  219|    163|            }

_RINvCsiyHrXHpLjPA_4rand6randomAhj10_ECs4ieSHZHrxF6_15direct_syscalls:
  183|    163|pub fn random<T>() -> T
  184|    163|where Standard: Distribution<T> {
  185|    163|    thread_rng().gen()
  186|    163|}

_RINvYNtNtNtCsiyHrXHpLjPA_4rand4rngs6thread9ThreadRngNtNtB9_3rng3Rng3genhECs4ieSHZHrxF6_15direct_syscalls:
   93|  2.60k|    fn gen<T>(&mut self) -> T
   94|  2.60k|    where Standard: Distribution<T> {
   95|  2.60k|        Standard.sample(self)
   96|  2.60k|    }
_RINvYNtNtNtCsiyHrXHpLjPA_4rand4rngs6thread9ThreadRngNtNtB9_3rng3Rng3genAhj10_ECs4ieSHZHrxF6_15direct_syscalls:
   93|    163|    fn gen<T>(&mut self) -> T
   94|    163|    where Standard: Distribution<T> {
   95|    163|        Standard.sample(self)
   96|    163|    }

_RNvMs3_NtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtNtCs8Y2Psa4FPcv_9rand_core2os5OsRngE9is_forkedCs4ieSHZHrxF6_15direct_syscalls:
  226|     41|    fn is_forked(&self, global_fork_counter: usize) -> bool {
  227|     41|        // In theory, on 32-bit platforms, it is possible for
  228|     41|        // `global_fork_counter` to wrap around after ~4e9 forks.
  229|     41|        //
  230|     41|        // This check will detect a fork in the normal case where
  231|     41|        // `fork_counter < global_fork_counter`, and also when the difference
  232|     41|        // between both is greater than `isize::MAX` (wrapped around).
  233|     41|        //
  234|     41|        // It will still fail to detect a fork if there have been more than
  235|     41|        // `isize::MAX` forks, without any reseed in between. Seems unlikely
  236|     41|        // enough.
  237|     41|        (self.fork_counter.wrapping_sub(global_fork_counter) as isize) < 0
  238|     41|    }
_RNvXs2_NtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtNtCs8Y2Psa4FPcv_9rand_core2os5OsRngENtNtB26_5block12BlockRngCore8generateCs4ieSHZHrxF6_15direct_syscalls:
  173|     41|    fn generate(&mut self, results: &mut Self::Results) {
  174|     41|        let global_fork_counter = fork::get_fork_counter();
  175|     41|        if self.bytes_until_reseed <= 0 || self.is_forked(global_fork_counter) {
  176|       |            // We get better performance by not calling only `reseed` here
  177|       |            // and continuing with the rest of the function, but by directly
  178|       |            // returning from a non-inlined function.
  179|      0|            return self.reseed_and_generate(results, global_fork_counter);
  180|     41|        }
  181|     41|        let num_bytes = results.as_ref().len() * size_of::<Self::Item>();
  182|     41|        self.bytes_until_reseed -= num_bytes as i64;
  183|     41|        self.inner.generate(results);
  184|     41|    }
_RNvXs_NtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseedingINtB4_12ReseedingRngNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtNtCs8Y2Psa4FPcv_9rand_core2os5OsRngENtB24_7RngCore8next_u32Cs4ieSHZHrxF6_15direct_syscalls:
  119|  2.60k|    fn next_u32(&mut self) -> u32 {
  120|  2.60k|        self.0.next_u32()
  121|  2.60k|    }
_RNCNvNtNtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseeding4fork21register_fork_handler0Bb_:
  319|      1|        REGISTER.call_once(|| {
  320|      1|            // Bump the counter before and after forking (see #1169):
  321|      1|            let ret = unsafe { libc::pthread_atfork(
  322|      1|                Some(fork_handler),
  323|      1|                Some(fork_handler),
  324|      1|                Some(fork_handler),
  325|      1|            ) };
  326|      1|            if ret != 0 {
  327|      0|                panic!("libc::pthread_atfork failed with code {}", ret);
  328|      1|            }
  329|      1|        });
_RNvMs3_NtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtNtCs8Y2Psa4FPcv_9rand_core2os5OsRngE3newBb_:
  193|      1|    fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
  194|      1|        use ::core::i64::MAX;
  195|      1|        fork::register_fork_handler();
  196|       |
  197|       |        // Because generating more values than `i64::MAX` takes centuries on
  198|       |        // current hardware, we just clamp to that value.
  199|       |        // Also we set a threshold of 0, which indicates no limit, to that
  200|       |        // value.
  201|      1|        let threshold = if threshold == 0 {
  202|      0|            MAX
  203|      1|        } else if threshold <= MAX as u64 {
  204|      1|            threshold as i64
  205|       |        } else {
  206|      0|            MAX
  207|       |        };
  208|       |
  209|      1|        ReseedingCore {
  210|      1|            inner: rng,
  211|      1|            reseeder,
  212|      1|            threshold: threshold as i64,
  213|      1|            bytes_until_reseed: threshold as i64,
  214|      1|            fork_counter: 0,
  215|      1|        }
  216|      1|    }
_RNvNtNtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseeding4fork16get_fork_counter:
  307|     41|    pub fn get_fork_counter() -> usize {
  308|     41|        RESEEDING_RNG_FORK_COUNTER.load(Ordering::Relaxed)
  309|     41|    }
_RNvMNtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseedingINtB2_12ReseedingRngNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtNtCs8Y2Psa4FPcv_9rand_core2os5OsRngE3newB8_:
  101|      1|    pub fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
  102|      1|        ReseedingRng(BlockRng::new(ReseedingCore::new(rng, threshold, reseeder)))
  103|      1|    }
_RNvNtNtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseeding4fork21register_fork_handler:
  317|      1|    pub fn register_fork_handler() {
  318|      1|        static REGISTER: Once = Once::new();
  319|      1|        REGISTER.call_once(|| {
  320|       |            // Bump the counter before and after forking (see #1169):
  321|       |            let ret = unsafe { libc::pthread_atfork(
  322|       |                Some(fork_handler),
  323|       |                Some(fork_handler),
  324|       |                Some(fork_handler),
  325|       |            ) };
  326|       |            if ret != 0 {
  327|       |                panic!("libc::pthread_atfork failed with code {}", ret);
  328|       |            }
  329|      1|        });
  330|      1|    }

_RNvXs_NtNtCsiyHrXHpLjPA_4rand4rngs6threadNtB4_9ThreadRngNtCs8Y2Psa4FPcv_9rand_core7RngCore8next_u32:
  101|  2.60k|    fn next_u32(&mut self) -> u32 {
  102|  2.60k|        // SAFETY: We must make sure to stop using `rng` before anyone else
  103|  2.60k|        // creates another mutable reference
  104|  2.60k|        let rng = unsafe { &mut *self.rng.get() };
  105|  2.60k|        rng.next_u32()
  106|  2.60k|    }
_RNvNtNtCsiyHrXHpLjPA_4rand4rngs6thread10thread_rng:
   88|    163|pub fn thread_rng() -> ThreadRng {
   89|    163|    let rng = THREAD_RNG_KEY.with(|t| t.clone());
   90|    163|    ThreadRng { rng }
   91|    163|}
_RNCNvNvNtNtCsiyHrXHpLjPA_4rand4rngs6thread14THREAD_RNG_KEY7___getit0B9_:
   67|      1|thread_local!(
   68|      1|    // We require Rc<..> to avoid premature freeing when thread_rng is used
   69|      1|    // within thread-local destructors. See #968.
   70|      1|    static THREAD_RNG_KEY: Rc<UnsafeCell<ReseedingRng<Core, OsRng>>> = {
   71|      1|        let r = Core::from_rng(OsRng).unwrap_or_else(|err|
   72|      1|                panic!("could not initialize thread_rng: {}", err));
   73|      1|        let rng = ReseedingRng::new(r,
   74|      1|                                    THREAD_RNG_RESEED_THRESHOLD,
   75|      1|                                    OsRng);
   76|      1|        Rc::new(UnsafeCell::new(rng))
   77|      1|    }
   78|      1|);
_RNCNvNtNtCsiyHrXHpLjPA_4rand4rngs6thread10thread_rng0B7_:
   89|    163|    let rng = THREAD_RNG_KEY.with(|t| t.clone());

_RNvXs_NtCs9wbMZuYrb6S_11rand_chacha6chachaINtB4_7Array64mEINtNtCsdRJjCzU6nMS_4core7convert5AsRefSmE6as_refCs4ieSHZHrxF6_15direct_syscalls:
   46|  5.29k|    fn as_ref(&self) -> &[T] {
   47|  5.29k|        &self.0
   48|  5.29k|    }
_RNvXs0_NtCs9wbMZuYrb6S_11rand_chacha6chachaINtB5_7Array64mEINtNtCsdRJjCzU6nMS_4core7convert5AsMutSmE6as_mutCs4ieSHZHrxF6_15direct_syscalls:
   51|     41|    fn as_mut(&mut self) -> &mut [T] {
   52|     41|        &mut self.0
   53|     41|    }
_RNvXsn_NtCs9wbMZuYrb6S_11rand_chacha6chachaNtB5_12ChaCha12CoreNtCs8Y2Psa4FPcv_9rand_core11SeedableRng9from_seed:
  103|      1|            fn from_seed(seed: Self::Seed) -> Self {
  104|      1|                $ChaChaXCore { state: ChaCha::new(&seed, &[0u8; 8]) }
  105|      1|            }
_RNvXsm_NtCs9wbMZuYrb6S_11rand_chacha6chachaNtB5_12ChaCha12CoreNtNtCs8Y2Psa4FPcv_9rand_core5block12BlockRngCore8generate:
   89|     41|            fn generate(&mut self, r: &mut Self::Results) {
   90|     41|                // Fill slice of words by writing to equivalent slice of bytes, then fixing endianness.
   91|     41|                self.state.refill4($rounds, unsafe {
   92|     41|                    &mut *(&mut *r as *mut Array64<u32> as *mut [u8; 256])
   93|     41|                });
   94|  2.62k|                for x in r.as_mut() {
   95|  2.62k|                    *x = x.to_le();
   96|  2.62k|                }
   97|     41|            }
_RNvXNtCs9wbMZuYrb6S_11rand_chacha6chachaINtB2_7Array64mENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsiyHrXHpLjPA_4rand:
   32|      1|    fn default() -> Self {
   33|      1|        Self([
   34|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   35|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   36|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   37|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   38|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   39|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   40|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   41|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   42|      1|        ])
   43|      1|    }
_RNvXs_NtCs9wbMZuYrb6S_11rand_chacha6chachaINtB4_7Array64mEINtNtCsdRJjCzU6nMS_4core7convert5AsRefSmE6as_refCsiyHrXHpLjPA_4rand:
   46|      1|    fn as_ref(&self) -> &[T] {
   47|      1|        &self.0
   48|      1|    }

_RNvMNtCs9wbMZuYrb6S_11rand_chacha4gutsNtB2_6ChaCha3new:
   72|      1|    pub fn new(key: &[u8; 32], nonce: &[u8]) -> Self {
   73|      1|        init_chacha(key, nonce)
   74|      1|    }
_RNvMNtCs9wbMZuYrb6S_11rand_chacha4gutsNtB2_6ChaCha7refill4:
   84|     41|    pub fn refill4(&mut self, drounds: u32, out: &mut [u8; BUFSZ]) {
   85|     41|        refill_wide(self, drounds, out)
   86|     41|    }
_RINvMNtCs9wbMZuYrb6S_11rand_chacha4gutsNtB3_6ChaCha5pos64INtNtCsbdpQ9YC9ceY_10ppv_lite866x86_6411Avx2MachineNtBW_4NoNIEEB5_:
   77|     82|    fn pos64<M: Machine>(&self, m: M) -> u64 {
   78|     82|        let d: M::u32x4 = m.unpack(self.d);
   79|     82|        ((d.extract(1) as u64) << 32) | d.extract(0) as u64
   80|     82|    }
_RINvNvNtCs9wbMZuYrb6S_11rand_chacha4guts11refill_wide7fn_implINtNtCsbdpQ9YC9ceY_10ppv_lite866x86_6411Avx2MachineNtB10_4NoNIEEB6_:
  172|     41|    fn refill_wide(state: &mut ChaCha, drounds: u32, out: &mut [u8; BUFSZ]) {
  173|     41|        refill_wide_impl(m, state, drounds, out);
  174|     41|    }
_RINvNtCs9wbMZuYrb6S_11rand_chacha4guts5roundINtNtCsbdpQ9YC9ceY_10ppv_lite864soft2x2INtNtNtNtBL_6x86_644sse24avx212u32x4x2_avx2NtB1q_4NoNIENtB1o_2G0EEB4_:
   43|    492|pub(crate) fn round<V: ArithOps + BitOps32>(mut x: State<V>) -> State<V> {
   44|    492|    x.a += x.b;
   45|    492|    x.d = (x.d ^ x.a).rotate_each_word_right16();
   46|    492|    x.c += x.d;
   47|    492|    x.b = (x.b ^ x.c).rotate_each_word_right20();
   48|    492|    x.a += x.b;
   49|    492|    x.d = (x.d ^ x.a).rotate_each_word_right24();
   50|    492|    x.c += x.d;
   51|    492|    x.b = (x.b ^ x.c).rotate_each_word_right25();
   52|    492|    x
   53|    492|}
_RINvNvNtCs9wbMZuYrb6S_11rand_chacha4guts11init_chacha7fn_implINtNtCsbdpQ9YC9ceY_10ppv_lite866x86_6410SseMachineNtB10_5YesS3NtB10_5YesS4NtB10_4NoNIEEB6_:
  235|      1|    fn init_chacha(key: &[u8; 32], nonce: &[u8]) -> ChaCha {
  236|      1|        let ctr_nonce = [
  237|       |            0,
  238|      1|            if nonce.len() == 12 {
  239|      0|                read_u32le(&nonce[0..4])
  240|       |            } else {
  241|      1|                0
  242|       |            },
  243|      1|            read_u32le(&nonce[nonce.len() - 8..nonce.len() - 4]),
  244|      1|            read_u32le(&nonce[nonce.len() - 4..]),
  245|      1|        ];
  246|      1|        let key0: Mach::u32x4 = m.read_le(&key[..16]);
  247|      1|        let key1: Mach::u32x4 = m.read_le(&key[16..]);
  248|      1|        ChaCha {
  249|      1|            b: key0.into(),
  250|      1|            c: key1.into(),
  251|      1|            d: ctr_nonce.into(),
  252|      1|        }
_RINvNtCs9wbMZuYrb6S_11rand_chacha4guts13undiagonalizeINtNtCsbdpQ9YC9ceY_10ppv_lite864soft2x2INtNtNtNtBU_6x86_644sse24avx212u32x4x2_avx2NtB1z_4NoNIENtB1x_2G0EEB4_:
   63|    246|pub(crate) fn undiagonalize<V: LaneWords4>(mut x: State<V>) -> State<V> {
   64|    246|    x.b = x.b.shuffle_lane_words1230();
   65|    246|    x.c = x.c.shuffle_lane_words2301();
   66|    246|    x.d = x.d.shuffle_lane_words3012();
   67|    246|    x
   68|    246|}
_RINvNtCs9wbMZuYrb6S_11rand_chacha4guts16refill_wide_implINtNtCsbdpQ9YC9ceY_10ppv_lite866x86_6411Avx2MachineNtBV_4NoNIEEB4_:
  116|     41|fn refill_wide_impl<Mach: Machine>(
  117|     41|    m: Mach, state: &mut ChaCha, drounds: u32, out: &mut [u8; BUFSZ],
  118|     41|) {
  119|     41|    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);
  120|     41|    let mut pos = state.pos64(m);
  121|     41|    let d0: Mach::u32x4 = m.unpack(state.d);
  122|     41|    pos = pos.wrapping_add(1);
  123|     41|    let d1 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  124|     41|    pos = pos.wrapping_add(1);
  125|     41|    let d2 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  126|     41|    pos = pos.wrapping_add(1);
  127|     41|    let d3 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  128|     41|
  129|     41|    let b = m.unpack(state.b);
  130|     41|    let c = m.unpack(state.c);
  131|     41|    let mut x = State {
  132|     41|        a: Mach::u32x4x4::from_lanes([k, k, k, k]),
  133|     41|        b: Mach::u32x4x4::from_lanes([b, b, b, b]),
  134|     41|        c: Mach::u32x4x4::from_lanes([c, c, c, c]),
  135|     41|        d: m.unpack(Mach::u32x4x4::from_lanes([d0, d1, d2, d3]).into()),
  136|     41|    };
  137|    246|    for _ in 0..drounds {
  138|    246|        x = round(x);
  139|    246|        x = undiagonalize(round(diagonalize(x)));
  140|    246|    }
  141|     41|    let mut pos = state.pos64(m);
  142|     41|    let d0: Mach::u32x4 = m.unpack(state.d);
  143|     41|    pos = pos.wrapping_add(1);
  144|     41|    let d1 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  145|     41|    pos = pos.wrapping_add(1);
  146|     41|    let d2 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  147|     41|    pos = pos.wrapping_add(1);
  148|     41|    let d3 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  149|     41|    pos = pos.wrapping_add(1);
  150|     41|    let d4 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  151|     41|
  152|     41|    let (a, b, c, d) = (
  153|     41|        x.a.to_lanes(),
  154|     41|        x.b.to_lanes(),
  155|     41|        x.c.to_lanes(),
  156|     41|        x.d.to_lanes(),
  157|     41|    );
  158|     41|    let sb = m.unpack(state.b);
  159|     41|    let sc = m.unpack(state.c);
  160|     41|    let sd = [m.unpack(state.d), d1, d2, d3];
  161|     41|    state.d = d4.into();
  162|     41|    let mut words = out.chunks_exact_mut(16);
  163|    164|    for ((((&a, &b), &c), &d), &sd) in a.iter().zip(&b).zip(&c).zip(&d).zip(&sd) {
  164|    164|        (a + k).write_le(words.next().unwrap());
  165|    164|        (b + sb).write_le(words.next().unwrap());
  166|    164|        (c + sc).write_le(words.next().unwrap());
  167|    164|        (d + sd).write_le(words.next().unwrap());
  168|    164|    }
  169|     41|}
_RNvNtCs9wbMZuYrb6S_11rand_chacha4guts10read_u32le:
  229|      2|fn read_u32le(xs: &[u8]) -> u32 {
  230|      2|    assert_eq!(xs.len(), 4);
  231|      2|    u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24)
  232|      2|}
_RINvNtCs9wbMZuYrb6S_11rand_chacha4guts11diagonalizeINtNtCsbdpQ9YC9ceY_10ppv_lite864soft2x2INtNtNtNtBS_6x86_644sse24avx212u32x4x2_avx2NtB1x_4NoNIENtB1v_2G0EEB4_:
   56|    246|pub(crate) fn diagonalize<V: LaneWords4>(mut x: State<V>) -> State<V> {
   57|    246|    x.b = x.b.shuffle_lane_words3012();
   58|    246|    x.c = x.c.shuffle_lane_words2301();
   59|    246|    x.d = x.d.shuffle_lane_words1230();
   60|    246|    x
   61|    246|}

_RNvXs0_NtCs8Y2Psa4FPcv_9rand_core5blockINtB5_8BlockRngINtNtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtNtB7_2os5OsRngEENtB7_7RngCore8next_u32Cs4ieSHZHrxF6_15direct_syscalls:
  186|  2.60k|    fn next_u32(&mut self) -> u32 {
  187|  2.60k|        if self.index >= self.results.as_ref().len() {
  188|     41|            self.generate_and_set(0);
  189|  2.56k|        }
  190|       |
  191|  2.60k|        let value = self.results.as_ref()[self.index];
  192|  2.60k|        self.index += 1;
  193|  2.60k|        value
  194|  2.60k|    }
_RNvMs_NtCs8Y2Psa4FPcv_9rand_core5blockINtB4_8BlockRngINtNtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtNtB6_2os5OsRngEE16generate_and_setCs4ieSHZHrxF6_15direct_syscalls:
  174|     41|    pub fn generate_and_set(&mut self, index: usize) {
  175|     41|        assert!(index < self.results.as_ref().len());
  176|     41|        self.core.generate(&mut self.results);
  177|     41|        self.index = index;
  178|     41|    }
_RNvMs_NtCs8Y2Psa4FPcv_9rand_core5blockINtB4_8BlockRngINtNtNtNtCsiyHrXHpLjPA_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtNtB6_2os5OsRngEE3newBY_:
  145|      1|    pub fn new(core: R) -> BlockRng<R> {
  146|      1|        let results_empty = R::Results::default();
  147|      1|        BlockRng {
  148|      1|            core,
  149|      1|            index: results_empty.as_ref().len(),
  150|      1|            results: results_empty,
  151|      1|        }
  152|      1|    }

_RINvYNtNtCs9wbMZuYrb6S_11rand_chacha6chacha12ChaCha12CoreNtCs8Y2Psa4FPcv_9rand_core11SeedableRng8from_rngNtNtBV_2os5OsRngECsiyHrXHpLjPA_4rand:
  390|      1|    fn from_rng<R: RngCore>(mut rng: R) -> Result<Self, Error> {
  391|      1|        let mut seed = Self::Seed::default();
  392|      1|        rng.try_fill_bytes(seed.as_mut())?;
  393|      1|        Ok(Self::from_seed(seed))
  394|      1|    }

_RNvXs_NtCs8Y2Psa4FPcv_9rand_core2osNtB4_5OsRngNtB6_7RngCore14try_fill_bytes:
   68|      1|        getrandom(dest)?;
   69|      1|        Ok(())
   70|      1|    }

_RNvMs4_CsijPsW9w8cJj_9regalloc2NtB5_4VReg4vreg:
  278|  29.3k|    pub const fn vreg(self) -> usize {
  279|  29.3k|        let vreg = (self.bits >> 1) as usize;
  280|  29.3k|        vreg
  281|  29.3k|    }
_RNvMCsijPsW9w8cJj_9regalloc2NtB2_4PReg5index:
  131|  10.4k|    pub const fn index(self) -> usize {
  132|  10.4k|        self.bits as usize
  133|  10.4k|    }
_RNvMCsijPsW9w8cJj_9regalloc2NtB2_4PReg3new:
   97|  10.4k|    pub const fn new(hw_enc: usize, class: RegClass) -> Self {
   98|  10.4k|        // We don't have const panics yet (rust-lang/rust#85194) so we
   99|  10.4k|        // need to use a little indexing trick here. We unfortunately
  100|  10.4k|        // can't use the `static-assertions` crate because we need
  101|  10.4k|        // this to work both for const `hw_enc` and for runtime
  102|  10.4k|        // values.
  103|  10.4k|        const HW_ENC_MUST_BE_IN_BOUNDS: &[bool; PReg::MAX + 1] = &[true; PReg::MAX + 1];
  104|  10.4k|        let _ = HW_ENC_MUST_BE_IN_BOUNDS[hw_enc];
  105|  10.4k|
  106|  10.4k|        PReg {
  107|  10.4k|            bits: ((class as u8) << Self::MAX_BITS) | (hw_enc as u8),
  108|  10.4k|        }
  109|  10.4k|    }
_RNvMCsijPsW9w8cJj_9regalloc2NtB2_4PReg10from_index:
  137|  19.5k|    pub const fn from_index(index: usize) -> Self {
  138|  19.5k|        PReg {
  139|  19.5k|            bits: (index & (Self::NUM_INDEX - 1)) as u8,
  140|  19.5k|        }
  141|  19.5k|    }
_RNvMs4_CsijPsW9w8cJj_9regalloc2NtB5_4VReg3new:
  266|  10.4k|    pub const fn new(virt_reg: usize, class: RegClass) -> Self {
  267|  10.4k|        // See comment in `PReg::new()`: we are emulating a const
  268|  10.4k|        // assert here until const panics are stable.
  269|  10.4k|        const VIRT_REG_MUST_BE_IN_BOUNDS: &[bool; VReg::MAX + 1] = &[true; VReg::MAX + 1];
  270|  10.4k|        let _ = VIRT_REG_MUST_BE_IN_BOUNDS[virt_reg];
  271|  10.4k|
  272|  10.4k|        VReg {
  273|  10.4k|            bits: ((virt_reg as u32) << 1) | (class as u8 as u32),
  274|  10.4k|        }
  275|  10.4k|    }
_RNvXsU_CsijPsW9w8cJj_9regalloc2NtB5_4VRegNtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eq:
  255|    326|#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]

_RNvNtNtNtNtCs9Er17ssDkOt_6rustix7backend4arch3asm11target_arch8syscall2:
   66|  1.30k|pub(in crate::backend) unsafe fn syscall2(
   67|  1.30k|    nr: SyscallNumber<'_>,
   68|  1.30k|    a0: ArgReg<'_, A0>,
   69|  1.30k|    a1: ArgReg<'_, A1>,
   70|  1.30k|) -> RetReg<R0> {
   71|  1.30k|    let r0;
   72|  1.30k|    asm!(
   73|  1.30k|        "syscall",
   74|  1.30k|        inlateout("rax") nr.to_asm() => r0,
   75|  1.30k|        in("rdi") a0.to_asm(),
   76|  1.30k|        in("rsi") a1.to_asm(),
   77|  1.30k|        lateout("rcx") _,
   78|  1.30k|        lateout("r11") _,
   79|  1.30k|        options(nostack, preserves_flags)
   80|  1.30k|    );
   81|  1.30k|    FromAsm::from_asm(r0)
   82|  1.30k|}
_RNvNtNtNtNtCs9Er17ssDkOt_6rustix7backend4arch3asm11target_arch8syscall6:
  242|  1.30k|pub(in crate::backend) unsafe fn syscall6(
  243|  1.30k|    nr: SyscallNumber<'_>,
  244|  1.30k|    a0: ArgReg<'_, A0>,
  245|  1.30k|    a1: ArgReg<'_, A1>,
  246|  1.30k|    a2: ArgReg<'_, A2>,
  247|  1.30k|    a3: ArgReg<'_, A3>,
  248|  1.30k|    a4: ArgReg<'_, A4>,
  249|  1.30k|    a5: ArgReg<'_, A5>,
  250|  1.30k|) -> RetReg<R0> {
  251|  1.30k|    let r0;
  252|  1.30k|    asm!(
  253|  1.30k|        "syscall",
  254|  1.30k|        inlateout("rax") nr.to_asm() => r0,
  255|  1.30k|        in("rdi") a0.to_asm(),
  256|  1.30k|        in("rsi") a1.to_asm(),
  257|  1.30k|        in("rdx") a2.to_asm(),
  258|  1.30k|        in("r10") a3.to_asm(),
  259|  1.30k|        in("r8") a4.to_asm(),
  260|  1.30k|        in("r9") a5.to_asm(),
  261|  1.30k|        lateout("rcx") _,
  262|  1.30k|        lateout("r11") _,
  263|  1.30k|        options(nostack, preserves_flags)
  264|  1.30k|    );
  265|  1.30k|    FromAsm::from_asm(r0)
  266|  1.30k|}

_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A3ECsfBAxPD3lkOv_16wasmtime_runtime:
   99|  1.30k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  1.30k|    raw_arg(t as *mut _)
  101|  1.30k|}
_RNvXsf_NtNtCs9Er17ssDkOt_6rustix7backend4convINtNtB7_3reg6ArgRegNtBK_2A2EINtNtCsdRJjCzU6nMS_4core7convert4FromNtNtNtB7_2mm5types9ProtFlagsE4fromCsfBAxPD3lkOv_16wasmtime_runtime:
  375|  1.30k|    fn from(flags: crate::backend::mm::types::ProtFlags) -> Self {
  376|  1.30k|        c_uint(flags.bits())
  377|  1.30k|    }
_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv5no_fdNtNtB4_3reg2A4ECsfBAxPD3lkOv_16wasmtime_runtime:
  178|  1.30k|pub(super) fn no_fd<'a, Num: ArgNumber>() -> ArgReg<'a, Num> {
  179|  1.30k|    pass_usize(!0_usize)
  180|  1.30k|}
_RNvXNtNtCs9Er17ssDkOt_6rustix7backend4convINtNtB4_3reg6ArgRegNtBH_2A0EINtNtCsdRJjCzU6nMS_4core7convert4FromONtNtB1b_3ffi6c_voidE4fromCsfBAxPD3lkOv_16wasmtime_runtime:
  105|  2.60k|    fn from(c: *mut T) -> ArgReg<'a, Num> {
  106|  2.60k|        raw_arg(c.cast())
  107|  2.60k|    }
_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A5ECsfBAxPD3lkOv_16wasmtime_runtime:
   99|  1.30k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  1.30k|    raw_arg(t as *mut _)
  101|  1.30k|}
_RNvNtNtCs9Er17ssDkOt_6rustix7backend4conv13ret_void_star:
  772|  1.30k|pub(super) fn ret_void_star(raw: RetReg<R0>) -> io::Result<*mut c::c_void> {
  773|  1.30k|    try_decode_void_star(raw)
  774|  1.30k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A4ECsfBAxPD3lkOv_16wasmtime_runtime:
   99|  1.30k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  1.30k|    raw_arg(t as *mut _)
  101|  1.30k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv15loff_t_from_u64NtNtB4_3reg2A5ECsfBAxPD3lkOv_16wasmtime_runtime:
  260|  1.30k|pub(super) fn loff_t_from_u64<'a, Num: ArgNumber>(i: u64) -> ArgReg<'a, Num> {
  261|  1.30k|    // `loff_t` is signed, but syscalls which expect `loff_t` return `EINVAL`
  262|  1.30k|    // if it's outside the signed `i64` range, so we can silently cast.
  263|  1.30k|    pass_usize(i as usize)
  264|  1.30k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A1ECsfBAxPD3lkOv_16wasmtime_runtime:
   99|  2.60k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  2.60k|    raw_arg(t as *mut _)
  101|  2.60k|}
_RNvNtNtCs9Er17ssDkOt_6rustix7backend4conv3ret:
  658|  1.30k|pub(super) unsafe fn ret(raw: RetReg<R0>) -> io::Result<()> {
  659|  1.30k|    try_decode_void(raw)
  660|  1.30k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv6c_uintNtNtB4_3reg2A2ECsfBAxPD3lkOv_16wasmtime_runtime:
  248|  1.30k|pub(super) fn c_uint<'a, Num: ArgNumber>(i: c::c_uint) -> ArgReg<'a, Num> {
  249|  1.30k|    pass_usize(i as usize)
  250|  1.30k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A2ECsfBAxPD3lkOv_16wasmtime_runtime:
   99|  1.30k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  1.30k|    raw_arg(t as *mut _)
  101|  1.30k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend4conv6c_uintNtNtB4_3reg2A3ECsfBAxPD3lkOv_16wasmtime_runtime:
  248|  1.30k|pub(super) fn c_uint<'a, Num: ArgNumber>(i: c::c_uint) -> ArgReg<'a, Num> {
  249|  1.30k|    pass_usize(i as usize)
  250|  1.30k|}

_RINvNtNtNtCs9Er17ssDkOt_6rustix7backend2io5errno20try_decode_void_starNtNtB6_3reg2R0ECsfBAxPD3lkOv_16wasmtime_runtime:
  124|  1.30k|pub(in crate::backend) fn try_decode_void_star<Num: RetNumber>(
  125|  1.30k|    raw: RetReg<Num>,
  126|  1.30k|) -> io::Result<*mut c::c_void> {
  127|  1.30k|    if raw.is_in_range(-4095..0) {
  128|       |        // Safety: `raw` must be in `-4095..0`, and we just checked that raw is
  129|       |        // in that range.
  130|      0|        return Err(unsafe { Errno(raw.decode_error_code()) });
  131|  1.30k|    }
  132|  1.30k|
  133|  1.30k|    Ok(raw.decode_void_star())
  134|  1.30k|}
_RINvNtNtNtCs9Er17ssDkOt_6rustix7backend2io5errno15try_decode_voidNtNtB6_3reg2R0ECsfBAxPD3lkOv_16wasmtime_runtime:
  187|  1.30k|pub(in crate::backend) unsafe fn try_decode_void<Num: RetNumber>(
  188|  1.30k|    raw: RetReg<Num>,
  189|  1.30k|) -> io::Result<()> {
  190|  1.30k|    // Instead of using `check_result` here, we just check for zero, since this
  191|  1.30k|    // function is only used for system calls which have no other return value,
  192|  1.30k|    // and this produces smaller code.
  193|  1.30k|    if raw.is_nonzero() {
  194|      0|        debug_assert!(raw.is_in_range(-4095..0));
  195|       |
  196|       |        // Tell the optimizer that we know the value is in the error range.
  197|       |        // This helps it avoid unnecessary integer conversions.
  198|       |        #[cfg(core_intrinsics)]
  199|      0|        {
  200|      0|            core::intrinsics::assume(raw.is_in_range(-4095..0));
  201|      0|        }
  202|      0|
  203|      0|        return Err(Errno(raw.decode_error_code()));
  204|  1.30k|    }
  205|  1.30k|
  206|  1.30k|    raw.decode_void();
  207|  1.30k|
  208|  1.30k|    Ok(())
  209|  1.30k|}

_RNvNtNtNtCs9Er17ssDkOt_6rustix7backend2mm8syscalls14mmap_anonymous:
   87|  1.30k|pub(crate) unsafe fn mmap_anonymous(
   88|  1.30k|    addr: *mut c::c_void,
   89|  1.30k|    length: usize,
   90|  1.30k|    prot: ProtFlags,
   91|  1.30k|    flags: MapFlags,
   92|  1.30k|) -> io::Result<*mut c::c_void> {
   93|  1.30k|    #[cfg(target_pointer_width = "32")]
   94|  1.30k|    {
   95|  1.30k|        ret_void_star(syscall!(
   96|  1.30k|            __NR_mmap2,
   97|  1.30k|            addr,
   98|  1.30k|            pass_usize(length),
   99|  1.30k|            prot,
  100|  1.30k|            c_uint(flags.bits() | MAP_ANONYMOUS),
  101|  1.30k|            no_fd(),
  102|  1.30k|            pass_usize(0)
  103|  1.30k|        ))
  104|  1.30k|    }
  105|  1.30k|    #[cfg(target_pointer_width = "64")]
  106|  1.30k|    {
  107|  1.30k|        ret_void_star(syscall!(
  108|  1.30k|            __NR_mmap,
  109|  1.30k|            addr,
  110|  1.30k|            pass_usize(length),
  111|  1.30k|            prot,
  112|  1.30k|            c_uint(flags.bits() | MAP_ANONYMOUS),
  113|  1.30k|            no_fd(),
  114|  1.30k|            loff_t_from_u64(0)
  115|  1.30k|        ))
  116|  1.30k|    }
  117|  1.30k|}
_RNvNtNtNtCs9Er17ssDkOt_6rustix7backend2mm8syscalls6munmap:
  133|  1.30k|pub(crate) unsafe fn munmap(addr: *mut c::c_void, length: usize) -> io::Result<()> {
  134|  1.30k|    ret(syscall!(__NR_munmap, addr, pass_usize(length)))
  135|  1.30k|}

_RINvNtNtCs9Er17ssDkOt_6rustix7backend3reg7raw_argNtB2_2A2ECsfBAxPD3lkOv_16wasmtime_runtime:
  221|  1.30k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  1.30k|    ArgReg {
  223|  1.30k|        raw,
  224|  1.30k|        _phantom: PhantomData,
  225|  1.30k|    }
  226|  1.30k|}
_RNvXs5_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6ArgRegNtB5_2A2ENtB5_5ToAsm6to_asmCsfBAxPD3lkOv_16wasmtime_runtime:
   95|  1.30k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  1.30k|        self.raw
   97|  1.30k|    }
_RNvXs7_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6RetRegNtB5_2R0ENtB5_7FromAsm8from_asmCsfBAxPD3lkOv_16wasmtime_runtime:
  198|  2.60k|    unsafe fn from_asm(raw: *mut Opaque) -> Self {
  199|  2.60k|        Self {
  200|  2.60k|            raw,
  201|  2.60k|            _phantom: PhantomData,
  202|  2.60k|        }
  203|  2.60k|    }
_RNvMs6_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6RetRegNtB5_2R0E11is_in_rangeCsfBAxPD3lkOv_16wasmtime_runtime:
  191|  1.30k|    pub(super) fn is_in_range(&self, range: core::ops::Range<isize>) -> bool {
  192|  1.30k|        range.contains(&(self.raw as isize))
  193|  1.30k|    }
_RNvMs6_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6RetRegNtB5_2R0E16decode_void_starCsfBAxPD3lkOv_16wasmtime_runtime:
  153|  1.30k|    pub(super) fn decode_void_star(self) -> *mut c::c_void {
  154|  1.30k|        self.raw.cast()
  155|  1.30k|    }
_RNvNtNtCs9Er17ssDkOt_6rustix7backend3reg2nr:
  230|  2.60k|pub(super) const fn nr<'a>(nr: u32) -> SyscallNumber<'a> {
  231|  2.60k|    SyscallNumber {
  232|  2.60k|        nr: nr as usize,
  233|  2.60k|        _phantom: PhantomData,
  234|  2.60k|    }
  235|  2.60k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend3reg7raw_argNtB2_2A3ECsfBAxPD3lkOv_16wasmtime_runtime:
  221|  1.30k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  1.30k|    ArgReg {
  223|  1.30k|        raw,
  224|  1.30k|        _phantom: PhantomData,
  225|  1.30k|    }
  226|  1.30k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend3reg7raw_argNtB2_2A5ECsfBAxPD3lkOv_16wasmtime_runtime:
  221|  1.30k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  1.30k|    ArgReg {
  223|  1.30k|        raw,
  224|  1.30k|        _phantom: PhantomData,
  225|  1.30k|    }
  226|  1.30k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend3reg7raw_argNtB2_2A1ECsfBAxPD3lkOv_16wasmtime_runtime:
  221|  2.60k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  2.60k|    ArgReg {
  223|  2.60k|        raw,
  224|  2.60k|        _phantom: PhantomData,
  225|  2.60k|    }
  226|  2.60k|}
_RINvNtNtCs9Er17ssDkOt_6rustix7backend3reg7raw_argNtB2_2A0ECsfBAxPD3lkOv_16wasmtime_runtime:
  221|  2.60k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  2.60k|    ArgReg {
  223|  2.60k|        raw,
  224|  2.60k|        _phantom: PhantomData,
  225|  2.60k|    }
  226|  2.60k|}
_RNvMs6_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6RetRegNtB5_2R0E11decode_voidCsfBAxPD3lkOv_16wasmtime_runtime:
  164|  1.30k|    pub(super) fn decode_void(self) {
  165|  1.30k|        let ignore = self.decode_usize();
  166|  1.30k|        debug_assert_eq!(ignore, 0);
  167|  1.30k|    }
_RNvXs5_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6ArgRegNtB5_2A0ENtB5_5ToAsm6to_asmCsfBAxPD3lkOv_16wasmtime_runtime:
   95|  2.60k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  2.60k|        self.raw
   97|  2.60k|    }
_RNvMs6_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6RetRegNtB5_2R0E10is_nonzeroCsfBAxPD3lkOv_16wasmtime_runtime:
  181|  1.30k|    pub(super) fn is_nonzero(&self) -> bool {
  182|  1.30k|        !self.raw.is_null()
  183|  1.30k|    }
_RNvXs5_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6ArgRegNtB5_2A5ENtB5_5ToAsm6to_asmCsfBAxPD3lkOv_16wasmtime_runtime:
   95|  1.30k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  1.30k|        self.raw
   97|  1.30k|    }
_RNvXs8_NtNtCs9Er17ssDkOt_6rustix7backend3regNtB5_13SyscallNumberNtB5_5ToAsm6to_asm:
  214|  2.60k|    unsafe fn to_asm(self) -> *mut Opaque {
  215|  2.60k|        self.nr as usize as *mut Opaque
  216|  2.60k|    }
_RNvXs5_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6ArgRegNtB5_2A3ENtB5_5ToAsm6to_asmCsfBAxPD3lkOv_16wasmtime_runtime:
   95|  1.30k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  1.30k|        self.raw
   97|  1.30k|    }
_RINvNtNtCs9Er17ssDkOt_6rustix7backend3reg7raw_argNtB2_2A4ECsfBAxPD3lkOv_16wasmtime_runtime:
  221|  1.30k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  1.30k|    ArgReg {
  223|  1.30k|        raw,
  224|  1.30k|        _phantom: PhantomData,
  225|  1.30k|    }
  226|  1.30k|}
_RNvMs6_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6RetRegNtB5_2R0E12decode_usizeCsfBAxPD3lkOv_16wasmtime_runtime:
  114|  1.30k|    pub(super) fn decode_usize(self) -> usize {
  115|  1.30k|        debug_assert!(!(-4095..0).contains(&(self.raw as isize)));
  116|  1.30k|        self.raw as usize
  117|  1.30k|    }
_RNvXs5_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6ArgRegNtB5_2A4ENtB5_5ToAsm6to_asmCsfBAxPD3lkOv_16wasmtime_runtime:
   95|  1.30k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  1.30k|        self.raw
   97|  1.30k|    }
_RNvXs5_NtNtCs9Er17ssDkOt_6rustix7backend3regINtB5_6ArgRegNtB5_2A1ENtB5_5ToAsm6to_asmCsfBAxPD3lkOv_16wasmtime_runtime:
   95|  2.60k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  2.60k|        self.raw
   97|  2.60k|    }

_RNvNtNtCs9Er17ssDkOt_6rustix2mm4mmap14mmap_anonymous:
   64|  1.30k|pub unsafe fn mmap_anonymous(
   65|  1.30k|    ptr: *mut c_void,
   66|  1.30k|    len: usize,
   67|  1.30k|    prot: ProtFlags,
   68|  1.30k|    flags: MapFlags,
   69|  1.30k|) -> io::Result<*mut c_void> {
   70|  1.30k|    backend::mm::syscalls::mmap_anonymous(ptr, len, prot, flags)
   71|  1.30k|}
_RNvNtNtCs9Er17ssDkOt_6rustix2mm4mmap6munmap:
   86|  1.30k|pub unsafe fn munmap(ptr: *mut c_void, len: usize) -> io::Result<()> {
   87|  1.30k|    backend::mm::syscalls::munmap(ptr, len)
   88|  1.30k|}

_RNvXs4_Cs6tWXBTLxExk_10scopeguardINtB5_10ScopeGuardQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCsdRJjCzU6nMS_4core3ops5deref8DerefMut9deref_mutCs4ieSHZHrxF6_15direct_syscalls:
  443|  9.12k|    fn deref_mut(&mut self) -> &mut T {
  444|  9.12k|        &mut *self.value
  445|  9.12k|    }
_RNvXCs6tWXBTLxExk_10scopeguardNtB2_6AlwaysNtB2_8Strategy10should_run:
  231|  12.2k|    fn should_run() -> bool { true }
_RINvCs6tWXBTLxExk_10scopeguard5guardQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEFBy_EuECs4ieSHZHrxF6_15direct_syscalls:
  367|  9.12k|pub fn guard<T, F>(v: T, dropfn: F) -> ScopeGuard<T, F, Always>
  368|  9.12k|    where F: FnOnce(T)
  369|  9.12k|{
  370|  9.12k|    ScopeGuard::with_strategy(v, dropfn)
  371|  9.12k|}
_RNvMs1_Cs6tWXBTLxExk_10scopeguardINtB5_10ScopeGuardQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEFBN_EuE13with_strategyCs4ieSHZHrxF6_15direct_syscalls:
  317|  9.12k|    pub fn with_strategy(v: T, dropfn: F) -> ScopeGuard<T, F, S> {
  318|  9.12k|        ScopeGuard {
  319|  9.12k|            value: ManuallyDrop::new(v),
  320|  9.12k|            dropfn: ManuallyDrop::new(dropfn),
  321|  9.12k|            strategy: PhantomData,
  322|  9.12k|        }
  323|  9.12k|    }
_RNvXs5_Cs6tWXBTLxExk_10scopeguardINtB5_10ScopeGuardQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4dropCs4ieSHZHrxF6_15direct_syscalls:
  452|  9.12k|    fn drop(&mut self) {
  453|  9.12k|        // This is OK because the fields are `ManuallyDrop`s
  454|  9.12k|        // which will not be dropped by the compiler.
  455|  9.12k|        let (value, dropfn) = unsafe {
  456|  9.12k|            (ptr::read(&*self.value), ptr::read(&*self.dropfn))
  457|  9.12k|        };
  458|  9.12k|        if S::should_run() {
  459|  9.12k|            dropfn(value);
  460|  9.12k|        }
  461|  9.12k|    }
_RNvXs4_Cs6tWXBTLxExk_10scopeguardINtB5_10ScopeGuardQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCsdRJjCzU6nMS_4core3ops5deref8DerefMut9deref_mutCsilvC8qPft2D_8fvm_fuzz:
  443|  3.09k|    fn deref_mut(&mut self) -> &mut T {
  444|  3.09k|        &mut *self.value
  445|  3.09k|    }
_RNvMs1_Cs6tWXBTLxExk_10scopeguardINtB5_10ScopeGuardQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEFBN_EuE13with_strategyCsilvC8qPft2D_8fvm_fuzz:
  317|  3.09k|    pub fn with_strategy(v: T, dropfn: F) -> ScopeGuard<T, F, S> {
  318|  3.09k|        ScopeGuard {
  319|  3.09k|            value: ManuallyDrop::new(v),
  320|  3.09k|            dropfn: ManuallyDrop::new(dropfn),
  321|  3.09k|            strategy: PhantomData,
  322|  3.09k|        }
  323|  3.09k|    }
_RNvXs5_Cs6tWXBTLxExk_10scopeguardINtB5_10ScopeGuardQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4dropCsilvC8qPft2D_8fvm_fuzz:
  452|  3.09k|    fn drop(&mut self) {
  453|  3.09k|        // This is OK because the fields are `ManuallyDrop`s
  454|  3.09k|        // which will not be dropped by the compiler.
  455|  3.09k|        let (value, dropfn) = unsafe {
  456|  3.09k|            (ptr::read(&*self.value), ptr::read(&*self.dropfn))
  457|  3.09k|        };
  458|  3.09k|        if S::should_run() {
  459|  3.09k|            dropfn(value);
  460|  3.09k|        }
  461|  3.09k|    }
_RINvCs6tWXBTLxExk_10scopeguard5guardQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEFBy_EuECsilvC8qPft2D_8fvm_fuzz:
  367|  3.09k|pub fn guard<T, F>(v: T, dropfn: F) -> ScopeGuard<T, F, Always>
  368|  3.09k|    where F: FnOnce(T)
  369|  3.09k|{
  370|  3.09k|    ScopeGuard::with_strategy(v, dropfn)
  371|  3.09k|}

_RINvXsX_NtNtCs2VpXLMAfFh1_5serde2de5implsyNtB8_11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  113|    489|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    489|            where
  115|    489|                D: Deserializer<'de>,
  116|    489|            {
  117|    489|                struct PrimitiveVisitor;
  118|    489|
  119|    489|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    489|                    type Value = $primitive;
  121|    489|
  122|    489|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    489|                        formatter.write_str(stringify!($primitive))
  124|    489|                    }
  125|    489|
  126|    489|                    $($($method!($val : $visit);)*)*
  127|    489|                }
  128|    489|
  129|    489|                deserializer.$deserialize(PrimitiveVisitor)
  130|    489|            }
_RINvXNvXsV_NtNtCs2VpXLMAfFh1_5serde2de5implsmNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u32INtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
  138|    163|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    163|        where
  140|    163|            E: Error,
  141|    163|        {
  142|    163|            Ok(v)
  143|    163|        }
_RINvXsd_NtNtCs2VpXLMAfFh1_5serde2de5implsINtB6_13OptionVisitorNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressENtB8_7Visitor10visit_noneNtNtCsb605JUWHIii_12libipld_core5error10SerdeErrorECs4ieSHZHrxF6_15direct_syscalls:
  781|    489|    fn visit_none<E>(self) -> Result<Self::Value, E>
  782|    489|    where
  783|    489|        E: Error,
  784|    489|    {
  785|    489|        Ok(None)
  786|    489|    }
_RINvXNvXsX_NtNtCs2VpXLMAfFh1_5serde2de5implsyNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u64NtNtCsb605JUWHIii_12libipld_core5error10SerdeErrorECs4ieSHZHrxF6_15direct_syscalls:
  138|    489|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    489|        where
  140|    489|            E: Error,
  141|    489|        {
  142|    489|            Ok(v)
  143|    489|        }
_RINvXse_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCsdRJjCzU6nMS_4core6option6OptionNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressENtB8_11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  808|    489|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  809|    489|    where
  810|    489|        D: Deserializer<'de>,
  811|    489|    {
  812|    489|        deserializer.deserialize_option(OptionVisitor {
  813|    489|            marker: PhantomData,
  814|    489|        })
  815|    489|    }
_RINvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1260|  2.44k|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|  2.44k|                where
 1262|  2.44k|                    D: Deserializer<'de>,
 1263|  2.44k|                {
 1264|  2.44k|                    struct TupleVisitor<$($name,)+> {
 1265|  2.44k|                        marker: PhantomData<($($name,)+)>,
 1266|  2.44k|                    }
 1267|  2.44k|
 1268|  2.44k|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|  2.44k|                        type Value = ($($name,)+);
 1270|  2.44k|
 1271|  2.44k|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|  2.44k|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|  2.44k|                        }
 1274|  2.44k|
 1275|  2.44k|                        #[inline]
 1276|  2.44k|                        #[allow(non_snake_case)]
 1277|  2.44k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  2.44k|                        where
 1279|  2.44k|                            A: SeqAccess<'de>,
 1280|  2.44k|                        {
 1281|  2.44k|                            $(
 1282|  2.44k|                                let $name = match try!(seq.next_element()) {
 1283|  2.44k|                                    Some(value) => value,
 1284|  2.44k|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|  2.44k|                                };
 1286|  2.44k|                            )+
 1287|  2.44k|
 1288|  2.44k|                            Ok(($($name,)+))
 1289|  2.44k|                        }
 1290|  2.44k|                    }
 1291|  2.44k|
 1292|  2.44k|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|  2.44k|                }
_RINvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEENtB8_11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
 1013|    489|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    489|    where
 1015|    489|        D: Deserializer<'de>,
 1016|    489|    {
 1017|    489|        struct VecVisitor<T> {
 1018|    489|            marker: PhantomData<T>,
 1019|    489|        }
 1020|    489|
 1021|    489|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    489|        where
 1023|    489|            T: Deserialize<'de>,
 1024|    489|        {
 1025|    489|            type Value = Vec<T>;
 1026|    489|
 1027|    489|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    489|                formatter.write_str("a sequence")
 1029|    489|            }
 1030|    489|
 1031|    489|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    489|            where
 1033|    489|                A: SeqAccess<'de>,
 1034|    489|            {
 1035|    489|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    489|
 1037|    489|                while let Some(value) = try!(seq.next_element()) {
 1038|    489|                    values.push(value);
 1039|    489|                }
 1040|    489|
 1041|    489|                Ok(values)
 1042|    489|            }
 1043|    489|        }
 1044|    489|
 1045|    489|        let visitor = VecVisitor {
 1046|    489|            marker: PhantomData,
 1047|    489|        };
 1048|    489|        deserializer.deserialize_seq(visitor)
 1049|    489|    }
_RINvXNvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorTNtNtBL_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEENtBb_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1031|    163|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    163|            where
 1033|    163|                A: SeqAccess<'de>,
 1034|    163|            {
 1035|    163|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|  2.60k|                while let Some(value) = try!(seq.next_element()) {
 1038|  2.44k|                    values.push(value);
 1039|  2.44k|                }
 1040|       |
 1041|    163|                Ok(values)
 1042|    163|            }
_RINvXNvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEENtBb_7Visitor9visit_seqQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerECs4ieSHZHrxF6_15direct_syscalls:
 1031|    489|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    489|            where
 1033|    489|                A: SeqAccess<'de>,
 1034|    489|            {
 1035|    489|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|    978|                while let Some(value) = try!(seq.next_element()) {
 1038|    489|                    values.push(value);
 1039|    489|                }
 1040|       |
 1041|    489|                Ok(values)
 1042|    489|            }
_RINvXsV_NtNtCs2VpXLMAfFh1_5serde2de5implsmNtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  113|    163|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    163|            where
  115|    163|                D: Deserializer<'de>,
  116|    163|            {
  117|    163|                struct PrimitiveVisitor;
  118|    163|
  119|    163|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    163|                    type Value = $primitive;
  121|    163|
  122|    163|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    163|                        formatter.write_str(stringify!($primitive))
  124|    163|                    }
  125|    163|
  126|    163|                    $($($method!($val : $visit);)*)*
  127|    163|                }
  128|    163|
  129|    163|                deserializer.$deserialize(PrimitiveVisitor)
  130|    163|            }
_RINvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecTNtNtBI_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEENtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1013|    163|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    163|    where
 1015|    163|        D: Deserializer<'de>,
 1016|    163|    {
 1017|    163|        struct VecVisitor<T> {
 1018|    163|            marker: PhantomData<T>,
 1019|    163|        }
 1020|    163|
 1021|    163|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    163|        where
 1023|    163|            T: Deserialize<'de>,
 1024|    163|        {
 1025|    163|            type Value = Vec<T>;
 1026|    163|
 1027|    163|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    163|                formatter.write_str("a sequence")
 1029|    163|            }
 1030|    163|
 1031|    163|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    163|            where
 1033|    163|                A: SeqAccess<'de>,
 1034|    163|            {
 1035|    163|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    163|
 1037|    163|                while let Some(value) = try!(seq.next_element()) {
 1038|    163|                    values.push(value);
 1039|    163|                }
 1040|    163|
 1041|    163|                Ok(values)
 1042|    163|            }
 1043|    163|        }
 1044|    163|
 1045|    163|        let visitor = VecVisitor {
 1046|    163|            marker: PhantomData,
 1047|    163|        };
 1048|    163|        deserializer.deserialize_seq(visitor)
 1049|    163|    }
_RINvXNvXsX_NtNtCs2VpXLMAfFh1_5serde2de5implsyNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u64INtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
  138|    163|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    163|        where
  140|    163|            E: Error,
  141|    163|        {
  142|    163|            Ok(v)
  143|    163|        }
_RINvXNvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitorNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1277|  2.44k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  2.44k|                        where
 1279|  2.44k|                            A: SeqAccess<'de>,
 1280|  2.44k|                        {
 1281|       |                            $(
 1282|  2.44k|                                let $name = match try!(seq.next_element()) {
 1283|  2.44k|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|  2.44k|                            Ok(($($name,)+))
 1289|  2.44k|                        }
_RINvXsX_NtNtCs2VpXLMAfFh1_5serde2de5implsyNtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  113|    163|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    163|            where
  115|    163|                D: Deserializer<'de>,
  116|    163|            {
  117|    163|                struct PrimitiveVisitor;
  118|    163|
  119|    163|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    163|                    type Value = $primitive;
  121|    163|
  122|    163|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    163|                        formatter.write_str(stringify!($primitive))
  124|    163|                    }
  125|    163|
  126|    163|                    $($($method!($val : $visit);)*)*
  127|    163|                }
  128|    163|
  129|    163|                deserializer.$deserialize(PrimitiveVisitor)
  130|    163|            }
_RINvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtBJ_7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtBJ_14hash_algorithm6Sha256EEENtB9_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1260|    163|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|    163|                where
 1262|    163|                    D: Deserializer<'de>,
 1263|    163|                {
 1264|    163|                    struct TupleVisitor<$($name,)+> {
 1265|    163|                        marker: PhantomData<($($name,)+)>,
 1266|    163|                    }
 1267|    163|
 1268|    163|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|    163|                        type Value = ($($name,)+);
 1270|    163|
 1271|    163|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|    163|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|    163|                        }
 1274|    163|
 1275|    163|                        #[inline]
 1276|    163|                        #[allow(non_snake_case)]
 1277|    163|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    163|                        where
 1279|    163|                            A: SeqAccess<'de>,
 1280|    163|                        {
 1281|    163|                            $(
 1282|    163|                                let $name = match try!(seq.next_element()) {
 1283|    163|                                    Some(value) => value,
 1284|    163|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|    163|                                };
 1286|    163|                            )+
 1287|    163|
 1288|    163|                            Ok(($($name,)+))
 1289|    163|                        }
 1290|    163|                    }
 1291|    163|
 1292|    163|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|    163|                }
_RINvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1260|    163|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|    163|                where
 1262|    163|                    D: Deserializer<'de>,
 1263|    163|                {
 1264|    163|                    struct TupleVisitor<$($name,)+> {
 1265|    163|                        marker: PhantomData<($($name,)+)>,
 1266|    163|                    }
 1267|    163|
 1268|    163|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|    163|                        type Value = ($($name,)+);
 1270|    163|
 1271|    163|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|    163|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|    163|                        }
 1274|    163|
 1275|    163|                        #[inline]
 1276|    163|                        #[allow(non_snake_case)]
 1277|    163|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    163|                        where
 1279|    163|                            A: SeqAccess<'de>,
 1280|    163|                        {
 1281|    163|                            $(
 1282|    163|                                let $name = match try!(seq.next_element()) {
 1283|    163|                                    Some(value) => value,
 1284|    163|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|    163|                                };
 1286|    163|                            )+
 1287|    163|
 1288|    163|                            Ok(($($name,)+))
 1289|    163|                        }
 1290|    163|                    }
 1291|    163|
 1292|    163|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|    163|                }
_RINvXNvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB27_14hash_algorithm6Sha256EENtBb_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1031|    163|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    163|            where
 1033|    163|                A: SeqAccess<'de>,
 1034|    163|            {
 1035|    163|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|    652|                while let Some(value) = try!(seq.next_element()) {
 1038|    489|                    values.push(value);
 1039|    489|                }
 1040|       |
 1041|    163|                Ok(values)
 1042|    163|            }
_RINvXs6_NtNtCs2VpXLMAfFh1_5serde2de5implsNtNtCs71iYhC60HpU_5alloc6string6StringNtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  582|  2.44k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  583|  2.44k|    where
  584|  2.44k|        D: Deserializer<'de>,
  585|  2.44k|    {
  586|  2.44k|        deserializer.deserialize_string(StringVisitor)
  587|  2.44k|    }
_RINvXNvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitormINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1277|    163|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    163|                        where
 1279|    163|                            A: SeqAccess<'de>,
 1280|    163|                        {
 1281|       |                            $(
 1282|    163|                                let $name = match try!(seq.next_element()) {
 1283|    163|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|    163|                            Ok(($($name,)+))
 1289|    163|                        }
_RINvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB1f_14hash_algorithm6Sha256EENtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1013|    163|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    163|    where
 1015|    163|        D: Deserializer<'de>,
 1016|    163|    {
 1017|    163|        struct VecVisitor<T> {
 1018|    163|            marker: PhantomData<T>,
 1019|    163|        }
 1020|    163|
 1021|    163|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    163|        where
 1023|    163|            T: Deserialize<'de>,
 1024|    163|        {
 1025|    163|            type Value = Vec<T>;
 1026|    163|
 1027|    163|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    163|                formatter.write_str("a sequence")
 1029|    163|            }
 1030|    163|
 1031|    163|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    163|            where
 1033|    163|                A: SeqAccess<'de>,
 1034|    163|            {
 1035|    163|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    163|
 1037|    163|                while let Some(value) = try!(seq.next_element()) {
 1038|    163|                    values.push(value);
 1039|    163|                }
 1040|    163|
 1041|    163|                Ok(values)
 1042|    163|            }
 1043|    163|        }
 1044|    163|
 1045|    163|        let visitor = VecVisitor {
 1046|    163|            marker: PhantomData,
 1047|    163|        };
 1048|    163|        deserializer.deserialize_seq(visitor)
 1049|    163|    }
_RINvXs4_NtNtCs2VpXLMAfFh1_5serde2de5implsNtB6_13StringVisitorNtB8_7Visitor9visit_strINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
  486|  2.44k|    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
  487|  2.44k|    where
  488|  2.44k|        E: Error,
  489|  2.44k|    {
  490|  2.44k|        Ok(v.to_owned())
  491|  2.44k|    }
_RINvXNvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitorNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtB1E_7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB1E_14hash_algorithm6Sha256EEENtBc_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
 1277|    163|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    163|                        where
 1279|    163|                            A: SeqAccess<'de>,
 1280|    163|                        {
 1281|       |                            $(
 1282|    163|                                let $name = match try!(seq.next_element()) {
 1283|    163|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|    163|                            Ok(($($name,)+))
 1289|    163|                        }
_RINvXsV_NtNtCs2VpXLMAfFh1_5serde2de5implsmNtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  113|    163|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    163|            where
  115|    163|                D: Deserializer<'de>,
  116|    163|            {
  117|    163|                struct PrimitiveVisitor;
  118|    163|
  119|    163|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    163|                    type Value = $primitive;
  121|    163|
  122|    163|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    163|                        formatter.write_str(stringify!($primitive))
  124|    163|                    }
  125|    163|
  126|    163|                    $($($method!($val : $visit);)*)*
  127|    163|                }
  128|    163|
  129|    163|                deserializer.$deserialize(PrimitiveVisitor)
  130|    163|            }
_RINvXNvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorTNtNtBL_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEENtBb_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
 1031|    163|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    163|            where
 1033|    163|                A: SeqAccess<'de>,
 1034|    163|            {
 1035|    163|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|  2.60k|                while let Some(value) = try!(seq.next_element()) {
 1038|  2.44k|                    values.push(value);
 1039|  2.44k|                }
 1040|       |
 1041|    163|                Ok(values)
 1042|    163|            }
_RINvXNvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitorNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
 1277|  2.44k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  2.44k|                        where
 1279|  2.44k|                            A: SeqAccess<'de>,
 1280|  2.44k|                        {
 1281|       |                            $(
 1282|  2.44k|                                let $name = match try!(seq.next_element()) {
 1283|  2.44k|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|  2.44k|                            Ok(($($name,)+))
 1289|  2.44k|                        }
_RINvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
 1260|  2.44k|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|  2.44k|                where
 1262|  2.44k|                    D: Deserializer<'de>,
 1263|  2.44k|                {
 1264|  2.44k|                    struct TupleVisitor<$($name,)+> {
 1265|  2.44k|                        marker: PhantomData<($($name,)+)>,
 1266|  2.44k|                    }
 1267|  2.44k|
 1268|  2.44k|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|  2.44k|                        type Value = ($($name,)+);
 1270|  2.44k|
 1271|  2.44k|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|  2.44k|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|  2.44k|                        }
 1274|  2.44k|
 1275|  2.44k|                        #[inline]
 1276|  2.44k|                        #[allow(non_snake_case)]
 1277|  2.44k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  2.44k|                        where
 1279|  2.44k|                            A: SeqAccess<'de>,
 1280|  2.44k|                        {
 1281|  2.44k|                            $(
 1282|  2.44k|                                let $name = match try!(seq.next_element()) {
 1283|  2.44k|                                    Some(value) => value,
 1284|  2.44k|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|  2.44k|                                };
 1286|  2.44k|                            )+
 1287|  2.44k|
 1288|  2.44k|                            Ok(($($name,)+))
 1289|  2.44k|                        }
 1290|  2.44k|                    }
 1291|  2.44k|
 1292|  2.44k|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|  2.44k|                }
_RINvXs6_NtNtCs2VpXLMAfFh1_5serde2de5implsNtNtCs71iYhC60HpU_5alloc6string6StringNtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  582|  2.44k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  583|  2.44k|    where
  584|  2.44k|        D: Deserializer<'de>,
  585|  2.44k|    {
  586|  2.44k|        deserializer.deserialize_string(StringVisitor)
  587|  2.44k|    }
_RINvXNvXsX_NtNtCs2VpXLMAfFh1_5serde2de5implsyNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u64INtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECsilvC8qPft2D_8fvm_fuzz:
  138|    163|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    163|        where
  140|    163|            E: Error,
  141|    163|        {
  142|    163|            Ok(v)
  143|    163|        }
_RINvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecTNtNtBI_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEENtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
 1013|    163|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    163|    where
 1015|    163|        D: Deserializer<'de>,
 1016|    163|    {
 1017|    163|        struct VecVisitor<T> {
 1018|    163|            marker: PhantomData<T>,
 1019|    163|        }
 1020|    163|
 1021|    163|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    163|        where
 1023|    163|            T: Deserialize<'de>,
 1024|    163|        {
 1025|    163|            type Value = Vec<T>;
 1026|    163|
 1027|    163|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    163|                formatter.write_str("a sequence")
 1029|    163|            }
 1030|    163|
 1031|    163|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    163|            where
 1033|    163|                A: SeqAccess<'de>,
 1034|    163|            {
 1035|    163|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    163|
 1037|    163|                while let Some(value) = try!(seq.next_element()) {
 1038|    163|                    values.push(value);
 1039|    163|                }
 1040|    163|
 1041|    163|                Ok(values)
 1042|    163|            }
 1043|    163|        }
 1044|    163|
 1045|    163|        let visitor = VecVisitor {
 1046|    163|            marker: PhantomData,
 1047|    163|        };
 1048|    163|        deserializer.deserialize_seq(visitor)
 1049|    163|    }
_RINvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
 1013|    163|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    163|    where
 1015|    163|        D: Deserializer<'de>,
 1016|    163|    {
 1017|    163|        struct VecVisitor<T> {
 1018|    163|            marker: PhantomData<T>,
 1019|    163|        }
 1020|    163|
 1021|    163|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    163|        where
 1023|    163|            T: Deserialize<'de>,
 1024|    163|        {
 1025|    163|            type Value = Vec<T>;
 1026|    163|
 1027|    163|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    163|                formatter.write_str("a sequence")
 1029|    163|            }
 1030|    163|
 1031|    163|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    163|            where
 1033|    163|                A: SeqAccess<'de>,
 1034|    163|            {
 1035|    163|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    163|
 1037|    163|                while let Some(value) = try!(seq.next_element()) {
 1038|    163|                    values.push(value);
 1039|    163|                }
 1040|    163|
 1041|    163|                Ok(values)
 1042|    163|            }
 1043|    163|        }
 1044|    163|
 1045|    163|        let visitor = VecVisitor {
 1046|    163|            marker: PhantomData,
 1047|    163|        };
 1048|    163|        deserializer.deserialize_seq(visitor)
 1049|    163|    }
_RINvXsX_NtNtCs2VpXLMAfFh1_5serde2de5implsyNtB8_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  113|    163|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    163|            where
  115|    163|                D: Deserializer<'de>,
  116|    163|            {
  117|    163|                struct PrimitiveVisitor;
  118|    163|
  119|    163|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    163|                    type Value = $primitive;
  121|    163|
  122|    163|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    163|                        formatter.write_str(stringify!($primitive))
  124|    163|                    }
  125|    163|
  126|    163|                    $($($method!($val : $visit);)*)*
  127|    163|                }
  128|    163|
  129|    163|                deserializer.$deserialize(PrimitiveVisitor)
  130|    163|            }
_RINvXs4_NtNtCs2VpXLMAfFh1_5serde2de5implsNtB6_13StringVisitorNtB8_7Visitor9visit_strINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECsilvC8qPft2D_8fvm_fuzz:
  486|  2.44k|    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
  487|  2.44k|    where
  488|  2.44k|        E: Error,
  489|  2.44k|    {
  490|  2.44k|        Ok(v.to_owned())
  491|  2.44k|    }
_RINvXNvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitormINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
 1277|    163|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    163|                        where
 1279|    163|                            A: SeqAccess<'de>,
 1280|    163|                        {
 1281|       |                            $(
 1282|    163|                                let $name = match try!(seq.next_element()) {
 1283|    163|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|    163|                            Ok(($($name,)+))
 1289|    163|                        }
_RINvXNvXsh_NtNtCs2VpXLMAfFh1_5serde2de5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtBb_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
 1031|    163|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    163|            where
 1033|    163|                A: SeqAccess<'de>,
 1034|    163|            {
 1035|    163|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|    326|                while let Some(value) = try!(seq.next_element()) {
 1038|    163|                    values.push(value);
 1039|    163|                }
 1040|       |
 1041|    163|                Ok(values)
 1042|    163|            }
_RINvXNvXsV_NtNtCs2VpXLMAfFh1_5serde2de5implsmNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u32INtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECsilvC8qPft2D_8fvm_fuzz:
  138|    163|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    163|        where
  140|    163|            E: Error,
  141|    163|        {
  142|    163|            Ok(v)
  143|    163|        }
_RINvXs2M_NtNtCs2VpXLMAfFh1_5serde2de5implsTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
 1260|    163|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|    163|                where
 1262|    163|                    D: Deserializer<'de>,
 1263|    163|                {
 1264|    163|                    struct TupleVisitor<$($name,)+> {
 1265|    163|                        marker: PhantomData<($($name,)+)>,
 1266|    163|                    }
 1267|    163|
 1268|    163|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|    163|                        type Value = ($($name,)+);
 1270|    163|
 1271|    163|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|    163|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|    163|                        }
 1274|    163|
 1275|    163|                        #[inline]
 1276|    163|                        #[allow(non_snake_case)]
 1277|    163|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    163|                        where
 1279|    163|                            A: SeqAccess<'de>,
 1280|    163|                        {
 1281|    163|                            $(
 1282|    163|                                let $name = match try!(seq.next_element()) {
 1283|    163|                                    Some(value) => value,
 1284|    163|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|    163|                                };
 1286|    163|                            )+
 1287|    163|
 1288|    163|                            Ok(($($name,)+))
 1289|    163|                        }
 1290|    163|                    }
 1291|    163|
 1292|    163|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|    163|                }

_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtB6_15DeserializeSeed11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  788|    978|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    978|    where
  790|    978|        D: Deserializer<'de>,
  791|    978|    {
  792|    978|        T::deserialize(deserializer)
  793|    978|    }
_RINvYNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementyECs4ieSHZHrxF6_15direct_syscalls:
 1728|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    489|    where
 1730|    489|        T: Deserialize<'de>,
 1731|    489|    {
 1732|    489|        self.next_element_seed(PhantomData)
 1733|    489|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCs71iYhC60HpU_5alloc6string6StringENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|  2.44k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  2.44k|    where
  790|  2.44k|        D: Deserializer<'de>,
  791|  2.44k|    {
  792|  2.44k|        T::deserialize(deserializer)
  793|  2.44k|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
 1728|  5.37k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  5.37k|    where
 1730|  5.37k|        T: Deserialize<'de>,
 1731|  5.37k|    {
 1732|  5.37k|        self.next_element_seed(PhantomData)
 1733|  5.37k|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldECs4ieSHZHrxF6_15direct_syscalls:
 1728|    163|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    163|    where
 1730|    163|        T: Deserialize<'de>,
 1731|    163|    {
 1732|    163|        self.next_element_seed(PhantomData)
 1733|    163|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementNtNtCs71iYhC60HpU_5alloc6string6StringECs4ieSHZHrxF6_15direct_syscalls:
 1728|  2.44k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  2.44k|    where
 1730|  2.44k|        T: Deserialize<'de>,
 1731|  2.44k|    {
 1732|  2.44k|        self.next_element_seed(PhantomData)
 1733|  2.44k|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementmECs4ieSHZHrxF6_15direct_syscalls:
 1728|    163|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    163|    where
 1730|    163|        T: Deserialize<'de>,
 1731|    163|    {
 1732|    163|        self.next_element_seed(PhantomData)
 1733|    163|    }
_RINvXs4_NtCs2VpXLMAfFh1_5serde2deQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EECs4ieSHZHrxF6_15direct_syscalls:
 1757|    978|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    978|    where
 1759|    978|        T: Deserialize<'de>,
 1760|    978|    {
 1761|    978|        (**self).next_element()
 1762|    978|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDatamENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|    163|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    163|    where
  790|    163|        D: Deserializer<'de>,
  791|    163|    {
  792|    163|        T::deserialize(deserializer)
  793|    163|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB1P_14hash_algorithm6Sha256EEENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|    163|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    163|    where
  790|    163|        D: Deserializer<'de>,
  791|    163|    {
  792|    163|        T::deserialize(deserializer)
  793|    163|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EECs4ieSHZHrxF6_15direct_syscalls:
 1728|  2.93k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  2.93k|    where
 1730|  2.93k|        T: Deserialize<'de>,
 1731|  2.93k|    {
 1732|  2.93k|        self.next_element_seed(PhantomData)
 1733|  2.93k|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementTNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
 1728|  2.60k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  2.60k|    where
 1730|  2.60k|        T: Deserialize<'de>,
 1731|  2.60k|    {
 1732|  2.60k|        self.next_element_seed(PhantomData)
 1733|  2.60k|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateENtB6_15DeserializeSeed11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  788|    489|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    489|    where
  790|    489|        D: Deserializer<'de>,
  791|    489|    {
  792|    489|        T::deserialize(deserializer)
  793|    489|    }
_RINvXs4_NtCs2VpXLMAfFh1_5serde2deQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateECs4ieSHZHrxF6_15direct_syscalls:
 1757|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    489|    where
 1759|    489|        T: Deserialize<'de>,
 1760|    489|    {
 1761|    489|        (**self).next_element()
 1762|    489|    }
_RINvXs4_NtCs2VpXLMAfFh1_5serde2deQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementyECs4ieSHZHrxF6_15direct_syscalls:
 1757|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    489|    where
 1759|    489|        T: Deserialize<'de>,
 1760|    489|    {
 1761|    489|        (**self).next_element()
 1762|    489|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEENtB6_15DeserializeSeed11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  788|    489|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    489|    where
  790|    489|        D: Deserializer<'de>,
  791|    489|    {
  792|    489|        T::deserialize(deserializer)
  793|    489|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCsb605JUWHIii_12libipld_core4ipld4IpldENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|  3.91k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  3.91k|    where
  790|  3.91k|        D: Deserializer<'de>,
  791|  3.91k|    {
  792|  3.91k|        T::deserialize(deserializer)
  793|  3.91k|    }
_RINvYNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyECs4ieSHZHrxF6_15direct_syscalls:
 1728|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    489|    where
 1730|    489|        T: Deserialize<'de>,
 1731|    489|    {
 1732|    489|        self.next_element_seed(PhantomData)
 1733|    489|    }
_RINvYNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementNtNtCsgTTZuTcaXZ2_10fvm_shared4econ11TokenAmountECs4ieSHZHrxF6_15direct_syscalls:
 1728|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    489|    where
 1730|    489|        T: Deserialize<'de>,
 1731|    489|    {
 1732|    489|        self.next_element_seed(PhantomData)
 1733|    489|    }
_RINvYNtNvXs_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc3vec3VechENtBa_11Deserialize11deserialize10VecVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor20visit_borrowed_bytesINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
 1568|    163|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|    163|    where
 1570|    163|        E: Error,
 1571|    163|    {
 1572|    163|        self.visit_bytes(v)
 1573|    163|    }
_RINvYNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementINtNtCsdRJjCzU6nMS_4core6option6OptionNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressEECs4ieSHZHrxF6_15direct_syscalls:
 1728|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    489|    where
 1730|    489|        T: Deserialize<'de>,
 1731|    489|    {
 1732|    489|        self.next_element_seed(PhantomData)
 1733|    489|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementNtNtCsgTTZuTcaXZ2_10fvm_shared5state16StateTreeVersionECs4ieSHZHrxF6_15direct_syscalls:
 1728|    163|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    163|    where
 1730|    163|        T: Deserialize<'de>,
 1731|    163|    {
 1732|    163|        self.next_element_seed(PhantomData)
 1733|    163|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|  2.93k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  2.93k|    where
  790|  2.93k|        D: Deserializer<'de>,
  791|  2.93k|    {
  792|  2.93k|        T::deserialize(deserializer)
  793|  2.93k|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyENtB6_15DeserializeSeed11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  788|    489|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    489|    where
  790|    489|        D: Deserializer<'de>,
  791|    489|    {
  792|    489|        T::deserialize(deserializer)
  793|    489|    }
_RINvYNtNtCseVyrqhqyiIX_3cid5serde17BytesToCidVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor20visit_borrowed_bytesINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
 1568|  3.91k|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|  3.91k|    where
 1570|  3.91k|        E: Error,
 1571|  3.91k|    {
 1572|  3.91k|        self.visit_bytes(v)
 1573|  3.91k|    }
_RINvYNtNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtBc_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize11IpldVisitorNtB16_7Visitor20visit_borrowed_bytesINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
 1568|    978|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|    978|    where
 1570|    978|        E: Error,
 1571|    978|    {
 1572|    978|        self.visit_bytes(v)
 1573|    978|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCsgTTZuTcaXZ2_10fvm_shared4econ11TokenAmountENtB6_15DeserializeSeed11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  788|    489|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    489|    where
  790|    489|        D: Deserializer<'de>,
  791|    489|    {
  792|    489|        T::deserialize(deserializer)
  793|    489|    }
_RINvYNtNtNtCs2VpXLMAfFh1_5serde2de5impls13StringVisitorNtB7_7Visitor18visit_borrowed_strINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
 1509|  2.44k|    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>
 1510|  2.44k|    where
 1511|  2.44k|        E: Error,
 1512|  2.44k|    {
 1513|  2.44k|        self.visit_str(v)
 1514|  2.44k|    }
_RINvYNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEECs4ieSHZHrxF6_15direct_syscalls:
 1728|    978|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    978|    where
 1730|    978|        T: Deserialize<'de>,
 1731|    978|    {
 1732|    978|        self.next_element_seed(PhantomData)
 1733|    978|    }
_RINvYNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateECs4ieSHZHrxF6_15direct_syscalls:
 1728|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    489|    where
 1730|    489|        T: Deserialize<'de>,
 1731|    489|    {
 1732|    489|        self.next_element_seed(PhantomData)
 1733|    489|    }
_RNvXs4_NtCs2VpXLMAfFh1_5serde2deQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtB5_9SeqAccess9size_hintCs4ieSHZHrxF6_15direct_syscalls:
 1765|    489|    fn size_hint(&self) -> Option<usize> {
 1766|    489|        (**self).size_hint()
 1767|    489|    }
_RINvXs4_NtCs2VpXLMAfFh1_5serde2deQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtNtCsdRJjCzU6nMS_4core6option6OptionNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressEECs4ieSHZHrxF6_15direct_syscalls:
 1757|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    489|    where
 1759|    489|        T: Deserialize<'de>,
 1760|    489|    {
 1761|    489|        (**self).next_element()
 1762|    489|    }
_RINvYNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EECs4ieSHZHrxF6_15direct_syscalls:
 1728|    978|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    978|    where
 1730|    978|        T: Deserialize<'de>,
 1731|    978|    {
 1732|    978|        self.next_element_seed(PhantomData)
 1733|    978|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataTNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|  2.44k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  2.44k|    where
  790|  2.44k|        D: Deserializer<'de>,
  791|  2.44k|    {
  792|  2.44k|        T::deserialize(deserializer)
  793|  2.44k|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDatayENtB6_15DeserializeSeed11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  788|    489|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    489|    where
  790|    489|        D: Deserializer<'de>,
  791|    489|    {
  792|    489|        T::deserialize(deserializer)
  793|    489|    }
_RINvXs4_NtCs2VpXLMAfFh1_5serde2deQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEECs4ieSHZHrxF6_15direct_syscalls:
 1757|    978|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    978|    where
 1759|    978|        T: Deserialize<'de>,
 1760|    978|    {
 1761|    978|        (**self).next_element()
 1762|    978|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB3a_14hash_algorithm6Sha256EEECs4ieSHZHrxF6_15direct_syscalls:
 1728|    163|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    163|    where
 1730|    163|        T: Deserialize<'de>,
 1731|    163|    {
 1732|    163|        self.next_element_seed(PhantomData)
 1733|    163|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCsgTTZuTcaXZ2_10fvm_shared5state16StateTreeVersionENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|    163|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    163|    where
  790|    163|        D: Deserializer<'de>,
  791|    163|    {
  792|    163|        T::deserialize(deserializer)
  793|    163|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|    163|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    163|    where
  790|    163|        D: Deserializer<'de>,
  791|    163|    {
  792|    163|        T::deserialize(deserializer)
  793|    163|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtBA_6option6OptionNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressEENtB6_15DeserializeSeed11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  788|    489|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    489|    where
  790|    489|        D: Deserializer<'de>,
  791|    489|    {
  792|    489|        T::deserialize(deserializer)
  793|    489|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB2D_14hash_algorithm6Sha256EECs4ieSHZHrxF6_15direct_syscalls:
 1728|    652|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    652|    where
 1730|    652|        T: Deserialize<'de>,
 1731|    652|    {
 1732|    652|        self.next_element_seed(PhantomData)
 1733|    652|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB1i_14hash_algorithm6Sha256EENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  788|    489|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    489|    where
  790|    489|        D: Deserializer<'de>,
  791|    489|    {
  792|    489|        T::deserialize(deserializer)
  793|    489|    }
_RINvXs4_NtCs2VpXLMAfFh1_5serde2deQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyECs4ieSHZHrxF6_15direct_syscalls:
 1757|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    489|    where
 1759|    489|        T: Deserialize<'de>,
 1760|    489|    {
 1761|    489|        (**self).next_element()
 1762|    489|    }
_RINvXs4_NtCs2VpXLMAfFh1_5serde2deQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCsgTTZuTcaXZ2_10fvm_shared4econ11TokenAmountECs4ieSHZHrxF6_15direct_syscalls:
 1757|    489|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    489|    where
 1759|    489|        T: Deserialize<'de>,
 1760|    489|    {
 1761|    489|        (**self).next_element()
 1762|    489|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementmECsilvC8qPft2D_8fvm_fuzz:
 1728|    163|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    163|    where
 1730|    163|        T: Deserialize<'de>,
 1731|    163|    {
 1732|    163|        self.next_element_seed(PhantomData)
 1733|    163|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9MapAccess8next_keyNtNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB2A_9CarHeaderNtB1L_11Deserialize11deserialize7___FieldECsilvC8qPft2D_8fvm_fuzz:
 1850|    489|    fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>
 1851|    489|    where
 1852|    489|        K: Deserialize<'de>,
 1853|    489|    {
 1854|    489|        self.next_key_seed(PhantomData)
 1855|    489|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EECsilvC8qPft2D_8fvm_fuzz:
 1728|  2.93k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  2.93k|    where
 1730|  2.93k|        T: Deserialize<'de>,
 1731|  2.93k|    {
 1732|  2.93k|        self.next_element_seed(PhantomData)
 1733|  2.93k|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementTNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
 1728|  2.60k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  2.60k|    where
 1730|  2.60k|        T: Deserialize<'de>,
 1731|  2.60k|    {
 1732|  2.60k|        self.next_element_seed(PhantomData)
 1733|  2.60k|    }
_RINvYNtNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtBa_9CarHeaderNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize14___FieldVisitorNtBY_7Visitor18visit_borrowed_strINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECsilvC8qPft2D_8fvm_fuzz:
 1509|    326|    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>
 1510|    326|    where
 1511|    326|        E: Error,
 1512|    326|    {
 1513|    326|        self.visit_str(v)
 1514|    326|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDatamENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  788|    163|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    163|    where
  790|    163|        D: Deserializer<'de>,
  791|    163|    {
  792|    163|        T::deserialize(deserializer)
  793|    163|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9MapAccess10next_valueINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
 1867|    163|    fn next_value<V>(&mut self) -> Result<V, Self::Error>
 1868|    163|    where
 1869|    163|        V: Deserialize<'de>,
 1870|    163|    {
 1871|    163|        self.next_value_seed(PhantomData)
 1872|    163|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  788|    163|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    163|    where
  790|    163|        D: Deserializer<'de>,
  791|    163|    {
  792|    163|        T::deserialize(deserializer)
  793|    163|    }
_RINvYNtNtCseVyrqhqyiIX_3cid5serde17BytesToCidVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor20visit_borrowed_bytesINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECsilvC8qPft2D_8fvm_fuzz:
 1568|  2.77k|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|  2.77k|    where
 1570|  2.77k|        E: Error,
 1571|  2.77k|    {
 1572|  2.77k|        self.visit_bytes(v)
 1573|  2.77k|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDatayENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  788|    163|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    163|    where
  790|    163|        D: Deserializer<'de>,
  791|    163|    {
  792|    163|        T::deserialize(deserializer)
  793|    163|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9MapAccess10next_valueyECsilvC8qPft2D_8fvm_fuzz:
 1867|    163|    fn next_value<V>(&mut self) -> Result<V, Self::Error>
 1868|    163|    where
 1869|    163|        V: Deserialize<'de>,
 1870|    163|    {
 1871|    163|        self.next_value_seed(PhantomData)
 1872|    163|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCs71iYhC60HpU_5alloc6string6StringENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  788|  2.44k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  2.44k|    where
  790|  2.44k|        D: Deserializer<'de>,
  791|  2.44k|    {
  792|  2.44k|        T::deserialize(deserializer)
  793|  2.44k|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  788|  2.77k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  2.77k|    where
  790|  2.77k|        D: Deserializer<'de>,
  791|  2.77k|    {
  792|  2.77k|        T::deserialize(deserializer)
  793|  2.77k|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB1k_9CarHeaderNtB6_11Deserialize11deserialize7___FieldENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  788|    326|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    326|    where
  790|    326|        D: Deserializer<'de>,
  791|    326|    {
  792|    326|        T::deserialize(deserializer)
  793|    326|    }
_RINvYNtNtNtCs2VpXLMAfFh1_5serde2de5impls13StringVisitorNtB7_7Visitor18visit_borrowed_strINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECsilvC8qPft2D_8fvm_fuzz:
 1509|  2.44k|    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>
 1510|  2.44k|    where
 1511|  2.44k|        E: Error,
 1512|  2.44k|    {
 1513|  2.44k|        self.visit_str(v)
 1514|  2.44k|    }
_RINvXs3_NtCs2VpXLMAfFh1_5serde2deINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataTNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEENtB6_15DeserializeSeed11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
  788|  2.44k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  2.44k|    where
  790|  2.44k|        D: Deserializer<'de>,
  791|  2.44k|    {
  792|  2.44k|        T::deserialize(deserializer)
  793|  2.44k|    }
_RINvYINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess12next_elementNtNtCs71iYhC60HpU_5alloc6string6StringECsilvC8qPft2D_8fvm_fuzz:
 1728|  2.44k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  2.44k|    where
 1730|  2.44k|        T: Deserialize<'de>,
 1731|  2.44k|    {
 1732|  2.44k|        self.next_element_seed(PhantomData)
 1733|  2.44k|    }

_RNvNtNtCs2VpXLMAfFh1_5serde9___private9size_hint8cautious:
   12|  1.14k|pub fn cautious(hint: Option<usize>) -> usize {
   13|  1.14k|    cmp::min(hint.unwrap_or(0), 4096)
   14|  1.14k|}

_RINvXs1p_NtNtCs2VpXLMAfFh1_5serde3ser5implsTRNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtBL_7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtBL_14hash_algorithm6Sha256EEENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  314|    163|                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  315|    163|                where
  316|    163|                    S: Serializer,
  317|    163|                {
  318|    163|                    let mut tuple = try!(serializer.serialize_tuple($len));
  319|       |                    $(
  320|    163|                        try!(tuple.serialize_element(&self.$n));
  321|       |                    )+
  322|    163|                    tuple.end()
  323|    163|                }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_ENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|  1.30k|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|  1.30k|            where
  388|  1.30k|                S: Serializer,
  389|  1.30k|            {
  390|  1.30k|                (**self).serialize(serializer)
  391|  1.30k|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRNtNtCsgTTZuTcaXZ2_10fvm_shared4econ11TokenAmountNtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|    489|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    489|            where
  388|    489|                S: Serializer,
  389|    489|            {
  390|    489|                (**self).serialize(serializer)
  391|    489|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRyNtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|    489|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    489|            where
  388|    489|                S: Serializer,
  389|    489|            {
  390|    489|                (**self).serialize(serializer)
  391|    489|            }
_RINvXs1m_NtNtCs2VpXLMAfFh1_5serde3ser5implsINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB1h_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  194|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    163|            where
  196|    163|                S: Serializer,
  197|    163|            {
  198|    163|                serializer.collect_seq(self)
  199|    163|            }
_RINvXsG_NtNtCs2VpXLMAfFh1_5serde3ser5implsyNtB8_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   11|    652|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   12|    652|            where
   13|    652|                S: Serializer,
   14|    652|            {
   15|    652|                serializer.$method(*self $($cast)*)
   16|    652|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtBL_14hash_algorithm6Sha256ENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|    489|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    489|            where
  388|    489|                S: Serializer,
  389|    489|            {
  390|    489|                (**self).serialize(serializer)
  391|    489|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|    489|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    489|            where
  388|    489|                S: Serializer,
  389|    489|            {
  390|    489|                (**self).serialize(serializer)
  391|    489|            }
_RINvXs3_NtNtCs2VpXLMAfFh1_5serde3ser5implsINtNtCsdRJjCzU6nMS_4core6option6OptionNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressENtB8_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  104|    489|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  105|    489|    where
  106|    489|        S: Serializer,
  107|    489|    {
  108|    489|        match *self {
  109|      0|            Some(ref value) => serializer.serialize_some(value),
  110|    489|            None => serializer.serialize_none(),
  111|       |        }
  112|    489|    }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRNtNtCsgTTZuTcaXZ2_10fvm_shared5state16StateTreeVersionNtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    163|            where
  388|    163|                S: Serializer,
  389|    163|            {
  390|    163|                (**self).serialize(serializer)
  391|    163|            }
_RINvXs1m_NtNtCs2VpXLMAfFh1_5serde3ser5implsINtNtCs71iYhC60HpU_5alloc3vec3VecINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  194|    489|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    489|            where
  196|    489|                S: Serializer,
  197|    489|            {
  198|    489|                serializer.collect_seq(self)
  199|    489|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldNtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    163|            where
  388|    163|                S: Serializer,
  389|    163|            {
  390|    163|                (**self).serialize(serializer)
  391|    163|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB1i_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    163|            where
  388|    163|                S: Serializer,
  389|    163|            {
  390|    163|                (**self).serialize(serializer)
  391|    163|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRINtNtCsdRJjCzU6nMS_4core6option6OptionNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  386|    489|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    489|            where
  388|    489|                S: Serializer,
  389|    489|            {
  390|    489|                (**self).serialize(serializer)
  391|    489|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRNtNtCs71iYhC60HpU_5alloc6string6StringNtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  386|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    163|            where
  388|    163|                S: Serializer,
  389|    163|            {
  390|    163|                (**self).serialize(serializer)
  391|    163|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtBL_6string6StringNtNtB1i_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  386|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    163|            where
  388|    163|                S: Serializer,
  389|    163|            {
  390|    163|                (**self).serialize(serializer)
  391|    163|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRyNtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  386|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    163|            where
  388|    163|                S: Serializer,
  389|    163|            {
  390|    163|                (**self).serialize(serializer)
  391|    163|            }
_RINvXsG_NtNtCs2VpXLMAfFh1_5serde3ser5implsyNtB8_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   11|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   12|    163|            where
   13|    163|                S: Serializer,
   14|    163|            {
   15|    163|                serializer.$method(*self $($cast)*)
   16|    163|            }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldNtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  386|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    163|            where
  388|    163|                S: Serializer,
  389|    163|            {
  390|    163|                (**self).serialize(serializer)
  391|    163|            }
_RINvXs_NtNtCs2VpXLMAfFh1_5serde3ser5implsNtNtCs71iYhC60HpU_5alloc6string6StringNtB7_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   56|    163|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   57|    163|    where
   58|    163|        S: Serializer,
   59|    163|    {
   60|    163|        serializer.serialize_str(self)
   61|    163|    }
_RINvXs1G_NtNtCs2VpXLMAfFh1_5serde3ser5implsRINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_ENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  386|    326|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    326|            where
  388|    326|                S: Serializer,
  389|    326|            {
  390|    326|                (**self).serialize(serializer)
  391|    326|            }
_RINvXs1p_NtNtCs2VpXLMAfFh1_5serde3ser5implsTRNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtBL_7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtB1C_6string6StringNtNtBL_14hash_algorithm6Sha256EEENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  314|    163|                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  315|    163|                where
  316|    163|                    S: Serializer,
  317|    163|                {
  318|    163|                    let mut tuple = try!(serializer.serialize_tuple($len));
  319|       |                    $(
  320|    163|                        try!(tuple.serialize_element(&self.$n));
  321|       |                    )+
  322|    163|                    tuple.end()
  323|    163|                }
_RINvXs1m_NtNtCs2VpXLMAfFh1_5serde3ser5implsINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtBK_6string6StringNtNtB1h_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  194|    163|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    163|            where
  196|    163|                S: Serializer,
  197|    163|            {
  198|    163|                serializer.collect_seq(self)
  199|    163|            }
_RINvXs5_NtNtCs2VpXLMAfFh1_5serde3ser5implsAuj0_NtB8_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  132|    326|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  133|    326|    where
  134|    326|        S: Serializer,
  135|    326|    {
  136|    326|        try!(serializer.serialize_tuple(0)).end()
  137|    326|    }

_RINvYQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer11collect_seqRINtNtCs71iYhC60HpU_5alloc3vec3VecINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEEECs4ieSHZHrxF6_15direct_syscalls:
 1275|    489|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    489|    where
 1277|    489|        I: IntoIterator,
 1278|    489|        <I as IntoIterator>::Item: Serialize,
 1279|    489|    {
 1280|    489|        let iter = iter.into_iter();
 1281|    489|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    489|            let mut iter = iter;
 1286|    489|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    489|        serializer.end()
 1297|    489|    }
_RINvYQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer11collect_seqRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB3f_14hash_algorithm6Sha256EEECs4ieSHZHrxF6_15direct_syscalls:
 1275|    163|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    163|    where
 1277|    163|        I: IntoIterator,
 1278|    163|        <I as IntoIterator>::Item: Serialize,
 1279|    163|    {
 1280|    163|        let iter = iter.into_iter();
 1281|    163|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    163|            let mut iter = iter;
 1286|    163|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    163|        serializer.end()
 1297|    163|    }
_RNCINvYQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer11collect_seqRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB3h_14hash_algorithm6Sha256EEE0Cs4ieSHZHrxF6_15direct_syscalls:
 1286|    489|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
_RNCINvYQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer11collect_seqRINtNtCs71iYhC60HpU_5alloc3vec3VecINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEEE0Cs4ieSHZHrxF6_15direct_syscalls:
 1286|    489|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
_RINvNtCs2VpXLMAfFh1_5serde3ser17iterator_len_hintINtNtNtCsdRJjCzU6nMS_4core5slice4iter4IterINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB1w_14hash_algorithm6Sha256EEECs4ieSHZHrxF6_15direct_syscalls:
 1982|    163|    match iter.size_hint() {
 1983|    163|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    163|}
_RINvNtCs2VpXLMAfFh1_5serde3ser17iterator_len_hintINtNtNtCsdRJjCzU6nMS_4core5slice4iter4IterINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEEECs4ieSHZHrxF6_15direct_syscalls:
 1982|    489|    match iter.size_hint() {
 1983|    489|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    489|}
_RINvNtCs2VpXLMAfFh1_5serde3ser17iterator_len_hintINtNtNtCsdRJjCzU6nMS_4core5slice4iter4IterINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCs71iYhC60HpU_5alloc6string6StringNtNtB1w_14hash_algorithm6Sha256EEECsilvC8qPft2D_8fvm_fuzz:
 1982|    163|    match iter.size_hint() {
 1983|    163|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    163|}
_RINvYQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer11collect_seqRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtB2I_6string6StringNtNtB3f_14hash_algorithm6Sha256EEECsilvC8qPft2D_8fvm_fuzz:
 1275|    163|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    163|    where
 1277|    163|        I: IntoIterator,
 1278|    163|        <I as IntoIterator>::Item: Serialize,
 1279|    163|    {
 1280|    163|        let iter = iter.into_iter();
 1281|    163|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    163|            let mut iter = iter;
 1286|    163|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    163|        serializer.end()
 1297|    163|    }

_RINvMNtCsgsynKAC2p8K_11serde_bytes7bytebufNtB3_7ByteBuf4fromINtNtCs71iYhC60HpU_5alloc3vec3VechEECs4ieSHZHrxF6_15direct_syscalls:
   60|  1.30k|    pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {
   61|  1.30k|        ByteBuf {
   62|  1.30k|            bytes: bytes.into(),
   63|  1.30k|        }
   64|  1.30k|    }
_RINvXsc_NtCsgsynKAC2p8K_11serde_bytes7bytebufNtB6_7ByteBufNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser13CidSerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  186|  1.30k|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  187|  1.30k|    where
  188|  1.30k|        S: Serializer,
  189|  1.30k|    {
  190|  1.30k|        serializer.serialize_bytes(&self.bytes)
  191|  1.30k|    }
_RINvXsc_NtCsgsynKAC2p8K_11serde_bytes7bytebufNtB6_7ByteBufNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser13CidSerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
  186|    326|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  187|    326|    where
  188|    326|        S: Serializer,
  189|    326|    {
  190|    326|        serializer.serialize_bytes(&self.bytes)
  191|    326|    }
_RINvMNtCsgsynKAC2p8K_11serde_bytes7bytebufNtB3_7ByteBuf4fromINtNtCs71iYhC60HpU_5alloc3vec3VechEECsilvC8qPft2D_8fvm_fuzz:
   60|    326|    pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {
   61|    326|        ByteBuf {
   62|    326|            bytes: bytes.into(),
   63|    326|        }
   64|    326|    }

_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor14cbor4ii_nonpub8peek_oneNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderECs4ieSHZHrxF6_15direct_syscalls:
   26|  8.96k|pub(crate) fn peek_one<'a, R: dec::Read<'a>>(reader: &mut R) -> Result<u8, DecodeError<R::Error>> {
   27|  8.96k|    let buf = match reader.fill(1)? {
   28|  8.96k|        dec::Reference::Long(buf) => buf,
   29|      0|        dec::Reference::Short(buf) => buf,
   30|       |    };
   31|  8.96k|    let byte = buf.get(0).copied().ok_or(DecodeError::Eof)?;
   32|  8.31k|    Ok(byte)
   33|  8.96k|}
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor14cbor4ii_nonpub8peek_oneNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderECsilvC8qPft2D_8fvm_fuzz:
   26|  3.26k|pub(crate) fn peek_one<'a, R: dec::Read<'a>>(reader: &mut R) -> Result<u8, DecodeError<R::Error>> {
   27|  3.26k|    let buf = match reader.fill(1)? {
   28|  3.26k|        dec::Reference::Long(buf) => buf,
   29|      0|        dec::Reference::Short(buf) => buf,
   30|       |    };
   31|  3.26k|    let byte = buf.get(0).copied().ok_or(DecodeError::Eof)?;
   32|  2.77k|    Ok(byte)
   33|  3.26k|}

_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitorNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
  344|  2.44k|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|  2.44k|    where
  346|  2.44k|        V: Visitor<'de>,
  347|  2.44k|    {
  348|  2.44k|        let mut de = self.try_step()?;
  349|  2.44k|        let seq = Accessor::tuple(&mut de, len)?;
  350|  2.44k|        visitor.visit_seq(seq)
  351|  2.44k|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
  484|  2.93k|        if let Some(len) = self.len.as_mut() {
  485|  2.93k|            if *len > 0 {
  486|  2.93k|                *len -= 1;
  487|  2.93k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  2.93k|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDatamEECs4ieSHZHrxF6_15direct_syscalls:
  484|    163|        if let Some(len) = self.len.as_mut() {
  485|    163|            if *len > 0 {
  486|    163|                *len -= 1;
  487|    163|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    163|    }
_RNvMs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE5arrayCs4ieSHZHrxF6_15direct_syscalls:
  434|  1.79k|    pub fn array(de: &'a mut Deserializer<R>) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  435|  1.79k|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  436|  1.79k|        Ok(Accessor {
  437|  1.79k|            de,
  438|  1.79k|            len: array_start.0,
  439|  1.79k|        })
  440|  1.79k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_u64NtNvXsX_NtB1X_5implsyNtB1X_11Deserialize11deserialize16PrimitiveVisitorECs4ieSHZHrxF6_15direct_syscalls:
  142|    163|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    163|        where V: Visitor<'de>
  144|    163|        {
  145|    163|            let value = <$t>::decode(&mut self.reader)?;
  146|    163|            visitor.$visit(value)
  147|    163|        }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_anyNtNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtB30_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECs4ieSHZHrxF6_15direct_syscalls:
  159|  4.40k|    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  160|  4.40k|    where
  161|  4.40k|        V: Visitor<'de>,
  162|  4.40k|    {
  163|  4.40k|        let mut de = self.try_step()?;
  164|  4.40k|        let de = &mut *de;
  165|       |
  166|  4.40k|        let byte = peek_one(&mut de.reader)?;
  167|  4.40k|        match dec::if_major(byte) {
  168|    489|            major::UNSIGNED => de.deserialize_u64(visitor),
  169|      0|            major::NEGATIVE => de.deserialize_i64(visitor),
  170|    978|            major::BYTES => de.deserialize_byte_buf(visitor),
  171|      0|            major::STRING => de.deserialize_string(visitor),
  172|  1.46k|            major::ARRAY => de.deserialize_seq(visitor),
  173|      0|            major::MAP => de.deserialize_map(visitor),
  174|       |            // The only supported tag is tag 42 (CID).
  175|    978|            major::TAG => de.deserialize_cid(visitor),
  176|    489|            major::SIMPLE => match byte {
  177|       |                marker::FALSE => {
  178|      0|                    de.reader.advance(1);
  179|      0|                    visitor.visit_bool(false)
  180|       |                }
  181|       |                marker::TRUE => {
  182|      0|                    de.reader.advance(1);
  183|      0|                    visitor.visit_bool(true)
  184|       |                }
  185|       |                marker::NULL | marker::UNDEFINED => {
  186|    489|                    de.reader.advance(1);
  187|    489|                    visitor.visit_none()
  188|       |                }
  189|      0|                marker::F32 => de.deserialize_f32(visitor),
  190|      0|                marker::F64 => de.deserialize_f64(visitor),
  191|      0|                _ => Err(DecodeError::Unsupported { byte }),
  192|       |            },
  193|      0|            _ => Err(DecodeError::Unsupported { byte }),
  194|       |        }
  195|  4.40k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitorNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtB47_7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB47_14hash_algorithm6Sha256EEEECs4ieSHZHrxF6_15direct_syscalls:
  344|    163|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    163|    where
  346|    163|        V: Visitor<'de>,
  347|    163|    {
  348|    163|        let mut de = self.try_step()?;
  349|    163|        let seq = Accessor::tuple(&mut de, len)?;
  350|    163|        visitor.visit_seq(seq)
  351|    163|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldEECs4ieSHZHrxF6_15direct_syscalls:
  484|    163|        if let Some(len) = self.len.as_mut() {
  485|    163|            if *len > 0 {
  486|    163|                *len -= 1;
  487|    163|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    163|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de10from_sliceINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtBW_14hash_algorithm6Sha256EECs4ieSHZHrxF6_15direct_syscalls:
   40|    163|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    163|where
   42|    163|    T: de::Deserialize<'a>,
   43|    163|{
   44|    163|    let reader = SliceReader::new(buf);
   45|    163|    let mut deserializer = Deserializer::from_reader(reader);
   46|    163|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    163|    deserializer.end()?;
   48|    163|    Ok(value)
   49|    163|}
_RNvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE8try_stepCs4ieSHZHrxF6_15direct_syscalls:
  101|  9.12k|    fn try_step<'a>(
  102|  9.12k|        &'a mut self,
  103|  9.12k|    ) -> Result<scopeguard::ScopeGuard<&'a mut Self, fn(&'a mut Self) -> ()>, DecodeError<R::Error>>
  104|  9.12k|    {
  105|  9.12k|        if self.reader.step_in() {
  106|  9.12k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
  107|       |        } else {
  108|      0|            Err(DecodeError::DepthLimit)
  109|       |        }
  110|  9.12k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1X_5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtB1X_11Deserialize11deserialize10VecVisitorTNtNtB3h_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECs4ieSHZHrxF6_15direct_syscalls:
  334|    163|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    163|    where
  336|    163|        V: Visitor<'de>,
  337|    163|    {
  338|    163|        let mut de = self.try_step()?;
  339|    163|        let seq = Accessor::array(&mut de)?;
  340|    163|        visitor.visit_seq(seq)
  341|    163|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCsb605JUWHIii_12libipld_core4ipld4IpldEECs4ieSHZHrxF6_15direct_syscalls:
  484|  5.37k|        if let Some(len) = self.len.as_mut() {
  485|  5.37k|            if *len > 0 {
  486|  3.91k|                *len -= 1;
  487|  3.91k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|  1.46k|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  5.37k|    }
_RNvMs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE5tupleCs4ieSHZHrxF6_15direct_syscalls:
  443|  2.93k|    pub fn tuple(
  444|  2.93k|        de: &'a mut Deserializer<R>,
  445|  2.93k|        len: usize,
  446|  2.93k|    ) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  447|  2.93k|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  448|       |
  449|  2.93k|        if array_start.0 == Some(len) {
  450|  2.93k|            Ok(Accessor {
  451|  2.93k|                de,
  452|  2.93k|                len: array_start.0,
  453|  2.93k|            })
  454|       |        } else {
  455|      0|            Err(DecodeError::RequireLength {
  456|      0|                name: "tuple",
  457|      0|                expect: len,
  458|      0|                value: array_start.0.unwrap_or(0),
  459|      0|            })
  460|       |        }
  461|  2.93k|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de10from_sliceNtNtCsgTTZuTcaXZ2_10fvm_shared5state9StateRootECs4ieSHZHrxF6_15direct_syscalls:
   40|    163|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    163|where
   42|    163|    T: de::Deserialize<'a>,
   43|    163|{
   44|    163|    let reader = SliceReader::new(buf);
   45|    163|    let mut deserializer = Deserializer::from_reader(reader);
   46|    163|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    163|    deserializer.end()?;
   48|    163|    Ok(value)
   49|    163|}
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCs71iYhC60HpU_5alloc6string6StringEECs4ieSHZHrxF6_15direct_syscalls:
  484|  2.44k|        if let Some(len) = self.len.as_mut() {
  485|  2.44k|            if *len > 0 {
  486|  2.44k|                *len -= 1;
  487|  2.44k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  2.44k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_bytesNtNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtB32_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECs4ieSHZHrxF6_15direct_syscalls:
  228|    978|    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  229|    978|    where
  230|    978|        V: Visitor<'de>,
  231|    978|    {
  232|    978|        match <types::Bytes<Cow<[u8]>>>::decode(&mut self.reader)?.0 {
  233|    978|            Cow::Borrowed(buf) => visitor.visit_borrowed_bytes(buf),
  234|      0|            Cow::Owned(buf) => visitor.visit_byte_buf(buf),
  235|       |        }
  236|    978|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_bytesNtNvXs_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc3vec3VechENtB30_11Deserialize11deserialize10VecVisitorECs4ieSHZHrxF6_15direct_syscalls:
  228|    163|    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  229|    163|    where
  230|    163|        V: Visitor<'de>,
  231|    163|    {
  232|    163|        match <types::Bytes<Cow<[u8]>>>::decode(&mut self.reader)?.0 {
  233|    163|            Cow::Borrowed(buf) => visitor.visit_borrowed_bytes(buf),
  234|      0|            Cow::Owned(buf) => visitor.visit_byte_buf(buf),
  235|       |        }
  236|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer20deserialize_byte_bufNtNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtB35_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECs4ieSHZHrxF6_15direct_syscalls:
  239|    978|    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  240|    978|    where
  241|    978|        V: Visitor<'de>,
  242|    978|    {
  243|    978|        self.deserialize_bytes(visitor)
  244|    978|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataTNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECs4ieSHZHrxF6_15direct_syscalls:
  484|  2.60k|        if let Some(len) = self.len.as_mut() {
  485|  2.60k|            if *len > 0 {
  486|  2.44k|                *len -= 1;
  487|  2.44k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    163|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  2.60k|    }
_RNCNvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE8try_step0Cs4ieSHZHrxF6_15direct_syscalls:
  106|  9.12k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_u64NtNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtB30_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECs4ieSHZHrxF6_15direct_syscalls:
  142|    489|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    489|        where V: Visitor<'de>
  144|    489|        {
  145|    489|            let value = <$t>::decode(&mut self.reader)?;
  146|    489|            visitor.$visit(value)
  147|    489|        }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer26deserialize_newtype_structINtNvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtB3d_3cid3CidKpENtB1X_11Deserialize11deserialize16MainEntryVisitorKj40_EECs4ieSHZHrxF6_15direct_syscalls:
  318|  2.93k|    fn deserialize_newtype_struct<V>(
  319|  2.93k|        self,
  320|  2.93k|        name: &'static str,
  321|  2.93k|        visitor: V,
  322|  2.93k|    ) -> Result<V::Value, Self::Error>
  323|  2.93k|    where
  324|  2.93k|        V: Visitor<'de>,
  325|  2.93k|    {
  326|  2.93k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  327|  2.93k|            self.deserialize_cid(visitor)
  328|       |        } else {
  329|      0|            visitor.visit_newtype_struct(self)
  330|       |        }
  331|  2.93k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitormINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
  344|    163|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    163|    where
  346|    163|        V: Visitor<'de>,
  347|    163|    {
  348|    163|        let mut de = self.try_step()?;
  349|    163|        let seq = Accessor::tuple(&mut de, len)?;
  350|    163|        visitor.visit_seq(seq)
  351|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXs9_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtB3d_9StateRootNtB1X_11Deserialize11deserialize1__NtB37_5InnerB41_11deserialize9___VisitorECs4ieSHZHrxF6_15direct_syscalls:
  354|    163|    fn deserialize_tuple_struct<V>(
  355|    163|        self,
  356|    163|        _name: &'static str,
  357|    163|        len: usize,
  358|    163|        visitor: V,
  359|    163|    ) -> Result<V::Value, Self::Error>
  360|    163|    where
  361|    163|        V: Visitor<'de>,
  362|    163|    {
  363|    163|        self.deserialize_tuple(len, visitor)
  364|    163|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB3w_14hash_algorithm6Sha256EEECs4ieSHZHrxF6_15direct_syscalls:
  484|    652|        if let Some(len) = self.len.as_mut() {
  485|    652|            if *len > 0 {
  486|    489|                *len -= 1;
  487|    489|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    163|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    652|    }
_RINvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE15deserialize_cidINtNvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtB2l_3cid3CidKpENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize16MainEntryVisitorKj40_EECs4ieSHZHrxF6_15direct_syscalls:
  113|  2.93k|    fn deserialize_cid<V>(&mut self, visitor: V) -> Result<V::Value, DecodeError<R::Error>>
  114|  2.93k|    where
  115|  2.93k|        V: Visitor<'de>,
  116|  2.93k|    {
  117|  2.93k|        let tag = dec::TagStart::decode(&mut self.reader)?;
  118|       |
  119|  2.93k|        match tag.0 {
  120|  2.93k|            CBOR_TAGS_CID => visitor.visit_newtype_struct(&mut CidDeserializer(self)),
  121|      0|            _ => Err(DecodeError::TypeMismatch {
  122|      0|                name: "CBOR tag",
  123|      0|                byte: tag.0 as u8,
  124|      0|            }),
  125|       |        }
  126|  2.93k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_seqNtNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtB30_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECs4ieSHZHrxF6_15direct_syscalls:
  334|  1.46k|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|  1.46k|    where
  336|  1.46k|        V: Visitor<'de>,
  337|  1.46k|    {
  338|  1.46k|        let mut de = self.try_step()?;
  339|  1.46k|        let seq = Accessor::array(&mut de)?;
  340|  1.46k|        visitor.visit_seq(seq)
  341|  1.46k|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de10from_sliceINtNtCs71iYhC60HpU_5alloc3vec3VecTNtNtBW_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECs4ieSHZHrxF6_15direct_syscalls:
   40|    163|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    163|where
   42|    163|    T: de::Deserialize<'a>,
   43|    163|{
   44|    163|    let reader = SliceReader::new(buf);
   45|    163|    let mut deserializer = Deserializer::from_reader(reader);
   46|    163|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    163|    deserializer.end()?;
   48|    163|    Ok(value)
   49|    163|}
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer20deserialize_byte_bufNtNvXs_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc3vec3VechENtB33_11Deserialize11deserialize10VecVisitorECs4ieSHZHrxF6_15direct_syscalls:
  239|    163|    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  240|    163|    where
  241|    163|        V: Visitor<'de>,
  242|    163|    {
  243|    163|        self.deserialize_bytes(visitor)
  244|    163|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCsgTTZuTcaXZ2_10fvm_shared5state16StateTreeVersionEECs4ieSHZHrxF6_15direct_syscalls:
  484|    163|        if let Some(len) = self.len.as_mut() {
  485|    163|            if *len > 0 {
  486|    163|                *len -= 1;
  487|    163|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_strNtNtB1X_5impls13StringVisitorECs4ieSHZHrxF6_15direct_syscalls:
  252|  2.44k|        match <Cow<str>>::decode(&mut self.reader)? {
  253|  2.44k|            Cow::Borrowed(buf) => visitor.visit_borrowed_str(buf),
  254|      0|            Cow::Owned(buf) => visitor.visit_string(buf),
  255|       |        }
  256|       |
  257|       |        // Don't use this. This can lead to random panics and invalid CBOR.
  258|       |        #[cfg(feature = "_do_not_use_its_unsafe_and_invalid_cbor")]
  259|       |        match types::BadStr::<Cow<[u8]>>::decode(&mut self.reader)? {
  260|       |            types::BadStr(Cow::Borrowed(buf)) => {
  261|       |                visitor.visit_borrowed_str(unsafe { std::str::from_utf8_unchecked(buf) })
  262|       |            }
  263|       |            types::BadStr(Cow::Owned(buf)) => {
  264|       |                visitor.visit_string(unsafe { String::from_utf8_unchecked(buf) })
  265|       |            }
  266|       |        }
  267|  2.44k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer18deserialize_stringNtNtB1X_5impls13StringVisitorECs4ieSHZHrxF6_15direct_syscalls:
  270|  2.44k|    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  271|  2.44k|    where
  272|  2.44k|        V: Visitor<'de>,
  273|  2.44k|    {
  274|  2.44k|        self.deserialize_str(visitor)
  275|  2.44k|    }
_RNvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE3endCs4ieSHZHrxF6_15direct_syscalls:
  131|    652|        match peek_one(&mut self.reader) {
  132|      0|            Ok(_) => Err(DecodeError::TrailingData),
  133|    652|            Err(DecodeError::Eof) => Ok(()),
  134|      0|            Err(error) => Err(error),
  135|       |        }
  136|    652|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_tupleNtNvXNvNvXs9_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtB36_9StateRootNtB1X_11Deserialize11deserialize1__NtB30_5InnerB3U_11deserialize9___VisitorECs4ieSHZHrxF6_15direct_syscalls:
  344|    163|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    163|    where
  346|    163|        V: Visitor<'de>,
  347|    163|    {
  348|    163|        let mut de = self.try_step()?;
  349|    163|        let seq = Accessor::tuple(&mut de, len)?;
  350|    163|        visitor.visit_seq(seq)
  351|    163|    }
_RNvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess9size_hintCs4ieSHZHrxF6_15direct_syscalls:
  500|  1.79k|    fn size_hint(&self) -> Option<usize> {
  501|  1.79k|        self.len
  502|  1.79k|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de10from_sliceTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
   40|    163|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    163|where
   42|    163|    T: de::Deserialize<'a>,
   43|    163|{
   44|    163|    let reader = SliceReader::new(buf);
   45|    163|    let mut deserializer = Deserializer::from_reader(reader);
   46|    163|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    163|    deserializer.end()?;
   48|    163|    Ok(value)
   49|    163|}
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB43_14hash_algorithm6Sha256EEEECs4ieSHZHrxF6_15direct_syscalls:
  484|    163|        if let Some(len) = self.len.as_mut() {
  485|    163|            if *len > 0 {
  486|    163|                *len -= 1;
  487|    163|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1X_5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtB1X_11Deserialize11deserialize10VecVisitorINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB4y_14hash_algorithm6Sha256EEECs4ieSHZHrxF6_15direct_syscalls:
  334|    163|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    163|    where
  336|    163|        V: Visitor<'de>,
  337|    163|    {
  338|    163|        let mut de = self.try_step()?;
  339|    163|        let seq = Accessor::array(&mut de)?;
  340|    163|        visitor.visit_seq(seq)
  341|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_u32NtNvXsV_NtB1X_5implsmNtB1X_11Deserialize11deserialize16PrimitiveVisitorECs4ieSHZHrxF6_15direct_syscalls:
  142|    163|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    163|        where V: Visitor<'de>
  144|    163|        {
  145|    163|            let value = <$t>::decode(&mut self.reader)?;
  146|    163|            visitor.$visit(value)
  147|    163|        }
_RINvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE15deserialize_cidNtNvXNtNtCsb605JUWHIii_12libipld_core5serde2deNtNtB2j_4ipld4IpldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize11IpldVisitorECs4ieSHZHrxF6_15direct_syscalls:
  113|    978|    fn deserialize_cid<V>(&mut self, visitor: V) -> Result<V::Value, DecodeError<R::Error>>
  114|    978|    where
  115|    978|        V: Visitor<'de>,
  116|    978|    {
  117|    978|        let tag = dec::TagStart::decode(&mut self.reader)?;
  118|       |
  119|    978|        match tag.0 {
  120|    978|            CBOR_TAGS_CID => visitor.visit_newtype_struct(&mut CidDeserializer(self)),
  121|      0|            _ => Err(DecodeError::TypeMismatch {
  122|      0|                name: "CBOR tag",
  123|      0|                byte: tag.0 as u8,
  124|      0|            }),
  125|       |        }
  126|    978|    }
_RINvXs7_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_15CidDeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_bytesNtNtCseVyrqhqyiIX_3cid5serde17BytesToCidVisitorECs4ieSHZHrxF6_15direct_syscalls:
  646|  3.91k|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  647|  3.91k|        let byte = peek_one(&mut self.0.reader)?;
  648|  3.91k|        match dec::if_major(byte) {
  649|       |            major::BYTES => {
  650|       |                // CBOR encoded CIDs have a zero byte prefix we have to remove.
  651|  3.91k|                match <types::Bytes<Cow<[u8]>>>::decode(&mut self.0.reader)?.0 {
  652|  3.91k|                    Cow::Borrowed(buf) => {
  653|  3.91k|                        if buf.len() <= 1 || buf[0] != 0 {
  654|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  655|       |                        } else {
  656|  3.91k|                            visitor.visit_borrowed_bytes(&buf[1..])
  657|       |                        }
  658|       |                    }
  659|      0|                    Cow::Owned(mut buf) => {
  660|      0|                        if buf.len() <= 1 || buf[0] != 0 {
  661|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  662|       |                        } else {
  663|      0|                            buf.remove(0);
  664|      0|                            visitor.visit_byte_buf(buf)
  665|       |                        }
  666|       |                    }
  667|       |                }
  668|       |            }
  669|      0|            _ => Err(DecodeError::Unsupported { byte }),
  670|       |        }
  671|  3.91k|    }
_RNvMNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB2_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE11from_readerCs4ieSHZHrxF6_15direct_syscalls:
   93|    652|    pub fn from_reader(reader: R) -> Deserializer<R> {
   94|    652|        Deserializer { reader }
   95|    652|    }
_RINvXs3_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9MapAccess15next_value_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDatayEECsilvC8qPft2D_8fvm_fuzz:
  529|    163|    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
  530|    163|    where
  531|    163|        V: de::DeserializeSeed<'de>,
  532|    163|    {
  533|    163|        seed.deserialize(&mut *self.de)
  534|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer22deserialize_identifierNtNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB35_9CarHeaderNtB1X_11Deserialize11deserialize14___FieldVisitorECsilvC8qPft2D_8fvm_fuzz:
  405|    326|    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  406|    326|    where
  407|    326|        V: Visitor<'de>,
  408|    326|    {
  409|    326|        self.deserialize_str(visitor)
  410|    326|    }
_RNvMs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE5arrayCsilvC8qPft2D_8fvm_fuzz:
  434|    326|    pub fn array(de: &'a mut Deserializer<R>) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  435|    326|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  436|    326|        Ok(Accessor {
  437|    326|            de,
  438|    326|            len: array_start.0,
  439|    326|        })
  440|    326|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de10from_sliceTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
   40|    163|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    163|where
   42|    163|    T: de::Deserialize<'a>,
   43|    163|{
   44|    163|    let reader = SliceReader::new(buf);
   45|    163|    let mut deserializer = Deserializer::from_reader(reader);
   46|    163|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    163|    deserializer.end()?;
   48|    163|    Ok(value)
   49|    163|}
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de10from_sliceNtCs2NnW6XqvVM8_12fvm_ipld_car9CarHeaderECsilvC8qPft2D_8fvm_fuzz:
   40|    163|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    163|where
   42|    163|    T: de::Deserialize<'a>,
   43|    163|{
   44|    163|    let reader = SliceReader::new(buf);
   45|    163|    let mut deserializer = Deserializer::from_reader(reader);
   46|    163|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    163|    deserializer.end()?;
   48|    163|    Ok(value)
   49|    163|}
_RINvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE15deserialize_cidINtNvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtB2l_3cid3CidKpENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize16MainEntryVisitorKj40_EECsilvC8qPft2D_8fvm_fuzz:
  113|  2.77k|    fn deserialize_cid<V>(&mut self, visitor: V) -> Result<V::Value, DecodeError<R::Error>>
  114|  2.77k|    where
  115|  2.77k|        V: Visitor<'de>,
  116|  2.77k|    {
  117|  2.77k|        let tag = dec::TagStart::decode(&mut self.reader)?;
  118|       |
  119|  2.77k|        match tag.0 {
  120|  2.77k|            CBOR_TAGS_CID => visitor.visit_newtype_struct(&mut CidDeserializer(self)),
  121|      0|            _ => Err(DecodeError::TypeMismatch {
  122|      0|                name: "CBOR tag",
  123|      0|                byte: tag.0 as u8,
  124|      0|            }),
  125|       |        }
  126|  2.77k|    }
_RINvXs3_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9MapAccess13next_key_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB3u_9CarHeaderNtB1R_11Deserialize11deserialize7___FieldEECsilvC8qPft2D_8fvm_fuzz:
  513|    489|        if let Some(len) = self.len.as_mut() {
  514|    489|            if *len > 0 {
  515|    326|                *len -= 1;
  516|    326|                Ok(Some(seed.deserialize(&mut *self.de)?))
  517|       |            } else {
  518|    163|                Ok(None)
  519|       |            }
  520|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  521|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  522|       |        } else {
  523|      0|            self.de.reader.advance(1);
  524|      0|            Ok(None)
  525|       |        }
  526|    489|    }
_RNvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess9size_hintCsilvC8qPft2D_8fvm_fuzz:
  500|    326|    fn size_hint(&self) -> Option<usize> {
  501|    326|        self.len
  502|    326|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitorNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
  344|  2.44k|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|  2.44k|    where
  346|  2.44k|        V: Visitor<'de>,
  347|  2.44k|    {
  348|  2.44k|        let mut de = self.try_step()?;
  349|  2.44k|        let seq = Accessor::tuple(&mut de, len)?;
  350|  2.44k|        visitor.visit_seq(seq)
  351|  2.44k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_strNtNtB1X_5impls13StringVisitorECsilvC8qPft2D_8fvm_fuzz:
  252|  2.44k|        match <Cow<str>>::decode(&mut self.reader)? {
  253|  2.44k|            Cow::Borrowed(buf) => visitor.visit_borrowed_str(buf),
  254|      0|            Cow::Owned(buf) => visitor.visit_string(buf),
  255|       |        }
  256|       |
  257|       |        // Don't use this. This can lead to random panics and invalid CBOR.
  258|       |        #[cfg(feature = "_do_not_use_its_unsafe_and_invalid_cbor")]
  259|       |        match types::BadStr::<Cow<[u8]>>::decode(&mut self.reader)? {
  260|       |            types::BadStr(Cow::Borrowed(buf)) => {
  261|       |                visitor.visit_borrowed_str(unsafe { std::str::from_utf8_unchecked(buf) })
  262|       |            }
  263|       |            types::BadStr(Cow::Owned(buf)) => {
  264|       |                visitor.visit_string(unsafe { String::from_utf8_unchecked(buf) })
  265|       |            }
  266|       |        }
  267|  2.44k|    }
_RNvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE3endCsilvC8qPft2D_8fvm_fuzz:
  131|    489|        match peek_one(&mut self.reader) {
  132|      0|            Ok(_) => Err(DecodeError::TrailingData),
  133|    489|            Err(DecodeError::Eof) => Ok(()),
  134|      0|            Err(error) => Err(error),
  135|       |        }
  136|    489|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDatamEECsilvC8qPft2D_8fvm_fuzz:
  484|    163|        if let Some(len) = self.len.as_mut() {
  485|    163|            if *len > 0 {
  486|    163|                *len -= 1;
  487|    163|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer26deserialize_newtype_structINtNvXs0_NtCseVyrqhqyiIX_3cid5serdeINtNtB3d_3cid3CidKpENtB1X_11Deserialize11deserialize16MainEntryVisitorKj40_EECsilvC8qPft2D_8fvm_fuzz:
  318|  2.77k|    fn deserialize_newtype_struct<V>(
  319|  2.77k|        self,
  320|  2.77k|        name: &'static str,
  321|  2.77k|        visitor: V,
  322|  2.77k|    ) -> Result<V::Value, Self::Error>
  323|  2.77k|    where
  324|  2.77k|        V: Visitor<'de>,
  325|  2.77k|    {
  326|  2.77k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  327|  2.77k|            self.deserialize_cid(visitor)
  328|       |        } else {
  329|      0|            visitor.visit_newtype_struct(self)
  330|       |        }
  331|  2.77k|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataNtNtCs71iYhC60HpU_5alloc6string6StringEECsilvC8qPft2D_8fvm_fuzz:
  484|  2.44k|        if let Some(len) = self.len.as_mut() {
  485|  2.44k|            if *len > 0 {
  486|  2.44k|                *len -= 1;
  487|  2.44k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  2.44k|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataTNtNtCs71iYhC60HpU_5alloc6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECsilvC8qPft2D_8fvm_fuzz:
  484|  2.60k|        if let Some(len) = self.len.as_mut() {
  485|  2.60k|            if *len > 0 {
  486|  2.44k|                *len -= 1;
  487|  2.44k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    163|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  2.60k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_u64NtNvXsX_NtB1X_5implsyNtB1X_11Deserialize11deserialize16PrimitiveVisitorECsilvC8qPft2D_8fvm_fuzz:
  142|    163|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    163|        where V: Visitor<'de>
  144|    163|        {
  145|    163|            let value = <$t>::decode(&mut self.reader)?;
  146|    163|            visitor.$visit(value)
  147|    163|        }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer18deserialize_structNtNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB31_9CarHeaderNtB1X_11Deserialize11deserialize9___VisitorECsilvC8qPft2D_8fvm_fuzz:
  377|    163|    fn deserialize_struct<V>(
  378|    163|        self,
  379|    163|        _name: &'static str,
  380|    163|        _fields: &'static [&'static str],
  381|    163|        visitor: V,
  382|    163|    ) -> Result<V::Value, Self::Error>
  383|    163|    where
  384|    163|        V: Visitor<'de>,
  385|    163|    {
  386|    163|        self.deserialize_map(visitor)
  387|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_mapNtNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB2Y_9CarHeaderNtB1X_11Deserialize11deserialize9___VisitorECsilvC8qPft2D_8fvm_fuzz:
  367|    163|    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  368|    163|    where
  369|    163|        V: Visitor<'de>,
  370|    163|    {
  371|    163|        let mut de = self.try_step()?;
  372|    163|        let map = Accessor::map(&mut de)?;
  373|    163|        visitor.visit_map(map)
  374|    163|    }
_RNvMs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE3mapCsilvC8qPft2D_8fvm_fuzz:
  464|    163|    pub fn map(de: &'a mut Deserializer<R>) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  465|    163|        let map_start = dec::MapStart::decode(&mut de.reader)?;
  466|    163|        Ok(Accessor {
  467|    163|            de,
  468|    163|            len: map_start.0,
  469|    163|        })
  470|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1X_5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtB1X_11Deserialize11deserialize10VecVisitorTNtNtB3h_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECsilvC8qPft2D_8fvm_fuzz:
  334|    163|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    163|    where
  336|    163|        V: Visitor<'de>,
  337|    163|    {
  338|    163|        let mut de = self.try_step()?;
  339|    163|        let seq = Accessor::array(&mut de)?;
  340|    163|        visitor.visit_seq(seq)
  341|    163|    }
_RNvMNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB2_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE11from_readerCsilvC8qPft2D_8fvm_fuzz:
   93|    489|    pub fn from_reader(reader: R) -> Deserializer<R> {
   94|    489|        Deserializer { reader }
   95|    489|    }
_RNCNvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE8try_step0CsilvC8qPft2D_8fvm_fuzz:
  106|  3.09k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
_RNvMs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE5tupleCsilvC8qPft2D_8fvm_fuzz:
  443|  2.60k|    pub fn tuple(
  444|  2.60k|        de: &'a mut Deserializer<R>,
  445|  2.60k|        len: usize,
  446|  2.60k|    ) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  447|  2.60k|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  448|       |
  449|  2.60k|        if array_start.0 == Some(len) {
  450|  2.60k|            Ok(Accessor {
  451|  2.60k|                de,
  452|  2.60k|                len: array_start.0,
  453|  2.60k|            })
  454|       |        } else {
  455|      0|            Err(DecodeError::RequireLength {
  456|      0|                name: "tuple",
  457|      0|                expect: len,
  458|      0|                value: array_start.0.unwrap_or(0),
  459|      0|            })
  460|       |        }
  461|  2.60k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitormINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
  344|    163|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    163|    where
  346|    163|        V: Visitor<'de>,
  347|    163|    {
  348|    163|        let mut de = self.try_step()?;
  349|    163|        let seq = Accessor::tuple(&mut de, len)?;
  350|    163|        visitor.visit_seq(seq)
  351|    163|    }
_RNvMs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderE8try_stepCsilvC8qPft2D_8fvm_fuzz:
  101|  3.09k|    fn try_step<'a>(
  102|  3.09k|        &'a mut self,
  103|  3.09k|    ) -> Result<scopeguard::ScopeGuard<&'a mut Self, fn(&'a mut Self) -> ()>, DecodeError<R::Error>>
  104|  3.09k|    {
  105|  3.09k|        if self.reader.step_in() {
  106|  3.09k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
  107|       |        } else {
  108|      0|            Err(DecodeError::DepthLimit)
  109|       |        }
  110|  3.09k|    }
_RINvXs7_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_15CidDeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer17deserialize_bytesNtNtCseVyrqhqyiIX_3cid5serde17BytesToCidVisitorECsilvC8qPft2D_8fvm_fuzz:
  646|  2.77k|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  647|  2.77k|        let byte = peek_one(&mut self.0.reader)?;
  648|  2.77k|        match dec::if_major(byte) {
  649|       |            major::BYTES => {
  650|       |                // CBOR encoded CIDs have a zero byte prefix we have to remove.
  651|  2.77k|                match <types::Bytes<Cow<[u8]>>>::decode(&mut self.0.reader)?.0 {
  652|  2.77k|                    Cow::Borrowed(buf) => {
  653|  2.77k|                        if buf.len() <= 1 || buf[0] != 0 {
  654|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  655|       |                        } else {
  656|  2.77k|                            visitor.visit_borrowed_bytes(&buf[1..])
  657|       |                        }
  658|       |                    }
  659|      0|                    Cow::Owned(mut buf) => {
  660|      0|                        if buf.len() <= 1 || buf[0] != 0 {
  661|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  662|       |                        } else {
  663|      0|                            buf.remove(0);
  664|      0|                            visitor.visit_byte_buf(buf)
  665|       |                        }
  666|       |                    }
  667|       |                }
  668|       |            }
  669|      0|            _ => Err(DecodeError::Unsupported { byte }),
  670|       |        }
  671|  2.77k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1X_5implsINtNtCs71iYhC60HpU_5alloc3vec3VecpENtB1X_11Deserialize11deserialize10VecVisitorINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
  334|    163|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    163|    where
  336|    163|        V: Visitor<'de>,
  337|    163|    {
  338|    163|        let mut de = self.try_step()?;
  339|    163|        let seq = Accessor::array(&mut de)?;
  340|    163|        visitor.visit_seq(seq)
  341|    163|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer18deserialize_stringNtNtB1X_5impls13StringVisitorECsilvC8qPft2D_8fvm_fuzz:
  270|  2.44k|    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  271|  2.44k|    where
  272|  2.44k|        V: Visitor<'de>,
  273|  2.44k|    {
  274|  2.44k|        self.deserialize_str(visitor)
  275|  2.44k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_u32NtNvXsV_NtB1X_5implsmNtB1X_11Deserialize11deserialize16PrimitiveVisitorECsilvC8qPft2D_8fvm_fuzz:
  142|    163|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    163|        where V: Visitor<'de>
  144|    163|        {
  145|    163|            let value = <$t>::decode(&mut self.reader)?;
  146|    163|            visitor.$visit(value)
  147|    163|        }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de12Deserializer15deserialize_strNtNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB2Y_9CarHeaderNtB1X_11Deserialize11deserialize14___FieldVisitorECsilvC8qPft2D_8fvm_fuzz:
  252|    326|        match <Cow<str>>::decode(&mut self.reader)? {
  253|    326|            Cow::Borrowed(buf) => visitor.visit_borrowed_str(buf),
  254|      0|            Cow::Owned(buf) => visitor.visit_string(buf),
  255|       |        }
  256|       |
  257|       |        // Don't use this. This can lead to random panics and invalid CBOR.
  258|       |        #[cfg(feature = "_do_not_use_its_unsafe_and_invalid_cbor")]
  259|       |        match types::BadStr::<Cow<[u8]>>::decode(&mut self.reader)? {
  260|       |            types::BadStr(Cow::Borrowed(buf)) => {
  261|       |                visitor.visit_borrowed_str(unsafe { std::str::from_utf8_unchecked(buf) })
  262|       |            }
  263|       |            types::BadStr(Cow::Owned(buf)) => {
  264|       |                visitor.visit_string(unsafe { String::from_utf8_unchecked(buf) })
  265|       |            }
  266|       |        }
  267|    326|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9SeqAccess17next_element_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
  484|  2.93k|        if let Some(len) = self.len.as_mut() {
  485|  2.93k|            if *len > 0 {
  486|  2.77k|                *len -= 1;
  487|  2.77k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    163|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  2.93k|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de10from_sliceINtNtCs71iYhC60HpU_5alloc3vec3VecTNtNtBW_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECsilvC8qPft2D_8fvm_fuzz:
   40|    163|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    163|where
   42|    163|    T: de::Deserialize<'a>,
   43|    163|{
   44|    163|    let reader = SliceReader::new(buf);
   45|    163|    let mut deserializer = Deserializer::from_reader(reader);
   46|    163|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    163|    deserializer.end()?;
   48|    163|    Ok(value)
   49|    163|}
_RINvXs3_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderENtNtCs2VpXLMAfFh1_5serde2de9MapAccess15next_value_seedINtNtCsdRJjCzU6nMS_4core6marker11PhantomDataINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECsilvC8qPft2D_8fvm_fuzz:
  529|    163|    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
  530|    163|    where
  531|    163|        V: de::DeserializeSeed<'de>,
  532|    163|    {
  533|    163|        seed.deserialize(&mut *self.de)
  534|    163|    }

_RNvMNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterE10into_innerCs4ieSHZHrxF6_15direct_syscalls:
   56|    326|    pub fn into_inner(self) -> W {
   57|    326|        self.writer
   58|    326|    }
_RNvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct3endCs4ieSHZHrxF6_15direct_syscalls:
  408|  1.14k|    fn end(self) -> Result<Self::Ok, Self::Error> {
  409|  1.14k|        Ok(())
  410|  1.14k|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser6to_vecNtNtCsgTTZuTcaXZ2_10fvm_shared5state9StateRootECs4ieSHZHrxF6_15direct_syscalls:
   23|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    163|where
   25|    163|    T: Serialize + ?Sized,
   26|    163|{
   27|    163|    let writer = BufWriter::new(Vec::new());
   28|    163|    let mut serializer = Serializer::new(writer);
   29|    163|    value.serialize(&mut serializer)?;
   30|    163|    Ok(serializer.into_inner().into_inner())
   31|    163|}
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_7CollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser12SerializeSeq17serialize_elementRINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB2R_14hash_algorithm6Sha256EECs4ieSHZHrxF6_15direct_syscalls:
  369|    489|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  370|    489|        value.serialize(&mut *self.ser)
  371|    489|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldRINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EECs4ieSHZHrxF6_15direct_syscalls:
  403|  1.30k|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|  1.30k|        value.serialize(&mut *self.ser)
  405|  1.30k|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateECs4ieSHZHrxF6_15direct_syscalls:
  403|    489|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    489|        value.serialize(&mut *self.ser)
  405|    489|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser6to_vecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtBS_14hash_algorithm6Sha256EECs4ieSHZHrxF6_15direct_syscalls:
   23|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    163|where
   25|    163|    T: Serialize + ?Sized,
   26|    163|{
   27|    163|    let writer = BufWriter::new(Vec::new());
   28|    163|    let mut serializer = Serializer::new(writer);
   29|    163|    value.serialize(&mut serializer)?;
   30|    163|    Ok(serializer.into_inner().into_inner())
   31|    163|}
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCsgTTZuTcaXZ2_10fvm_shared5state16StateTreeVersionECs4ieSHZHrxF6_15direct_syscalls:
  403|    163|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    163|        value.serialize(&mut *self.ser)
  405|    163|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldRINtNtCsdRJjCzU6nMS_4core6option6OptionNtNtCsgTTZuTcaXZ2_10fvm_shared7address7AddressEECs4ieSHZHrxF6_15direct_syscalls:
  403|    489|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    489|        value.serialize(&mut *self.ser)
  405|    489|    }
_RINvXs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser14SerializeTuple17serialize_elementRNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldECs4ieSHZHrxF6_15direct_syscalls:
  388|    163|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    163|        value.serialize(&mut *self.ser)
  390|    163|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer15serialize_tupleCs4ieSHZHrxF6_15direct_syscalls:
  239|  1.30k|        enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  240|  1.30k|        Ok(BoundedCollect { ser: self })
  241|  1.30k|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCsgTTZuTcaXZ2_10fvm_shared4econ11TokenAmountECs4ieSHZHrxF6_15direct_syscalls:
  403|    489|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    489|        value.serialize(&mut *self.ser)
  405|    489|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer15serialize_bytesCs4ieSHZHrxF6_15direct_syscalls:
  160|  1.14k|        types::Bytes(v).encode(&mut self.writer)?;
  161|  1.14k|        Ok(())
  162|  1.14k|    }
_RINvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_7CollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser12SerializeSeq17serialize_elementRINtCs6zZxOXcsMaf_13fvm_ipld_hamt12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEECs4ieSHZHrxF6_15direct_syscalls:
  369|    489|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  370|    489|        value.serialize(&mut *self.ser)
  371|    489|    }
_RINvXs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser14SerializeTuple17serialize_elementRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB3y_14hash_algorithm6Sha256EEECs4ieSHZHrxF6_15direct_syscalls:
  388|    163|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    163|        value.serialize(&mut *self.ser)
  390|    163|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer14serialize_noneCs4ieSHZHrxF6_15direct_syscalls:
  166|    489|        types::Null.encode(&mut self.writer)?;
  167|    489|        Ok(())
  168|    489|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyECs4ieSHZHrxF6_15direct_syscalls:
  403|    489|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    489|        value.serialize(&mut *self.ser)
  405|    489|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer13serialize_seqCs4ieSHZHrxF6_15direct_syscalls:
  226|    652|        if let Some(len) = len {
  227|    652|            enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  228|       |        } else {
  229|      0|            enc::ArrayStartUnbounded.encode(&mut self.writer)?;
  230|       |        }
  231|    652|        Ok(Collect {
  232|    652|            bounded: len.is_some(),
  233|    652|            ser: self,
  234|    652|        })
  235|    652|    }
_RNvXs7_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB5_13CidSerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer15serialize_bytesCs4ieSHZHrxF6_15direct_syscalls:
  550|  1.30k|    fn serialize_bytes(self, value: &[u8]) -> Result<Self::Ok, Self::Error> {
  551|  1.30k|        // The bytes of the CID is prefixed with a null byte when encoded as CBOR.
  552|  1.30k|        let prefixed = [&[0x00], value].concat();
  553|  1.30k|        // CIDs are serialized with CBOR tag 42.
  554|  1.30k|        types::Tag(CBOR_TAGS_CID, types::Bytes(&prefixed[..])).encode(&mut self.0.writer)?;
  555|  1.30k|        Ok(())
  556|  1.30k|    }
_RINvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB5_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer24serialize_newtype_structNtNtCsgsynKAC2p8K_11serde_bytes7bytebuf7ByteBufECs4ieSHZHrxF6_15direct_syscalls:
  199|  1.30k|    fn serialize_newtype_struct<T: Serialize + ?Sized>(
  200|  1.30k|        self,
  201|  1.30k|        name: &'static str,
  202|  1.30k|        value: &T,
  203|  1.30k|    ) -> Result<Self::Ok, Self::Error> {
  204|  1.30k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  205|  1.30k|            value.serialize(&mut CidSerializer(self))
  206|       |        } else {
  207|      0|            value.serialize(self)
  208|       |        }
  209|  1.30k|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer13serialize_u64Cs4ieSHZHrxF6_15direct_syscalls:
  123|    652|        v.encode(&mut self.writer)?;
  124|    652|        Ok(())
  125|    652|    }
_RNvMNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterE3newCs4ieSHZHrxF6_15direct_syscalls:
   51|    326|    pub fn new(writer: W) -> Serializer<W> {
   52|    326|        Serializer { writer }
   53|    326|    }
_RNvXs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser14SerializeTuple3endCs4ieSHZHrxF6_15direct_syscalls:
  393|    163|    fn end(self) -> Result<Self::Ok, Self::Error> {
  394|    163|        Ok(())
  395|    163|    }
_RNvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB5_7CollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser12SerializeSeq3endCs4ieSHZHrxF6_15direct_syscalls:
  374|    652|    fn end(self) -> Result<Self::Ok, Self::Error> {
  375|    652|        if !self.bounded {
  376|      0|            enc::End.encode(&mut self.ser.writer)?;
  377|    652|        }
  378|       |
  379|    652|        Ok(())
  380|    652|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer22serialize_tuple_structCs4ieSHZHrxF6_15direct_syscalls:
  244|  1.14k|    fn serialize_tuple_struct(
  245|  1.14k|        self,
  246|  1.14k|        _name: &'static str,
  247|  1.14k|        len: usize,
  248|  1.14k|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  249|  1.14k|        self.serialize_tuple(len)
  250|  1.14k|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldRyECs4ieSHZHrxF6_15direct_syscalls:
  403|    489|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    489|        value.serialize(&mut *self.ser)
  405|    489|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser6to_vecNtNtCsheoVkkQew6K_3fvm10init_actor5StateECsilvC8qPft2D_8fvm_fuzz:
   23|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    163|where
   25|    163|    T: Serialize + ?Sized,
   26|    163|{
   27|    163|    let writer = BufWriter::new(Vec::new());
   28|    163|    let mut serializer = Serializer::new(writer);
   29|    163|    value.serialize(&mut serializer)?;
   30|    163|    Ok(serializer.into_inner().into_inner())
   31|    163|}
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser6to_vecNtNtCsgTTZuTcaXZ2_10fvm_shared5state10StateInfo0ECsilvC8qPft2D_8fvm_fuzz:
   23|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    163|where
   25|    163|    T: Serialize + ?Sized,
   26|    163|{
   27|    163|    let writer = BufWriter::new(Vec::new());
   28|    163|    let mut serializer = Serializer::new(writer);
   29|    163|    value.serialize(&mut serializer)?;
   30|    163|    Ok(serializer.into_inner().into_inner())
   31|    163|}
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer13serialize_u64CsilvC8qPft2D_8fvm_fuzz:
  123|    163|        v.encode(&mut self.writer)?;
  124|    163|        Ok(())
  125|    163|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer15serialize_tupleCsilvC8qPft2D_8fvm_fuzz:
  239|    815|        enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  240|    815|        Ok(BoundedCollect { ser: self })
  241|    815|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser6to_vecNtNtCsheoVkkQew6K_3fvm12system_actor5StateECsilvC8qPft2D_8fvm_fuzz:
   23|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    163|where
   25|    163|    T: Serialize + ?Sized,
   26|    163|{
   27|    163|    let writer = BufWriter::new(Vec::new());
   28|    163|    let mut serializer = Serializer::new(writer);
   29|    163|    value.serialize(&mut serializer)?;
   30|    163|    Ok(serializer.into_inner().into_inner())
   31|    163|}
_RINvXs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser14SerializeTuple17serialize_elementRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtB31_6string6StringNtNtB3y_14hash_algorithm6Sha256EEECsilvC8qPft2D_8fvm_fuzz:
  388|    163|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    163|        value.serialize(&mut *self.ser)
  390|    163|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer15serialize_bytesCsilvC8qPft2D_8fvm_fuzz:
  160|    163|        types::Bytes(v).encode(&mut self.writer)?;
  161|    163|        Ok(())
  162|    163|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldRyECsilvC8qPft2D_8fvm_fuzz:
  403|    163|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    163|        value.serialize(&mut *self.ser)
  405|    163|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser6to_vecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCs71iYhC60HpU_5alloc6string6StringNtNtBS_14hash_algorithm6Sha256EECsilvC8qPft2D_8fvm_fuzz:
   23|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    163|where
   25|    163|    T: Serialize + ?Sized,
   26|    163|{
   27|    163|    let writer = BufWriter::new(Vec::new());
   28|    163|    let mut serializer = Serializer::new(writer);
   29|    163|    value.serialize(&mut serializer)?;
   30|    163|    Ok(serializer.into_inner().into_inner())
   31|    163|}
_RNvXs0_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB5_7CollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser12SerializeSeq3endCsilvC8qPft2D_8fvm_fuzz:
  374|    163|    fn end(self) -> Result<Self::Ok, Self::Error> {
  375|    163|        if !self.bounded {
  376|      0|            enc::End.encode(&mut self.ser.writer)?;
  377|    163|        }
  378|       |
  379|    163|        Ok(())
  380|    163|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer13serialize_strCsilvC8qPft2D_8fvm_fuzz:
  154|    163|        v.encode(&mut self.writer)?;
  155|    163|        Ok(())
  156|    163|    }
_RINvNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser6to_vecAuj0_ECsilvC8qPft2D_8fvm_fuzz:
   23|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    163|where
   25|    163|    T: Serialize + ?Sized,
   26|    163|{
   27|    163|    let writer = BufWriter::new(Vec::new());
   28|    163|    let mut serializer = Serializer::new(writer);
   29|    163|    value.serialize(&mut serializer)?;
   30|    163|    Ok(serializer.into_inner().into_inner())
   31|    163|}
_RINvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB5_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer24serialize_newtype_structNtNtCsgsynKAC2p8K_11serde_bytes7bytebuf7ByteBufECsilvC8qPft2D_8fvm_fuzz:
  199|    326|    fn serialize_newtype_struct<T: Serialize + ?Sized>(
  200|    326|        self,
  201|    326|        name: &'static str,
  202|    326|        value: &T,
  203|    326|    ) -> Result<Self::Ok, Self::Error> {
  204|    326|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  205|    326|            value.serialize(&mut CidSerializer(self))
  206|       |        } else {
  207|      0|            value.serialize(self)
  208|       |        }
  209|    326|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer13serialize_seqCsilvC8qPft2D_8fvm_fuzz:
  226|    163|        if let Some(len) = len {
  227|    163|            enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  228|       |        } else {
  229|      0|            enc::ArrayStartUnbounded.encode(&mut self.writer)?;
  230|       |        }
  231|    163|        Ok(Collect {
  232|    163|            bounded: len.is_some(),
  233|    163|            ser: self,
  234|    163|        })
  235|    163|    }
_RNvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct3endCsilvC8qPft2D_8fvm_fuzz:
  408|    326|    fn end(self) -> Result<Self::Ok, Self::Error> {
  409|    326|        Ok(())
  410|    326|    }
_RNvMNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterE10into_innerCsilvC8qPft2D_8fvm_fuzz:
   56|    815|    pub fn into_inner(self) -> W {
   57|    815|        self.writer
   58|    815|    }
_RNvMNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterE3newCsilvC8qPft2D_8fvm_fuzz:
   51|    815|    pub fn new(writer: W) -> Serializer<W> {
   52|    815|        Serializer { writer }
   53|    815|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCs71iYhC60HpU_5alloc6string6StringECsilvC8qPft2D_8fvm_fuzz:
  403|    163|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    163|        value.serialize(&mut *self.ser)
  405|    163|    }
_RNvXs7_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB5_13CidSerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer15serialize_bytesCsilvC8qPft2D_8fvm_fuzz:
  550|    326|    fn serialize_bytes(self, value: &[u8]) -> Result<Self::Ok, Self::Error> {
  551|    326|        // The bytes of the CID is prefixed with a null byte when encoded as CBOR.
  552|    326|        let prefixed = [&[0x00], value].concat();
  553|    326|        // CIDs are serialized with CBOR tag 42.
  554|    326|        types::Tag(CBOR_TAGS_CID, types::Bytes(&prefixed[..])).encode(&mut self.0.writer)?;
  555|    326|        Ok(())
  556|    326|    }
_RINvXs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser14SerializeTuple17serialize_elementRNtNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield8BitfieldECsilvC8qPft2D_8fvm_fuzz:
  388|    163|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    163|        value.serialize(&mut *self.ser)
  390|    163|    }
_RNvXs1_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser14SerializeTuple3endCsilvC8qPft2D_8fvm_fuzz:
  393|    489|    fn end(self) -> Result<Self::Ok, Self::Error> {
  394|    489|        Ok(())
  395|    489|    }
_RNvXs_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser10Serializer22serialize_tuple_structCsilvC8qPft2D_8fvm_fuzz:
  244|    326|    fn serialize_tuple_struct(
  245|    326|        self,
  246|    326|        _name: &'static str,
  247|    326|        len: usize,
  248|    326|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  249|    326|        self.serialize_tuple(len)
  250|    326|    }
_RINvXs2_NtCsfJMW7pIFHVe_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterENtNtCs2VpXLMAfFh1_5serde3ser20SerializeTupleStruct15serialize_fieldRINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EECsilvC8qPft2D_8fvm_fuzz:
  403|    326|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    326|        value.serialize(&mut *self.ser)
  405|    326|    }

_RINvXs_Cs6R461GKLOna_11serde_tupleINtB5_12DeserializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEENtNtCs2VpXLMAfFh1_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXs9_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtB3V_9StateRootNtB2F_11Deserialize11deserialize1__NtB3P_5InnerB4J_11deserialize9___VisitorECs4ieSHZHrxF6_15direct_syscalls:
  353|    163|    fn deserialize_tuple_struct<V>(
  354|    163|        self,
  355|    163|        name: &'static str,
  356|    163|        len: usize,
  357|    163|        visitor: V,
  358|    163|    ) -> Result<V::Value, Self::Error>
  359|    163|    where
  360|    163|        V: serde::de::Visitor<'de>,
  361|    163|    {
  362|    163|        self.0.deserialize_tuple_struct(name, len, visitor)
  363|    163|    }
_RINvXs_Cs6R461GKLOna_11serde_tupleINtB5_12DeserializerNtNtCsb605JUWHIii_12libipld_core4ipld4IpldENtNtCs2VpXLMAfFh1_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXsa_NtCsheoVkkQew6K_3fvm10state_treeNtB2P_10ActorStateNtB1z_11Deserialize11deserialize1__NtB2J_5InnerB3D_11deserialize9___VisitorECs4ieSHZHrxF6_15direct_syscalls:
  353|    489|    fn deserialize_tuple_struct<V>(
  354|    489|        self,
  355|    489|        name: &'static str,
  356|    489|        len: usize,
  357|    489|        visitor: V,
  358|    489|    ) -> Result<V::Value, Self::Error>
  359|    489|    where
  360|    489|        V: serde::de::Visitor<'de>,
  361|    489|    {
  362|    489|        self.0.deserialize_tuple_struct(name, len, visitor)
  363|    489|    }
_RNvXCs6R461GKLOna_11serde_tupleINtB2_10SerializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEENtNtCs2VpXLMAfFh1_5serde3ser10Serializer22serialize_tuple_structCs4ieSHZHrxF6_15direct_syscalls:
  158|    652|    fn serialize_tuple_struct(
  159|    652|        self,
  160|    652|        name: &'static str,
  161|    652|        len: usize,
  162|    652|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  163|    652|        self.0.serialize_tuple_struct(name, len)
  164|    652|    }
_RINvXCs6R461GKLOna_11serde_tupleINtB3_10SerializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEENtNtCs2VpXLMAfFh1_5serde3ser10Serializer24serialize_newtype_structRINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EECsilvC8qPft2D_8fvm_fuzz:
  123|    163|    fn serialize_newtype_struct<T: ?Sized>(
  124|    163|        self,
  125|    163|        name: &'static str,
  126|    163|        value: &T,
  127|    163|    ) -> Result<Self::Ok, Self::Error>
  128|    163|    where
  129|    163|        T: serde::Serialize,
  130|    163|    {
  131|       |        use serde::ser::SerializeTupleStruct;
  132|    163|        let mut out = self.serialize_tuple_struct(name, 1)?;
  133|    163|        out.serialize_field(value)?;
  134|    163|        out.end()
  135|    163|    }
_RNvXCs6R461GKLOna_11serde_tupleINtB2_10SerializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEENtNtCs2VpXLMAfFh1_5serde3ser10Serializer22serialize_tuple_structCsilvC8qPft2D_8fvm_fuzz:
  158|    326|    fn serialize_tuple_struct(
  159|    326|        self,
  160|    326|        name: &'static str,
  161|    326|        len: usize,
  162|    326|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  163|    326|        self.0.serialize_tuple_struct(name, len)
  164|    326|    }

_RNvXs3_NtCs7HNaFSx2gxZ_4sha28core_apiNtB5_13Sha256VarCoreNtNtCsh9D4u1TLtsH_6digest8core_api18VariableOutputCore3new:
   49|    489|    fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {
   50|    489|        let state = match output_size {
   51|      0|            28 => consts::H256_224,
   52|    489|            32 => consts::H256_256,
   53|      0|            _ => return Err(InvalidOutputSize),
   54|       |        };
   55|    489|        let block_len = 0;
   56|    489|        Ok(Self { state, block_len })
   57|    489|    }
_RNvXs3_NtCs7HNaFSx2gxZ_4sha28core_apiNtB5_13Sha256VarCoreNtNtCsh9D4u1TLtsH_6digest8core_api18VariableOutputCore22finalize_variable_core:
   60|    489|    fn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {
   61|    489|        let bs = Self::BlockSize::U64;
   62|    489|        let bit_len = 8 * (buffer.get_pos() as u64 + bs * self.block_len);
   63|    489|        buffer.len64_padding_be(bit_len, |b| compress256(&mut self.state, from_ref(b)));
   64|       |
   65|  3.91k|        for (chunk, v) in out.chunks_exact_mut(4).zip(self.state.iter()) {
   66|  3.91k|            chunk.copy_from_slice(&v.to_be_bytes());
   67|  3.91k|        }
   68|    489|    }
_RNCNvXs3_NtCs7HNaFSx2gxZ_4sha28core_apiNtB7_13Sha256VarCoreNtNtCsh9D4u1TLtsH_6digest8core_api18VariableOutputCore22finalize_variable_core0Cs4ieSHZHrxF6_15direct_syscalls:
   63|    489|        buffer.len64_padding_be(bit_len, |b| compress256(&mut self.state, from_ref(b)));

_RNvNtCs7HNaFSx2gxZ_4sha26sha25611compress256:
   31|    489|pub fn compress256(state: &mut [u32; 8], blocks: &[GenericArray<u8, U64>]) {
   32|    489|    // SAFETY: GenericArray<u8, U64> and [u8; 64] have
   33|    489|    // exactly the same memory layout
   34|    489|    let p = blocks.as_ptr() as *const [u8; 64];
   35|    489|    let blocks = unsafe { core::slice::from_raw_parts(p, blocks.len()) };
   36|    489|    compress(state, blocks)
   37|    489|}

_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft22sha256_digest_round_x2:
   74|  15.6k|fn sha256_digest_round_x2(cdgh: [u32; 4], abef: [u32; 4], wk: [u32; 4]) -> [u32; 4] {
   75|  15.6k|    macro_rules! big_sigma0 {
   76|  15.6k|        ($a:expr) => {
   77|  15.6k|            ($a.rotate_right(2) ^ $a.rotate_right(13) ^ $a.rotate_right(22))
   78|  15.6k|        };
   79|  15.6k|    }
   80|  15.6k|    macro_rules! big_sigma1 {
   81|  15.6k|        ($a:expr) => {
   82|  15.6k|            ($a.rotate_right(6) ^ $a.rotate_right(11) ^ $a.rotate_right(25))
   83|  15.6k|        };
   84|  15.6k|    }
   85|  15.6k|    macro_rules! bool3ary_202 {
   86|  15.6k|        ($a:expr, $b:expr, $c:expr) => {
   87|  15.6k|            $c ^ ($a & ($b ^ $c))
   88|  15.6k|        };
   89|  15.6k|    } // Choose, MD5F, SHA1C
   90|  15.6k|    macro_rules! bool3ary_232 {
   91|  15.6k|        ($a:expr, $b:expr, $c:expr) => {
   92|  15.6k|            ($a & $b) ^ ($a & $c) ^ ($b & $c)
   93|  15.6k|        };
   94|  15.6k|    } // Majority, SHA1M
   95|  15.6k|
   96|  15.6k|    let [_, _, wk1, wk0] = wk;
   97|  15.6k|    let [a0, b0, e0, f0] = abef;
   98|  15.6k|    let [c0, d0, g0, h0] = cdgh;
   99|  15.6k|
  100|  15.6k|    // a round
  101|  15.6k|    let x0 = big_sigma1!(e0)
  102|  15.6k|        .wrapping_add(bool3ary_202!(e0, f0, g0))
  103|  15.6k|        .wrapping_add(wk0)
  104|  15.6k|        .wrapping_add(h0);
  105|  15.6k|    let y0 = big_sigma0!(a0).wrapping_add(bool3ary_232!(a0, b0, c0));
  106|  15.6k|    let (a1, b1, c1, d1, e1, f1, g1, h1) = (
  107|  15.6k|        x0.wrapping_add(y0),
  108|  15.6k|        a0,
  109|  15.6k|        b0,
  110|  15.6k|        c0,
  111|  15.6k|        x0.wrapping_add(d0),
  112|  15.6k|        e0,
  113|  15.6k|        f0,
  114|  15.6k|        g0,
  115|  15.6k|    );
  116|  15.6k|
  117|  15.6k|    // a round
  118|  15.6k|    let x1 = big_sigma1!(e1)
  119|  15.6k|        .wrapping_add(bool3ary_202!(e1, f1, g1))
  120|  15.6k|        .wrapping_add(wk1)
  121|  15.6k|        .wrapping_add(h1);
  122|  15.6k|    let y1 = big_sigma0!(a1).wrapping_add(bool3ary_232!(a1, b1, c1));
  123|  15.6k|    let (a2, b2, _, _, e2, f2, _, _) = (
  124|  15.6k|        x1.wrapping_add(y1),
  125|  15.6k|        a1,
  126|  15.6k|        b1,
  127|  15.6k|        c1,
  128|  15.6k|        x1.wrapping_add(d1),
  129|  15.6k|        e1,
  130|  15.6k|        f1,
  131|  15.6k|        g1,
  132|  15.6k|    );
  133|  15.6k|
  134|  15.6k|    [a2, b2, e2, f2]
  135|  15.6k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft8schedule:
  137|  5.86k|fn schedule(v0: [u32; 4], v1: [u32; 4], v2: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
  138|  5.86k|    let t1 = sha256msg1(v0, v1);
  139|  5.86k|    let t2 = sha256load(v2, v3);
  140|  5.86k|    let t3 = add(t1, t2);
  141|  5.86k|    sha256msg2(t3, v3)
  142|  5.86k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft10sha256msg1:
   43|  5.86k|fn sha256msg1(v0: [u32; 4], v1: [u32; 4]) -> [u32; 4] {
   44|  5.86k|    // sigma 0 on vectors
   45|  5.86k|    #[inline]
   46|  5.86k|    fn sigma0x4(x: [u32; 4]) -> [u32; 4] {
   47|  5.86k|        let t1 = or(shl(x, 7), shr(x, 25));
   48|  5.86k|        let t2 = or(shl(x, 18), shr(x, 14));
   49|  5.86k|        let t3 = shl(x, 3);
   50|  5.86k|        xor(xor(t1, t2), t3)
   51|  5.86k|    }
   52|  5.86k|
   53|  5.86k|    add(v0, sigma0x4(sha256load(v0, v1)))
   54|  5.86k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft3shl:
    6|  17.6k|fn shl(v: [u32; 4], o: u32) -> [u32; 4] {
    7|  17.6k|    [v[0] >> o, v[1] >> o, v[2] >> o, v[3] >> o]
    8|  17.6k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft8compress:
  206|    489|pub fn compress(state: &mut [u32; 8], blocks: &[[u8; 64]]) {
  207|    489|    let mut block_u32 = [0u32; BLOCK_LEN];
  208|    489|    // since LLVM can't properly use aliasing yet it will make
  209|    489|    // unnecessary state stores without this copy
  210|    489|    let mut state_cpy = *state;
  211|    978|    for block in blocks {
  212|  7.82k|        for (o, chunk) in block_u32.iter_mut().zip(block.chunks_exact(4)) {
  213|  7.82k|            *o = u32::from_be_bytes(chunk.try_into().unwrap());
  214|  7.82k|        }
  215|    489|        sha256_digest_block_u32(&mut state_cpy, &block_u32);
  216|       |    }
  217|    489|    *state = state_cpy;
  218|    489|}
_RNvNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft10sha256msg18sigma0x4:
   46|  5.86k|    fn sigma0x4(x: [u32; 4]) -> [u32; 4] {
   47|  5.86k|        let t1 = or(shl(x, 7), shr(x, 25));
   48|  5.86k|        let t2 = or(shl(x, 18), shr(x, 14));
   49|  5.86k|        let t3 = shl(x, 3);
   50|  5.86k|        xor(xor(t1, t2), t3)
   51|  5.86k|    }
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft10sha256msg2:
   56|  5.86k|fn sha256msg2(v4: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
   57|  5.86k|    macro_rules! sigma1 {
   58|  5.86k|        ($a:expr) => {
   59|  5.86k|            $a.rotate_right(17) ^ $a.rotate_right(19) ^ ($a >> 10)
   60|  5.86k|        };
   61|  5.86k|    }
   62|  5.86k|
   63|  5.86k|    let [x3, x2, x1, x0] = v4;
   64|  5.86k|    let [w15, w14, _, _] = v3;
   65|  5.86k|
   66|  5.86k|    let w16 = x0.wrapping_add(sigma1!(w14));
   67|  5.86k|    let w17 = x1.wrapping_add(sigma1!(w15));
   68|  5.86k|    let w18 = x2.wrapping_add(sigma1!(w16));
   69|  5.86k|    let w19 = x3.wrapping_add(sigma1!(w17));
   70|  5.86k|
   71|  5.86k|    [w19, w18, w17, w16]
   72|  5.86k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft3shr:
   11|  11.7k|fn shr(v: [u32; 4], o: u32) -> [u32; 4] {
   12|  11.7k|    [v[0] << o, v[1] << o, v[2] << o, v[3] << o]
   13|  11.7k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft3add:
   26|  19.5k|fn add(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   27|  19.5k|    [
   28|  19.5k|        a[0].wrapping_add(b[0]),
   29|  19.5k|        a[1].wrapping_add(b[1]),
   30|  19.5k|        a[2].wrapping_add(b[2]),
   31|  19.5k|        a[3].wrapping_add(b[3]),
   32|  19.5k|    ]
   33|  19.5k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft23sha256_digest_block_u32:
  165|    489|fn sha256_digest_block_u32(state: &mut [u32; 8], block: &[u32; 16]) {
  166|    489|    let mut abef = [state[0], state[1], state[4], state[5]];
  167|    489|    let mut cdgh = [state[2], state[3], state[6], state[7]];
  168|    489|
  169|    489|    // Rounds 0..64
  170|    489|    let mut w0 = [block[3], block[2], block[1], block[0]];
  171|    489|    let mut w1 = [block[7], block[6], block[5], block[4]];
  172|    489|    let mut w2 = [block[11], block[10], block[9], block[8]];
  173|    489|    let mut w3 = [block[15], block[14], block[13], block[12]];
  174|    489|    let mut w4;
  175|    489|
  176|    489|    rounds4!(abef, cdgh, w0, 0);
  177|    489|    rounds4!(abef, cdgh, w1, 1);
  178|    489|    rounds4!(abef, cdgh, w2, 2);
  179|    489|    rounds4!(abef, cdgh, w3, 3);
  180|    489|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 4);
  181|    489|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 5);
  182|    489|    schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 6);
  183|    489|    schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 7);
  184|    489|    schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 8);
  185|    489|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 9);
  186|    489|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 10);
  187|    489|    schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 11);
  188|    489|    schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 12);
  189|    489|    schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 13);
  190|    489|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 14);
  191|    489|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 15);
  192|    489|
  193|    489|    let [a, b, e, f] = abef;
  194|    489|    let [c, d, g, h] = cdgh;
  195|    489|
  196|    489|    state[0] = state[0].wrapping_add(a);
  197|    489|    state[1] = state[1].wrapping_add(b);
  198|    489|    state[2] = state[2].wrapping_add(c);
  199|    489|    state[3] = state[3].wrapping_add(d);
  200|    489|    state[4] = state[4].wrapping_add(e);
  201|    489|    state[5] = state[5].wrapping_add(f);
  202|    489|    state[6] = state[6].wrapping_add(g);
  203|    489|    state[7] = state[7].wrapping_add(h);
  204|    489|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft2or:
   16|  11.7k|fn or(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   17|  11.7k|    [a[0] | b[0], a[1] | b[1], a[2] | b[2], a[3] | b[3]]
   18|  11.7k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft10sha256load:
   35|  11.7k|fn sha256load(v2: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
   36|  11.7k|    [v3[3], v2[0], v2[1], v2[2]]
   37|  11.7k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft3xor:
   21|  11.7k|fn xor(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   22|  11.7k|    [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
   23|  11.7k|}
_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2564soft10sha256swap:
   39|  7.82k|fn sha256swap(v0: [u32; 4]) -> [u32; 4] {
   40|  7.82k|    [v0[2], v0[3], v0[0], v0[1]]
   41|  7.82k|}

_RNvNtNtCs7HNaFSx2gxZ_4sha26sha2563x868compress:
  102|    489|pub fn compress(state: &mut [u32; 8], blocks: &[[u8; 64]]) {
  103|    489|    // TODO: Replace with https://github.com/rust-lang/rfcs/pull/2725
  104|    489|    // after stabilization
  105|    489|    if shani_cpuid::get() {
  106|      0|        unsafe {
  107|      0|            digest_blocks(state, blocks);
  108|      0|        }
  109|    489|    } else {
  110|    489|        super::soft::compress(state, blocks);
  111|    489|    }
  112|    489|}

_RNvXst_NtCs6PBDMK1Y3DJ_14target_lexicon7targetsNtB5_12ArchitectureNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   13|    326|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1y_NtCs6PBDMK1Y3DJ_14target_lexicon7targetsNtB6_6VendorNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  403|    326|#[derive(Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1O_NtCs6PBDMK1Y3DJ_14target_lexicon7targetsNtB6_11EnvironmentNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  476|    326|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1G_NtCs6PBDMK1Y3DJ_14target_lexicon7targetsNtB6_15OperatingSystemNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  434|    326|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1W_NtCs6PBDMK1Y3DJ_14target_lexicon7targetsNtB6_12BinaryFormatNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  515|    326|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]

_RNvXsr_NtCs6PBDMK1Y3DJ_14target_lexicon6tripleNtB5_6TripleNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   87|    326|#[derive(Clone, Debug, PartialEq, Eq, Hash)]

_RNvXso_Csl23fe6LXXvn_9termcolorINtB5_7NoColorINtNtCs71iYhC60HpU_5alloc3vec3VechEENtB5_10WriteColor5resetCsgVqcGLl2G6M_10env_logger:
 1247|    978|    fn reset(&mut self) -> io::Result<()> {
 1248|    978|        Ok(())
 1249|    978|    }
_RNvXso_Csl23fe6LXXvn_9termcolorINtB5_7NoColorINtNtCs71iYhC60HpU_5alloc3vec3VechEENtB5_10WriteColor9set_colorCsgVqcGLl2G6M_10env_logger:
 1242|    978|    fn set_color(&mut self, _: &ColorSpec) -> io::Result<()> {
 1243|    978|        Ok(())
 1244|    978|    }
_RNvXsR_Csl23fe6LXXvn_9termcolorNtB5_5ColorNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
 1805|    652|#[derive(Clone, Copy, Debug, Eq, PartialEq)]
_RNvXsl_Csl23fe6LXXvn_9termcolorNtB5_6BufferNtB5_10WriteColor5reset:
 1182|    978|    fn reset(&mut self) -> io::Result<()> {
 1183|    978|        match self.0 {
 1184|    978|            BufferInner::NoColor(ref mut w) => w.reset(),
 1185|      0|            BufferInner::Ansi(ref mut w) => w.reset(),
 1186|       |            #[cfg(windows)]
 1187|       |            BufferInner::Windows(ref mut w) => w.reset(),
 1188|       |        }
 1189|    978|    }
_RNvXsl_Csl23fe6LXXvn_9termcolorNtB5_6BufferNtB5_10WriteColor9set_color:
 1172|    978|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
 1173|    978|        match self.0 {
 1174|    978|            BufferInner::NoColor(ref mut w) => w.set_color(spec),
 1175|      0|            BufferInner::Ansi(ref mut w) => w.set_color(spec),
 1176|       |            #[cfg(windows)]
 1177|       |            BufferInner::Windows(ref mut w) => w.set_color(spec),
 1178|       |        }
 1179|    978|    }
_RNvXsL_Csl23fe6LXXvn_9termcolorNtB5_9ColorSpecNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
 1579|    652|#[derive(Clone, Debug, Eq, PartialEq)]
_RNvXsn_Csl23fe6LXXvn_9termcolorINtB5_7NoColorINtNtCs71iYhC60HpU_5alloc3vec3VechEENtNtCslmThs0IH7zH_3std2io5Write5writeCsgVqcGLl2G6M_10env_logger:
 1225|  4.89k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1226|  4.89k|        self.0.write(buf)
 1227|  4.89k|    }
_RNvXsk_Csl23fe6LXXvn_9termcolorNtB5_6BufferNtNtCslmThs0IH7zH_3std2io5Write5write:
 1140|  4.89k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1141|  4.89k|        match self.0 {
 1142|  4.89k|            BufferInner::NoColor(ref mut w) => w.write(buf),
 1143|      0|            BufferInner::Ansi(ref mut w) => w.write(buf),
 1144|       |            #[cfg(windows)]
 1145|       |            BufferInner::Windows(ref mut w) => w.write(buf),
 1146|       |        }
 1147|  4.89k|    }
_RNvMsB_Csl23fe6LXXvn_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE3newB5_:
 2010|    163|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|    163|        LossyStandardStream { wtr: wtr }
 2012|    163|    }
_RNvMsv_Csl23fe6LXXvn_9termcolorNtB5_9ColorSpec3new:
 1608|    978|    pub fn new() -> ColorSpec {
 1609|    978|        ColorSpec::default()
 1610|    978|    }
_RINvMsB_Csl23fe6LXXvn_9termcolorINtB6_19LossyStandardStreamNtB6_16IoStandardStreamE4wrapNtB6_20IoStandardStreamLockEB6_:
 2022|    326|    fn wrap<Q: io::Write>(&self, wtr: Q) -> LossyStandardStream<Q> {
 2023|    326|        LossyStandardStream::new(wtr)
 2024|    326|    }
_RNvMs1_Csl23fe6LXXvn_9termcolorNtB5_16IoStandardStream4lock:
  332|    326|    fn lock(&self) -> IoStandardStreamLock<'_> {
  333|    326|        match *self {
  334|      0|            IoStandardStream::Stdout(ref s) => {
  335|      0|                IoStandardStreamLock::StdoutLock(s.lock())
  336|       |            }
  337|    326|            IoStandardStream::Stderr(ref s) => {
  338|    326|                IoStandardStreamLock::StderrLock(s.lock())
  339|       |            }
  340|       |            IoStandardStream::StdoutBuffered(_)
  341|       |            | IoStandardStream::StderrBuffered(_) => {
  342|       |                // We don't permit this case to ever occur in the public API,
  343|       |                // so it's OK to panic.
  344|      0|                panic!("cannot lock a buffered standard stream")
  345|       |            }
  346|       |        }
  347|    326|    }
_RNvMsB_Csl23fe6LXXvn_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE7get_refB5_:
 2031|    326|    fn get_ref(&self) -> &W {
 2032|    326|        &self.wtr
 2033|    326|    }
_RNvMsi_Csl23fe6LXXvn_9termcolorNtB5_12BufferWriter6buffer:
  956|      1|    pub fn buffer(&self) -> Buffer {
  957|      1|        Buffer::new(self.color_choice)
  958|      1|    }
_RNvXsu_Csl23fe6LXXvn_9termcolorNtB5_9ColorSpecNtNtCsdRJjCzU6nMS_4core7default7Default7default:
 1592|    978|    fn default() -> ColorSpec {
 1593|    978|        ColorSpec {
 1594|    978|            fg_color: None,
 1595|    978|            bg_color: None,
 1596|    978|            bold: false,
 1597|    978|            intense: false,
 1598|    978|            underline: false,
 1599|    978|            dimmed: false,
 1600|    978|            italic: false,
 1601|    978|            reset: true,
 1602|    978|        }
 1603|    978|    }
_RNvMs0_Csl23fe6LXXvn_9termcolorNtB5_11ColorChoice20should_attempt_color:
  224|      1|    fn should_attempt_color(&self) -> bool {
  225|      1|        match *self {
  226|      0|            ColorChoice::Always => true,
  227|      0|            ColorChoice::AlwaysAnsi => true,
  228|      1|            ColorChoice::Never => false,
  229|      0|            ColorChoice::Auto => self.env_allows_color(),
  230|       |        }
  231|      1|    }
_RNvXs3_Csl23fe6LXXvn_9termcolorNtB5_20IoStandardStreamLockNtNtCslmThs0IH7zH_3std2io5Write5write:
  381|    326|    fn write(&mut self, b: &[u8]) -> io::Result<usize> {
  382|    326|        match *self {
  383|      0|            IoStandardStreamLock::StdoutLock(ref mut s) => s.write(b),
  384|    326|            IoStandardStreamLock::StderrLock(ref mut s) => s.write(b),
  385|       |        }
  386|    326|    }
_RNvMsB_Csl23fe6LXXvn_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockE3newB5_:
 2010|    326|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|    326|        LossyStandardStream { wtr: wtr }
 2012|    326|    }
_RNvMsv_Csl23fe6LXXvn_9termcolorNtB5_9ColorSpec11set_intense:
 1741|    652|    pub fn set_intense(&mut self, yes: bool) -> &mut ColorSpec {
 1742|    652|        self.intense = yes;
 1743|    652|        self
 1744|    652|    }
_RNvMsi_Csl23fe6LXXvn_9termcolorNtB5_12BufferWriter5print:
  974|    326|    pub fn print(&self, buf: &Buffer) -> io::Result<()> {
  975|    326|        if buf.is_empty() {
  976|      0|            return Ok(());
  977|    326|        }
  978|    326|        let mut stream = self.stream.wrap(self.stream.get_ref().lock());
  979|    326|        if let Some(ref sep) = self.separator {
  980|      0|            if self.printed.load(Ordering::SeqCst) {
  981|      0|                stream.write_all(sep)?;
  982|      0|                stream.write_all(b"\n")?;
  983|      0|            }
  984|    326|        }
  985|    326|        match buf.0 {
  986|    326|            BufferInner::NoColor(ref b) => stream.write_all(&b.0)?,
  987|      0|            BufferInner::Ansi(ref b) => stream.write_all(&b.0)?,
  988|       |            #[cfg(windows)]
  989|       |            BufferInner::Windows(ref b) => {
  990|       |                // We guarantee by construction that we have a console here.
  991|       |                // Namely, a BufferWriter is the only way to produce a Buffer.
  992|       |                let console_mutex = self
  993|       |                    .console
  994|       |                    .as_ref()
  995|       |                    .expect("got Windows buffer but have no Console");
  996|       |                let mut console = console_mutex.lock().unwrap();
  997|       |                b.print(&mut *console, &mut stream)?;
  998|       |            }
  999|       |        }
 1000|    326|        self.printed.store(true, Ordering::SeqCst);
 1001|    326|        Ok(())
 1002|    326|    }
_RNvMsj_Csl23fe6LXXvn_9termcolorNtB5_6Buffer3len:
 1085|    326|    pub fn len(&self) -> usize {
 1086|    326|        match self.0 {
 1087|    326|            BufferInner::NoColor(ref b) => b.0.len(),
 1088|      0|            BufferInner::Ansi(ref b) => b.0.len(),
 1089|       |            #[cfg(windows)]
 1090|       |            BufferInner::Windows(ref b) => b.buf.len(),
 1091|       |        }
 1092|    326|    }
_RNvMsi_Csl23fe6LXXvn_9termcolorNtB5_12BufferWriter6create:
  874|    163|    fn create(sty: StandardStreamType, choice: ColorChoice) -> BufferWriter {
  875|    163|        BufferWriter {
  876|    163|            stream: LossyStandardStream::new(IoStandardStream::new(sty)),
  877|    163|            printed: AtomicBool::new(false),
  878|    163|            separator: None,
  879|    163|            color_choice: choice,
  880|    163|        }
  881|    163|    }
_RNvMsj_Csl23fe6LXXvn_9termcolorNtB5_6Buffer8is_empty:
 1080|    326|    pub fn is_empty(&self) -> bool {
 1081|    326|        self.len() == 0
 1082|    326|    }
_RNvMsv_Csl23fe6LXXvn_9termcolorNtB5_9ColorSpec6set_fg:
 1618|    978|    pub fn set_fg(&mut self, color: Option<Color>) -> &mut ColorSpec {
 1619|    978|        self.fg_color = color;
 1620|    978|        self
 1621|    978|    }
_RNvMs1_Csl23fe6LXXvn_9termcolorNtB5_16IoStandardStream3new:
  313|    163|    fn new(sty: StandardStreamType) -> IoStandardStream {
  314|    163|        match sty {
  315|       |            StandardStreamType::Stdout => {
  316|      0|                IoStandardStream::Stdout(io::stdout())
  317|       |            }
  318|       |            StandardStreamType::Stderr => {
  319|    163|                IoStandardStream::Stderr(io::stderr())
  320|       |            }
  321|       |            StandardStreamType::StdoutBuffered => {
  322|      0|                let wtr = io::BufWriter::new(io::stdout());
  323|      0|                IoStandardStream::StdoutBuffered(wtr)
  324|       |            }
  325|       |            StandardStreamType::StderrBuffered => {
  326|      0|                let wtr = io::BufWriter::new(io::stderr());
  327|      0|                IoStandardStream::StderrBuffered(wtr)
  328|       |            }
  329|       |        }
  330|    163|    }
_RNvMsi_Csl23fe6LXXvn_9termcolorNtB5_12BufferWriter6stderr:
  939|    163|    pub fn stderr(choice: ColorChoice) -> BufferWriter {
  940|    163|        BufferWriter::create(StandardStreamType::Stderr, choice)
  941|    163|    }
_RNvMsj_Csl23fe6LXXvn_9termcolorNtB5_6Buffer8no_color:
 1064|      1|    pub fn no_color() -> Buffer {
 1065|      1|        Buffer(BufferInner::NoColor(NoColor(vec![])))
 1066|      1|    }
_RNvXsD_Csl23fe6LXXvn_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockENtNtCslmThs0IH7zH_3std2io5Write5writeB5_:
 2053|    326|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 2054|    326|        self.wtr.write(buf)
 2055|    326|    }
_RNvMsj_Csl23fe6LXXvn_9termcolorNtB5_6Buffer5clear:
 1095|    326|    pub fn clear(&mut self) {
 1096|    326|        match self.0 {
 1097|    326|            BufferInner::NoColor(ref mut b) => b.0.clear(),
 1098|      0|            BufferInner::Ansi(ref mut b) => b.0.clear(),
 1099|       |            #[cfg(windows)]
 1100|       |            BufferInner::Windows(ref mut b) => b.clear(),
 1101|       |        }
 1102|    326|    }
_RNvMsj_Csl23fe6LXXvn_9termcolorNtB5_6Buffer3new:
 1035|      1|    fn new(choice: ColorChoice) -> Buffer {
 1036|      1|        if choice.should_attempt_color() {
 1037|      0|            Buffer::ansi()
 1038|       |        } else {
 1039|      1|            Buffer::no_color()
 1040|       |        }
 1041|      1|    }

_RNvNtCsbn2VTn2D7sd_15unsigned_varint6decode3u64:
  122|  41.7k|pub fn u64(buf: &[u8]) -> Result<(u64, &[u8]), Error> {
  123|  41.7k|    decode!(buf, 9, u64)
  124|  41.7k|}
_RNvNtCsbn2VTn2D7sd_15unsigned_varint6decode7is_last:
   90|   125k|pub fn is_last(b: u8) -> bool {
   91|   125k|    b & 0x80 == 0
   92|   125k|}

_RNvNtCsbn2VTn2D7sd_15unsigned_varint6encode3u64:
   69|  8.80k|pub fn u64(number: u64, buf: &mut [u8; U64_LEN]) -> &[u8] {
   70|  8.80k|    encode!(number, buf)
   71|  8.80k|}
_RNvNtCsbn2VTn2D7sd_15unsigned_varint6encode10u64_buffer:
  119|  50.5k|pub fn u64_buffer() -> [u8; U64_LEN] {
  120|  50.5k|    [0; U64_LEN]
  121|  50.5k|}
_RNvNtCsbn2VTn2D7sd_15unsigned_varint6encode2u8:
   45|  2.77k|pub fn u8(number: u8, buf: &mut [u8; U8_LEN]) -> &[u8] {
   46|  2.77k|    encode!(number, buf)
   47|  2.77k|}
_RNvNtCsbn2VTn2D7sd_15unsigned_varint6encode9u8_buffer:
  101|  2.77k|pub fn u8_buffer() -> [u8; U8_LEN] {
  102|  2.77k|    [0; U8_LEN]
  103|  2.77k|}

_RINvNtCsbn2VTn2D7sd_15unsigned_varint2io8read_u64QQRShECs4ieSHZHrxF6_15direct_syscalls:
   31|  19.5k|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|  19.5k|                let mut b = encode::$b();
   33|  29.3k|                for i in 0 .. b.len() {
   34|  29.3k|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|  29.3k|                    if n == 0 {
   36|      0|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|  29.3k|                    }
   38|  29.3k|                    if decode::is_last(b[i]) {
   39|  19.5k|                        return Ok(decode::$t(&b[..= i])?.0)
   40|  9.78k|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|  19.5k|            }
_RINvNtCsbn2VTn2D7sd_15unsigned_varint2io8read_u64QQINtNtNtCslmThs0IH7zH_3std2io6cursor6CursorRINtNtCs71iYhC60HpU_5alloc3vec3VechEEECsilvC8qPft2D_8fvm_fuzz:
   31|  11.0k|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|  11.0k|                let mut b = encode::$b();
   33|  16.6k|                for i in 0 .. b.len() {
   34|  16.6k|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|  16.6k|                    if n == 0 {
   36|      0|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|  16.6k|                    }
   38|  16.6k|                    if decode::is_last(b[i]) {
   39|  11.0k|                        return Ok(decode::$t(&b[..= i])?.0)
   40|  5.54k|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|  11.0k|            }
_RINvNtCsbn2VTn2D7sd_15unsigned_varint2io8read_u64QQRShECsilvC8qPft2D_8fvm_fuzz:
   31|  11.0k|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|  11.0k|                let mut b = encode::$b();
   33|  16.6k|                for i in 0 .. b.len() {
   34|  16.6k|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|  16.6k|                    if n == 0 {
   36|      0|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|  16.6k|                    }
   38|  16.6k|                    if decode::is_last(b[i]) {
   39|  11.0k|                        return Ok(decode::$t(&b[..= i])?.0)
   40|  5.54k|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|  11.0k|            }

_RNvXse_NtCssOC9dAN6Xz_10wasmparser9validatorNtB5_12WasmFeaturesNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  208|    326|#[derive(Hash, Debug, Copy, Clone)]
_RNvXs1_NtCssOC9dAN6Xz_10wasmparser9validatorNtB5_12WasmFeaturesNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  267|    326|    fn default() -> WasmFeatures {
  268|    326|        WasmFeatures {
  269|    326|            // off-by-default features
  270|    326|            relaxed_simd: false,
  271|    326|            threads: false,
  272|    326|            tail_call: false,
  273|    326|            multi_memory: false,
  274|    326|            exceptions: false,
  275|    326|            memory64: false,
  276|    326|            extended_const: false,
  277|    326|            component_model: false,
  278|    326|            deterministic_only: cfg!(feature = "deterministic"),
  279|    326|
  280|    326|            // on-by-default features
  281|    326|            mutable_global: true,
  282|    326|            saturating_float_to_int: true,
  283|    326|            sign_extension: true,
  284|    326|            bulk_memory: true,
  285|    326|            multi_value: true,
  286|    326|            reference_types: true,
  287|    326|            simd: true,
  288|    326|        }
  289|    326|    }

_RNvXs7_NtCscE26HxwD491_8wasmtime6configNtB5_21ModuleVersionStrategyNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   63|    326|#[derive(Clone)]
_RNvXs4_NtCscE26HxwD491_8wasmtime6configNtB5_6ConfigNtNtCsdRJjCzU6nMS_4core7default7Default7default:
 1565|    326|    fn default() -> Config {
 1566|    326|        Config::new()
 1567|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config15memory_init_cow:
 1348|    326|    pub fn memory_init_cow(&mut self, enable: bool) -> &mut Self {
 1349|    326|        self.memory_init_cow = enable;
 1350|    326|        self
 1351|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config13wasm_memory64:
  765|    326|    pub fn wasm_memory64(&mut self, enable: bool) -> &mut Self {
  766|    326|        self.features.memory64 = enable;
  767|    326|        self
  768|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config18epoch_interruption:
  553|    326|    pub fn epoch_interruption(&mut self, enable: bool) -> &mut Self {
  554|    326|        self.tunables.epoch_interruption = enable;
  555|    326|        self
  556|    326|    }
_RNvXsa_NtCscE26HxwD491_8wasmtime6configNtB5_14CompilerConfigNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  117|    326|#[derive(Debug, Clone)]
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config20generate_address_map:
 1302|    326|    pub fn generate_address_map(&mut self, generate: bool) -> &mut Self {
 1303|    326|        self.tunables.generate_address_map = generate;
 1304|    326|        self
 1305|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config12consume_fuel:
  459|    326|    pub fn consume_fuel(&mut self, enable: bool) -> &mut Self {
  460|    326|        self.tunables.consume_fuel = enable;
  461|    326|        self
  462|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config26guard_before_linear_memory:
 1257|    326|    pub fn guard_before_linear_memory(&mut self, guard: bool) -> &mut Self {
 1258|    326|        self.tunables.guard_before_linear_memory = guard;
 1259|    326|        self
 1260|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config14wasm_backtrace:
  395|    326|    pub fn wasm_backtrace(&mut self, enable: bool) -> &mut Self {
  396|    326|        self.wasm_backtrace = enable;
  397|    326|        self
  398|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config24cranelift_debug_verifier:
  827|    652|    pub fn cranelift_debug_verifier(&mut self, enable: bool) -> &mut Self {
  828|    652|        let val = if enable { "true" } else { "false" };
  829|    652|        self.compiler_config
  830|    652|            .settings
  831|    652|            .insert("enable_verifier".to_string(), val.to_string());
  832|    652|        self
  833|    652|    }
_RNvXs8_NtCscE26HxwD491_8wasmtime6configNtB5_6ConfigNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   88|    326|#[derive(Clone)]
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config16wasm_bulk_memory:
  722|    652|    pub fn wasm_bulk_memory(&mut self, enable: bool) -> &mut Self {
  723|    652|        self.features.bulk_memory = enable;
  724|    652|        self
  725|    652|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config14build_profiler:
 1471|    326|    pub(crate) fn build_profiler(&self) -> Result<Box<dyn ProfilingAgent>> {
 1472|    326|        Ok(match self.profiling_strategy {
 1473|      0|            ProfilingStrategy::JitDump => Box::new(JitDumpAgent::new()?) as Box<dyn ProfilingAgent>,
 1474|      0|            ProfilingStrategy::VTune => Box::new(VTuneAgent::new()?) as Box<dyn ProfilingAgent>,
 1475|    326|            ProfilingStrategy::None => Box::new(NullProfilerAgent),
 1476|       |        })
 1477|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config20parallel_compilation:
 1288|    326|    pub fn parallel_compilation(&mut self, parallel: bool) -> &mut Self {
 1289|    326|        self.parallel_compilation = parallel;
 1290|    326|        self
 1291|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config22wasm_backtrace_details:
  411|    326|    pub fn wasm_backtrace_details(&mut self, enable: WasmBacktraceDetails) -> &mut Self {
  412|    326|        self.wasm_backtrace_details_env_used = false;
  413|    326|        self.tunables.parse_wasm_debuginfo = match enable {
  414|      0|            WasmBacktraceDetails::Enable => true,
  415|      0|            WasmBacktraceDetails::Disable => false,
  416|       |            WasmBacktraceDetails::Environment => {
  417|    326|                self.wasm_backtrace_details_env_used = true;
  418|    326|                std::env::var("WASMTIME_BACKTRACE_DETAILS")
  419|    326|                    .map(|s| s == "1")
  420|    326|                    .unwrap_or(false)
  421|       |            }
  422|       |        };
  423|    326|        self
  424|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config19cranelift_opt_level:
  844|    652|    pub fn cranelift_opt_level(&mut self, level: OptLevel) -> &mut Self {
  845|    652|        let val = match level {
  846|      0|            OptLevel::None => "none",
  847|    652|            OptLevel::Speed => "speed",
  848|      0|            OptLevel::SpeedAndSize => "speed_and_size",
  849|       |        };
  850|    652|        self.compiler_config
  851|    652|            .settings
  852|    652|            .insert("opt_level".to_string(), val.to_string());
  853|    652|        self
  854|    652|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config15build_allocator:
 1445|    326|    pub(crate) fn build_allocator(&self) -> Result<Box<dyn InstanceAllocator>> {
 1446|    326|        #[cfg(feature = "async")]
 1447|    326|        let stack_size = self.async_stack_size;
 1448|    326|
 1449|    326|        #[cfg(not(feature = "async"))]
 1450|    326|        let stack_size = 0;
 1451|    326|
 1452|    326|        match self.allocation_strategy {
 1453|      0|            InstanceAllocationStrategy::OnDemand => Ok(Box::new(OnDemandInstanceAllocator::new(
 1454|      0|                self.mem_creator.clone(),
 1455|      0|                stack_size,
 1456|      0|            ))),
 1457|       |            #[cfg(feature = "pooling-allocator")]
 1458|       |            InstanceAllocationStrategy::Pooling {
 1459|    326|                strategy,
 1460|    326|                instance_limits,
 1461|    326|            } => Ok(Box::new(wasmtime_runtime::PoolingInstanceAllocator::new(
 1462|    326|                strategy,
 1463|    326|                instance_limits,
 1464|    326|                stack_size,
 1465|    326|                &self.tunables,
 1466|    326|                self.async_stack_zeroing,
 1467|    326|            )?)),
 1468|       |        }
 1469|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config19allocation_strategy:
  994|    326|    pub fn allocation_strategy(&mut self, strategy: InstanceAllocationStrategy) -> &mut Self {
  995|    326|        self.allocation_strategy = strategy;
  996|    326|        self
  997|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config16wasm_multi_value:
  736|    652|    pub fn wasm_multi_value(&mut self, enable: bool) -> &mut Self {
  737|    652|        self.features.multi_value = enable;
  738|    652|        self
  739|    652|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config8validate:
 1422|    326|    pub(crate) fn validate(&self) -> Result<()> {
 1423|    326|        if self.features.reference_types && !self.features.bulk_memory {
 1424|      0|            bail!("feature 'reference_types' requires 'bulk_memory' to be enabled");
 1425|    326|        }
 1426|    326|        if self.features.threads && !self.features.bulk_memory {
 1427|      0|            bail!("feature 'threads' requires 'bulk_memory' to be enabled");
 1428|    326|        }
 1429|    326|        #[cfg(feature = "async")]
 1430|    326|        if self.max_wasm_stack > self.async_stack_size {
 1431|    326|            bail!("max_wasm_stack size cannot exceed the async_stack_size");
 1432|    326|        }
 1433|    326|        if self.max_wasm_stack == 0 {
 1434|      0|            bail!("max_wasm_stack size cannot be zero");
 1435|    326|        }
 1436|    326|        if self.tunables.static_memory_offset_guard_size
 1437|    326|            < self.tunables.dynamic_memory_offset_guard_size
 1438|       |        {
 1439|      0|            bail!("static memory guard size cannot be smaller than dynamic memory guard size");
 1440|    326|        }
 1441|    326|
 1442|    326|        Ok(())
 1443|    326|    }
_RNvMs1_NtCscE26HxwD491_8wasmtime6configNtB5_14CompilerConfig3new:
  129|    326|    fn new(strategy: Strategy) -> Self {
  130|    326|        Self {
  131|    326|            strategy,
  132|    326|            target: None,
  133|    326|            settings: HashMap::new(),
  134|    326|            flags: HashSet::new(),
  135|    326|            cache_store: None,
  136|    326|        }
  137|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config9wasm_simd:
  699|    652|    pub fn wasm_simd(&mut self, enable: bool) -> &mut Self {
  700|    652|        self.features.simd = enable;
  701|    652|        self
  702|    652|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config14max_wasm_stack:
  604|    326|    pub fn max_wasm_stack(&mut self, size: usize) -> &mut Self {
  605|    326|        self.max_wasm_stack = size;
  606|    326|        self
  607|    326|    }
_RNvXs2_NtCscE26HxwD491_8wasmtime6configNtB5_14CompilerConfigNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  161|    326|    fn default() -> Self {
  162|    326|        Self::new(Strategy::Auto)
  163|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config10debug_info:
  379|    326|    pub fn debug_info(&mut self, enable: bool) -> &mut Self {
  380|    326|        self.tunables.generate_native_debuginfo = enable;
  381|    326|        self
  382|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config26static_memory_maximum_size:
 1087|    326|    pub fn static_memory_maximum_size(&mut self, max_size: u64) -> &mut Self {
 1088|    326|        let max_pages = max_size / u64::from(wasmtime_environ::WASM_PAGE_SIZE);
 1089|    326|        self.tunables.static_memory_bound = max_pages;
 1090|    326|        self
 1091|    326|    }
_RNvXsl_NtCscE26HxwD491_8wasmtime6configNtB5_17ProfilingStrategyNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
 1643|    326|#[derive(Debug, Clone, Copy)]
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config12wasm_threads:
  657|    326|    pub fn wasm_threads(&mut self, enable: bool) -> &mut Self {
  658|    326|        self.features.threads = enable;
  659|    326|        self
  660|    326|    }
_RNvXs6_NtCscE26HxwD491_8wasmtime6configNtB5_26InstanceAllocationStrategyNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   23|    326|#[derive(Clone)]
_RNvXs0_NtCscE26HxwD491_8wasmtime6configNtB5_21ModuleVersionStrategyNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   75|    326|    fn default() -> Self {
   76|    326|        ModuleVersionStrategy::WasmtimeVersion
   77|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config17wasm_multi_memory:
  750|    326|    pub fn wasm_multi_memory(&mut self, enable: bool) -> &mut Self {
  751|    326|        self.features.multi_memory = enable;
  752|    326|        self
  753|    326|    }
_RNvXsb_NtCscE26HxwD491_8wasmtime6configNtB5_8StrategyNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
 1610|    326|#[derive(Clone, Debug, Copy)]
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config14build_compiler:
 1480|    326|    pub(crate) fn build_compiler(&mut self) -> Result<Box<dyn wasmtime_environ::Compiler>> {
 1481|    326|        let mut compiler = match self.compiler_config.strategy {
 1482|    326|            Strategy::Auto | Strategy::Cranelift => wasmtime_cranelift::builder(),
 1483|       |        };
 1484|    326|        if let Some(target) = &self.compiler_config.target {
 1485|      0|            compiler.target(target.clone())?;
 1486|    326|        }
 1487|       |
 1488|    326|        if self.native_unwind_info ||
 1489|       |            // Windows always needs unwind info, since it is part of the ABI.
 1490|    326|            self
 1491|    326|                .compiler_config
 1492|    326|                .target
 1493|    326|                .as_ref()
 1494|    326|                .map_or(cfg!(target_os = "windows"), |target| {
 1495|       |                    target.operating_system == target_lexicon::OperatingSystem::Windows
 1496|    326|                })
 1497|       |        {
 1498|      0|            if !self
 1499|      0|                .compiler_config
 1500|      0|                .ensure_setting_unset_or_given("unwind_info", "true")
 1501|       |            {
 1502|      0|                bail!("compiler option 'unwind_info' must be enabled profiling");
 1503|      0|            }
 1504|    326|        }
 1505|       |
 1506|       |        // We require frame pointers for correct stack walking, which is safety
 1507|       |        // critical in the presence of reference types, and otherwise it is just
 1508|       |        // really bad developer experience to get wrong.
 1509|    326|        self.compiler_config
 1510|    326|            .settings
 1511|    326|            .insert("preserve_frame_pointers".into(), "true".into());
 1512|    326|
 1513|    326|        // check for incompatible compiler options and set required values
 1514|    326|        if self.features.reference_types {
 1515|      0|            if !self
 1516|      0|                .compiler_config
 1517|      0|                .ensure_setting_unset_or_given("enable_safepoints", "true")
 1518|       |            {
 1519|      0|                bail!("compiler option 'enable_safepoints' must be enabled when 'reference types' is enabled");
 1520|      0|            }
 1521|    326|        }
 1522|    326|        if self.features.simd {
 1523|      0|            if !self
 1524|      0|                .compiler_config
 1525|      0|                .ensure_setting_unset_or_given("enable_simd", "true")
 1526|       |            {
 1527|      0|                bail!("compiler option 'enable_simd' must be enabled when 'simd' is enabled");
 1528|      0|            }
 1529|    326|        }
 1530|       |
 1531|       |        // Apply compiler settings and flags
 1532|  1.30k|        for (k, v) in self.compiler_config.settings.iter() {
 1533|  1.30k|            compiler.set(k, v)?;
 1534|       |        }
 1535|    326|        for flag in self.compiler_config.flags.iter() {
 1536|      0|            compiler.enable(flag)?;
 1537|       |        }
 1538|       |
 1539|    326|        if let Some(cache_store) = &self.compiler_config.cache_store {
 1540|      0|            compiler.enable_incremental_compilation(cache_store.clone());
 1541|    326|        }
 1542|       |
 1543|    326|        compiler.build()
 1544|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config20wasm_reference_types:
  678|    652|    pub fn wasm_reference_types(&mut self, enable: bool) -> &mut Self {
  679|    652|        self.features.reference_types = enable;
  680|    652|        self
  681|    652|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config18native_unwind_info:
  439|    326|    pub fn native_unwind_info(&mut self, enable: bool) -> &mut Self {
  440|    326|        self.native_unwind_info = enable;
  441|    326|        self
  442|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config3new:
  169|    326|    pub fn new() -> Self {
  170|    326|        let mut ret = Self {
  171|    326|            tunables: Tunables::default(),
  172|    326|            #[cfg(compiler)]
  173|    326|            compiler_config: CompilerConfig::default(),
  174|    326|            #[cfg(feature = "cache")]
  175|    326|            cache_config: CacheConfig::new_cache_disabled(),
  176|    326|            profiling_strategy: ProfilingStrategy::None,
  177|    326|            mem_creator: None,
  178|    326|            allocation_strategy: InstanceAllocationStrategy::OnDemand,
  179|    326|            // 512k of stack -- note that this is chosen currently to not be too
  180|    326|            // big, not be too small, and be a good default for most platforms.
  181|    326|            // One platform of particular note is Windows where the stack size
  182|    326|            // of the main thread seems to, by default, be smaller than that of
  183|    326|            // Linux and macOS. This 512k value at least lets our current test
  184|    326|            // suite pass on the main thread of Windows (using `--test-threads
  185|    326|            // 1` forces this), or at least it passed when this change was
  186|    326|            // committed.
  187|    326|            max_wasm_stack: 512 * 1024,
  188|    326|            wasm_backtrace: true,
  189|    326|            wasm_backtrace_details_env_used: false,
  190|    326|            native_unwind_info: true,
  191|    326|            features: WasmFeatures::default(),
  192|    326|            #[cfg(feature = "async")]
  193|    326|            async_stack_size: 2 << 20,
  194|    326|            async_support: false,
  195|    326|            module_version: ModuleVersionStrategy::default(),
  196|    326|            parallel_compilation: true,
  197|    326|            memory_init_cow: true,
  198|    326|            memory_guaranteed_dense_image_size: 16 << 20,
  199|    326|            force_memory_init_memfd: false,
  200|    326|            async_stack_zeroing: false,
  201|    326|        };
  202|    326|        #[cfg(compiler)]
  203|    326|        {
  204|    326|            ret.cranelift_debug_verifier(false);
  205|    326|            ret.cranelift_opt_level(OptLevel::Speed);
  206|    326|        }
  207|    326|        ret.wasm_reference_types(true);
  208|    326|        ret.wasm_multi_value(true);
  209|    326|        ret.wasm_bulk_memory(true);
  210|    326|        ret.wasm_simd(true);
  211|    326|        ret.wasm_backtrace_details(WasmBacktraceDetails::Environment);
  212|    326|        ret
  213|    326|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6configNtB5_6Config30cranelift_nan_canonicalization:
  866|    326|    pub fn cranelift_nan_canonicalization(&mut self, enable: bool) -> &mut Self {
  867|    326|        let val = if enable { "true" } else { "false" };
  868|    326|        self.compiler_config
  869|    326|            .settings
  870|    326|            .insert("enable_nan_canonicalization".to_string(), val.to_string());
  871|    326|        self
  872|    326|    }

_RNvMNtCscE26HxwD491_8wasmtime6engineNtB2_6Engine6config:
  126|    652|    pub fn config(&self) -> &Config {
  127|    652|        &self.inner.config
  128|    652|    }
_RNvXs0_NtCscE26HxwD491_8wasmtime6engineNtB5_6EngineNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   37|    326|#[derive(Clone)]
_RNvMNtCscE26HxwD491_8wasmtime6engineNtB2_6Engine3new:
   70|    326|    pub fn new(config: &Config) -> Result<Engine> {
   71|    326|        // Ensure that wasmtime_runtime's signal handlers are configured. This
   72|    326|        // is the per-program initialization required for handling traps, such
   73|    326|        // as configuring signals, vectored exception handlers, etc.
   74|    326|        wasmtime_runtime::init_traps(crate::module::is_wasm_trap_pc);
   75|    326|        debug_builtins::ensure_exported();
   76|    326|
   77|    326|        let registry = SignatureRegistry::new();
   78|    326|        let mut config = config.clone();
   79|    326|        config.validate()?;
   80|       |
   81|       |        #[cfg(compiler)]
   82|    326|        let compiler = config.build_compiler()?;
   83|       |
   84|    326|        let allocator = config.build_allocator()?;
   85|    326|        allocator.adjust_tunables(&mut config.tunables);
   86|    326|        let profiler = config.build_profiler()?;
   87|       |
   88|    326|        Ok(Engine {
   89|    326|            inner: Arc::new(EngineInner {
   90|    326|                #[cfg(compiler)]
   91|    326|                compiler,
   92|    326|                config,
   93|    326|                allocator,
   94|    326|                profiler,
   95|    326|                signatures: registry,
   96|    326|                epoch: AtomicU64::new(0),
   97|    326|                unique_id_allocator: CompiledModuleIdAllocator::new(),
   98|    326|                compatible_with_native_host: OnceCell::new(),
   99|    326|            }),
  100|    326|        })
  101|    326|    }
_RNvMNtCscE26HxwD491_8wasmtime6engineNtB2_6Engine13epoch_counter:
  157|    978|    pub(crate) fn epoch_counter(&self) -> &AtomicU64 {
  158|    978|        &self.inner.epoch
  159|    978|    }
_RNvMNtCscE26HxwD491_8wasmtime6engineNtB2_6Engine9allocator:
  135|    326|    pub(crate) fn allocator(&self) -> &dyn InstanceAllocator {
  136|    326|        self.inner.allocator.as_ref()
  137|    326|    }

_RINvMs4_NtCscE26HxwD491_8wasmtime9externalsNtB6_6Global3newQINtNtB8_5store5StoreuEECsheoVkkQew6K_3fvm:
  244|    326|    pub fn new(mut store: impl AsContextMut, ty: GlobalType, val: Val) -> Result<Global> {
  245|    326|        Global::_new(store.as_context_mut().0, ty, val)
  246|    326|    }
_RNvMs4_NtCscE26HxwD491_8wasmtime9externalsNtB5_6Global4__new:
  248|    326|    fn _new(store: &mut StoreOpaque, ty: GlobalType, val: Val) -> Result<Global> {
  249|    326|        if !val.comes_from_same_store(store) {
  250|      0|            bail!("cross-`Store` globals are not supported");
  251|    326|        }
  252|    326|        if val.ty() != *ty.content() {
  253|      0|            bail!("value provided does not match the type of this global");
  254|    326|        }
  255|       |        unsafe {
  256|    326|            let wasmtime_export = generate_global_export(store, &ty, val)?;
  257|    326|            Ok(Global::from_wasmtime_global(wasmtime_export, store))
  258|       |        }
  259|    326|    }
_RNvMs4_NtCscE26HxwD491_8wasmtime9externalsNtB5_6Global20from_wasmtime_global:
  346|    326|    pub(crate) unsafe fn from_wasmtime_global(
  347|    326|        wasmtime_export: wasmtime_runtime::ExportGlobal,
  348|    326|        store: &mut StoreOpaque,
  349|    326|    ) -> Global {
  350|    326|        Global(store.store_data_mut().insert(wasmtime_export))
  351|    326|    }

_RINvMs0_NtCscE26HxwD491_8wasmtime6memoryNtB6_6Memory3newQINtNtB8_5store5StoreuEECsheoVkkQew6K_3fvm:
  231|    326|    pub fn new(mut store: impl AsContextMut, ty: MemoryType) -> Result<Memory> {
  232|    326|        Self::_new(store.as_context_mut().0, ty)
  233|    326|    }
_RNvMs0_NtCscE26HxwD491_8wasmtime6memoryNtB5_6Memory4__new:
  261|    326|    fn _new(store: &mut StoreOpaque, ty: MemoryType) -> Result<Memory> {
  262|       |        unsafe {
  263|    326|            let export = generate_memory_export(store, &ty, None)?;
  264|    326|            Ok(Memory::from_wasmtime_memory(export, store))
  265|       |        }
  266|    326|    }
_RNvMs0_NtCscE26HxwD491_8wasmtime6memoryNtB5_6Memory20from_wasmtime_memory:
  550|    326|    pub(crate) unsafe fn from_wasmtime_memory(
  551|    326|        wasmtime_export: wasmtime_runtime::ExportMemory,
  552|    326|        store: &mut StoreOpaque,
  553|    326|    ) -> Memory {
  554|    326|        Memory(store.store_data_mut().insert(wasmtime_export))
  555|    326|    }

_RNvMs3_NtCscE26HxwD491_8wasmtime6moduleNtB5_14BareModuleInfo13into_traitobj:
 1029|    978|    pub(crate) fn into_traitobj(self) -> Arc<dyn wasmtime_runtime::ModuleRuntimeInfo> {
 1030|    978|        Arc::new(self)
 1031|    978|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6moduleNtB5_14BareModuleInfo19maybe_imported_func:
 1017|    652|    pub(crate) fn maybe_imported_func(
 1018|    652|        module: Arc<wasmtime_environ::Module>,
 1019|    652|        one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,
 1020|    652|    ) -> Self {
 1021|    652|        BareModuleInfo {
 1022|    652|            module,
 1023|    652|            image_base: 0,
 1024|    652|            one_signature,
 1025|    652|            function_info: PrimaryMap::default(),
 1026|    652|        }
 1027|    652|    }
_RNvXs4_NtCscE26HxwD491_8wasmtime6moduleNtB5_14BareModuleInfoNtCsfBAxPD3lkOv_16wasmtime_runtime17ModuleRuntimeInfo13signature_ids:
 1067|    978|    fn signature_ids(&self) -> &[VMSharedSignatureIndex] {
 1068|    978|        match &self.one_signature {
 1069|      0|            Some((_, id)) => std::slice::from_ref(id),
 1070|    978|            None => &[],
 1071|       |        }
 1072|    978|    }
_RNvMs3_NtCscE26HxwD491_8wasmtime6moduleNtB5_14BareModuleInfo5empty:
 1008|    326|    pub(crate) fn empty(module: Arc<wasmtime_environ::Module>) -> Self {
 1009|    326|        BareModuleInfo {
 1010|    326|            module,
 1011|    326|            image_base: 0,
 1012|    326|            one_signature: None,
 1013|    326|            function_info: PrimaryMap::default(),
 1014|    326|        }
 1015|    326|    }
_RNvXs4_NtCscE26HxwD491_8wasmtime6moduleNtB5_14BareModuleInfoNtCsfBAxPD3lkOv_16wasmtime_runtime17ModuleRuntimeInfo6module:
 1035|  6.84k|    fn module(&self) -> &Arc<wasmtime_environ::Module> {
 1036|  6.84k|        &self.module
 1037|  6.84k|    }

_RNvXs_NtNtCscE26HxwD491_8wasmtime6module8registryNtB4_14ModuleRegistryNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   28|    326|#[derive(Default)]

_RNvXs6_NtCscE26HxwD491_8wasmtime10signaturesNtB5_22SignatureRegistryInnerNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   80|    326|#[derive(Debug, Default)]
_RNvXs1_NtCscE26HxwD491_8wasmtime10signaturesNtB5_22SignatureRegistryInnerNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
  198|    326|    fn drop(&mut self) {
  199|    326|        assert!(
  200|    326|            self.map.is_empty() && self.free.len() == self.entries.len(),
  201|      0|            "signature registry not empty"
  202|       |        );
  203|    326|    }
_RNvMs2_NtCscE26HxwD491_8wasmtime10signaturesNtB5_17SignatureRegistry3new:
  217|    326|    pub fn new() -> Self {
  218|    326|        Self(Arc::new(RwLock::new(SignatureRegistryInner::default())))
  219|    326|    }

_RNvMs9_NtCscE26HxwD491_8wasmtime5storeNtB5_11StoreOpaque14store_data_mut:
 1167|    652|    pub fn store_data_mut(&mut self) -> &mut StoreData {
 1168|    652|        &mut self.store_data
 1169|    652|    }
_RNvMs9_NtCscE26HxwD491_8wasmtime5storeNtB5_11StoreOpaque16vmruntime_limits:
 1452|    978|    pub fn vmruntime_limits(&self) -> *mut VMRuntimeLimits {
 1453|    978|        &self.runtime_limits as *const VMRuntimeLimits as *mut VMRuntimeLimits
 1454|    978|    }
_RNvMs9_NtCscE26HxwD491_8wasmtime5storeNtB5_11StoreOpaque6engine:
 1157|    652|    pub fn engine(&self) -> &Engine {
 1158|    652|        &self.engine
 1159|    652|    }
_RNvXsb_NtCscE26HxwD491_8wasmtime5storeINtB5_10StoreInneruENtCsfBAxPD3lkOv_16wasmtime_runtime5Store27externref_activations_tableCsheoVkkQew6K_3fvm:
 1801|    978|    fn externref_activations_table(
 1802|    978|        &mut self,
 1803|    978|    ) -> (
 1804|    978|        &mut VMExternRefActivationsTable,
 1805|    978|        &dyn wasmtime_runtime::ModuleInfoLookup,
 1806|    978|    ) {
 1807|    978|        let inner = &mut self.inner;
 1808|    978|        (&mut inner.externref_activations_table, &inner.modules)
 1809|    978|    }
_RNvXsf_NtCscE26HxwD491_8wasmtime5storeINtB5_5StoreuENtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4dropCsheoVkkQew6K_3fvm:
 2026|    326|    fn drop(&mut self) {
 2027|    326|        // for documentation on this `unsafe`, see `into_data`.
 2028|    326|        unsafe {
 2029|    326|            ManuallyDrop::drop(&mut self.inner.data);
 2030|    326|            ManuallyDrop::drop(&mut self.inner);
 2031|    326|        }
 2032|    326|    }
_RNvXsb_NtCscE26HxwD491_8wasmtime5storeINtB5_10StoreInneruENtCsfBAxPD3lkOv_16wasmtime_runtime5Store14memory_growingCsheoVkkQew6K_3fvm:
 1811|    326|    fn memory_growing(
 1812|    326|        &mut self,
 1813|    326|        current: usize,
 1814|    326|        desired: usize,
 1815|    326|        maximum: Option<usize>,
 1816|    326|    ) -> Result<bool, anyhow::Error> {
 1817|    326|        match self.limiter {
 1818|      0|            Some(ResourceLimiterInner::Sync(ref mut limiter)) => {
 1819|      0|                Ok(limiter(&mut self.data).memory_growing(current, desired, maximum))
 1820|       |            }
 1821|       |            #[cfg(feature = "async")]
 1822|       |            Some(ResourceLimiterInner::Async(ref mut limiter)) => unsafe {
 1823|       |                Ok(self
 1824|       |                    .inner
 1825|       |                    .async_cx()
 1826|       |                    .expect("ResourceLimiterAsync requires async Store")
 1827|       |                    .block_on(
 1828|       |                        limiter(&mut self.data)
 1829|       |                            .memory_growing(current, desired, maximum)
 1830|       |                            .as_mut(),
 1831|       |                    )?)
 1832|       |            },
 1833|    326|            None => Ok(true),
 1834|       |        }
 1835|    326|    }
_RNvMs5_NtCscE26HxwD491_8wasmtime5storeINtB5_5StoreuE3newCsheoVkkQew6K_3fvm:
  450|    326|    pub fn new(engine: &Engine, data: T) -> Self {
  451|    326|        // Wasmtime uses the callee argument to host functions to learn about
  452|    326|        // the original pointer to the `Store` itself, allowing it to
  453|    326|        // reconstruct a `StoreContextMut<T>`. When we initially call a `Func`,
  454|    326|        // however, there's no "callee" to provide. To fix this we allocate a
  455|    326|        // single "default callee" for the entire `Store`. This is then used as
  456|    326|        // part of `Func::call` to guarantee that the `callee: *mut VMContext`
  457|    326|        // is never null.
  458|    326|        let default_callee = unsafe {
  459|    326|            let module = Arc::new(wasmtime_environ::Module::default());
  460|    326|            let shim = BareModuleInfo::empty(module).into_traitobj();
  461|    326|            OnDemandInstanceAllocator::default()
  462|    326|                .allocate(InstanceAllocationRequest {
  463|    326|                    host_state: Box::new(()),
  464|    326|                    imports: Default::default(),
  465|    326|                    store: StorePtr::empty(),
  466|    326|                    runtime_info: &shim,
  467|    326|                })
  468|    326|                .expect("failed to allocate default callee")
  469|    326|        };
  470|    326|
  471|    326|        let mut inner = Box::new(StoreInner {
  472|    326|            inner: StoreOpaque {
  473|    326|                _marker: marker::PhantomPinned,
  474|    326|                engine: engine.clone(),
  475|    326|                runtime_limits: Default::default(),
  476|    326|                instances: Vec::new(),
  477|    326|                signal_handler: None,
  478|    326|                externref_activations_table: VMExternRefActivationsTable::new(),
  479|    326|                modules: ModuleRegistry::default(),
  480|    326|                host_trampolines: HashMap::default(),
  481|    326|                host_func_trampolines_registered: 0,
  482|    326|                instance_count: 0,
  483|    326|                instance_limit: crate::DEFAULT_INSTANCE_LIMIT,
  484|    326|                memory_count: 0,
  485|    326|                memory_limit: crate::DEFAULT_MEMORY_LIMIT,
  486|    326|                table_count: 0,
  487|    326|                table_limit: crate::DEFAULT_TABLE_LIMIT,
  488|    326|                fuel_adj: 0,
  489|    326|                #[cfg(feature = "async")]
  490|    326|                async_state: AsyncState {
  491|    326|                    current_suspend: UnsafeCell::new(ptr::null()),
  492|    326|                    current_poll_cx: UnsafeCell::new(ptr::null_mut()),
  493|    326|                },
  494|    326|                out_of_gas_behavior: OutOfGas::Trap,
  495|    326|                store_data: ManuallyDrop::new(StoreData::new()),
  496|    326|                default_caller: default_callee,
  497|    326|                hostcall_val_storage: Vec::new(),
  498|    326|                wasm_val_raw_storage: Vec::new(),
  499|    326|                rooted_host_funcs: ManuallyDrop::new(Vec::new()),
  500|    326|            },
  501|    326|            limiter: None,
  502|    326|            call_hook: None,
  503|    326|            epoch_deadline_behavior: EpochDeadline::Trap,
  504|    326|            data: ManuallyDrop::new(data),
  505|    326|        });
  506|    326|
  507|    326|        // Once we've actually allocated the store itself we can configure the
  508|    326|        // trait object pointer of the default callee. Note the erasure of the
  509|    326|        // lifetime here into `'static`, so in general usage of this trait
  510|    326|        // object must be strictly bounded to the `Store` itself, and is a
  511|    326|        // variant that we have to maintain throughout Wasmtime.
  512|    326|        unsafe {
  513|    326|            let traitobj = std::mem::transmute::<
  514|    326|                *mut (dyn wasmtime_runtime::Store + '_),
  515|    326|                *mut (dyn wasmtime_runtime::Store + 'static),
  516|    326|            >(&mut *inner);
  517|    326|            inner.default_caller.set_store(traitobj);
  518|    326|        }
  519|    326|
  520|    326|        Self {
  521|    326|            inner: ManuallyDrop::new(inner),
  522|    326|        }
  523|    326|    }
_RNvXs_NtCscE26HxwD491_8wasmtime5storeINtB4_10StoreInneruENtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5derefCsheoVkkQew6K_3fvm:
  234|  1.95k|    fn deref(&self) -> &Self::Target {
  235|  1.95k|        &self.inner
  236|  1.95k|    }
_RNvXsb_NtCscE26HxwD491_8wasmtime5storeINtB5_10StoreInneruENtCsfBAxPD3lkOv_16wasmtime_runtime5Store9epoch_ptrCsheoVkkQew6K_3fvm:
 1797|    978|    fn epoch_ptr(&self) -> *const AtomicU64 {
 1798|    978|        self.engine.epoch_counter() as *const _
 1799|    978|    }
_RNvXs0_NtCscE26HxwD491_8wasmtime5storeINtB5_10StoreInneruENtNtNtCsdRJjCzU6nMS_4core3ops5deref8DerefMut9deref_mutCsheoVkkQew6K_3fvm:
  240|    978|    fn deref_mut(&mut self) -> &mut Self::Target {
  241|    978|        &mut self.inner
  242|    978|    }
_RNvXsb_NtCscE26HxwD491_8wasmtime5storeINtB5_10StoreInneruENtCsfBAxPD3lkOv_16wasmtime_runtime5Store16vmruntime_limitsCsheoVkkQew6K_3fvm:
 1793|    978|    fn vmruntime_limits(&self) -> *mut VMRuntimeLimits {
 1794|    978|        <StoreOpaque>::vmruntime_limits(self)
 1795|    978|    }
_RNvMs9_NtCscE26HxwD491_8wasmtime5storeNtB5_11StoreOpaque12add_instance:
 1181|    652|    pub unsafe fn add_instance(&mut self, handle: InstanceHandle, ondemand: bool) -> InstanceId {
 1182|    652|        self.instances.push(StoreInstance {
 1183|    652|            handle: handle.clone(),
 1184|    652|            ondemand,
 1185|    652|        });
 1186|    652|        InstanceId(self.instances.len() - 1)
 1187|    652|    }
_RNvMs9_NtCscE26HxwD491_8wasmtime5storeNtB5_11StoreOpaque8traitobj:
 1465|    978|    pub fn traitobj(&self) -> *mut dyn wasmtime_runtime::Store {
 1466|    978|        self.default_caller.store()
 1467|    978|    }
_RNvMs9_NtCscE26HxwD491_8wasmtime5storeNtB5_11StoreOpaque12instance_mut:
 1193|    652|    pub fn instance_mut(&mut self, id: InstanceId) -> &mut InstanceHandle {
 1194|    652|        &mut self.instances[id.0].handle
 1195|    652|    }
_RNvXsg_NtCscE26HxwD491_8wasmtime5storeNtB5_11StoreOpaqueNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
 2036|    326|    fn drop(&mut self) {
 2037|    326|        // NB it's important that this destructor does not access `self.data`.
 2038|    326|        // That is deallocated by `Drop for Store<T>` above.
 2039|    326|
 2040|    326|        unsafe {
 2041|    326|            let allocator = self.engine.allocator();
 2042|    326|            let ondemand = OnDemandInstanceAllocator::default();
 2043|    652|            for instance in self.instances.iter() {
 2044|    652|                if instance.ondemand {
 2045|    652|                    ondemand.deallocate(&instance.handle);
 2046|    652|                } else {
 2047|      0|                    allocator.deallocate(&instance.handle);
 2048|      0|                }
 2049|       |            }
 2050|    326|            ondemand.deallocate(&self.default_caller);
 2051|    326|
 2052|    326|            // See documentation for these fields on `StoreOpaque` for why they
 2053|    326|            // must be dropped in this order.
 2054|    326|            ManuallyDrop::drop(&mut self.store_data);
 2055|    326|            ManuallyDrop::drop(&mut self.rooted_host_funcs);
 2056|    326|        }
 2057|    326|    }

_RNvXs0_NtNtCscE26HxwD491_8wasmtime5store7contextINtB7_5StoreuENtB5_12AsContextMut14as_context_mutCsheoVkkQew6K_3fvm:
  134|    652|    fn as_context_mut(&mut self) -> StoreContextMut<'_, T> {
  135|    652|        StoreContextMut(&mut self.inner)
  136|    652|    }
_RNvXs9_NtNtCscE26HxwD491_8wasmtime5store7contextQINtB7_5StoreuENtB5_12AsContextMut14as_context_mutCsheoVkkQew6K_3fvm:
  214|    652|    fn as_context_mut(&mut self) -> StoreContextMut<'_, T::Data> {
  215|    652|        T::as_context_mut(*self)
  216|    652|    }

_RNvXsf_NtNtCscE26HxwD491_8wasmtime5store4dataNtNtCsfBAxPD3lkOv_16wasmtime_runtime6export12ExportGlobalNtB5_10StoredData8list_mut:
   38|    326|            fn list_mut(data: &mut StoreData) -> &mut Vec<Self> { &mut data.$field }
_RNvXsh_NtNtCscE26HxwD491_8wasmtime5store4dataNtNtCsfBAxPD3lkOv_16wasmtime_runtime6export12ExportMemoryNtB5_10StoredData8list_mut:
   38|    326|            fn list_mut(data: &mut StoreData) -> &mut Vec<Self> { &mut data.$field }
_RINvMNtNtCscE26HxwD491_8wasmtime5store4dataNtB3_9StoreData6insertNtNtCsfBAxPD3lkOv_16wasmtime_runtime6export12ExportGlobalEB7_:
   69|    326|    pub fn insert<T>(&mut self, data: T) -> Stored<T>
   70|    326|    where
   71|    326|        T: StoredData,
   72|    326|    {
   73|    326|        let list = T::list_mut(self);
   74|    326|        let index = list.len();
   75|    326|        list.push(data);
   76|    326|        Stored::new(self.id, index)
   77|    326|    }
_RNvMs6_NtNtCscE26HxwD491_8wasmtime5store4dataINtB5_6StoredNtNtCsfBAxPD3lkOv_16wasmtime_runtime6export12ExportGlobalE3newB9_:
  238|    326|    fn new(store_id: StoreId, index: usize) -> Stored<T> {
  239|    326|        Stored {
  240|    326|            store_id,
  241|    326|            index,
  242|    326|            _marker: marker::PhantomData,
  243|    326|        }
  244|    326|    }
_RINvMNtNtCscE26HxwD491_8wasmtime5store4dataNtB3_9StoreData6insertNtNtCsfBAxPD3lkOv_16wasmtime_runtime6export12ExportMemoryEB7_:
   69|    326|    pub fn insert<T>(&mut self, data: T) -> Stored<T>
   70|    326|    where
   71|    326|        T: StoredData,
   72|    326|    {
   73|    326|        let list = T::list_mut(self);
   74|    326|        let index = list.len();
   75|    326|        list.push(data);
   76|    326|        Stored::new(self.id, index)
   77|    326|    }
_RNvMs6_NtNtCscE26HxwD491_8wasmtime5store4dataINtB5_6StoredNtNtCsfBAxPD3lkOv_16wasmtime_runtime6export12ExportMemoryE3newB9_:
  238|    326|    fn new(store_id: StoreId, index: usize) -> Stored<T> {
  239|    326|        Stored {
  240|    326|            store_id,
  241|    326|            index,
  242|    326|            _marker: marker::PhantomData,
  243|    326|        }
  244|    326|    }
_RNvMs5_NtNtCscE26HxwD491_8wasmtime5store4dataNtB5_7StoreId8allocate:
  200|    326|    fn allocate() -> StoreId {
  201|    326|        static NEXT_ID: AtomicU64 = AtomicU64::new(0);
  202|    326|
  203|    326|        // Only allow 2^63 stores at which point we start panicking to prevent
  204|    326|        // overflow.
  205|    326|        //
  206|    326|        // If a store is created once per microsecond then this will last the
  207|    326|        // current process for 584,540 years before overflowing.
  208|    326|        //
  209|    326|        // Also note the usage of `Relaxed` ordering here which should be ok
  210|    326|        // since we're only looking for atomicity on this counter and this
  211|    326|        // otherwise isn't used to synchronize memory stored anywhere else.
  212|    326|        let id = NEXT_ID.fetch_add(1, Relaxed);
  213|    326|        if id & (1 << 63) != 0 {
  214|      0|            NEXT_ID.store(1 << 63, Relaxed);
  215|      0|            panic!("store id allocator overflow");
  216|    326|        }
  217|    326|
  218|    326|        StoreId(NonZeroU64::new(id + 1).unwrap())
  219|    326|    }
_RNvMNtNtCscE26HxwD491_8wasmtime5store4dataNtB2_9StoreData3new:
   52|    326|    pub fn new() -> StoreData {
   53|    326|        StoreData {
   54|    326|            id: StoreId::allocate(),
   55|    326|            funcs: Vec::new(),
   56|    326|            tables: Vec::new(),
   57|    326|            globals: Vec::new(),
   58|    326|            instances: Vec::new(),
   59|    326|            memories: Vec::new(),
   60|    326|            #[cfg(feature = "component-model")]
   61|    326|            components: Default::default(),
   62|    326|        }
   63|    326|    }

_RNvNtCscE26HxwD491_8wasmtime10trampoline22generate_global_export:
   57|    326|pub fn generate_global_export(
   58|    326|    store: &mut StoreOpaque,
   59|    326|    gt: &GlobalType,
   60|    326|    val: Val,
   61|    326|) -> Result<wasmtime_runtime::ExportGlobal> {
   62|    326|    let instance = create_global(store, gt, val)?;
   63|    326|    Ok(store
   64|    326|        .instance_mut(instance)
   65|    326|        .get_exported_global(GlobalIndex::from_u32(0)))
   66|    326|}
_RNvNtCscE26HxwD491_8wasmtime10trampoline13create_handle:
   26|    326|fn create_handle(
   27|    326|    module: Module,
   28|    326|    store: &mut StoreOpaque,
   29|    326|    host_state: Box<dyn Any + Send + Sync>,
   30|    326|    func_imports: &[VMFunctionImport],
   31|    326|    one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,
   32|    326|) -> Result<InstanceId> {
   33|    326|    let mut imports = Imports::default();
   34|    326|    imports.functions = func_imports;
   35|    326|
   36|    326|    unsafe {
   37|    326|        let config = store.engine().config();
   38|    326|        // Use the on-demand allocator when creating handles associated with host objects
   39|    326|        // The configured instance allocator should only be used when creating module instances
   40|    326|        // as we don't want host objects to count towards instance limits.
   41|    326|        let module = Arc::new(module);
   42|    326|        let runtime_info =
   43|    326|            &BareModuleInfo::maybe_imported_func(module, one_signature).into_traitobj();
   44|    326|        let handle = OnDemandInstanceAllocator::new(config.mem_creator.clone(), 0).allocate(
   45|    326|            InstanceAllocationRequest {
   46|    326|                imports,
   47|    326|                host_state,
   48|    326|                store: StorePtr::new(store.traitobj()),
   49|    326|                runtime_info,
   50|    326|            },
   51|    326|        )?;
   52|       |
   53|    326|        Ok(store.add_instance(handle, true))
   54|       |    }
   55|    326|}
_RNvNtCscE26HxwD491_8wasmtime10trampoline22generate_memory_export:
   68|    326|pub fn generate_memory_export(
   69|    326|    store: &mut StoreOpaque,
   70|    326|    m: &MemoryType,
   71|    326|    preallocation: Option<SharedMemory>,
   72|    326|) -> Result<wasmtime_runtime::ExportMemory> {
   73|    326|    let instance = create_memory(store, m, preallocation)?;
   74|    326|    Ok(store
   75|    326|        .instance_mut(instance)
   76|    326|        .get_exported_memory(MemoryIndex::from_u32(0)))
   77|    326|}

_RNvNtNtCscE26HxwD491_8wasmtime10trampoline6global13create_global:
   10|    326|pub fn create_global(store: &mut StoreOpaque, gt: &GlobalType, val: Val) -> Result<InstanceId> {
   11|    326|    let mut module = Module::new();
   12|    326|    let mut func_imports = Vec::new();
   13|    326|    let mut externref_init = None;
   14|    326|    let mut one_signature = None;
   15|       |
   16|    326|    let global = Global {
   17|    326|        wasm_ty: gt.content().to_wasm_type(),
   18|    326|        mutability: match gt.mutability() {
   19|      0|            Mutability::Const => false,
   20|    326|            Mutability::Var => true,
   21|       |        },
   22|      0|        initializer: match val {
   23|      0|            Val::I32(i) => GlobalInit::I32Const(i),
   24|    326|            Val::I64(i) => GlobalInit::I64Const(i),
   25|      0|            Val::F32(f) => GlobalInit::F32Const(f),
   26|      0|            Val::F64(f) => GlobalInit::F64Const(f),
   27|      0|            Val::V128(i) => GlobalInit::V128Const(i.into()),
   28|      0|            Val::ExternRef(None) | Val::FuncRef(None) => GlobalInit::RefNullConst,
   29|      0|            Val::ExternRef(Some(x)) => {
   30|      0|                // There is no `GlobalInit` variant for using an existing
   31|      0|                // `externref` that isn't an import (because Wasm can't create
   32|      0|                // an `externref` by itself). Therefore, initialize the global
   33|      0|                // as null, and then monkey patch it after instantiation below.
   34|      0|                externref_init = Some(x);
   35|      0|                GlobalInit::RefNullConst
   36|       |            }
   37|      0|            Val::FuncRef(Some(f)) => {
   38|      0|                // Add a function import to the stub module, and then initialize
   39|      0|                // our global with a `ref.func` to grab that imported function.
   40|      0|                let f = f.caller_checked_anyfunc(store);
   41|      0|                let f = unsafe { f.as_ref() };
   42|      0|                let sig_id = SignatureIndex::from_u32(u32::max_value() - 1);
   43|      0|                one_signature = Some((sig_id, f.type_index));
   44|      0|                module.types.push(ModuleType::Function(sig_id));
   45|      0|                let func_index = module.push_escaped_function(sig_id, AnyfuncIndex::from_u32(0));
   46|      0|                module.num_imported_funcs = 1;
   47|      0|                module.num_escaped_funcs = 1;
   48|      0|                module
   49|      0|                    .initializers
   50|      0|                    .push(wasmtime_environ::Initializer::Import {
   51|      0|                        name: "".into(),
   52|      0|                        field: "".into(),
   53|      0|                        index: EntityIndex::Function(func_index),
   54|      0|                    });
   55|      0|
   56|      0|                func_imports.push(VMFunctionImport {
   57|      0|                    body: f.func_ptr,
   58|      0|                    vmctx: f.vmctx,
   59|      0|                });
   60|      0|
   61|      0|                GlobalInit::RefFunc(func_index)
   62|       |            }
   63|       |        },
   64|       |    };
   65|       |
   66|    326|    let global_id = module.globals.push(global);
   67|    326|    module
   68|    326|        .exports
   69|    326|        .insert(String::new(), EntityIndex::Global(global_id));
   70|    326|    let id = create_handle(module, store, Box::new(()), &func_imports, one_signature)?;
   71|       |
   72|    326|    if let Some(x) = externref_init {
   73|      0|        let instance = store.instance_mut(id);
   74|      0|        let g = instance.get_exported_global(global_id);
   75|      0|        unsafe {
   76|      0|            *(*g.definition).as_externref_mut() = Some(x.inner);
   77|      0|        }
   78|    326|    }
   79|       |
   80|    326|    Ok(id)
   81|    326|}

_RNvNtNtCscE26HxwD491_8wasmtime10trampoline6memory13create_memory:
   20|    326|pub fn create_memory(
   21|    326|    store: &mut StoreOpaque,
   22|    326|    memory_ty: &MemoryType,
   23|    326|    preallocation: Option<SharedMemory>,
   24|    326|) -> Result<InstanceId> {
   25|    326|    let mut module = Module::new();
   26|    326|
   27|    326|    // Create a memory plan for the memory, though it will never be used for
   28|    326|    // constructing a memory with an allocator: instead the memories are either
   29|    326|    // preallocated (i.e., shared memory) or allocated manually below.
   30|    326|    let plan = wasmtime_environ::MemoryPlan::for_memory(
   31|    326|        memory_ty.wasmtime_memory().clone(),
   32|    326|        &store.engine().config().tunables,
   33|    326|    );
   34|    326|    let memory_id = module.memory_plans.push(plan.clone());
   35|       |
   36|    326|    let memory = match &preallocation {
   37|       |        // If we are passing in a pre-allocated shared memory, we can clone its
   38|       |        // `Arc`. We know that a preallocated memory *must* be shared--it could
   39|       |        // be used by several instances.
   40|      0|        Some(shared_memory) => shared_memory.clone().as_memory(),
   41|       |        // If we do not have a pre-allocated memory, then we create it here and
   42|       |        // associate it with the "frankenstein" instance, which now owns it.
   43|       |        None => {
   44|    326|            let creator = &DefaultMemoryCreator;
   45|    326|            let store = unsafe {
   46|    326|                store
   47|    326|                    .traitobj()
   48|    326|                    .as_mut()
   49|    326|                    .expect("the store pointer cannot be null here")
   50|    326|            };
   51|    326|            Memory::new_dynamic(&plan, creator, store, None)
   52|    326|                .map_err(|err| InstantiationError::Resource(err.into()))?
   53|       |        }
   54|       |    };
   55|       |
   56|       |    // Since we have only associated a single memory with the "frankenstein"
   57|       |    // instance, it will be exported at index 0.
   58|    326|    debug_assert_eq!(memory_id.as_u32(), 0);
   59|    326|    module
   60|    326|        .exports
   61|    326|        .insert(String::new(), EntityIndex::Memory(memory_id));
   62|    326|
   63|    326|    // We create an instance in the on-demand allocator when creating handles
   64|    326|    // associated with external objects. The configured instance allocator
   65|    326|    // should only be used when creating module instances as we don't want host
   66|    326|    // objects to count towards instance limits.
   67|    326|    let runtime_info = &BareModuleInfo::maybe_imported_func(Arc::new(module), None).into_traitobj();
   68|    326|    let host_state = Box::new(());
   69|    326|    let imports = Imports::default();
   70|    326|    let request = InstanceAllocationRequest {
   71|    326|        imports,
   72|    326|        host_state,
   73|    326|        store: StorePtr::new(store.traitobj()),
   74|    326|        runtime_info,
   75|    326|    };
   76|       |
   77|       |    unsafe {
   78|    326|        let handle = allocate_single_memory_instance(request, memory)?;
   79|    326|        let instance_id = store.add_instance(handle.clone(), true);
   80|    326|        Ok(instance_id)
   81|       |    }
   82|    326|}

_RNvXsr_NtCscE26HxwD491_8wasmtime5typesNtB5_7ValTypeNtNtCsdRJjCzU6nMS_4core3cmp9PartialEq2eq:
   22|    326|#[derive(Debug, Clone, Hash, Eq, PartialEq)]
_RNCNvMs8_NtCscE26HxwD491_8wasmtime5typesNtB7_10MemoryType3new0B9_:
  352|    326|                maximum: maximum.map(|i| i.into()),
_RNvMs_NtCscE26HxwD491_8wasmtime5typesNtB4_7ValType12to_wasm_type:
   74|    326|    pub(crate) fn to_wasm_type(&self) -> WasmType {
   75|    326|        match self {
   76|      0|            Self::I32 => WasmType::I32,
   77|    326|            Self::I64 => WasmType::I64,
   78|      0|            Self::F32 => WasmType::F32,
   79|      0|            Self::F64 => WasmType::F64,
   80|      0|            Self::V128 => WasmType::V128,
   81|      0|            Self::FuncRef => WasmType::FuncRef,
   82|      0|            Self::ExternRef => WasmType::ExternRef,
   83|       |        }
   84|    326|    }
_RNvMs6_NtCscE26HxwD491_8wasmtime5typesNtB5_10GlobalType7content:
  255|    652|    pub fn content(&self) -> &ValType {
  256|    652|        &self.content
  257|    652|    }
_RNvMs6_NtCscE26HxwD491_8wasmtime5typesNtB5_10GlobalType10mutability:
  260|    326|    pub fn mutability(&self) -> Mutability {
  261|    326|        self.mutability
  262|    326|    }
_RNvMs8_NtCscE26HxwD491_8wasmtime5typesNtB5_10MemoryType15wasmtime_memory:
  434|    326|    pub(crate) fn wasmtime_memory(&self) -> &Memory {
  435|    326|        &self.ty
  436|    326|    }
_RNvMs8_NtCscE26HxwD491_8wasmtime5typesNtB5_10MemoryType3new:
  346|    326|    pub fn new(minimum: u32, maximum: Option<u32>) -> MemoryType {
  347|    326|        MemoryType {
  348|    326|            ty: Memory {
  349|    326|                memory64: false,
  350|    326|                shared: false,
  351|    326|                minimum: minimum.into(),
  352|    326|                maximum: maximum.map(|i| i.into()),
  353|    326|            },
  354|    326|        }
  355|    326|    }
_RNvMs6_NtCscE26HxwD491_8wasmtime5typesNtB5_10GlobalType3new:
  247|    326|    pub fn new(content: ValType, mutability: Mutability) -> GlobalType {
  248|    326|        GlobalType {
  249|    326|            content,
  250|    326|            mutability,
  251|    326|        }
  252|    326|    }

_RNvMNtCscE26HxwD491_8wasmtime6valuesNtB2_3Val2ty:
   86|    326|    pub fn ty(&self) -> ValType {
   87|    326|        match self {
   88|      0|            Val::I32(_) => ValType::I32,
   89|    326|            Val::I64(_) => ValType::I64,
   90|      0|            Val::F32(_) => ValType::F32,
   91|      0|            Val::F64(_) => ValType::F64,
   92|      0|            Val::ExternRef(_) => ValType::ExternRef,
   93|      0|            Val::FuncRef(_) => ValType::FuncRef,
   94|      0|            Val::V128(_) => ValType::V128,
   95|       |        }
   96|    326|    }
_RNvMNtCscE26HxwD491_8wasmtime6valuesNtB2_3Val21comes_from_same_store:
  212|      0|        match self {
  213|      0|            Val::FuncRef(Some(f)) => f.comes_from_same_store(store),
  214|      0|            Val::FuncRef(None) => true,
  215|       |
  216|       |            // Integers, floats, vectors, and `externref`s have no association
  217|       |            // with any particular store, so they're always considered as "yes I
  218|       |            // came from that store",
  219|       |            Val::I32(_)
  220|       |            | Val::I64(_)
  221|       |            | Val::F32(_)
  222|       |            | Val::F64(_)
  223|       |            | Val::V128(_)
  224|    326|            | Val::ExternRef(_) => true,
  225|       |        }
  226|    326|    }

_RNvXNtCs2PfZMjlnlOj_18wasmtime_cranelift7builderNtB2_7BuilderNtNtCs7L8xYe2Gdyw_16wasmtime_environ11compilation15CompilerBuilder5build:
  102|    326|    fn build(&self) -> Result<Box<dyn wasmtime_environ::Compiler>> {
  103|    326|        let isa = self
  104|    326|            .isa_flags
  105|    326|            .clone()
  106|    326|            .finish(settings::Flags::new(self.flags.clone()))?;
  107|    326|        Ok(Box::new(crate::compiler::Compiler::new(
  108|    326|            isa,
  109|    326|            self.cache_store.clone(),
  110|    326|            self.linkopts.clone(),
  111|    326|        )))
  112|    326|    }
_RNvXNtCs2PfZMjlnlOj_18wasmtime_cranelift7builderNtB2_7BuilderNtNtCs7L8xYe2Gdyw_16wasmtime_environ11compilation15CompilerBuilder3set:
   65|  1.30k|    fn set(&mut self, name: &str, value: &str) -> Result<()> {
   66|  1.30k|        // Special wasmtime-cranelift-only settings first
   67|  1.30k|        if name == "wasmtime_linkopt_padding_between_functions" {
   68|      0|            self.linkopts.padding_between_functions = value.parse()?;
   69|      0|            return Ok(());
   70|  1.30k|        }
   71|  1.30k|        if name == "wasmtime_linkopt_force_jump_veneer" {
   72|      0|            self.linkopts.force_jump_veneers = value.parse()?;
   73|      0|            return Ok(());
   74|  1.30k|        }
   75|       |
   76|       |        // ... then forward this to Cranelift
   77|  1.30k|        if let Err(err) = self.flags.set(name, value) {
   78|      0|            match err {
   79|       |                SetError::BadName(_) => {
   80|       |                    // Try the target-specific flags.
   81|      0|                    self.isa_flags.set(name, value)?;
   82|       |                }
   83|      0|                _ => return Err(err.into()),
   84|       |            }
   85|  1.30k|        }
   86|  1.30k|        Ok(())
   87|  1.30k|    }
_RNvXs0_NtCs2PfZMjlnlOj_18wasmtime_cranelift7builderNtB5_11LinkOptionsNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   20|    326|#[derive(Clone, Default)]
_RNvXs1_NtCs2PfZMjlnlOj_18wasmtime_cranelift7builderNtB5_11LinkOptionsNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   20|    326|#[derive(Clone, Default)]
_RNvNtCs2PfZMjlnlOj_18wasmtime_cranelift7builder7builder:
   33|    326|pub fn builder() -> Box<dyn CompilerBuilder> {
   34|    326|    let mut flags = settings::builder();
   35|    326|
   36|    326|    // There are two possible traps for division, and this way
   37|    326|    // we get the proper one if code traps.
   38|    326|    flags
   39|    326|        .enable("avoid_div_traps")
   40|    326|        .expect("should be valid flag");
   41|    326|
   42|    326|    // We don't use probestack as a stack limit mechanism
   43|    326|    flags
   44|    326|        .set("enable_probestack", "false")
   45|    326|        .expect("should be valid flag");
   46|    326|
   47|    326|    Box::new(Builder {
   48|    326|        flags,
   49|    326|        isa_flags: cranelift_native::builder().expect("host machine is not a supported target"),
   50|    326|        linkopts: LinkOptions::default(),
   51|    326|        cache_store: None,
   52|    326|    })
   53|    326|}

_RNvXs_NtCs2PfZMjlnlOj_18wasmtime_cranelift8compilerNtB4_8CompilerNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
   76|    326|    fn drop(&mut self) {
   77|    326|        if self.cache_store.is_none() {
   78|    326|            return;
   79|      0|        }
   80|      0|
   81|      0|        let mut num_hits = 0;
   82|      0|        let mut num_cached = 0;
   83|      0|        for ctx in self.contexts.lock().unwrap().iter() {
   84|      0|            if let Some(ref cache_ctx) = ctx.incremental_cache_ctx {
   85|      0|                num_hits += cache_ctx.num_hits;
   86|      0|                num_cached += cache_ctx.num_cached;
   87|      0|            }
   88|       |        }
   89|       |
   90|      0|        let total = num_hits + num_cached;
   91|      0|        if num_hits + num_cached > 0 {
   92|      0|            log::trace!(
   93|      0|                "Incremental compilation cache stats: {}/{} = {}% (hits/lookup)\ncached: {}",
   94|      0|                num_hits,
   95|      0|                total,
   96|      0|                (num_hits as f32) / (total as f32) * 100.0,
   97|       |                num_cached
   98|       |            );
   99|      0|        }
  100|    326|    }
_RNvMs0_NtCs2PfZMjlnlOj_18wasmtime_cranelift8compilerNtB5_8Compiler3new:
  104|    326|    pub(crate) fn new(
  105|    326|        isa: Box<dyn TargetIsa>,
  106|    326|        cache_store: Option<Arc<dyn CacheStore>>,
  107|    326|        linkopts: LinkOptions,
  108|    326|    ) -> Compiler {
  109|    326|        Compiler {
  110|    326|            contexts: Default::default(),
  111|    326|            isa,
  112|    326|            linkopts,
  113|    326|            cache_store,
  114|    326|        }
  115|    326|    }

_RNvXsw_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_6ModuleNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  767|    978|#[derive(Default, Debug, Serialize, Deserialize)]
_RNvXsd_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_10MemoryPlanNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   73|    652|#[derive(Debug, Clone, Hash, Serialize, Deserialize)]
_RNvXsa_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_11MemoryStyleNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   14|    652|#[derive(Debug, Clone, Hash, Serialize, Deserialize)]
_RNvMs7_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_6Module20defined_global_index:
  959|    978|    pub fn defined_global_index(&self, global: GlobalIndex) -> Option<DefinedGlobalIndex> {
  960|    978|        if global.index() < self.num_imported_globals {
  961|      0|            None
  962|       |        } else {
  963|    978|            Some(DefinedGlobalIndex::new(
  964|    978|                global.index() - self.num_imported_globals,
  965|    978|            ))
  966|       |        }
  967|    978|    }
_RNvMs7_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_6Module20defined_memory_index:
  912|    326|    pub fn defined_memory_index(&self, memory: MemoryIndex) -> Option<DefinedMemoryIndex> {
  913|    326|        if memory.index() < self.num_imported_memories {
  914|      0|            None
  915|       |        } else {
  916|    326|            Some(DefinedMemoryIndex::new(
  917|    326|                memory.index() - self.num_imported_memories,
  918|    326|            ))
  919|       |        }
  920|    326|    }
_RNvMs7_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_6Module12memory_index:
  905|    326|    pub fn memory_index(&self, defined_memory: DefinedMemoryIndex) -> MemoryIndex {
  906|    326|        MemoryIndex::new(self.num_imported_memories + defined_memory.index())
  907|    326|    }
_RNvXs1_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_20MemoryInitializationNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  481|    978|    fn default() -> Self {
  482|    978|        Self::Segmented(Vec::new())
  483|    978|    }
_RNvMs7_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_6Module3new:
  849|    652|    pub fn new() -> Self {
  850|    652|        Module::default()
  851|    652|    }
_RNvXs5_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB5_19TableInitializationNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  740|    978|    fn default() -> Self {
  741|    978|        TableInitialization::Segments { segments: vec![] }
  742|    978|    }
_RNvMs_NtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB4_10MemoryPlan10for_memory:
   87|    326|    pub fn for_memory(memory: Memory, tunables: &Tunables) -> Self {
   88|    326|        let (style, offset_guard_size) = MemoryStyle::for_memory(memory, tunables);
   89|    326|        Self {
   90|    326|            memory,
   91|    326|            style,
   92|    326|            offset_guard_size,
   93|    326|            pre_guard_size: if tunables.guard_before_linear_memory {
   94|    326|                offset_guard_size
   95|       |            } else {
   96|      0|                0
   97|       |            },
   98|       |        }
   99|    326|    }
_RNvMNtCs7L8xYe2Gdyw_16wasmtime_environ6moduleNtB2_11MemoryStyle10for_memory:
   30|    326|    pub fn for_memory(memory: Memory, tunables: &Tunables) -> (Self, u64) {
   31|       |        // A heap with a maximum that doesn't exceed the static memory bound specified by the
   32|       |        // tunables make it static.
   33|       |        //
   34|       |        // If the module doesn't declare an explicit maximum treat it as 4GiB when not
   35|       |        // requested to use the static memory bound itself as the maximum.
   36|    326|        let absolute_max_pages = if memory.memory64 {
   37|      0|            crate::WASM64_MAX_PAGES
   38|       |        } else {
   39|    326|            crate::WASM32_MAX_PAGES
   40|       |        };
   41|    326|        let maximum = std::cmp::min(
   42|    326|            memory.maximum.unwrap_or(absolute_max_pages),
   43|    326|            if tunables.static_memory_bound_is_maximum {
   44|    326|                std::cmp::min(tunables.static_memory_bound, absolute_max_pages)
   45|       |            } else {
   46|      0|                absolute_max_pages
   47|       |            },
   48|       |        );
   49|       |
   50|       |        // Ensure the minimum is less than the maximum; the minimum might exceed the maximum
   51|       |        // when the memory is artificially bounded via `static_memory_bound_is_maximum` above
   52|    326|        if memory.minimum <= maximum && maximum <= tunables.static_memory_bound {
   53|    326|            return (
   54|    326|                Self::Static {
   55|    326|                    bound: tunables.static_memory_bound,
   56|    326|                },
   57|    326|                tunables.static_memory_offset_guard_size,
   58|    326|            );
   59|      0|        }
   60|      0|
   61|      0|        // Otherwise, make it dynamic.
   62|      0|        (
   63|      0|            Self::Dynamic {
   64|      0|                reserve: tunables.dynamic_memory_growth_reserve,
   65|      0|            },
   66|      0|            tunables.dynamic_memory_offset_guard_size,
   67|      0|        )
   68|    326|    }

_RNvXs_NtCs7L8xYe2Gdyw_16wasmtime_environ8tunablesNtB4_8TunablesNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
    4|    326|#[derive(Clone, Hash, Serialize, Deserialize)]
_RNvXNtCs7L8xYe2Gdyw_16wasmtime_environ8tunablesNtB2_8TunablesNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   51|    326|    fn default() -> Self {
   52|    326|        let (static_memory_bound, static_memory_offset_guard_size) =
   53|    326|            if cfg!(target_pointer_width = "64") {
   54|       |                // 64-bit has tons of address space to static memories can have 4gb
   55|       |                // address space reservations liberally by default, allowing us to
   56|       |                // help eliminate bounds checks.
   57|       |                //
   58|       |                // Coupled with a 2 GiB address space guard it lets us translate
   59|       |                // wasm offsets into x86 offsets as aggressively as we can.
   60|    326|                (0x1_0000, 0x8000_0000)
   61|      0|            } else if cfg!(target_pointer_width = "32") {
   62|       |                // For 32-bit we scale way down to 10MB of reserved memory. This
   63|       |                // impacts performance severely but allows us to have more than a
   64|       |                // few instances running around.
   65|      0|                ((10 * (1 << 20)) / crate::WASM_PAGE_SIZE as u64, 0x1_0000)
   66|       |            } else {
   67|      0|                panic!("unsupported target_pointer_width");
   68|       |            };
   69|    326|        Self {
   70|    326|            static_memory_bound,
   71|    326|            static_memory_offset_guard_size,
   72|    326|
   73|    326|            // Size in bytes of the offset guard for dynamic memories.
   74|    326|            //
   75|    326|            // Allocate a small guard to optimize common cases but without
   76|    326|            // wasting too much memory.
   77|    326|            dynamic_memory_offset_guard_size: 0x1_0000,
   78|    326|
   79|    326|            // We've got lots of address space on 64-bit so use a larger
   80|    326|            // grow-into-this area, but on 32-bit we aren't as lucky.
   81|    326|            #[cfg(target_pointer_width = "64")]
   82|    326|            dynamic_memory_growth_reserve: 2 << 30, // 2GB
   83|    326|            #[cfg(target_pointer_width = "32")]
   84|    326|            dynamic_memory_growth_reserve: 1 << 20, // 1MB
   85|    326|
   86|    326|            generate_native_debuginfo: false,
   87|    326|            parse_wasm_debuginfo: true,
   88|    326|            consume_fuel: false,
   89|    326|            epoch_interruption: false,
   90|    326|            static_memory_bound_is_maximum: false,
   91|    326|            guard_before_linear_memory: true,
   92|    326|            generate_address_map: true,
   93|    326|            debug_adapter_modules: false,
   94|    326|        }
   95|    326|    }

_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_storeCscE26HxwD491_8wasmtime:
  616|    978|    pub fn vmctx_store(&self) -> u32 {
  617|    978|        self.store
  618|    978|    }
_RNvNtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsets5align:
   50|  1.95k|fn align(offset: u32, width: u32) -> u32 {
   51|  1.95k|    (offset + (width - 1)) / width * width
   52|  1.95k|}
_RNvNvXs1_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetspEINtNtCsdRJjCzU6nMS_4core7convert4FromINtB7_15VMOffsetsFieldspEE4from4cadd:
  383|  16.6k|        fn cadd(count: u32, size: u32) -> u32 {
  384|  16.6k|            count.checked_add(size).unwrap()
  385|  16.6k|        }
_RNvNvXs1_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetspEINtNtCsdRJjCzU6nMS_4core7convert4FromINtB7_15VMOffsetsFieldspEE4from4cmul:
  388|  8.80k|        fn cmul(count: u32, size: u8) -> u32 {
  389|  8.80k|            count.checked_mul(u32::from(size)).unwrap()
  390|  8.80k|        }
_RNvMs5_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE26size_of_vmtable_definitionCsfBAxPD3lkOv_16wasmtime_runtime:
  528|    978|    pub fn size_of_vmtable_definition(&self) -> u8 {
  529|    978|        2 * self.pointer_size()
  530|    978|    }
_RNvXNtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsNtB2_7HostPtrNtB2_7PtrSize4size:
  208|  15.9k|    fn size(&self) -> u8 {
  209|  15.9k|        std::mem::size_of::<usize>() as u8
  210|  15.9k|    }
_RNvMs4_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE22size_of_vmtable_importCsfBAxPD3lkOv_16wasmtime_runtime:
  500|    978|    pub fn size_of_vmtable_import(&self) -> u8 {
  501|    978|        2 * self.pointer_size()
  502|    978|    }
_RNvXs1_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrEINtNtCsdRJjCzU6nMS_4core7convert4FromINtB5_15VMOffsetsFieldsB13_EE4fromCsfBAxPD3lkOv_16wasmtime_runtime:
  346|    978|    fn from(fields: VMOffsetsFields<P>) -> VMOffsets<P> {
  347|    978|        let mut ret = Self {
  348|    978|            ptr: fields.ptr,
  349|    978|            num_imported_functions: fields.num_imported_functions,
  350|    978|            num_imported_tables: fields.num_imported_tables,
  351|    978|            num_imported_memories: fields.num_imported_memories,
  352|    978|            num_imported_globals: fields.num_imported_globals,
  353|    978|            num_defined_tables: fields.num_defined_tables,
  354|    978|            num_defined_memories: fields.num_defined_memories,
  355|    978|            num_owned_memories: fields.num_owned_memories,
  356|    978|            num_defined_globals: fields.num_defined_globals,
  357|    978|            num_escaped_funcs: fields.num_escaped_funcs,
  358|    978|            magic: 0,
  359|    978|            runtime_limits: 0,
  360|    978|            callee: 0,
  361|    978|            epoch_ptr: 0,
  362|    978|            externref_activations_table: 0,
  363|    978|            store: 0,
  364|    978|            builtin_functions: 0,
  365|    978|            signature_ids: 0,
  366|    978|            imported_functions: 0,
  367|    978|            imported_tables: 0,
  368|    978|            imported_memories: 0,
  369|    978|            imported_globals: 0,
  370|    978|            defined_tables: 0,
  371|    978|            defined_memories: 0,
  372|    978|            owned_memories: 0,
  373|    978|            defined_globals: 0,
  374|    978|            defined_anyfuncs: 0,
  375|    978|            size: 0,
  376|    978|        };
  377|    978|
  378|    978|        // Convenience functions for checked addition and multiplication.
  379|    978|        // As side effect this reduces binary size by using only a single
  380|    978|        // `#[track_caller]` location for each function instead of one for
  381|    978|        // each individual invocation.
  382|    978|        #[inline]
  383|    978|        fn cadd(count: u32, size: u32) -> u32 {
  384|    978|            count.checked_add(size).unwrap()
  385|    978|        }
  386|    978|
  387|    978|        #[inline]
  388|    978|        fn cmul(count: u32, size: u8) -> u32 {
  389|    978|            count.checked_mul(u32::from(size)).unwrap()
  390|    978|        }
  391|    978|
  392|    978|        let mut next_field_offset = 0;
  393|    978|
  394|    978|        macro_rules! fields {
  395|    978|            (size($field:ident) = $size:expr, $($rest:tt)*) => {
  396|    978|                ret.$field = next_field_offset;
  397|    978|                next_field_offset = cadd(next_field_offset, u32::from($size));
  398|    978|                fields!($($rest)*);
  399|    978|            };
  400|    978|            (align($align:expr), $($rest:tt)*) => {
  401|    978|                next_field_offset = align(next_field_offset, $align);
  402|    978|                fields!($($rest)*);
  403|    978|            };
  404|    978|            () => {};
  405|    978|        }
  406|    978|
  407|    978|        fields! {
  408|    978|            size(magic) = 4u32,
  409|    978|            align(u32::from(ret.ptr.size())),
  410|    978|            size(runtime_limits) = ret.ptr.size(),
  411|    978|            size(callee) = ret.ptr.size(),
  412|    978|            size(epoch_ptr) = ret.ptr.size(),
  413|    978|            size(externref_activations_table) = ret.ptr.size(),
  414|    978|            size(store) = ret.ptr.size() * 2,
  415|    978|            size(builtin_functions) = ret.pointer_size(),
  416|    978|            size(signature_ids) = ret.ptr.size(),
  417|    978|            size(imported_functions)
  418|    978|                = cmul(ret.num_imported_functions, ret.size_of_vmfunction_import()),
  419|    978|            size(imported_tables)
  420|    978|                = cmul(ret.num_imported_tables, ret.size_of_vmtable_import()),
  421|    978|            size(imported_memories)
  422|    978|                = cmul(ret.num_imported_memories, ret.size_of_vmmemory_import()),
  423|    978|            size(imported_globals)
  424|    978|                = cmul(ret.num_imported_globals, ret.size_of_vmglobal_import()),
  425|    978|            size(defined_tables)
  426|    978|                = cmul(ret.num_defined_tables, ret.size_of_vmtable_definition()),
  427|    978|            size(defined_memories)
  428|    978|                = cmul(ret.num_defined_memories, ret.ptr.size_of_vmmemory_pointer()),
  429|    978|            size(owned_memories)
  430|    978|                = cmul(ret.num_owned_memories, ret.ptr.size_of_vmmemory_definition()),
  431|    978|            align(16),
  432|    978|            size(defined_globals)
  433|    978|                = cmul(ret.num_defined_globals, ret.ptr.size_of_vmglobal_definition()),
  434|    978|            size(defined_anyfuncs) = cmul(
  435|    978|                ret.num_escaped_funcs,
  436|    978|                ret.ptr.size_of_vmcaller_checked_anyfunc(),
  437|    978|            ),
  438|    978|        }
  439|    978|
  440|    978|        ret.size = next_field_offset;
  441|    978|
  442|    978|        // This is required by the implementation of `VMContext::instance` and
  443|    978|        // `VMContext::instance_mut`. If this value changes then those locations
  444|    978|        // need to be updated.
  445|    978|        assert_eq!(ret.magic, 0);
  446|       |
  447|    978|        return ret;
  448|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25vmctx_vmglobal_definitionCsfBAxPD3lkOv_16wasmtime_runtime:
  751|    652|    pub fn vmctx_vmglobal_definition(&self, index: DefinedGlobalIndex) -> u32 {
  752|    652|        assert!(index.as_u32() < self.num_defined_globals);
  753|    652|        self.vmctx_globals_begin()
  754|    652|            + index.as_u32() * u32::from(self.ptr.size_of_vmglobal_definition())
  755|    652|    }
_RNCNvMs0_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetsNtB7_7HostPtrE3new0CsfBAxPD3lkOv_16wasmtime_runtime:
  253|    326|            .filter(|p| !p.1.memory.shared)
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE30vmctx_imported_functions_beginCsfBAxPD3lkOv_16wasmtime_runtime:
  629|    978|    pub fn vmctx_imported_functions_begin(&self) -> u32 {
  630|    978|        self.imported_functions
  631|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE29vmctx_imported_memories_beginCsfBAxPD3lkOv_16wasmtime_runtime:
  642|    978|    pub fn vmctx_imported_memories_begin(&self) -> u32 {
  643|    978|        self.imported_memories
  644|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE20vmctx_memories_beginCsfBAxPD3lkOv_16wasmtime_runtime:
  660|  1.30k|    pub fn vmctx_memories_begin(&self) -> u32 {
  661|  1.30k|        self.defined_memories
  662|  1.30k|    }
_RNvMs6_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23size_of_vmmemory_importCsfBAxPD3lkOv_16wasmtime_runtime:
  551|    978|    pub fn size_of_vmmemory_import(&self) -> u8 {
  552|    978|        3 * self.pointer_size()
  553|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25vmctx_signature_ids_arrayCsfBAxPD3lkOv_16wasmtime_runtime:
  622|    978|    pub fn vmctx_signature_ids_array(&self) -> u32 {
  623|    978|        self.signature_ids
  624|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE22vmctx_vmmemory_pointerCsfBAxPD3lkOv_16wasmtime_runtime:
  735|    326|    pub fn vmctx_vmmemory_pointer(&self, index: DefinedMemoryIndex) -> u32 {
  736|    326|        assert!(index.as_u32() < self.num_defined_memories);
  737|    326|        self.vmctx_memories_begin()
  738|    326|            + index.as_u32() * u32::from(self.ptr.size_of_vmmemory_pointer())
  739|    326|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE19vmctx_globals_beginCsfBAxPD3lkOv_16wasmtime_runtime:
  672|    652|    pub fn vmctx_globals_begin(&self) -> u32 {
  673|    652|        self.defined_globals
  674|    652|    }
_RNvYNtNtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize27size_of_vmglobal_definitionCsfBAxPD3lkOv_16wasmtime_runtime:
  135|  1.63k|    fn size_of_vmglobal_definition(&self) -> u8 {
  136|  1.63k|        16
  137|  1.63k|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE20vmctx_runtime_limitsCsfBAxPD3lkOv_16wasmtime_runtime:
  592|  1.30k|    pub fn vmctx_runtime_limits(&self) -> u32 {
  593|  1.30k|        self.runtime_limits
  594|  1.30k|    }
_RNvMs0_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE3newCsfBAxPD3lkOv_16wasmtime_runtime:
  248|    978|    pub fn new(ptr: P, module: &Module) -> Self {
  249|    978|        let num_owned_memories = module
  250|    978|            .memory_plans
  251|    978|            .iter()
  252|    978|            .skip(module.num_imported_memories)
  253|    978|            .filter(|p| !p.1.memory.shared)
  254|    978|            .count()
  255|    978|            .try_into()
  256|    978|            .unwrap();
  257|    978|        VMOffsets::from(VMOffsetsFields {
  258|    978|            ptr,
  259|    978|            num_imported_functions: cast_to_u32(module.num_imported_funcs),
  260|    978|            num_imported_tables: cast_to_u32(module.num_imported_tables),
  261|    978|            num_imported_memories: cast_to_u32(module.num_imported_memories),
  262|    978|            num_imported_globals: cast_to_u32(module.num_imported_globals),
  263|    978|            num_defined_tables: cast_to_u32(module.table_plans.len() - module.num_imported_tables),
  264|    978|            num_defined_memories: cast_to_u32(
  265|    978|                module.memory_plans.len() - module.num_imported_memories,
  266|    978|            ),
  267|    978|            num_owned_memories,
  268|    978|            num_defined_globals: cast_to_u32(module.globals.len() - module.num_imported_globals),
  269|    978|            num_escaped_funcs: cast_to_u32(module.num_escaped_funcs),
  270|    978|        })
  271|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE13size_of_vmctxCsfBAxPD3lkOv_16wasmtime_runtime:
  690|  2.93k|    pub fn size_of_vmctx(&self) -> u32 {
  691|  2.93k|        self.size
  692|  2.93k|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE28vmctx_imported_globals_beginCsfBAxPD3lkOv_16wasmtime_runtime:
  648|    978|    pub fn vmctx_imported_globals_begin(&self) -> u32 {
  649|    978|        self.imported_globals
  650|    978|    }
_RNvMs2_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25size_of_vmfunction_importCsfBAxPD3lkOv_16wasmtime_runtime:
  468|    978|    pub fn size_of_vmfunction_import(&self) -> u8 {
  469|    978|        2 * self.pointer_size()
  470|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE33vmctx_externref_activations_tableCsfBAxPD3lkOv_16wasmtime_runtime:
  610|  1.30k|    pub fn vmctx_externref_activations_table(&self) -> u32 {
  611|  1.30k|        self.externref_activations_table
  612|  1.30k|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_storeCsfBAxPD3lkOv_16wasmtime_runtime:
  616|  1.30k|    pub fn vmctx_store(&self) -> u32 {
  617|  1.30k|        self.store
  618|  1.30k|    }
_RNvYNtNtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize32size_of_vmcaller_checked_anyfuncCsfBAxPD3lkOv_16wasmtime_runtime:
  128|    978|    fn size_of_vmcaller_checked_anyfunc(&self) -> u8 {
  129|    978|        3 * self.size()
  130|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_magicCsfBAxPD3lkOv_16wasmtime_runtime:
  586|    978|    pub fn vmctx_magic(&self) -> u32 {
  587|    978|        self.magic
  588|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE12vmctx_calleeCsfBAxPD3lkOv_16wasmtime_runtime:
  597|    978|    pub fn vmctx_callee(&self) -> u32 {
  598|    978|        self.callee
  599|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23vmctx_builtin_functionsCsfBAxPD3lkOv_16wasmtime_runtime:
  684|    978|    pub fn vmctx_builtin_functions(&self) -> u32 {
  685|    978|        self.builtin_functions
  686|    978|    }
_RNvYNtNtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize24size_of_vmmemory_pointerCsfBAxPD3lkOv_16wasmtime_runtime:
  198|  1.30k|    fn size_of_vmmemory_pointer(&self) -> u8 {
  199|  1.30k|        self.size()
  200|  1.30k|    }
_RNvMs7_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23size_of_vmglobal_importCsfBAxPD3lkOv_16wasmtime_runtime:
  568|    978|    pub fn size_of_vmglobal_import(&self) -> u8 {
  569|    978|        1 * self.pointer_size()
  570|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE26vmctx_owned_memories_beginCsfBAxPD3lkOv_16wasmtime_runtime:
  666|    978|    pub fn vmctx_owned_memories_begin(&self) -> u32 {
  667|    978|        self.owned_memories
  668|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE15vmctx_epoch_ptrCsfBAxPD3lkOv_16wasmtime_runtime:
  604|  1.30k|    pub fn vmctx_epoch_ptr(&self) -> u32 {
  605|  1.30k|        self.epoch_ptr
  606|  1.30k|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE18vmctx_tables_beginCsfBAxPD3lkOv_16wasmtime_runtime:
  654|    978|    pub fn vmctx_tables_begin(&self) -> u32 {
  655|    978|        self.defined_tables
  656|    978|    }
_RNvMs9_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE27vmctx_imported_tables_beginCsfBAxPD3lkOv_16wasmtime_runtime:
  636|    978|    pub fn vmctx_imported_tables_begin(&self) -> u32 {
  637|    978|        self.imported_tables
  638|    978|    }
_RNvMs0_NtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE12pointer_sizeCsfBAxPD3lkOv_16wasmtime_runtime:
  275|  5.86k|    pub fn pointer_size(&self) -> u8 {
  276|  5.86k|        self.ptr.size()
  277|  5.86k|    }
_RNvYNtNtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize27size_of_vmmemory_definitionCsfBAxPD3lkOv_16wasmtime_runtime:
  192|    978|    fn size_of_vmmemory_definition(&self) -> u8 {
  193|    978|        2 * self.size()
  194|    978|    }
_RNvNtCs7L8xYe2Gdyw_16wasmtime_environ9vmoffsets11cast_to_u32:
   44|  7.82k|fn cast_to_u32(sz: usize) -> u32 {
   45|  7.82k|    u32::try_from(sz).expect("overflow in cast from usize to u32")
   46|  7.82k|}

_RNvNtCsfBAxPD3lkOv_16wasmtime_runtime14debug_builtins15ensure_exported:
   47|    326|pub fn ensure_exported() {
   48|    326|    unsafe {
   49|    326|        std::ptr::read_volatile(resolve_vmctx_memory_ptr as *const u8);
   50|    326|        std::ptr::read_volatile(set_vmctx_memory as *const u8);
   51|    326|        std::ptr::read_volatile(resolve_vmctx_memory as *const u8);
   52|    326|    }
   53|    326|}

_RNvMsc_NtCsfBAxPD3lkOv_16wasmtime_runtime9externrefNtB5_27VMExternRefActivationsTable3new:
  576|    326|    pub fn new() -> Self {
  577|    326|        // Start with an empty chunk in case this activations table isn't used.
  578|    326|        // This means that there's no space in the bump-allocation area which
  579|    326|        // will force any path trying to use this to the slow gc path. The first
  580|    326|        // time this happens, though, the slow gc path will allocate a new chunk
  581|    326|        // for actual fast-bumping.
  582|    326|        let mut chunk: Box<[TableElem]> = Box::new([]);
  583|    326|        let next = chunk.as_mut_ptr();
  584|    326|        let end = unsafe { next.add(chunk.len()) };
  585|    326|
  586|    326|        VMExternRefActivationsTable {
  587|    326|            alloc: VMExternRefTableAlloc {
  588|    326|                next: UnsafeCell::new(NonNull::new(next).unwrap()),
  589|    326|                end: NonNull::new(end).unwrap(),
  590|    326|                chunk,
  591|    326|            },
  592|    326|            over_approximated_stack_roots: HashSet::new(),
  593|    326|            precise_stack_roots: HashSet::new(),
  594|    326|            #[cfg(debug_assertions)]
  595|    326|            gc_okay: true,
  596|    326|        }
  597|    326|    }

_RNvXNtCsfBAxPD3lkOv_16wasmtime_runtime7importsNtB2_7ImportsNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   14|    978|#[derive(Default)]

_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance5store:
  267|    978|    pub fn store(&self) -> *mut dyn Store {
  268|    978|        let ptr = unsafe { *self.vmctx_plus_offset::<*mut dyn Store>(self.offsets.vmctx_store()) };
  269|    978|        assert!(!ptr.is_null());
  270|    978|        ptr
  271|    978|    }
_RNvMs2_NtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB5_14InstanceHandle8instance:
 1158|  1.95k|    pub(crate) fn instance(&self) -> &Instance {
 1159|  1.95k|        unsafe { &*(self.instance as *const Instance) }
 1160|  1.95k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance5vmctx:
  300|  18.2k|    pub fn vmctx(&self) -> &VMContext {
  301|  18.2k|        &self.vmctx
  302|  18.2k|    }
_RNvMs2_NtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB5_14InstanceHandle5store:
 1168|    978|    pub fn store(&self) -> *mut dyn Store {
 1169|    978|        self.instance().store()
 1170|    978|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance9vmctx_ptr:
  306|  18.2k|    pub fn vmctx_ptr(&self) -> *mut VMContext {
  307|  18.2k|        self.vmctx() as *const VMContext as *mut VMContext
  308|  18.2k|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetODNtB5_5StoreEL_ECscE26HxwD491_8wasmtime:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RNvMs2_NtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB5_14InstanceHandle5clone:
 1187|    978|    pub unsafe fn clone(&self) -> InstanceHandle {
 1188|    978|        InstanceHandle {
 1189|    978|            instance: self.instance,
 1190|    978|        }
 1191|    978|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9vmcontext14VMFunctionBodyEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance10memory_ptr:
  212|    326|    fn memory_ptr(&self, index: DefinedMemoryIndex) -> *mut VMMemoryDefinition {
  213|    326|        unsafe { *self.vmctx_plus_offset(self.offsets.vmctx_vmmemory_pointer(index)) }
  214|    326|    }
_RNvXs_NtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB4_8InstanceNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
 1020|    978|    fn drop(&mut self) {
 1021|       |        // Drop any defined globals
 1022|    978|        for (idx, global) in self.module().globals.iter() {
 1023|    326|            let idx = match self.module().defined_global_index(idx) {
 1024|    326|                Some(idx) => idx,
 1025|      0|                None => continue,
 1026|       |            };
 1027|    326|            match global.wasm_ty {
 1028|       |                // For now only externref globals need to get destroyed
 1029|      0|                WasmType::ExternRef => {}
 1030|    326|                _ => continue,
 1031|       |            }
 1032|      0|            unsafe {
 1033|      0|                drop((*self.global_ptr(idx)).as_externref_mut().take());
 1034|      0|            }
 1035|       |        }
 1036|    978|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetAOuj2_EB5_:
  141|    326|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    326|        (self.vmctx_ptr().cast::<u8>())
  143|    326|            .add(usize::try_from(offset).unwrap())
  144|    326|            .cast()
  145|    326|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext14VMGlobalImportEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance19get_exported_global:
  347|    326|    fn get_exported_global(&mut self, index: GlobalIndex) -> ExportGlobal {
  348|       |        ExportGlobal {
  349|    326|            definition: if let Some(def_index) = self.module().defined_global_index(index) {
  350|    326|                self.global_ptr(def_index)
  351|       |            } else {
  352|      0|                self.imported_global(index).from
  353|       |            },
  354|    326|            global: self.module().globals[index],
  355|    326|        }
  356|    326|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext16VMFunctionImportEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9vmcontext18VMMemoryDefinitionEB5_:
  141|  1.30k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.30k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.30k|            .add(usize::try_from(offset).unwrap())
  144|  1.30k|            .cast()
  145|  1.30k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance10global_ptr:
  222|    652|    fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {
  223|    652|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_vmglobal_definition(index)) }
  224|    652|    }
_RNvMs2_NtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB5_14InstanceHandle19get_exported_global:
 1092|    326|    pub fn get_exported_global(&mut self, export: GlobalIndex) -> ExportGlobal {
 1093|    326|        self.instance_mut().get_exported_global(export)
 1094|    326|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext14VMMemoryImportEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance6module:
  147|  3.58k|    pub(crate) fn module(&self) -> &Arc<Module> {
  148|  3.58k|        self.runtime_info.module()
  149|  3.58k|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9externref27VMExternRefActivationsTableEB5_:
  141|  1.30k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.30k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.30k|            .add(usize::try_from(offset).unwrap())
  144|  1.30k|            .cast()
  145|  1.30k|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetODNtB5_5StoreEL_EB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext18VMGlobalDefinitionEB5_:
  141|    652|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    652|        (self.vmctx_ptr().cast::<u8>())
  143|    652|            .add(usize::try_from(offset).unwrap())
  144|    652|            .cast()
  145|    652|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtNtCsdRJjCzU6nMS_4core4sync6atomic9AtomicU64EB5_:
  141|  1.30k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.30k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.30k|            .add(usize::try_from(offset).unwrap())
  144|  1.30k|            .cast()
  145|  1.30k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance19get_exported_memory:
  331|    326|    fn get_exported_memory(&mut self, index: MemoryIndex) -> ExportMemory {
  332|    326|        let (definition, vmctx, def_index) =
  333|    326|            if let Some(def_index) = self.module().defined_memory_index(index) {
  334|    326|                (self.memory_ptr(def_index), self.vmctx_ptr(), def_index)
  335|       |            } else {
  336|      0|                let import = self.imported_memory(index);
  337|      0|                (import.from, import.vmctx, import.index)
  338|       |            };
  339|    326|        ExportMemory {
  340|    326|            definition,
  341|    326|            vmctx,
  342|    326|            memory: self.module().memory_plans[index].clone(),
  343|    326|            index: def_index,
  344|    326|        }
  345|    326|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance14runtime_limits:
  242|  1.30k|    pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {
  243|  1.30k|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_runtime_limits()) }
  244|  1.30k|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext13VMTableImportEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RNvMs2_NtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB5_14InstanceHandle12instance_mut:
 1162|    978|    pub(crate) fn instance_mut(&mut self) -> &mut Instance {
 1163|    978|        unsafe { &mut *self.instance }
 1164|    978|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext17VMTableDefinitionEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetmEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetRNtNtB5_9vmcontext23VMBuiltinFunctionsArrayEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance9set_store:
  273|  1.30k|    pub unsafe fn set_store(&mut self, store: Option<*mut dyn Store>) {
  274|  1.30k|        if let Some(store) = store {
  275|    978|            *self.vmctx_plus_offset(self.offsets.vmctx_store()) = store;
  276|    978|            *self.runtime_limits() = (*store).vmruntime_limits();
  277|    978|            *self.epoch_ptr() = (*store).epoch_ptr();
  278|    978|            *self.externref_activations_table() = (*store).externref_activations_table().0;
  279|    978|        } else {
  280|    326|            assert_eq!(
  281|    326|                mem::size_of::<*mut dyn Store>(),
  282|    326|                mem::size_of::<[*mut (); 2]>()
  283|    326|            );
  284|    326|            *self.vmctx_plus_offset::<[*mut (); 2]>(self.offsets.vmctx_store()) =
  285|    326|                [ptr::null_mut(), ptr::null_mut()];
  286|    326|
  287|    326|            *self.runtime_limits() = ptr::null_mut();
  288|    326|            *self.epoch_ptr() = ptr::null_mut();
  289|    326|            *self.externref_activations_table() = ptr::null_mut();
  290|       |        }
  291|  1.30k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance6new_at:
  105|    978|    unsafe fn new_at(
  106|    978|        ptr: *mut Instance,
  107|    978|        alloc_size: usize,
  108|    978|        offsets: VMOffsets<HostPtr>,
  109|    978|        req: InstanceAllocationRequest,
  110|    978|        memories: PrimaryMap<DefinedMemoryIndex, Memory>,
  111|    978|        tables: PrimaryMap<DefinedTableIndex, Table>,
  112|    978|    ) {
  113|    978|        // The allocation must be *at least* the size required of `Instance`.
  114|    978|        assert!(alloc_size >= Self::alloc_layout(&offsets).size());
  115|       |
  116|    978|        let module = req.runtime_info.module();
  117|    978|        let dropped_elements = EntitySet::with_capacity(module.passive_elements.len());
  118|    978|        let dropped_data = EntitySet::with_capacity(module.passive_data_map.len());
  119|    978|
  120|    978|        ptr::write(
  121|    978|            ptr,
  122|    978|            Instance {
  123|    978|                runtime_info: req.runtime_info.clone(),
  124|    978|                offsets,
  125|    978|                memories,
  126|    978|                tables,
  127|    978|                dropped_elements,
  128|    978|                dropped_data,
  129|    978|                host_state: req.host_state,
  130|    978|                vmctx: VMContext {
  131|    978|                    _marker: std::marker::PhantomPinned,
  132|    978|                },
  133|    978|            },
  134|    978|        );
  135|    978|
  136|    978|        (*ptr).initialize_vmctx(module, req.store, req.imports);
  137|    978|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance9epoch_ptr:
  247|  1.30k|    pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {
  248|  1.30k|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_epoch_ptr()) }
  249|  1.30k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance10set_callee:
  293|    978|    pub(crate) unsafe fn set_callee(&mut self, callee: Option<NonNull<VMFunctionBody>>) {
  294|    978|        *self.vmctx_plus_offset(self.offsets.vmctx_callee()) =
  295|    978|            callee.map_or(ptr::null_mut(), |c| c.as_ptr());
  296|    978|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance24initialize_vmctx_globals:
  972|    978|    unsafe fn initialize_vmctx_globals(&mut self, module: &Module) {
  973|    978|        let num_imports = module.num_imported_globals;
  974|    978|        for (index, global) in module.globals.iter().skip(num_imports) {
  975|    326|            let def_index = module.defined_global_index(index).unwrap();
  976|    326|            let to = self.global_ptr(def_index);
  977|    326|
  978|    326|            // Initialize the global before writing to it
  979|    326|            ptr::write(to, VMGlobalDefinition::new());
  980|    326|
  981|    326|            match global.initializer {
  982|      0|                GlobalInit::I32Const(x) => *(*to).as_i32_mut() = x,
  983|    326|                GlobalInit::I64Const(x) => *(*to).as_i64_mut() = x,
  984|      0|                GlobalInit::F32Const(x) => *(*to).as_f32_bits_mut() = x,
  985|      0|                GlobalInit::F64Const(x) => *(*to).as_f64_bits_mut() = x,
  986|      0|                GlobalInit::V128Const(x) => *(*to).as_u128_mut() = x,
  987|      0|                GlobalInit::GetGlobal(x) => {
  988|      0|                    let from = if let Some(def_x) = module.defined_global_index(x) {
  989|      0|                        self.global(def_x)
  990|       |                    } else {
  991|      0|                        &*self.imported_global(x).from
  992|       |                    };
  993|       |                    // Globals of type `externref` need to manage the reference
  994|       |                    // count as values move between globals, everything else is just
  995|       |                    // copy-able bits.
  996|      0|                    match global.wasm_ty {
  997|       |                        WasmType::ExternRef => {
  998|      0|                            *(*to).as_externref_mut() = from.as_externref().clone()
  999|       |                        }
 1000|      0|                        _ => ptr::copy_nonoverlapping(from, to, 1),
 1001|       |                    }
 1002|       |                }
 1003|      0|                GlobalInit::RefFunc(f) => {
 1004|      0|                    *(*to).as_anyfunc_mut() = self.get_caller_checked_anyfunc(f).unwrap()
 1005|      0|                        as *const VMCallerCheckedAnyfunc;
 1006|      0|                }
 1007|      0|                GlobalInit::RefNullConst => match global.wasm_ty {
 1008|       |                    // `VMGlobalDefinition::new()` already zeroed out the bits
 1009|      0|                    WasmType::FuncRef => {}
 1010|      0|                    WasmType::ExternRef => {}
 1011|      0|                    ty => panic!("unsupported reference type for global: {:?}", ty),
 1012|       |                },
 1013|      0|                GlobalInit::Import => panic!("locally-defined global initialized as import"),
 1014|       |            }
 1015|       |        }
 1016|    978|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtB5_9vmcontext15VMRuntimeLimitsEB5_:
  141|  1.30k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.30k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.30k|            .add(usize::try_from(offset).unwrap())
  144|  1.30k|            .cast()
  145|  1.30k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance12alloc_layout:
  468|  2.93k|    fn alloc_layout(offsets: &VMOffsets<HostPtr>) -> Layout {
  469|  2.93k|        let size = mem::size_of::<Self>()
  470|  2.93k|            .checked_add(usize::try_from(offsets.size_of_vmctx()).unwrap())
  471|  2.93k|            .unwrap();
  472|  2.93k|        let align = mem::align_of::<Self>();
  473|  2.93k|        Layout::from_size_align(size, align).unwrap()
  474|  2.93k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance16initialize_vmctx:
  890|    978|    unsafe fn initialize_vmctx(&mut self, module: &Module, store: StorePtr, imports: Imports) {
  891|    978|        assert!(std::ptr::eq(module, self.module().as_ref()));
  892|       |
  893|    978|        *self.vmctx_plus_offset(self.offsets.vmctx_magic()) = VMCONTEXT_MAGIC;
  894|    978|        self.set_callee(None);
  895|    978|        self.set_store(store.as_raw());
  896|    978|
  897|    978|        // Initialize shared signatures
  898|    978|        let signatures = self.runtime_info.signature_ids();
  899|    978|        *self.vmctx_plus_offset(self.offsets.vmctx_signature_ids_array()) = signatures.as_ptr();
  900|    978|
  901|    978|        // Initialize the built-in functions
  902|    978|        *self.vmctx_plus_offset(self.offsets.vmctx_builtin_functions()) =
  903|    978|            &VMBuiltinFunctionsArray::INIT;
  904|       |
  905|       |        // Initialize the imports
  906|    978|        debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);
  907|    978|        ptr::copy_nonoverlapping(
  908|    978|            imports.functions.as_ptr(),
  909|    978|            self.vmctx_plus_offset(self.offsets.vmctx_imported_functions_begin()),
  910|    978|            imports.functions.len(),
  911|    978|        );
  912|    978|        debug_assert_eq!(imports.tables.len(), module.num_imported_tables);
  913|    978|        ptr::copy_nonoverlapping(
  914|    978|            imports.tables.as_ptr(),
  915|    978|            self.vmctx_plus_offset(self.offsets.vmctx_imported_tables_begin()),
  916|    978|            imports.tables.len(),
  917|    978|        );
  918|    978|        debug_assert_eq!(imports.memories.len(), module.num_imported_memories);
  919|    978|        ptr::copy_nonoverlapping(
  920|    978|            imports.memories.as_ptr(),
  921|    978|            self.vmctx_plus_offset(self.offsets.vmctx_imported_memories_begin()),
  922|    978|            imports.memories.len(),
  923|    978|        );
  924|    978|        debug_assert_eq!(imports.globals.len(), module.num_imported_globals);
  925|    978|        ptr::copy_nonoverlapping(
  926|    978|            imports.globals.as_ptr(),
  927|    978|            self.vmctx_plus_offset(self.offsets.vmctx_imported_globals_begin()),
  928|    978|            imports.globals.len(),
  929|    978|        );
  930|    978|
  931|    978|        // N.B.: there is no need to initialize the anyfuncs array because
  932|    978|        // we eagerly construct each element in it whenever asked for a
  933|    978|        // reference to that element. In other words, there is no state
  934|    978|        // needed to track the lazy-init, so we don't need to initialize
  935|    978|        // any state now.
  936|    978|
  937|    978|        // Initialize the defined tables
  938|    978|        let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_tables_begin());
  939|    978|        for i in 0..module.table_plans.len() - module.num_imported_tables {
  940|      0|            ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());
  941|      0|            ptr = ptr.add(1);
  942|      0|        }
  943|       |
  944|       |        // Initialize the defined memories. This fills in both the
  945|       |        // `defined_memories` table and the `owned_memories` table at the same
  946|       |        // time. Entries in `defined_memories` hold a pointer to a definition
  947|       |        // (all memories) whereas the `owned_memories` hold the actual
  948|       |        // definitions of memories owned (not shared) in the module.
  949|    978|        let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_memories_begin());
  950|    978|        let mut owned_ptr = self.vmctx_plus_offset(self.offsets.vmctx_owned_memories_begin());
  951|    978|        for i in 0..module.memory_plans.len() - module.num_imported_memories {
  952|    326|            let defined_memory_index = DefinedMemoryIndex::new(i);
  953|    326|            let memory_index = module.memory_index(defined_memory_index);
  954|    326|            if module.memory_plans[memory_index].memory.shared {
  955|      0|                let def_ptr = self.memories[defined_memory_index]
  956|      0|                    .as_shared_memory()
  957|      0|                    .unwrap()
  958|      0|                    .vmmemory_ptr_mut();
  959|      0|                ptr::write(ptr, def_ptr);
  960|    326|            } else {
  961|    326|                ptr::write(owned_ptr, self.memories[defined_memory_index].vmmemory());
  962|    326|                ptr::write(ptr, owned_ptr);
  963|    326|                owned_ptr = owned_ptr.add(1);
  964|    326|            }
  965|    326|            ptr = ptr.add(1);
  966|       |        }
  967|       |
  968|       |        // Initialize the defined globals
  969|    978|        self.initialize_vmctx_globals(module);
  970|    978|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB2_8Instance27externref_activations_table:
  252|  1.30k|    pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {
  253|  1.30k|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_externref_activations_table()) }
  254|  1.30k|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext18VMMemoryDefinitionEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }
_RNvMs2_NtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB5_14InstanceHandle19get_exported_memory:
 1097|    326|    pub fn get_exported_memory(&mut self, export: MemoryIndex) -> ExportMemory {
 1098|    326|        self.instance_mut().get_exported_memory(export)
 1099|    326|    }
_RNvMs2_NtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB5_14InstanceHandle9set_store:
 1176|    326|    pub unsafe fn set_store(&mut self, store: *mut dyn Store) {
 1177|    326|        self.instance_mut().set_store(Some(store));
 1178|    326|    }
_RINvMNtCsfBAxPD3lkOv_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtB5_9vmcontext22VMSharedSignatureIndexEB5_:
  141|    978|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    978|        (self.vmctx_ptr().cast::<u8>())
  143|    978|            .add(usize::try_from(offset).unwrap())
  144|    978|            .cast()
  145|    978|    }

_RNCNvMs_NtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB6_25OnDemandInstanceAllocator15create_memories0Ba_:
  477|    652|            .unwrap_or_else(|| &DefaultMemoryCreator);
_RNvMs_NtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator13create_tables:
  447|    652|    fn create_tables(
  448|    652|        store: &mut StorePtr,
  449|    652|        runtime_info: &Arc<dyn ModuleRuntimeInfo>,
  450|    652|    ) -> Result<PrimaryMap<DefinedTableIndex, Table>, InstantiationError> {
  451|    652|        let module = runtime_info.module();
  452|    652|        let num_imports = module.num_imported_tables;
  453|    652|        let mut tables: PrimaryMap<DefinedTableIndex, _> =
  454|    652|            PrimaryMap::with_capacity(module.table_plans.len() - num_imports);
  455|    652|        for (_, table) in module.table_plans.iter().skip(num_imports) {
  456|       |            tables.push(
  457|      0|                Table::new_dynamic(table, unsafe {
  458|      0|                    store
  459|      0|                        .get()
  460|      0|                        .expect("if module has table plans, store is not empty")
  461|      0|                })
  462|      0|                .map_err(InstantiationError::Resource)?,
  463|       |            );
  464|       |        }
  465|    652|        Ok(tables)
  466|    652|    }
_RNvXs1_NtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtB5_17InstanceAllocator10deallocate:
  575|    978|    unsafe fn deallocate(&self, handle: &InstanceHandle) {
  576|    978|        deallocate(handle)
  577|    978|    }
_RNvXs0_NtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  508|    652|    fn default() -> Self {
  509|    652|        Self {
  510|    652|            mem_creator: None,
  511|    652|            #[cfg(feature = "async")]
  512|    652|            stack_size: 0,
  513|    652|        }
  514|    652|    }
_RNvMs_NtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator15create_memories:
  468|    652|    fn create_memories(
  469|    652|        &self,
  470|    652|        store: &mut StorePtr,
  471|    652|        runtime_info: &Arc<dyn ModuleRuntimeInfo>,
  472|    652|    ) -> Result<PrimaryMap<DefinedMemoryIndex, Memory>, InstantiationError> {
  473|    652|        let module = runtime_info.module();
  474|    652|        let creator = self
  475|    652|            .mem_creator
  476|    652|            .as_deref()
  477|    652|            .unwrap_or_else(|| &DefaultMemoryCreator);
  478|    652|        let num_imports = module.num_imported_memories;
  479|    652|        let mut memories: PrimaryMap<DefinedMemoryIndex, _> =
  480|    652|            PrimaryMap::with_capacity(module.memory_plans.len() - num_imports);
  481|    652|        for (memory_idx, plan) in module.memory_plans.iter().skip(num_imports) {
  482|      0|            let defined_memory_idx = module
  483|      0|                .defined_memory_index(memory_idx)
  484|      0|                .expect("Skipped imports, should never be None");
  485|      0|            let image = runtime_info
  486|      0|                .memory_image(defined_memory_idx)
  487|      0|                .map_err(|err| InstantiationError::Resource(err.into()))?;
  488|       |
  489|       |            memories.push(
  490|      0|                Memory::new_dynamic(
  491|      0|                    plan,
  492|      0|                    creator,
  493|      0|                    unsafe {
  494|      0|                        store
  495|      0|                            .get()
  496|      0|                            .expect("if module has memory plans, store is not empty")
  497|      0|                    },
  498|      0|                    image,
  499|      0|                )
  500|      0|                .map_err(InstantiationError::Resource)?,
  501|       |            );
  502|       |        }
  503|    652|        Ok(memories)
  504|    652|    }
_RNvMNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr3new:
   70|    652|    pub fn new(ptr: *mut dyn Store) -> Self {
   71|    652|        Self(Some(ptr))
   72|    652|    }
_RNvNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator31allocate_single_memory_instance:
  523|    326|pub unsafe fn allocate_single_memory_instance(
  524|    326|    req: InstanceAllocationRequest,
  525|    326|    memory: Memory,
  526|    326|) -> Result<InstanceHandle, InstantiationError> {
  527|    326|    let mut memories = PrimaryMap::default();
  528|    326|    memories.push(memory);
  529|    326|    let tables = PrimaryMap::default();
  530|    326|    let module = req.runtime_info.module();
  531|    326|    let offsets = VMOffsets::new(HostPtr, module);
  532|    326|    let layout = Instance::alloc_layout(&offsets);
  533|    326|    let instance = alloc::alloc(layout) as *mut Instance;
  534|    326|    Instance::new_at(instance, layout.size(), offsets, req, memories, tables);
  535|    326|    Ok(InstanceHandle { instance })
  536|    326|}
_RNvMs_NtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator3new:
  438|    326|    pub fn new(mem_creator: Option<Arc<dyn RuntimeMemoryCreator>>, stack_size: usize) -> Self {
  439|    326|        drop(stack_size); // suppress unused warnings w/o async feature
  440|    326|        Self {
  441|    326|            mem_creator,
  442|    326|            #[cfg(feature = "async")]
  443|    326|            stack_size,
  444|    326|        }
  445|    326|    }
_RNvMNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr5empty:
   66|    326|    pub fn empty() -> Self {
   67|    326|        Self(None)
   68|    326|    }
_RNvMNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr6as_raw:
   74|    978|    pub fn as_raw(&self) -> Option<*mut dyn Store> {
   75|    978|        self.0.clone()
   76|    978|    }
_RNvNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator10deallocate:
  541|    978|pub unsafe fn deallocate(handle: &InstanceHandle) {
  542|    978|    let layout = Instance::alloc_layout(&handle.instance().offsets);
  543|    978|    ptr::drop_in_place(handle.instance);
  544|    978|    alloc::dealloc(handle.instance.cast(), layout);
  545|    978|}
_RNvXs1_NtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtB5_17InstanceAllocator8allocate:
  548|    652|    unsafe fn allocate(
  549|    652|        &self,
  550|    652|        mut req: InstanceAllocationRequest,
  551|    652|    ) -> Result<InstanceHandle, InstantiationError> {
  552|    652|        let memories = self.create_memories(&mut req.store, &req.runtime_info)?;
  553|    652|        let tables = Self::create_tables(&mut req.store, &req.runtime_info)?;
  554|    652|        let module = req.runtime_info.module();
  555|    652|        let offsets = VMOffsets::new(HostPtr, module);
  556|    652|        let layout = Instance::alloc_layout(&offsets);
  557|    652|        let instance_ptr = alloc::alloc(layout) as *mut Instance;
  558|    652|
  559|    652|        Instance::new_at(instance_ptr, layout.size(), offsets, req, memories, tables);
  560|    652|
  561|    652|        Ok(InstanceHandle {
  562|    652|            instance: instance_ptr,
  563|    652|        })
  564|    652|    }

_RNvXs8_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB5_14InstanceLimitsNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   54|    326|#[derive(Debug, Copy, Clone)]
_RNvXsa_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB5_25PoolingAllocationStrategyNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  173|    326|#[derive(Debug, Clone, Copy, PartialEq, Eq)]
_RNvMs4_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB5_24PoolingInstanceAllocator3new:
 1049|    326|    pub fn new(
 1050|    326|        strategy: PoolingAllocationStrategy,
 1051|    326|        instance_limits: InstanceLimits,
 1052|    326|        stack_size: usize,
 1053|    326|        tunables: &Tunables,
 1054|    326|        async_stack_zeroing: bool,
 1055|    326|    ) -> Result<Self> {
 1056|    326|        if instance_limits.count == 0 {
 1057|      0|            bail!("the instance count limit cannot be zero");
 1058|    326|        }
 1059|       |
 1060|    326|        let instances = InstancePool::new(strategy, &instance_limits, tunables)?;
 1061|       |
 1062|    326|        drop(stack_size); // suppress unused warnings w/o async feature
 1063|    326|        drop(async_stack_zeroing); // suppress unused warnings w/o async feature
 1064|    326|
 1065|    326|        Ok(Self {
 1066|    326|            instances: instances,
 1067|    326|            #[cfg(all(feature = "async", unix))]
 1068|    326|            stacks: StackPool::new(&instance_limits, stack_size, async_stack_zeroing)?,
 1069|    326|            #[cfg(all(feature = "async", windows))]
 1070|    326|            stack_size,
 1071|    326|        })
 1072|    326|    }
_RNvXNtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB2_14InstanceLimitsNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  159|    326|    fn default() -> Self {
  160|    326|        // See doc comments for `wasmtime::InstanceLimits` for these default values
  161|    326|        Self {
  162|    326|            count: 1000,
  163|    326|            size: 1 << 20, // 1 MB
  164|    326|            tables: 1,
  165|    326|            table_elements: 10_000,
  166|    326|            memories: 1,
  167|    326|            memory_pages: 160,
  168|    326|        }
  169|    326|    }
_RNCNvMs1_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news_0Bd_:
  738|    326|            .and_then(|c| c.checked_mul(max_instances))
_RNCNvMs3_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB7_9TablePool3news_0Bd_:
  861|    326|            .and_then(|c| c.checked_mul(max_instances))
_RNvMs0_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB5_12InstancePool3new:
  212|    326|    fn new(
  213|    326|        strategy: PoolingAllocationStrategy,
  214|    326|        instance_limits: &InstanceLimits,
  215|    326|        tunables: &Tunables,
  216|    326|    ) -> Result<Self> {
  217|    326|        let page_size = crate::page_size();
  218|    326|
  219|    326|        let instance_size = round_up_to_pow2(instance_limits.size, mem::align_of::<Instance>());
  220|    326|
  221|    326|        let max_instances = instance_limits.count as usize;
  222|       |
  223|    326|        let allocation_size = round_up_to_pow2(
  224|    326|            instance_size
  225|    326|                .checked_mul(max_instances)
  226|    326|                .ok_or_else(|| anyhow!("total size of instance data exceeds addressable memory"))?,
  227|    326|            page_size,
  228|       |        );
  229|       |
  230|    326|        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)
  231|    326|            .context("failed to create instance pool mapping")?;
  232|       |
  233|    326|        let pool = Self {
  234|    326|            mapping,
  235|    326|            instance_size,
  236|    326|            max_instances,
  237|    326|            index_allocator: Mutex::new(PoolingAllocationState::new(strategy, max_instances)),
  238|    326|            memories: MemoryPool::new(instance_limits, tunables)?,
  239|    326|            tables: TablePool::new(instance_limits)?,
  240|       |        };
  241|       |
  242|    326|        Ok(pool)
  243|    326|    }
_RNCNvMs1_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news2_0Bd_:
  753|   334k|        let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))
_RNvMs1_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB5_10MemoryPool3new:
  685|    326|    fn new(instance_limits: &InstanceLimits, tunables: &Tunables) -> Result<Self> {
  686|    326|        // The maximum module memory page count cannot exceed 65536 pages
  687|    326|        if instance_limits.memory_pages > 0x10000 {
  688|      0|            bail!(
  689|      0|                "module memory page limit of {} exceeds the maximum of 65536",
  690|      0|                instance_limits.memory_pages
  691|      0|            );
  692|    326|        }
  693|    326|
  694|    326|        // The maximum module memory page count cannot exceed the memory reservation size
  695|    326|        if u64::from(instance_limits.memory_pages) > tunables.static_memory_bound {
  696|      0|            bail!(
  697|      0|                "module memory page limit of {} pages exceeds maximum static memory limit of {} pages",
  698|      0|                instance_limits.memory_pages,
  699|      0|                tunables.static_memory_bound,
  700|      0|            );
  701|    326|        }
  702|    326|
  703|    326|        let static_memory_bound =
  704|    326|            u64::from(tunables.static_memory_bound) * u64::from(WASM_PAGE_SIZE);
  705|    326|        let memory_size =
  706|    326|            usize::try_from(static_memory_bound + tunables.static_memory_offset_guard_size)
  707|    326|                .map_err(|_| anyhow!("memory reservation size exceeds addressable memory"))?;
  708|       |
  709|    326|        assert!(
  710|    326|            memory_size % crate::page_size() == 0,
  711|      0|            "memory size {} is not a multiple of system page size",
  712|       |            memory_size
  713|       |        );
  714|       |
  715|    326|        let max_instances = instance_limits.count as usize;
  716|    326|        let max_memories = instance_limits.memories as usize;
  717|    326|        let initial_memory_offset = if tunables.guard_before_linear_memory {
  718|    326|            usize::try_from(tunables.static_memory_offset_guard_size).unwrap()
  719|       |        } else {
  720|      0|            0
  721|       |        };
  722|       |
  723|       |        // The entire allocation here is the size of each memory times the
  724|       |        // max memories per instance times the number of instances allowed in
  725|       |        // this pool, plus guard regions.
  726|       |        //
  727|       |        // Note, though, that guard regions are required to be after each linear
  728|       |        // memory. If the `guard_before_linear_memory` setting is specified,
  729|       |        // then due to the contiguous layout of linear memories the guard pages
  730|       |        // after one memory are also guard pages preceding the next linear
  731|       |        // memory. This means that we only need to handle pre-guard-page sizes
  732|       |        // specially for the first linear memory, hence the
  733|       |        // `initial_memory_offset` variable here. If guards aren't specified
  734|       |        // before linear memories this is set to `0`, otherwise it's set to
  735|       |        // the same size as guard regions for other memories.
  736|    326|        let allocation_size = memory_size
  737|    326|            .checked_mul(max_memories)
  738|    326|            .and_then(|c| c.checked_mul(max_instances))
  739|    326|            .and_then(|c| c.checked_add(initial_memory_offset))
  740|    326|            .ok_or_else(|| {
  741|       |                anyhow!("total size of memory reservation exceeds addressable memory")
  742|    326|            })?;
  743|       |
  744|       |        // Create a completely inaccessible region to start
  745|    326|        let mapping = Mmap::accessible_reserved(0, allocation_size)
  746|    326|            .context("failed to create memory pool mapping")?;
  747|       |
  748|    326|        let num_image_slots = if cfg!(memory_init_cow) {
  749|    326|            max_instances * max_memories
  750|       |        } else {
  751|      0|            0
  752|       |        };
  753|    326|        let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))
  754|    326|            .take(num_image_slots)
  755|    326|            .collect();
  756|    326|
  757|    326|        let pool = Self {
  758|    326|            mapping,
  759|    326|            image_slots,
  760|    326|            memory_reservation_size: memory_size,
  761|    326|            initial_memory_offset,
  762|    326|            max_memories,
  763|    326|            max_instances,
  764|    326|            max_memory_size: (instance_limits.memory_pages as usize) * (WASM_PAGE_SIZE as usize),
  765|    326|            static_memory_bound,
  766|    326|        };
  767|    326|
  768|    326|        Ok(pool)
  769|    326|    }
_RNvNtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7pooling16round_up_to_pow2:
   47|    978|fn round_up_to_pow2(n: usize, to: usize) -> usize {
   48|    978|    debug_assert!(to > 0);
   49|    978|    debug_assert!(to.is_power_of_two());
   50|    978|    (n + to - 1) & !(to - 1)
   51|    978|}
_RNvXs5_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB5_24PoolingInstanceAllocatorNtB7_17InstanceAllocator15adjust_tunables:
 1091|    326|    fn adjust_tunables(&self, tunables: &mut Tunables) {
 1092|    326|        // Treat the static memory bound as the maximum for unbounded Wasm memories
 1093|    326|        // Because we guarantee a module cannot compile unless it fits in the limits of
 1094|    326|        // the pool allocator, this ensures all memories are treated as static (i.e. immovable).
 1095|    326|        tunables.static_memory_bound_is_maximum = true;
 1096|    326|    }
_RNvXs2_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB5_10MemoryPoolNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
  818|    326|    fn drop(&mut self) {
  819|       |        // Clear the `clear_no_drop` flag (i.e., ask to *not* clear on
  820|       |        // drop) for all slots, and then drop them here. This is
  821|       |        // valid because the one `Mmap` that covers the whole region
  822|       |        // can just do its one munmap.
  823|   334k|        for mut slot in std::mem::take(&mut self.image_slots) {
  824|   334k|            if let Some(slot) = slot.get_mut().unwrap() {
  825|      0|                slot.no_clear_on_drop();
  826|   334k|            }
  827|       |        }
  828|    326|    }
_RNCNvMs1_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news0_0Bd_:
  739|    326|            .and_then(|c| c.checked_add(initial_memory_offset))
_RNvMs3_NtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7poolingNtB5_9TablePool3new:
  846|    326|    fn new(instance_limits: &InstanceLimits) -> Result<Self> {
  847|    326|        let page_size = crate::page_size();
  848|       |
  849|    326|        let table_size = round_up_to_pow2(
  850|    326|            mem::size_of::<*mut u8>()
  851|    326|                .checked_mul(instance_limits.table_elements as usize)
  852|    326|                .ok_or_else(|| anyhow!("table size exceeds addressable memory"))?,
  853|    326|            page_size,
  854|    326|        );
  855|    326|
  856|    326|        let max_instances = instance_limits.count as usize;
  857|    326|        let max_tables = instance_limits.tables as usize;
  858|       |
  859|    326|        let allocation_size = table_size
  860|    326|            .checked_mul(max_tables)
  861|    326|            .and_then(|c| c.checked_mul(max_instances))
  862|    326|            .ok_or_else(|| anyhow!("total size of instance tables exceeds addressable memory"))?;
  863|       |
  864|    326|        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)
  865|    326|            .context("failed to create table pool mapping")?;
  866|       |
  867|    326|        Ok(Self {
  868|    326|            mapping,
  869|    326|            table_size,
  870|    326|            max_tables,
  871|    326|            max_instances,
  872|    326|            page_size,
  873|    326|            max_elements: instance_limits.table_elements,
  874|    326|        })
  875|    326|    }

_RNvMs3_NtNtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB5_22PoolingAllocationState3new:
  251|    326|    pub(crate) fn new(strategy: PoolingAllocationStrategy, max_instances: usize) -> Self {
  252|    326|        let ids = (0..max_instances).map(|i| SlotId(i)).collect::<Vec<_>>();
  253|    326|        match strategy {
  254|      0|            PoolingAllocationStrategy::NextAvailable => PoolingAllocationState::NextAvailable(ids),
  255|      0|            PoolingAllocationStrategy::Random => PoolingAllocationState::Random(ids),
  256|    326|            PoolingAllocationStrategy::ReuseAffinity => PoolingAllocationState::ReuseAffinity {
  257|    326|                free_list: ids,
  258|    326|                per_module: HashMap::new(),
  259|    326|                slot_state: (0..max_instances)
  260|    326|                    .map(|i| {
  261|       |                        SlotState::Free(FreeSlotState::NoAffinity {
  262|       |                            free_list_index: GlobalFreeListIndex(i),
  263|       |                        })
  264|    326|                    })
  265|    326|                    .collect(),
  266|    326|            },
  267|       |        }
  268|    326|    }
_RNCNvMs3_NtNtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB7_22PoolingAllocationState3new0Bf_:
  252|   334k|        let ids = (0..max_instances).map(|i| SlotId(i)).collect::<Vec<_>>();
_RNCNvMs3_NtNtNtNtCsfBAxPD3lkOv_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB7_22PoolingAllocationState3news_0Bf_:
  260|   334k|                    .map(|i| {
  261|   334k|                        SlotState::Free(FreeSlotState::NoAffinity {
  262|   334k|                            free_list_index: GlobalFreeListIndex(i),
  263|   334k|                        })
  264|   334k|                    })

_RNvCsfBAxPD3lkOv_16wasmtime_runtime9page_size:
  207|  2.28k|pub fn page_size() -> usize {
  208|  2.28k|    static PAGE_SIZE: AtomicUsize = AtomicUsize::new(0);
  209|  2.28k|
  210|  2.28k|    return match PAGE_SIZE.load(Ordering::Relaxed) {
  211|       |        0 => {
  212|      1|            let size = get_page_size();
  213|      1|            assert!(size != 0);
  214|      1|            PAGE_SIZE.store(size, Ordering::Relaxed);
  215|      1|            size
  216|       |        }
  217|  2.28k|        n => n,
  218|       |    };
  219|       |
  220|       |    #[cfg(windows)]
  221|       |    fn get_page_size() -> usize {
  222|       |        use std::mem::MaybeUninit;
  223|       |        use windows_sys::Win32::System::SystemInformation::*;
  224|       |
  225|       |        unsafe {
  226|       |            let mut info = MaybeUninit::uninit();
  227|       |            GetSystemInfo(info.as_mut_ptr());
  228|       |            info.assume_init_ref().dwPageSize as usize
  229|       |        }
  230|       |    }
  231|       |
  232|       |    #[cfg(unix)]
  233|       |    fn get_page_size() -> usize {
  234|       |        unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }
  235|       |    }
  236|  2.28k|}
_RNvNvCsfBAxPD3lkOv_16wasmtime_runtime9page_size13get_page_size:
  233|      1|    fn get_page_size() -> usize {
  234|      1|        unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }
  235|      1|    }

_RNvXs0_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB5_10MmapMemoryNtB5_19RuntimeLinearMemory8vmmemory:
  326|    326|    fn vmmemory(&mut self) -> VMMemoryDefinition {
  327|    326|        VMMemoryDefinition {
  328|    326|            base: unsafe { self.mmap.as_mut_ptr().add(self.pre_guard_size) },
  329|    326|            current_length: self.accessible.into(),
  330|    326|        }
  331|    326|    }
_RNvXNtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB2_20DefaultMemoryCreatorNtB2_20RuntimeMemoryCreator10new_memory:
   38|    326|    fn new_memory(
   39|    326|        &self,
   40|    326|        plan: &MemoryPlan,
   41|    326|        minimum: usize,
   42|    326|        maximum: Option<usize>,
   43|    326|        memory_image: Option<&Arc<MemoryImage>>,
   44|    326|    ) -> Result<Box<dyn RuntimeLinearMemory>> {
   45|    326|        Ok(Box::new(MmapMemory::new(
   46|    326|            plan,
   47|    326|            minimum,
   48|    326|            maximum,
   49|    326|            memory_image,
   50|    326|        )?))
   51|    326|    }
_RNvMs7_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB5_6Memory11new_dynamic:
  610|    326|    pub fn new_dynamic(
  611|    326|        plan: &MemoryPlan,
  612|    326|        creator: &dyn RuntimeMemoryCreator,
  613|    326|        store: &mut dyn Store,
  614|    326|        memory_image: Option<&Arc<MemoryImage>>,
  615|    326|    ) -> Result<Self> {
  616|    326|        let (minimum, maximum) = Self::limit_new(plan, Some(store))?;
  617|    326|        let allocation = creator.new_memory(plan, minimum, maximum, memory_image)?;
  618|    326|        let allocation = if plan.memory.shared {
  619|      0|            Box::new(SharedMemory::wrap(plan, allocation, plan.memory)?)
  620|       |        } else {
  621|    326|            allocation
  622|       |        };
  623|    326|        Ok(Memory(allocation))
  624|    326|    }
_RNCNvMs_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB6_10MmapMemory3news_0B8_:
  227|    326|            .and_then(|i| i.checked_add(offset_guard_bytes))
_RNCNvMs7_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB7_6Memory9limit_new0B9_:
  688|    326|            .and_then(|m| usize::try_from(m).ok());
_RNCNvMs7_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB7_6Memory9limit_news_0B9_:
  696|    326|        let mut maximum = plan.memory.maximum.map(|max| {
  697|    326|            usize::try_from(max)
  698|    326|                .ok()
  699|    326|                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
  700|    326|                .unwrap_or(absolute_max)
  701|    326|        });
_RNvMs7_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB5_6Memory9limit_new:
  654|    326|    fn limit_new(
  655|    326|        plan: &MemoryPlan,
  656|    326|        store: Option<&mut dyn Store>,
  657|    326|    ) -> Result<(usize, Option<usize>)> {
  658|       |        // Sanity-check what should already be true from wasm module validation.
  659|    326|        let absolute_max = if plan.memory.memory64 {
  660|      0|            WASM64_MAX_PAGES
  661|       |        } else {
  662|    326|            WASM32_MAX_PAGES
  663|       |        };
  664|    326|        assert!(plan.memory.minimum <= absolute_max);
  665|    326|        assert!(plan.memory.maximum.is_none() || plan.memory.maximum.unwrap() <= absolute_max);
  666|       |
  667|       |        // This is the absolute possible maximum that the module can try to
  668|       |        // allocate, which is our entire address space minus a wasm page. That
  669|       |        // shouldn't ever actually work in terms of an allocation because
  670|       |        // presumably the kernel wants *something* for itself, but this is used
  671|       |        // to pass to the `store`'s limiter for a requested size
  672|       |        // to approximate the scale of the request that the wasm module is
  673|       |        // making. This is necessary because the limiter works on `usize` bytes
  674|       |        // whereas we're working with possibly-overflowing `u64` calculations
  675|       |        // here. To actually faithfully represent the byte requests of modules
  676|       |        // we'd have to represent things as `u128`, but that's kinda
  677|       |        // overkill for this purpose.
  678|    326|        let absolute_max = 0usize.wrapping_sub(WASM_PAGE_SIZE);
  679|    326|
  680|    326|        // If the minimum memory size overflows the size of our own address
  681|    326|        // space, then we can't satisfy this request, but defer the error to
  682|    326|        // later so the `store` can be informed that an effective oom is
  683|    326|        // happening.
  684|    326|        let minimum = plan
  685|    326|            .memory
  686|    326|            .minimum
  687|    326|            .checked_mul(WASM_PAGE_SIZE_U64)
  688|    326|            .and_then(|m| usize::try_from(m).ok());
  689|    326|
  690|    326|        // The plan stores the maximum size in units of wasm pages, but we
  691|    326|        // use units of bytes. Unlike for the `minimum` size we silently clamp
  692|    326|        // the effective maximum size to `absolute_max` above if the maximum is
  693|    326|        // too large. This should be ok since as a wasm runtime we get to
  694|    326|        // arbitrarily decide the actual maximum size of memory, regardless of
  695|    326|        // what's actually listed on the memory itself.
  696|    326|        let mut maximum = plan.memory.maximum.map(|max| {
  697|       |            usize::try_from(max)
  698|       |                .ok()
  699|       |                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
  700|       |                .unwrap_or(absolute_max)
  701|    326|        });
  702|    326|
  703|    326|        // If this is a 32-bit memory and no maximum is otherwise listed then we
  704|    326|        // need to still specify a maximum size of 4GB. If the host platform is
  705|    326|        // 32-bit then there's no need to limit the maximum this way since no
  706|    326|        // allocation of 4GB can succeed, but for 64-bit platforms this is
  707|    326|        // required to limit memories to 4GB.
  708|    326|        if !plan.memory.memory64 && maximum.is_none() {
  709|      0|            maximum = usize::try_from(1u64 << 32).ok();
  710|    326|        }
  711|       |
  712|       |        // Inform the store's limiter what's about to happen. This will let the
  713|       |        // limiter reject anything if necessary, and this also guarantees that
  714|       |        // we should call the limiter for all requested memories, even if our
  715|       |        // `minimum` calculation overflowed. This means that the `minimum` we're
  716|       |        // informing the limiter is lossy and may not be 100% accurate, but for
  717|       |        // now the expected uses of limiter means that's ok.
  718|    326|        if let Some(store) = store {
  719|       |            // We ignore the store limits for shared memories since they are
  720|       |            // technically not created within a store (though, trickily, they
  721|       |            // may be associated with one in order to get a `vmctx`).
  722|    326|            if !plan.memory.shared {
  723|    326|                if !store.memory_growing(0, minimum.unwrap_or(absolute_max), maximum)? {
  724|      0|                    bail!(
  725|      0|                        "memory minimum size of {} pages exceeds memory limits",
  726|      0|                        plan.memory.minimum
  727|      0|                    );
  728|    326|                }
  729|      0|            }
  730|      0|        }
  731|       |
  732|       |        // At this point we need to actually handle overflows, so bail out with
  733|       |        // an error if we made it this far.
  734|    326|        let minimum = minimum.ok_or_else(|| {
  735|       |            format_err!(
  736|       |                "memory minimum size of {} pages exceeds memory limits",
  737|       |                plan.memory.minimum
  738|       |            )
  739|    326|        })?;
  740|    326|        Ok((minimum, maximum))
  741|    326|    }
_RNvMs_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB4_10MmapMemory3new:
  193|    326|    pub fn new(
  194|    326|        plan: &MemoryPlan,
  195|    326|        minimum: usize,
  196|    326|        mut maximum: Option<usize>,
  197|    326|        memory_image: Option<&Arc<MemoryImage>>,
  198|    326|    ) -> Result<Self> {
  199|    326|        // It's a programmer error for these two configuration values to exceed
  200|    326|        // the host available address space, so panic if such a configuration is
  201|    326|        // found (mostly an issue for hypothetical 32-bit hosts).
  202|    326|        let offset_guard_bytes = usize::try_from(plan.offset_guard_size).unwrap();
  203|    326|        let pre_guard_bytes = usize::try_from(plan.pre_guard_size).unwrap();
  204|       |
  205|    326|        let (alloc_bytes, extra_to_reserve_on_growth) = match plan.style {
  206|       |            // Dynamic memories start with the minimum size plus the `reserve`
  207|       |            // amount specified to grow into.
  208|      0|            MemoryStyle::Dynamic { reserve } => (minimum, usize::try_from(reserve).unwrap()),
  209|       |
  210|       |            // Static memories will never move in memory and consequently get
  211|       |            // their entire allocation up-front with no extra room to grow into.
  212|       |            // Note that the `maximum` is adjusted here to whatever the smaller
  213|       |            // of the two is, the `maximum` given or the `bound` specified for
  214|       |            // this memory.
  215|    326|            MemoryStyle::Static { bound } => {
  216|    326|                assert!(bound >= plan.memory.minimum);
  217|    326|                let bound_bytes =
  218|    326|                    usize::try_from(bound.checked_mul(WASM_PAGE_SIZE_U64).unwrap()).unwrap();
  219|    326|                maximum = Some(bound_bytes.min(maximum.unwrap_or(usize::MAX)));
  220|    326|                (bound_bytes, 0)
  221|       |            }
  222|       |        };
  223|       |
  224|    326|        let request_bytes = pre_guard_bytes
  225|    326|            .checked_add(alloc_bytes)
  226|    326|            .and_then(|i| i.checked_add(extra_to_reserve_on_growth))
  227|    326|            .and_then(|i| i.checked_add(offset_guard_bytes))
  228|    326|            .ok_or_else(|| format_err!("cannot allocate {} with guard regions", minimum))?;
  229|    326|        let mut mmap = Mmap::accessible_reserved(0, request_bytes)?;
  230|       |
  231|    326|        if minimum > 0 {
  232|      0|            mmap.make_accessible(pre_guard_bytes, minimum)?;
  233|    326|        }
  234|       |
  235|       |        // If a memory image was specified, try to create the MemoryImageSlot on
  236|       |        // top of our mmap.
  237|    326|        let memory_image = match memory_image {
  238|      0|            Some(image) => {
  239|      0|                let base = unsafe { mmap.as_mut_ptr().add(pre_guard_bytes) };
  240|      0|                let mut slot = MemoryImageSlot::create(
  241|      0|                    base.cast(),
  242|      0|                    minimum,
  243|      0|                    alloc_bytes + extra_to_reserve_on_growth,
  244|      0|                );
  245|      0|                slot.instantiate(minimum, Some(image))?;
  246|       |                // On drop, we will unmap our mmap'd range that this slot was
  247|       |                // mapped on top of, so there is no need for the slot to wipe
  248|       |                // it with an anonymous mapping first.
  249|      0|                slot.no_clear_on_drop();
  250|      0|                Some(slot)
  251|       |            }
  252|    326|            None => None,
  253|       |        };
  254|       |
  255|    326|        Ok(Self {
  256|    326|            mmap,
  257|    326|            accessible: minimum,
  258|    326|            maximum,
  259|    326|            pre_guard_size: pre_guard_bytes,
  260|    326|            offset_guard_size: offset_guard_bytes,
  261|    326|            extra_to_reserve_on_growth,
  262|    326|            memory_image,
  263|    326|        })
  264|    326|    }
_RNvMs7_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB5_6Memory8vmmemory:
  793|    326|    pub fn vmmemory(&mut self) -> VMMemoryDefinition {
  794|    326|        self.0.vmmemory()
  795|    326|    }
_RNCNCNvMs7_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB9_6Memory9limit_news_00Bb_:
  699|    326|                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
_RNCNvMs_NtCsfBAxPD3lkOv_16wasmtime_runtime6memoryNtB6_10MmapMemory3new0B8_:
  226|    326|            .and_then(|i| i.checked_add(extra_to_reserve_on_growth))

_RNvXs_NtCsfBAxPD3lkOv_16wasmtime_runtime4mmapNtB4_4MmapNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
  454|  1.30k|    fn drop(&mut self) {
  455|  1.30k|        if self.len != 0 {
  456|  1.30k|            unsafe { rustix::mm::munmap(self.ptr as *mut std::ffi::c_void, self.len) }
  457|  1.30k|                .expect("munmap failed");
  458|  1.30k|        }
  459|  1.30k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime4mmapNtB2_4Mmap19accessible_reserved:
  160|  1.30k|    pub fn accessible_reserved(accessible_size: usize, mapping_size: usize) -> Result<Self> {
  161|  1.30k|        let page_size = crate::page_size();
  162|  1.30k|        assert!(accessible_size <= mapping_size);
  163|  1.30k|        assert_eq!(mapping_size & (page_size - 1), 0);
  164|  1.30k|        assert_eq!(accessible_size & (page_size - 1), 0);
  165|       |
  166|       |        // Mmap may return EINVAL if the size is zero, so just
  167|       |        // special-case that.
  168|  1.30k|        if mapping_size == 0 {
  169|      0|            return Ok(Self::new());
  170|  1.30k|        }
  171|  1.30k|
  172|  1.30k|        Ok(if accessible_size == mapping_size {
  173|       |            // Allocate a single read-write region at once.
  174|    652|            let ptr = unsafe {
  175|    652|                rustix::mm::mmap_anonymous(
  176|    652|                    ptr::null_mut(),
  177|    652|                    mapping_size,
  178|    652|                    rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,
  179|    652|                    rustix::mm::MapFlags::PRIVATE,
  180|    652|                )
  181|    652|                .context(format!("mmap failed to allocate {:#x} bytes", mapping_size))?
  182|       |            };
  183|       |
  184|    652|            Self {
  185|    652|                ptr: ptr as usize,
  186|    652|                len: mapping_size,
  187|    652|                file: None,
  188|    652|            }
  189|       |        } else {
  190|       |            // Reserve the mapping size.
  191|    652|            let ptr = unsafe {
  192|    652|                rustix::mm::mmap_anonymous(
  193|    652|                    ptr::null_mut(),
  194|    652|                    mapping_size,
  195|    652|                    rustix::mm::ProtFlags::empty(),
  196|    652|                    rustix::mm::MapFlags::PRIVATE,
  197|    652|                )
  198|    652|                .context(format!("mmap failed to allocate {:#x} bytes", mapping_size))?
  199|       |            };
  200|       |
  201|    652|            let mut result = Self {
  202|    652|                ptr: ptr as usize,
  203|    652|                len: mapping_size,
  204|    652|                file: None,
  205|    652|            };
  206|    652|
  207|    652|            if accessible_size != 0 {
  208|       |                // Commit the accessible size.
  209|      0|                result.make_accessible(0, accessible_size)?;
  210|    652|            }
  211|       |
  212|    652|            result
  213|       |        })
  214|  1.30k|    }
_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime4mmapNtB2_4Mmap10as_mut_ptr:
  353|    326|    pub fn as_mut_ptr(&self) -> *mut u8 {
  354|    326|        self.ptr as *mut u8
  355|    326|    }

_RNvMNtCsfBAxPD3lkOv_16wasmtime_runtime9module_idNtB2_25CompiledModuleIdAllocator3new:
   20|    326|    pub fn new() -> Self {
   21|    326|        Self {
   22|    326|            next: AtomicU64::new(1),
   23|    326|        }
   24|    326|    }

_RNvNtCsfBAxPD3lkOv_16wasmtime_runtime12traphandlers10init_traps:
   65|    326|pub fn init_traps(is_wasm_pc: fn(usize) -> bool) {
   66|    326|    static INIT: Once = Once::new();
   67|    326|    INIT.call_once(|| unsafe {
   68|       |        IS_WASM_PC = is_wasm_pc;
   69|       |        sys::platform_init();
   70|    326|    });
   71|    326|}
_RNCNvNtCsfBAxPD3lkOv_16wasmtime_runtime12traphandlers10init_traps0B5_:
   67|      1|    INIT.call_once(|| unsafe {
   68|      1|        IS_WASM_PC = is_wasm_pc;
   69|      1|        sys::platform_init();
   70|      1|    });

_RNvNtNtCsfBAxPD3lkOv_16wasmtime_runtime12traphandlers4unix13platform_init:
   16|      1|pub unsafe fn platform_init() {
   17|      1|    let register = |slot: &mut MaybeUninit<libc::sigaction>, signal: i32| {
   18|       |        let mut handler: libc::sigaction = mem::zeroed();
   19|       |        // The flags here are relatively careful, and they are...
   20|       |        //
   21|       |        // SA_SIGINFO gives us access to information like the program
   22|       |        // counter from where the fault happened.
   23|       |        //
   24|       |        // SA_ONSTACK allows us to handle signals on an alternate stack,
   25|       |        // so that the handler can run in response to running out of
   26|       |        // stack space on the main stack. Rust installs an alternate
   27|       |        // stack with sigaltstack, so we rely on that.
   28|       |        //
   29|       |        // SA_NODEFER allows us to reenter the signal handler if we
   30|       |        // crash while handling the signal, and fall through to the
   31|       |        // Breakpad handler by testing handlingSegFault.
   32|       |        handler.sa_flags = libc::SA_SIGINFO | libc::SA_NODEFER | libc::SA_ONSTACK;
   33|       |        handler.sa_sigaction = trap_handler as usize;
   34|       |        libc::sigemptyset(&mut handler.sa_mask);
   35|       |        if libc::sigaction(signal, &handler, slot.as_mut_ptr()) != 0 {
   36|       |            panic!(
   37|       |                "unable to install signal handler: {}",
   38|       |                io::Error::last_os_error(),
   39|       |            );
   40|       |        }
   41|       |    };
   42|       |
   43|       |    // Allow handling OOB with signals on all architectures
   44|      1|    register(&mut PREV_SIGSEGV, libc::SIGSEGV);
   45|      1|
   46|      1|    // Handle `unreachable` instructions which execute `ud2` right now
   47|      1|    register(&mut PREV_SIGILL, libc::SIGILL);
   48|       |
   49|       |    // x86 and s390x use SIGFPE to report division by zero
   50|      1|    if cfg!(target_arch = "x86") || cfg!(target_arch = "x86_64") || cfg!(target_arch = "s390x") {
   51|      1|        register(&mut PREV_SIGFPE, libc::SIGFPE);
   52|      1|    }
   53|       |
   54|       |    // Sometimes we need to handle SIGBUS too:
   55|       |    // - On ARM, handle Unaligned Accesses.
   56|       |    // - On Darwin, guard page accesses are raised as SIGBUS.
   57|      1|    if cfg!(target_arch = "arm") || cfg!(target_os = "macos") || cfg!(target_os = "freebsd") {
   58|      0|        register(&mut PREV_SIGBUS, libc::SIGBUS);
   59|      1|    }
   60|      1|}
_RNCNvNtNtCsfBAxPD3lkOv_16wasmtime_runtime12traphandlers4unix13platform_init0B7_:
   17|      3|    let register = |slot: &mut MaybeUninit<libc::sigaction>, signal: i32| {
   18|      3|        let mut handler: libc::sigaction = mem::zeroed();
   19|      3|        // The flags here are relatively careful, and they are...
   20|      3|        //
   21|      3|        // SA_SIGINFO gives us access to information like the program
   22|      3|        // counter from where the fault happened.
   23|      3|        //
   24|      3|        // SA_ONSTACK allows us to handle signals on an alternate stack,
   25|      3|        // so that the handler can run in response to running out of
   26|      3|        // stack space on the main stack. Rust installs an alternate
   27|      3|        // stack with sigaltstack, so we rely on that.
   28|      3|        //
   29|      3|        // SA_NODEFER allows us to reenter the signal handler if we
   30|      3|        // crash while handling the signal, and fall through to the
   31|      3|        // Breakpad handler by testing handlingSegFault.
   32|      3|        handler.sa_flags = libc::SA_SIGINFO | libc::SA_NODEFER | libc::SA_ONSTACK;
   33|      3|        handler.sa_sigaction = trap_handler as usize;
   34|      3|        libc::sigemptyset(&mut handler.sa_mask);
   35|      3|        if libc::sigaction(signal, &handler, slot.as_mut_ptr()) != 0 {
   36|      0|            panic!(
   37|      0|                "unable to install signal handler: {}",
   38|      0|                io::Error::last_os_error(),
   39|      0|            );
   40|      3|        }
   41|      3|    };

_RNvXsf_NtCsfBAxPD3lkOv_16wasmtime_runtime9vmcontextNtB5_15VMRuntimeLimitsNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  777|    326|    fn default() -> VMRuntimeLimits {
  778|    326|        VMRuntimeLimits {
  779|    326|            stack_limit: UnsafeCell::new(usize::max_value()),
  780|    326|            fuel_consumed: UnsafeCell::new(0),
  781|    326|            epoch_deadline: UnsafeCell::new(0),
  782|    326|            last_wasm_exit_fp: UnsafeCell::new(0),
  783|    326|            last_wasm_exit_pc: UnsafeCell::new(0),
  784|    326|            last_wasm_entry_sp: UnsafeCell::new(0),
  785|    326|        }
  786|    326|    }
_RNvMs7_NtCsfBAxPD3lkOv_16wasmtime_runtime9vmcontextNtB5_18VMGlobalDefinition10as_i64_mut:
  411|    326|    pub unsafe fn as_i64_mut(&mut self) -> &mut i64 {
  412|    326|        &mut *(self.storage.as_mut().as_mut_ptr().cast::<i64>())
  413|    326|    }
_RNvMs7_NtCsfBAxPD3lkOv_16wasmtime_runtime9vmcontextNtB5_18VMGlobalDefinition3new:
  375|    326|    pub fn new() -> Self {
  376|    326|        Self { storage: [0; 16] }
  377|    326|    }

_RNvXs3X_Cs4z64eNW3Ya4_14wasmtime_typesNtB6_6MemoryNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  347|    978|#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, Serialize, Deserialize)]

_RNvNvNvXs0_CsgVqcGLl2G6M_10env_loggerNtB9_6LoggerNtCs5Em8znMBCBW_3log3Log3log9FORMATTER7___getit:
  319|    326|            unsafe fn __getit(
  320|    326|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    326|            ) -> $crate::option::Option<&'static $t> {
  322|    326|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    326|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    326|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    326|
  326|    326|                #[thread_local]
  327|    326|                #[cfg(all(
  328|    326|                    target_thread_local,
  329|    326|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    326|                ))]
  331|    326|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    326|                    $crate::thread::__FastLocalKeyInner::new();
  333|    326|
  334|    326|                #[cfg(all(
  335|    326|                    not(target_thread_local),
  336|    326|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    326|                ))]
  338|    326|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    326|                    $crate::thread::__OsLocalKeyInner::new();
  340|    326|
  341|    326|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    326|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    326|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    326|                #[allow(unused_unsafe)]
  345|    326|                unsafe {
  346|    326|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    326|                    })
  356|    326|                }
  357|    326|            }
_RNvNvNvXs0_CsgVqcGLl2G6M_10env_loggerNtB9_6LoggerNtCs5Em8znMBCBW_3log3Log3log9FORMATTER6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNtCsgtagClrasaP_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY7___getit:
  319|    163|            unsafe fn __getit(
  320|    163|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    163|            ) -> $crate::option::Option<&'static $t> {
  322|    163|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    163|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    163|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    163|
  326|    163|                #[thread_local]
  327|    163|                #[cfg(all(
  328|    163|                    target_thread_local,
  329|    163|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    163|                ))]
  331|    163|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    163|                    $crate::thread::__FastLocalKeyInner::new();
  333|    163|
  334|    163|                #[cfg(all(
  335|    163|                    not(target_thread_local),
  336|    163|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    163|                ))]
  338|    163|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    163|                    $crate::thread::__OsLocalKeyInner::new();
  340|    163|
  341|    163|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    163|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    163|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    163|                #[allow(unused_unsafe)]
  345|    163|                unsafe {
  346|    163|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    163|                    })
  356|    163|                }
  357|    163|            }
_RNvNvNtCsgtagClrasaP_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNtCsgtagClrasaP_16futures_executor5enter7ENTERED6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNtCsgtagClrasaP_16futures_executor5enter7ENTERED7___getit:
  319|    326|            unsafe fn __getit(
  320|    326|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    326|            ) -> $crate::option::Option<&'static $t> {
  322|    326|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    326|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    326|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    326|
  326|    326|                #[thread_local]
  327|    326|                #[cfg(all(
  328|    326|                    target_thread_local,
  329|    326|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    326|                ))]
  331|    326|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    326|                    $crate::thread::__FastLocalKeyInner::new();
  333|    326|
  334|    326|                #[cfg(all(
  335|    326|                    not(target_thread_local),
  336|    326|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    326|                ))]
  338|    326|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    326|                    $crate::thread::__OsLocalKeyInner::new();
  340|    326|
  341|    326|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    326|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    326|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    326|                #[allow(unused_unsafe)]
  345|    326|                unsafe {
  346|    326|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    326|                    })
  356|    326|                }
  357|    326|            }
_RNvNvNtNtCsiyHrXHpLjPA_4rand4rngs6thread14THREAD_RNG_KEY6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNtNtCsiyHrXHpLjPA_4rand4rngs6thread14THREAD_RNG_KEY7___getit:
  319|    163|            unsafe fn __getit(
  320|    163|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    163|            ) -> $crate::option::Option<&'static $t> {
  322|    163|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    163|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    163|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    163|
  326|    163|                #[thread_local]
  327|    163|                #[cfg(all(
  328|    163|                    target_thread_local,
  329|    163|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    163|                ))]
  331|    163|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    163|                    $crate::thread::__FastLocalKeyInner::new();
  333|    163|
  334|    163|                #[cfg(all(
  335|    163|                    not(target_thread_local),
  336|    163|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    163|                ))]
  338|    163|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    163|                    $crate::thread::__OsLocalKeyInner::new();
  340|    163|
  341|    163|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    163|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    163|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    163|                #[allow(unused_unsafe)]
  345|    163|                unsafe {
  346|    163|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    163|                    })
  356|    163|                }
  357|    163|            }

_RNvCs4ieSHZHrxF6_15direct_syscalls15stress_syscalls:
   29|    163|pub fn stress_syscalls(data: &[u8]) {
   30|    163|    let _ = env_logger::try_init();
   31|    163|
   32|    163|    let nc = NetworkConfig::new(NetworkVersion::V18);
   33|    163|    let ec = EngineConfig::from(&nc);
   34|    163|
   35|    163|    let mut tester = get_tester();
   36|    163|    tester.instantiate_machine(DummyExterns).unwrap();
   37|    163|
   38|    163|    let mut u = Unstructured::new(data);
   39|    163|
   40|    163|    let mut cp: [u8; 100_000] = u.arbitrary().unwrap();
   41|    163|    let mem = fvm::syscalls::context::Memory::new(&mut cp);
   42|    163|
   43|    163|    let machine = tester.executor.unwrap().into_machine().unwrap();
   44|    163|
   45|    163|    let pool = EnginePool::new_default(ec).unwrap();
   46|    163|
   47|    163|    let engine = pool.acquire();
   48|    163|
   49|    163|    let _t1: [u32; 10] = u.arbitrary().unwrap();
   50|    163|    let bignumber: u128 = u.arbitrary().unwrap();
   51|    163|    let bigint = BigInt::from_str(&format!("{}", bignumber));
   52|    163|
   53|    163|    let call_manager = DefaultCallManager::new(
   54|    163|        machine,
   55|    163|        engine,
   56|    163|        u.arbitrary().unwrap(),
   57|    163|        u.arbitrary().unwrap(),
   58|    163|        Address::new_id(u.arbitrary().unwrap()),
   59|    163|        u.arbitrary().unwrap(),
   60|    163|        // Try different froms
   61|    163|        TokenAmount::from_atto(bigint.clone().unwrap()),
   62|    163|    );
   63|    163|
   64|    163|    let block_registry = BlockRegistry::default();
   65|    163|
   66|    163|    let mut default_kernel = DefaultKernel::new(
   67|    163|        call_manager,
   68|    163|        block_registry,
   69|    163|        // This should be the same as line 54?
   70|    163|        u.arbitrary().unwrap(),
   71|    163|        // TODO, get the ids from the builtin actors
   72|    163|        u.arbitrary().unwrap(),
   73|    163|        // In theory is always method number 0 ?
   74|    163|        u.arbitrary().unwrap(),
   75|    163|        TokenAmount::from_atto(bigint.unwrap()),
   76|    163|    );
   77|    163|
   78|    163|    // TODO, dice the syscalls
   79|    163|    let r = block_create(
   80|    163|        fvm::syscalls::context::Context {
   81|    163|            kernel: &mut default_kernel,
   82|    163|            memory: mem,
   83|    163|        },
   84|    163|        u.arbitrary().unwrap(),
   85|    163|        u.arbitrary().unwrap(),
   86|    163|        u.arbitrary().unwrap(),
   87|    163|    );
   88|    163|
   89|    163|    match r {
   90|      0|        Ok(r) => {
   91|      0|            log::debug!("Correct {:?}", r)
   92|       |        }
   93|    163|        Err(e) => {
   94|    163|            log::warn!("{:?}", e)
   95|       |        }
   96|       |    }
   97|    163|}

_RNvCsilvC8qPft2D_8fvm_fuzz10get_tester:
  309|    163|pub fn get_tester() -> Tester<MemoryBlockstore, DummyExterns> {
  310|    163|    let bs = MemoryBlockstore::default();
  311|    163|    let bundle_root = import_bundle(&bs, actors_v10::BUNDLE_CAR).unwrap();
  312|    163|
  313|    163|    Tester::new(NetworkVersion::V18, StateTreeVersion::V5, bundle_root, bs).unwrap()
  314|    163|}

_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags7has_avx:
  141|    326|    pub fn has_avx(&self) -> bool {
  142|    326|        self.numbered_predicate(4)
  143|    326|    }
_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_sse42:
  136|    652|    pub fn has_sse42(&self) -> bool {
  137|    652|        self.numbered_predicate(3)
  138|    652|    }
_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags8has_bmi1:
  186|    326|    pub fn has_bmi1(&self) -> bool {
  187|    326|        self.numbered_predicate(13)
  188|    326|    }
_RNvMNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB2_5Flags3new:
    9|    326|    pub fn new(shared: &settings::Flags, builder: Builder) -> Self {
   10|    326|        let bvec = builder.state_for("x86");
   11|    326|        let mut x86 = Self { bytes: [0; 5] };
   12|    326|        debug_assert_eq!(bvec.len(), 2);
   13|    326|        x86.bytes[0..2].copy_from_slice(&bvec);
   14|    326|        // Precompute #16.
   15|    326|        if shared.is_pic() {
   16|      0|            x86.bytes[2] |= 1 << 0;
   17|    326|        }
   18|       |        // Precompute #17.
   19|    326|        if !(shared.is_pic()) {
   20|    326|            x86.bytes[2] |= 1 << 1;
   21|    326|        }
   22|       |        // Precompute #18.
   23|    326|        if shared.enable_simd() && x86.has_avx2() {
   24|      0|            x86.bytes[2] |= 1 << 2;
   25|    326|        }
   26|       |        // Precompute #19.
   27|    326|        if shared.enable_simd() && x86.has_avx512bitalg() {
   28|      0|            x86.bytes[2] |= 1 << 3;
   29|    326|        }
   30|       |        // Precompute #20.
   31|    326|        if shared.enable_simd() && x86.has_avx512dq() {
   32|      0|            x86.bytes[2] |= 1 << 4;
   33|    326|        }
   34|       |        // Precompute #21.
   35|    326|        if shared.enable_simd() && x86.has_avx512f() {
   36|      0|            x86.bytes[2] |= 1 << 5;
   37|    326|        }
   38|       |        // Precompute #22.
   39|    326|        if shared.enable_simd() && x86.has_avx512vbmi() {
   40|      0|            x86.bytes[2] |= 1 << 6;
   41|    326|        }
   42|       |        // Precompute #23.
   43|    326|        if shared.enable_simd() && x86.has_avx512vl() {
   44|      0|            x86.bytes[2] |= 1 << 7;
   45|    326|        }
   46|       |        // Precompute #24.
   47|    326|        if shared.enable_simd() && x86.has_avx() {
   48|      0|            x86.bytes[3] |= 1 << 0;
   49|    326|        }
   50|       |        // Precompute #25.
   51|    326|        if x86.has_bmi1() {
   52|    326|            x86.bytes[3] |= 1 << 1;
   53|    326|        }
   54|       |        // Precompute #26.
   55|    326|        if x86.has_avx() && x86.has_fma() {
   56|    326|            x86.bytes[3] |= 1 << 2;
   57|    326|        }
   58|       |        // Precompute #27.
   59|    326|        if x86.has_lzcnt() {
   60|    326|            x86.bytes[3] |= 1 << 3;
   61|    326|        }
   62|       |        // Precompute #28.
   63|    326|        if x86.has_popcnt() && x86.has_sse42() {
   64|    326|            x86.bytes[3] |= 1 << 4;
   65|    326|        }
   66|       |        // Precompute #29.
   67|    326|        if x86.has_sse41() {
   68|    326|            x86.bytes[3] |= 1 << 5;
   69|    326|        }
   70|       |        // Precompute #30.
   71|    326|        if shared.enable_simd() && x86.has_sse41() {
   72|      0|            x86.bytes[3] |= 1 << 6;
   73|    326|        }
   74|       |        // Precompute #31.
   75|    326|        if x86.has_sse41() && x86.has_sse42() {
   76|    326|            x86.bytes[3] |= 1 << 7;
   77|    326|        }
   78|       |        // Precompute #32.
   79|    326|        if shared.enable_simd() && x86.has_sse41() && x86.has_sse42() {
   80|      0|            x86.bytes[4] |= 1 << 0;
   81|    326|        }
   82|       |        // Precompute #33.
   83|    326|        if x86.has_ssse3() {
   84|    326|            x86.bytes[4] |= 1 << 1;
   85|    326|        }
   86|       |        // Precompute #34.
   87|    326|        if shared.enable_simd() && x86.has_ssse3() {
   88|      0|            x86.bytes[4] |= 1 << 2;
   89|    326|        }
   90|    326|        x86
   91|    326|    }
_RNvNtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settings7builder:
  493|    326|pub fn builder() -> Builder {
  494|    326|    Builder::new(&TEMPLATE)
  495|    326|}
_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_ssse3:
  126|    326|    pub fn has_ssse3(&self) -> bool {
  127|    326|        self.numbered_predicate(1)
  128|    326|    }
_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags7has_fma:
  151|    326|    pub fn has_fma(&self) -> bool {
  152|    326|        self.numbered_predicate(6)
  153|    326|    }
_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags10has_popcnt:
  181|    326|    pub fn has_popcnt(&self) -> bool {
  182|    326|        self.numbered_predicate(12)
  183|    326|    }
_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags18numbered_predicate:
  116|  3.26k|    fn numbered_predicate(&self, p: usize) -> bool {
  117|  3.26k|        self.bytes[0 + p / 8] & (1 << (p % 8)) != 0
  118|  3.26k|    }
_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_lzcnt:
  196|    326|    pub fn has_lzcnt(&self) -> bool {
  197|    326|        self.numbered_predicate(15)
  198|    326|    }
_RNvMs0_NtNtNtCs3IsnRjS6uPr_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_sse41:
  131|    652|    pub fn has_sse41(&self) -> bool {
  132|    652|        self.numbered_predicate(2)
  133|    652|    }

_RNvMsB_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_5Flags18numbered_predicate:
  176|  4.56k|    fn numbered_predicate(&self, p: usize) -> bool {
  177|  4.56k|        self.bytes[5 + p / 8] & (1 << (p % 8)) != 0
  178|  4.56k|    }
_RNvMsB_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_5Flags6is_pic:
  323|    652|    pub fn is_pic(&self) -> bool {
  324|    652|        self.numbered_predicate(4)
  325|    652|    }
_RNvMsB_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_5Flags11enable_simd:
  379|  3.58k|    pub fn enable_simd(&self) -> bool {
  380|  3.58k|        self.numbered_predicate(11)
  381|  3.58k|    }
_RNvNtCs3IsnRjS6uPr_17cranelift_codegen8settings7builder:
  761|    326|pub fn builder() -> Builder {
  762|    326|    Builder::new(&TEMPLATE)
  763|    326|}
_RNvMsB_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_5Flags17enable_pinned_reg:
  363|    326|    pub fn enable_pinned_reg(&self) -> bool {
  364|    326|        self.numbered_predicate(9)
  365|    326|    }
_RNvMsr_NtCs3IsnRjS6uPr_17cranelift_codegen8settingsNtB5_5Flags3new:
    9|    326|    pub fn new(builder: Builder) -> Self {
   10|    326|        let bvec = builder.state_for("shared");
   11|    326|        let mut shared = Self { bytes: [0; 8] };
   12|    326|        debug_assert_eq!(bvec.len(), 8);
   13|    326|        shared.bytes[0..8].copy_from_slice(&bvec);
   14|    326|        shared
   15|    326|    }

_RNvMs3_NtCs6PBDMK1Y3DJ_14target_lexicon4hostNtNtB7_6triple6Triple4host:
   64|    326|    pub const fn host() -> Self {
   65|    326|        Self {
   66|    326|            architecture: Architecture::X86_64,
   67|    326|            vendor: Vendor::Unknown,
   68|    326|            operating_system: OperatingSystem::Linux,
   69|    326|            environment: Environment::Gnu,
   70|    326|            binary_format: BinaryFormat::Elf,
   71|    326|        }
   72|    326|    }

_RNvMNtNtCsheoVkkQew6K_3fvm10blockstore8bufferedINtB2_18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE3newCs4ieSHZHrxF6_15direct_syscalls:
   28|    163|    pub fn new(base: BS) -> Self {
   29|    163|        Self {
   30|    163|            base,
   31|    163|            write: Default::default(),
   32|    163|        }
   33|    163|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm10blockstore8bufferedINtB5_18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtB1g_10Blockstore3getCs4ieSHZHrxF6_15direct_syscalls:
  235|    652|    fn get(&self, cid: &Cid) -> Result<Option<Vec<u8>>> {
  236|    652|        Ok(if let Some(data) = self.write.borrow().get(cid) {
  237|      0|            Some(data.clone())
  238|       |        } else {
  239|    652|            self.base.get(cid)?
  240|       |        })
  241|    652|    }

_RNvXs4_NtNtCsheoVkkQew6K_3fvm12call_manager9backtraceNtB5_9BacktraceNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   14|    163|#[derive(Debug, Default, Clone)]

_RNvXNtNtCsheoVkkQew6K_3fvm12call_manager7defaultINtB2_18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEENtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5derefCs4ieSHZHrxF6_15direct_syscalls:
   85|    326|    fn deref(&self) -> &Self::Target {
   86|    326|        self.0.as_ref().expect("call manager is poisoned")
   87|    326|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager3newCs4ieSHZHrxF6_15direct_syscalls:
  103|    163|    fn new(
  104|    163|        machine: M,
  105|    163|        engine: Engine,
  106|    163|        gas_limit: i64,
  107|    163|        origin: ActorID,
  108|    163|        origin_address: Address,
  109|    163|        nonce: u64,
  110|    163|        gas_premium: TokenAmount,
  111|    163|    ) -> Self {
  112|    163|        let limits = machine.new_limiter();
  113|    163|        let gas_tracker =
  114|    163|            GasTracker::new(Gas::new(gas_limit), Gas::zero(), machine.context().tracing);
  115|    163|
  116|    163|        DefaultCallManager(Some(Box::new(InnerDefaultCallManager {
  117|    163|            engine: Rc::new(engine),
  118|    163|            machine,
  119|    163|            gas_tracker,
  120|    163|            gas_premium,
  121|    163|            origin,
  122|    163|            origin_address,
  123|    163|            nonce,
  124|    163|            num_actors_created: 0,
  125|    163|            call_stack_depth: 0,
  126|    163|            backtrace: Backtrace::default(),
  127|    163|            exec_trace: vec![],
  128|    163|            invocation_count: 0,
  129|    163|            limits,
  130|    163|            events: Default::default(),
  131|    163|        })))
  132|    163|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager11gas_trackerCs4ieSHZHrxF6_15direct_syscalls:
  280|    163|    fn gas_tracker(&self) -> &GasTracker {
  281|    163|        &self.gas_tracker
  282|    163|    }
_RNvXs5_NtNtCsheoVkkQew6K_3fvm12call_manager7defaultNtB5_17EventsAccumulatorNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  769|    163|#[derive(Default)]
_RNvXs0_NtNtCsheoVkkQew6K_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager7machineCs4ieSHZHrxF6_15direct_syscalls:
  268|    163|    fn machine(&self) -> &Self::Machine {
  269|    163|        &self.machine
  270|    163|    }

_RNvYINtNtNtCsheoVkkQew6K_3fvm12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager10charge_gasCs4ieSHZHrxF6_15direct_syscalls:
  150|    163|    fn charge_gas(&self, charge: GasCharge) -> Result<GasTimer> {
  151|    163|        self.gas_tracker().apply_charge(charge)
  152|    163|    }
_RNvYINtNtNtCsheoVkkQew6K_3fvm12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager10price_listCs4ieSHZHrxF6_15direct_syscalls:
  120|    163|    fn price_list(&self) -> &PriceList {
  121|    163|        self.machine().context().price_list
  122|    163|    }

_RINvMs4_NtCsheoVkkQew6K_3fvm6engineNtB6_6Engine7preloadRNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreRINtNtCs71iYhC60HpU_5alloc3vec3VecINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
  358|    163|    pub fn preload<'a, BS, I>(&self, blockstore: BS, cids: I) -> anyhow::Result<usize>
  359|    163|    where
  360|    163|        BS: Blockstore,
  361|    163|        I: IntoIterator<Item = &'a Cid>,
  362|    163|    {
  363|    163|        let mut total_size = 0usize;
  364|    163|        for cid in cids {
  365|      0|            log::trace!("preloading code CID {cid}");
  366|      0|            let size = self.prepare_actor_code(cid, &blockstore).with_context(|| {
  367|       |                anyhow!("could not prepare actor with code CID {}", &cid.to_string())
  368|      0|            })?;
  369|      0|            total_size += size;
  370|       |        }
  371|    163|        Ok(total_size)
  372|    163|    }
_RNvXs3_NtCsheoVkkQew6K_3fvm6engineNtB5_6EngineNtNtNtCsdRJjCzU6nMS_4core3ops4drop4Drop4drop:
  314|    326|    fn drop(&mut self) {
  315|    326|        let mut limit = self.0.limit.lock().unwrap();
  316|    326|        *limit += 1;
  317|    326|        self.0.condv.notify_one();
  318|    326|    }
_RNvNtCsheoVkkQew6K_3fvm6engine15wasmtime_config:
  102|    326|fn wasmtime_config(ec: &EngineConfig) -> anyhow::Result<wasmtime::Config> {
  103|    326|    let instance_count = (1 + ec.max_call_depth) * ec.concurrency;
  104|    326|    let instance_memory_maximum_size = ec.max_inst_memory_bytes;
  105|    326|    if instance_memory_maximum_size % wasmtime_environ::WASM_PAGE_SIZE as u64 != 0 {
  106|      0|        return Err(anyhow!(
  107|      0|            "requested memory limit {} not a multiple of the WASM_PAGE_SIZE {}",
  108|      0|            instance_memory_maximum_size,
  109|      0|            wasmtime_environ::WASM_PAGE_SIZE
  110|      0|        ));
  111|    326|    }
  112|    326|
  113|    326|    let mut c = wasmtime::Config::default();
  114|    326|
  115|    326|    // wasmtime default: OnDemand
  116|    326|    // We want to pre-allocate all permissible memory to support the maximum allowed recursion limit.
  117|    326|    c.allocation_strategy(InstanceAllocationStrategy::Pooling {
  118|    326|        strategy: PoolingAllocationStrategy::ReuseAffinity,
  119|    326|        instance_limits: InstanceLimits {
  120|    326|            count: instance_count,
  121|    326|            // Adjust the maximum amount of host memory that can be committed to an instance to
  122|    326|            // match the static linear memory size we reserve for each slot.
  123|    326|            memory_pages: instance_memory_maximum_size / (wasmtime_environ::WASM_PAGE_SIZE as u64),
  124|    326|            ..Default::default()
  125|    326|        },
  126|    326|    });
  127|    326|
  128|    326|    // wasmtime default: true
  129|    326|    // We disable this as we always charge for memory regardless and `memory_init_cow` can baloon compiled wasm modules.
  130|    326|    c.memory_init_cow(false);
  131|    326|
  132|    326|    // wasmtime default: 4GB
  133|    326|    c.static_memory_maximum_size(instance_memory_maximum_size);
  134|    326|
  135|    326|    // wasmtime default: false
  136|    326|    // We don't want threads, there is no way to ensure determisism
  137|    326|    c.wasm_threads(false);
  138|    326|
  139|    326|    // wasmtime default: true
  140|    326|    // simd isn't supported in wasm-instrument, but if we add support there, we can probably enable this.
  141|    326|    // Note: stack limits may need adjusting after this is enabled
  142|    326|    c.wasm_simd(false);
  143|    326|
  144|    326|    // wasmtime default: false
  145|    326|    c.wasm_multi_memory(false);
  146|    326|
  147|    326|    // wasmtime default: false
  148|    326|    c.wasm_memory64(false);
  149|    326|
  150|    326|    // wasmtime default: true
  151|    326|    // Note: wasm-instrument only supports this at a basic level, for M2 we will
  152|    326|    // need to add more advanced support
  153|    326|    c.wasm_bulk_memory(true);
  154|    326|
  155|    326|    // wasmtime default: true
  156|    326|    // we should be able to enable this for M2, just need to make sure that it's
  157|    326|    // handled correctly in wasm-instrument
  158|    326|    c.wasm_multi_value(false);
  159|    326|
  160|    326|    // wasmtime default: false
  161|    326|    //
  162|    326|    // from wasmtime docs:
  163|    326|    // > When Cranelift is used as a code generation backend this will
  164|    326|    // > configure it to replace NaNs with a single canonical value. This
  165|    326|    // > is useful for users requiring entirely deterministic WebAssembly
  166|    326|    // > computation. This is not required by the WebAssembly spec, so it is
  167|    326|    // > not enabled by default.
  168|    326|    c.cranelift_nan_canonicalization(true);
  169|    326|
  170|    326|    // wasmtime default: 512KiB
  171|    326|    // Set to something much higher than the instrumented limiter.
  172|    326|    // Note: This is in bytes, while the instrumented limit is in stack elements
  173|    326|    c.max_wasm_stack(4 << 20);
  174|    326|
  175|    326|    // Execution cost accouting is done through wasm instrumentation,
  176|    326|    c.consume_fuel(false);
  177|    326|    c.epoch_interruption(false);
  178|    326|
  179|    326|    // Disable debug-related things, wasm-instrument doesn't fix debug info
  180|    326|    // yet, so those aren't useful, just add overhead
  181|    326|    c.debug_info(false);
  182|    326|    c.generate_address_map(false);
  183|    326|    c.cranelift_debug_verifier(false);
  184|    326|    c.native_unwind_info(false);
  185|    326|    #[allow(deprecated)] // TODO https://github.com/bytecodealliance/wasmtime/issues/5037
  186|    326|    c.wasm_backtrace(false);
  187|    326|    c.wasm_reference_types(false);
  188|    326|
  189|    326|    // Reiterate some defaults
  190|    326|    c.guard_before_linear_memory(true);
  191|    326|    c.parallel_compilation(true);
  192|    326|
  193|    326|    #[cfg(feature = "wasmtime/async")]
  194|    326|    c.async_support(false);
  195|    326|
  196|    326|    // Doesn't seem to have significant impact on the time it takes to load code
  197|    326|    // todo(M2): make sure this is guaranteed to run in linear time.
  198|    326|    c.cranelift_opt_level(Speed);
  199|    326|
  200|    326|    Ok(c)
  201|    326|}
_RNvMs1_NtCsheoVkkQew6K_3fvm6engineNtB5_10EnginePool3new:
  268|    326|    pub fn new(c: &wasmtime::Config, ec: EngineConfig) -> anyhow::Result<Self> {
  269|    326|        let engine = wasmtime::Engine::new(c)?;
  270|       |
  271|    326|        let mut dummy_store = wasmtime::Store::new(&engine, ());
  272|    326|        let gg_type = GlobalType::new(ValType::I64, Mutability::Var);
  273|    326|        let dummy_gg = Global::new(&mut dummy_store, gg_type, Val::I64(0))
  274|    326|            .expect("failed to create dummy gas global");
  275|    326|
  276|    326|        let dummy_memory = Memory::new(&mut dummy_store, MemoryType::new(0, Some(0)))
  277|    326|            .expect("failed to create dummy memory");
  278|    326|
  279|    326|        let actor_redirect = ec.actor_redirect.iter().cloned().collect();
  280|    326|
  281|    326|        Ok(EnginePool(Arc::new(EngineInner {
  282|    326|            limit: Mutex::new(ec.concurrency),
  283|    326|            condv: Condvar::new(),
  284|    326|            engine,
  285|    326|            dummy_memory,
  286|    326|            dummy_gas_global: dummy_gg,
  287|    326|            module_cache: Default::default(),
  288|    326|            instance_cache: Mutex::new(HashMap::new()),
  289|    326|            config: ec,
  290|    326|            actor_redirect,
  291|    326|        })))
  292|    326|    }
_RNvMs1_NtCsheoVkkQew6K_3fvm6engineNtB5_10EnginePool11new_default:
  263|    326|    pub fn new_default(ec: EngineConfig) -> anyhow::Result<Self> {
  264|    326|        EnginePool::new(&wasmtime_config(&ec)?, ec)
  265|    326|    }
_RNvXNtCsheoVkkQew6K_3fvm6engineNtB2_12EngineConfigINtNtCsdRJjCzU6nMS_4core7convert4FromRNtNtB4_7machine13NetworkConfigE4from:
   55|    326|    fn from(nc: &NetworkConfig) -> Self {
   56|    326|        EngineConfig {
   57|    326|            max_call_depth: nc.max_call_depth,
   58|    326|            max_wasm_stack: nc.max_wasm_stack,
   59|    326|            max_inst_memory_bytes: nc.max_inst_memory_bytes,
   60|    326|            wasm_prices: &nc.price_list.wasm_rules,
   61|    326|            actor_redirect: nc.actor_redirect.clone(),
   62|    326|            concurrency: 1,
   63|    326|        }
   64|    326|    }
_RNvMs1_NtCsheoVkkQew6K_3fvm6engineNtB5_10EnginePool7acquire:
  238|    326|    pub fn acquire(&self) -> Engine {
  239|    326|        *self
  240|    326|            .0
  241|    326|            .condv
  242|    326|            .wait_while(self.0.limit.lock().unwrap(), |limit| *limit == 0)
  243|    326|            .unwrap() -= 1;
  244|    326|        Engine(self.0.clone())
  245|    326|    }
_RNCNvMs1_NtCsheoVkkQew6K_3fvm6engineNtB7_10EnginePool7acquire0B9_:
  242|    326|            .wait_while(self.0.limit.lock().unwrap(), |limit| *limit == 0)

_RNvMs1_NtNtCsheoVkkQew6K_3fvm8executor7defaultINtB5_15DefaultExecutorINtNtNtB9_6kernel7default13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEEEE12into_machineCs4ieSHZHrxF6_15direct_syscalls:
  358|    163|    pub fn into_machine(self) -> Option<<K::CallManager as CallManager>::Machine> {
  359|    163|        self.machine
  360|    163|    }
_RNvMs1_NtNtCsheoVkkQew6K_3fvm8executor7defaultINtB5_15DefaultExecutorINtNtNtB9_6kernel7default13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEEEE3newCs4ieSHZHrxF6_15direct_syscalls:
  334|    163|    pub fn new(
  335|    163|        engine_pool: EnginePool,
  336|    163|        machine: <K::CallManager as CallManager>::Machine,
  337|    163|    ) -> anyhow::Result<Self> {
  338|    163|        // Skip preloading all builtin actors when testing.
  339|    163|        #[cfg(not(any(test, feature = "testing")))]
  340|    163|        {
  341|    163|            // Preload any uncached modules.
  342|    163|            // This interface works for now because we know all actor CIDs
  343|    163|            // ahead of time, but with user-supplied code, we won't have that
  344|    163|            // guarantee.
  345|    163|            engine_pool.acquire().preload(
  346|    163|                machine.blockstore(),
  347|    163|                machine.builtin_actors().builtin_actor_codes(),
  348|    163|            )?;
  349|    163|        }
  350|    163|        Ok(Self {
  351|    163|            engine_pool,
  352|    163|            machine: Some(machine),
  353|    163|        })
  354|    163|    }

_RINvMNtNtCsheoVkkQew6K_3fvm3gas6chargeNtB3_9GasCharge3newReECs4ieSHZHrxF6_15direct_syscalls:
   24|    163|    pub fn new(name: impl Into<Cow<'static, str>>, compute_gas: Gas, storage_gas: Gas) -> Self {
   25|    163|        let name = name.into();
   26|    163|        Self {
   27|    163|            name,
   28|    163|            compute_gas,
   29|    163|            storage_gas,
   30|    163|            elapsed: GasDuration::default(),
   31|    163|        }
   32|    163|    }
_RNvMNtNtCsheoVkkQew6K_3fvm3gas6chargeNtB2_9GasCharge5total:
   36|    163|    pub fn total(&self) -> Gas {
   37|    163|        self.compute_gas + self.storage_gas
   38|    163|    }

_RNvXs2_NtCsheoVkkQew6K_3fvm3gasNtB5_3GasNtNtNtCsdRJjCzU6nMS_4core3ops5arith3Add3add:
  111|    652|    fn add(self, rhs: Self) -> Self::Output {
  112|    652|        Self(self.0.saturating_add(rhs.0))
  113|    652|    }
_RNvXsa_NtCsheoVkkQew6K_3fvm3gasNtB5_3GasINtNtNtCsdRJjCzU6nMS_4core3ops5arith3MuljE3mul:
  179|    326|    fn mul(self, rhs: usize) -> Self::Output {
  180|    326|        Self(self.0.saturating_mul(rhs.try_into().unwrap_or(i64::MAX)))
  181|    326|    }
_RNvMs0_NtCsheoVkkQew6K_3fvm3gasNtB5_3Gas3new:
   69|    214|    pub const fn new(gas: i64) -> Gas {
   70|    214|        Gas(gas.saturating_mul(MILLIGAS_PRECISION))
   71|    214|    }
_RNvMs0_NtCsheoVkkQew6K_3fvm3gasNtB5_3Gas13from_milligas:
   62|      1|    pub const fn from_milligas(milligas: i64) -> Gas {
   63|      1|        Gas(milligas)
   64|      1|    }
_RNvMsb_NtCsheoVkkQew6K_3fvm3gasNtB5_10GasTracker16charge_gas_inner:
  201|    163|    fn charge_gas_inner(&self, to_use: Gas) -> Result<()> {
  202|    163|        // The gas type uses saturating math.
  203|    163|        let gas_used = self.gas_used.get() + to_use;
  204|    163|        if gas_used > self.gas_limit {
  205|      0|            log::trace!("gas limit reached");
  206|      0|            self.gas_used.set(self.gas_limit);
  207|      0|            Err(ExecutionError::OutOfGas)
  208|       |        } else {
  209|    163|            self.gas_used.set(gas_used);
  210|    163|            Ok(())
  211|       |        }
  212|    163|    }
_RNvXs_NtCsheoVkkQew6K_3fvm3gasNtB4_3GasNtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt:
   48|    163|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   49|    163|        if self.0 == 0 {
   50|    163|            f.write_str("0")
   51|       |        } else {
   52|      0|            let integral = self.0 / MILLIGAS_PRECISION;
   53|      0|            let fractional = self.0 % MILLIGAS_PRECISION;
   54|      0|            write!(f, "{integral}.{fractional:03}")
   55|       |        }
   56|    163|    }
_RNvXs1_NtCsheoVkkQew6K_3fvm3gasNtB5_3GasNtNtCsfVZxj7gvuuV_10num_traits10identities4Zero4zero:
   98|    345|    fn zero() -> Self {
   99|    345|        Gas(0)
  100|    345|    }
_RNCNvMsb_NtCsheoVkkQew6K_3fvm3gasNtB7_10GasTracker12apply_charge0B9_:
  237|    163|            res.map(|_| timer)
_RNvMsb_NtCsheoVkkQew6K_3fvm3gasNtB5_10GasTracker12apply_charge:
  230|    163|    pub fn apply_charge(&self, mut charge: GasCharge) -> Result<GasTimer> {
  231|    163|        let to_use = charge.total();
  232|    163|        log::trace!("charging gas: {} {}", &charge.name, to_use);
  233|    163|        let res = self.charge_gas_inner(to_use);
  234|    163|        if let Some(trace) = &self.trace {
  235|    163|            let timer = GasTimer::new(&mut charge.elapsed);
  236|    163|            trace.borrow_mut().push(charge);
  237|    163|            res.map(|_| timer)
  238|       |        } else {
  239|      0|            res.map(|_| GasTimer::empty())
  240|       |        }
  241|    163|    }
_RNvMsb_NtCsheoVkkQew6K_3fvm3gasNtB5_10GasTracker3new:
  193|    163|    pub fn new(gas_limit: Gas, gas_used: Gas, enable_tracing: bool) -> Self {
  194|    163|        Self {
  195|    163|            gas_limit,
  196|    163|            gas_used: Cell::new(gas_used),
  197|    163|            trace: enable_tracing.then_some(Default::default()),
  198|    163|        }
  199|    163|    }
_RNvXsi_NtCsheoVkkQew6K_3fvm3gasNtB5_3GasNtNtCsdRJjCzU6nMS_4core3cmp10PartialOrd11partial_cmp:
   30|    163|#[derive(Hash, Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Default)]

_RNvMs_NtNtCsheoVkkQew6K_3fvm3gas10price_listNtB4_9PriceList15on_block_create:
  884|    163|    pub fn on_block_create(&self, data_size: usize) -> GasCharge {
  885|    163|        let mem_costs = (self.block_create_memret_per_byte_cost * data_size)
  886|    163|            + (self.block_memcpy_per_byte_cost * data_size);
  887|    163|        GasCharge::new(
  888|    163|            "OnBlockCreate",
  889|    163|            self.block_create_base + mem_costs,
  890|    163|            Zero::zero(),
  891|    163|        )
  892|    163|    }
_RNvNtNtCsheoVkkQew6K_3fvm3gas10price_list29price_list_by_network_version:
 1045|    326|pub fn price_list_by_network_version(network_version: NetworkVersion) -> &'static PriceList {
 1046|    326|    match network_version {
 1047|      0|        NetworkVersion::V15 => &OH_SNAP_PRICES,
 1048|      0|        NetworkVersion::V16 | NetworkVersion::V17 => &SKYR_PRICES,
 1049|    326|        NetworkVersion::V18 => &HYGGE_PRICES,
 1050|      0|        _ => panic!("network version {nv} not supported", nv = network_version),
 1051|       |    }
 1052|    326|}
_RNvXse_NtNtCsheoVkkQew6K_3fvm3gas10price_listNtB5_8StepCostNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  472|      2|#[derive(Clone, Debug, PartialEq, Eq)]

_RNvXs0_NtNtCsheoVkkQew6K_3fvm3gas5timerNtB5_11GasDurationNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   16|    163|#[derive(Default, Debug, Clone)]
_RNvMNtNtCsheoVkkQew6K_3fvm3gas5timerNtB2_11GasDuration3get:
   20|    163|    pub fn get(&self) -> Option<&Duration> {
   21|    163|        self.0.as_ref().and_then(|d| d.get())
   22|    163|    }
_RNvMs_NtNtCsheoVkkQew6K_3fvm3gas5timerNtB4_8GasTimer5start:
   45|    163|    pub fn start() -> GasInstant {
   46|    163|        GasInstant::now()
   47|    163|    }
_RNvMs_NtNtCsheoVkkQew6K_3fvm3gas5timerNtB4_8GasTimer3new:
   57|    163|    pub fn new(duration: &mut GasDuration) -> Self {
   58|    163|        assert!(duration.get().is_none(), "GasCharge::elapsed already set!");
   59|       |
   60|    163|        let cell = match &duration.0 {
   61|      0|            Some(cell) => cell.clone(),
   62|       |            None => {
   63|    163|                let cell = DurationCell::default();
   64|    163|                duration.0 = Some(cell.clone());
   65|    163|                cell
   66|       |            }
   67|       |        };
   68|       |
   69|    163|        Self(Some(GasTimerInner {
   70|    163|            start: Self::start(),
   71|    163|            elapsed: cell,
   72|    163|        }))
   73|    163|    }

_RINvXs0_NtCsheoVkkQew6K_3fvm10init_actorNtB6_5StateNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   33|    163|#[derive(Serialize_tuple, Deserialize_tuple, Debug)]
_RINvXNvNvXs0_NtCsheoVkkQew6K_3fvm10init_actorNtBb_5StateNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serialize1__NtB5_5InnerBS_9serializeINtCs6R461GKLOna_11serde_tuple10SerializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEEECsilvC8qPft2D_8fvm_fuzz:
   33|    163|#[derive(Serialize_tuple, Deserialize_tuple, Debug)]
_RINvMs_NtCsheoVkkQew6K_3fvm10init_actorNtB5_5State8new_testNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
   48|    163|    pub fn new_test<B: Blockstore>(store: &B) -> Self {
   49|    163|        #[cfg(feature = "m2-native")]
   50|    163|        use cid::multihash::Code::Blake2b256;
   51|    163|
   52|    163|        // Empty hamt Cid used for testing
   53|    163|        let e_cid = Hamt::<_, String>::new_with_bit_width(&store, 5)
   54|    163|            .flush()
   55|    163|            .unwrap();
   56|    163|
   57|    163|        // Empty list Cid used for testing
   58|    163|        #[cfg(feature = "m2-native")]
   59|    163|        let el_cid = store.put_cbor(&Vec::<Cid>::new(), Blake2b256).unwrap();
   60|    163|
   61|    163|        State {
   62|    163|            address_map: e_cid,
   63|    163|            next_id: 100,
   64|    163|            network_name: "test".to_owned(),
   65|    163|            #[cfg(feature = "m2-native")]
   66|    163|            installed_actors: el_cid,
   67|    163|        }
   68|    163|    }

_RNvXs5_NtNtCsheoVkkQew6K_3fvm6kernel6blocksNtB5_13BlockRegistryNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   13|    163|#[derive(Default)]
_RINvMNtNtCsheoVkkQew6K_3fvm6kernel6blocksNtB3_5Block3newRShECs4ieSHZHrxF6_15direct_syscalls:
   45|    163|    pub fn new(codec: u64, data: impl Into<Box<[u8]>>) -> Self {
   46|    163|        // This requires an extra allocation (ew) but no extra copy on send.
   47|    163|        // The extra allocation is basically nothing.
   48|    163|        Self {
   49|    163|            codec,
   50|    163|            data: Rc::new(data.into()),
   51|    163|        }
   52|    163|    }
_RNvMs4_NtNtCsheoVkkQew6K_3fvm6kernel6blocksNtB5_13BlockRegistry7is_full:
  165|    163|    pub fn is_full(&self) -> bool {
  166|    163|        self.blocks.len() as u32 == MAX_BLOCKS
  167|    163|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm6kernel6blocksNtNtB7_5error14ExecutionErrorINtNtCsdRJjCzU6nMS_4core7convert4FromNtB5_13BlockPutErrorE4from:
   96|    163|    fn from(e: BlockPutError) -> Self {
   97|    163|        ExecutionError::Syscall(e.into())
   98|    163|    }
_RNvXs_NtNtCsheoVkkQew6K_3fvm6kernel6blocksNtNtB6_5error12SyscallErrorINtNtCsdRJjCzU6nMS_4core7convert4FromNtB4_13BlockPutErrorE4from:
   87|    163|    fn from(e: BlockPutError) -> Self {
   88|    163|        match e {
   89|      0|            BlockPutError::TooManyBlocks => syscall_error!(LimitExceeded; "{}", e),
   90|    163|            BlockPutError::InvalidCodec(_) => syscall_error!(IllegalCodec; "{}", e),
   91|       |        }
   92|    163|    }
_RNvMs4_NtNtCsheoVkkQew6K_3fvm6kernel6blocksNtB5_13BlockRegistry3put:
  125|    163|    pub fn put(&mut self, block: Block) -> Result<BlockId, BlockPutError> {
  126|    163|        if self.is_full() {
  127|      0|            return Err(BlockPutError::TooManyBlocks);
  128|    163|        }
  129|    163|
  130|    163|        if !ALLOWED_CODECS.contains(&block.codec) {
  131|    163|            return Err(BlockPutError::InvalidCodec(block.codec));
  132|      0|        }
  133|      0|
  134|      0|        let id = FIRST_ID + self.blocks.len() as u32;
  135|      0|        self.blocks.push(block);
  136|      0|        Ok(id)
  137|    163|    }
_RNvXsc_NtNtCsheoVkkQew6K_3fvm6kernel6blocksNtB5_13BlockPutErrorNtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt:
   78|    163|#[derive(Error, Debug)]

_RNvXNtNtCsheoVkkQew6K_3fvm6kernel7defaultINtB2_13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEEENtB4_6Kernel3newCs4ieSHZHrxF6_15direct_syscalls:
   83|    163|    fn new(
   84|    163|        mgr: C,
   85|    163|        blocks: BlockRegistry,
   86|    163|        caller: ActorID,
   87|    163|        actor_id: ActorID,
   88|    163|        method: MethodNum,
   89|    163|        value_received: TokenAmount,
   90|    163|    ) -> Self {
   91|    163|        DefaultKernel {
   92|    163|            call_manager: mgr,
   93|    163|            blocks,
   94|    163|            caller,
   95|    163|            actor_id,
   96|    163|            method,
   97|    163|            value_received,
   98|    163|        }
   99|    163|    }
_RNvXs1_NtNtCsheoVkkQew6K_3fvm6kernel7defaultINtB5_13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEEENtB7_12IpldBlockOps12block_createCs4ieSHZHrxF6_15direct_syscalls:
  251|    163|    fn block_create(&mut self, codec: u64, data: &[u8]) -> Result<BlockId> {
  252|    163|        let t = self
  253|    163|            .call_manager
  254|    163|            .charge_gas(self.call_manager.price_list().on_block_create(data.len()))?;
  255|       |
  256|    163|        t.record(Ok(self.blocks.put(Block::new(codec, data))?))
  257|    163|    }

_RNvXs0_NtNtCsheoVkkQew6K_3fvm6kernel5errorINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_ENtNtCs6zZxOXcsMaf_13fvm_ipld_hamt5error5ErrorENtB5_14ClassifyResult8or_fatalCs4ieSHZHrxF6_15direct_syscalls:
  100|    163|    fn or_fatal(self) -> Result<Self::Value>
  101|    163|    where
  102|    163|        Self::Error: Into<anyhow::Error>,
  103|    163|    {
  104|    163|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    163|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm6kernel5errorINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_ENtCslfc1tI9p8hD_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalCs4ieSHZHrxF6_15direct_syscalls:
  100|    163|    fn or_fatal(self) -> Result<Self::Value>
  101|    163|    where
  102|    163|        Self::Error: Into<anyhow::Error>,
  103|    163|    {
  104|    163|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    163|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm6kernel5errorINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtBJ_6option6OptionNtNtB9_10state_tree10ActorStateENtNtCs6zZxOXcsMaf_13fvm_ipld_hamt5error5ErrorENtB5_14ClassifyResult8or_fatalCs4ieSHZHrxF6_15direct_syscalls:
  100|    489|    fn or_fatal(self) -> Result<Self::Value>
  101|    489|    where
  102|    489|        Self::Error: Into<anyhow::Error>,
  103|    489|    {
  104|    489|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    489|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm6kernel5errorINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamt4HamtINtNtNtB9_10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtB9_10state_tree10ActorStateENtCslfc1tI9p8hD_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalCs4ieSHZHrxF6_15direct_syscalls:
  100|    163|    fn or_fatal(self) -> Result<Self::Value>
  101|    163|    where
  102|    163|        Self::Error: Into<anyhow::Error>,
  103|    163|    {
  104|    163|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    163|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm6kernel5errorINtNtCsdRJjCzU6nMS_4core6result6ResultINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_ENtCslfc1tI9p8hD_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalCsilvC8qPft2D_8fvm_fuzz:
  100|    163|    fn or_fatal(self) -> Result<Self::Value>
  101|    163|    where
  102|    163|        Self::Error: Into<anyhow::Error>,
  103|    163|    {
  104|    163|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    163|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm6kernel5errorINtNtCsdRJjCzU6nMS_4core6result6ResultRShNtNtCs71iYhC60HpU_5alloc6string6StringENtB5_14ClassifyResult8or_errorB9_:
  106|    163|    fn or_error(self, code: ErrorNumber) -> Result<Self::Value>
  107|    163|    where
  108|    163|        Self::Error: Display,
  109|    163|    {
  110|    163|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
  111|    163|    }
_RINvMs4_NtNtCsheoVkkQew6K_3fvm6kernel5errorNtB6_12SyscallError3newNtNtCsdRJjCzU6nMS_4core3fmt9ArgumentsEBa_:
  185|    163|    pub fn new<D: Display>(c: ErrorNumber, d: D) -> Self {
  186|    163|        SyscallError(d.to_string(), c)
  187|    163|    }
_RNvXs0_NtNtCsheoVkkQew6K_3fvm6kernel5errorINtNtCsdRJjCzU6nMS_4core6result6ResultRNtNtB9_10state_tree14StateSnapLayerNtCslfc1tI9p8hD_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalB9_:
  100|    489|    fn or_fatal(self) -> Result<Self::Value>
  101|    489|    where
  102|    489|        Self::Error: Into<anyhow::Error>,
  103|    489|    {
  104|    489|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    489|    }

_RNvXs_NtNtCsheoVkkQew6K_3fvm7machine7defaultINtB4_14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsENtB6_7Machine11new_limiterCs4ieSHZHrxF6_15direct_syscalls:
  260|    163|    fn new_limiter(&self) -> Self::Limiter {
  261|    163|        ExecResourceLimiter::for_network(&self.context().network)
  262|    163|    }
_RNvXs_NtNtCsheoVkkQew6K_3fvm7machine7defaultINtB4_14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsENtB6_7Machine7contextCs4ieSHZHrxF6_15direct_syscalls:
  143|    489|    fn context(&self) -> &MachineContext {
  144|    489|        &self.context
  145|    489|    }
_RNvMNtNtCsheoVkkQew6K_3fvm7machine7defaultINtB2_14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsE3newCs4ieSHZHrxF6_15direct_syscalls:
   63|    163|    pub fn new(context: &MachineContext, blockstore: B, externs: E) -> anyhow::Result<Self> {
   64|    163|        const SUPPORTED_VERSIONS: RangeInclusive<NetworkVersion> =
   65|    163|            NetworkVersion::V18..=NetworkVersion::V18;
   66|    163|
   67|    163|        debug!(
   68|    163|            "initializing a new machine, epoch={}, base_fee={}, nv={:?}, root={}",
   69|    163|            context.epoch, &context.base_fee, context.network_version, context.initial_state_root
   70|       |        );
   71|       |
   72|    163|        if !SUPPORTED_VERSIONS.contains(&context.network_version) {
   73|      0|            return Err(anyhow!(
   74|      0|                "unsupported network version: {}",
   75|      0|                context.network_version
   76|      0|            ));
   77|    163|        }
   78|    163|
   79|    163|        // Sanity check that the blockstore contains the supplied state root.
   80|    163|        if !blockstore
   81|    163|            .has(&context.initial_state_root)
   82|    163|            .context("failed to load initial state-root")?
   83|       |        {
   84|      0|            return Err(anyhow!(
   85|      0|                "blockstore doesn't have the initial state-root {}",
   86|      0|                &context.initial_state_root
   87|      0|            ));
   88|    163|        }
   89|       |
   90|       |        // Create a new state tree from the supplied root.
   91|    163|        let state_tree = {
   92|    163|            let bstore = BufferedBlockstore::new(blockstore);
   93|    163|            StateTree::new_from_root(bstore, &context.initial_state_root)?
   94|       |        };
   95|       |
   96|       |        // Load the built-in actors manifest.
   97|    163|        let (builtin_actors_cid, manifest_version) = match context.builtin_actors_override {
   98|    163|            Some(manifest_cid) => {
   99|    163|                let (version, cid): (u32, Cid) = state_tree
  100|    163|                    .store()
  101|    163|                    .get_cbor(&manifest_cid)?
  102|    163|                    .context("failed to load actor manifest")?;
  103|    163|                (cid, version)
  104|       |            }
  105|       |            None => {
  106|      0|                let (state, _) = SystemActorState::load(&state_tree)?;
  107|      0|                (state.builtin_actors, 1)
  108|       |            }
  109|       |        };
  110|    163|        let builtin_actors =
  111|    163|            Manifest::load(state_tree.store(), &builtin_actors_cid, manifest_version)?;
  112|       |
  113|       |        // 16 bytes is random _enough_
  114|    163|        let randomness: [u8; 16] = rand::random();
  115|    163|
  116|    163|        Ok(DefaultMachine {
  117|    163|            context: context.clone(),
  118|    163|            externs,
  119|    163|            state_tree,
  120|    163|            builtin_actors,
  121|    163|            id: format!(
  122|    163|                "{}-{}",
  123|    163|                context.epoch,
  124|    163|                cid::multibase::encode(cid::multibase::Base::Base32Lower, randomness)
  125|    163|            ),
  126|    163|        })
  127|    163|    }

_RNvMNtNtCsheoVkkQew6K_3fvm7machine7limiterNtB2_19ExecResourceLimiter3new:
   35|    163|    pub fn new(max_inst_memory_bytes: usize, max_exec_memory_bytes: usize) -> Self {
   36|    163|        Self {
   37|    163|            max_inst_memory_bytes,
   38|    163|            max_exec_memory_bytes,
   39|    163|            curr_exec_memory_bytes: 0,
   40|    163|        }
   41|    163|    }
_RNvMNtNtCsheoVkkQew6K_3fvm7machine7limiterNtB2_19ExecResourceLimiter11for_network:
   43|    163|    pub fn for_network(config: &NetworkConfig) -> Self {
   44|    163|        Self::new(
   45|    163|            config.max_inst_memory_bytes as usize,
   46|    163|            config.max_exec_memory_bytes as usize,
   47|    163|        )
   48|    163|    }

_RNCINvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB5_8Manifest3newNtNtCs71iYhC60HpU_5alloc6string6StringINtNtB14_3vec3VecTB10_INtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEE0Cs4ieSHZHrxF6_15direct_syscalls:
  116|  1.30k|            .flat_map(|&k| by_name.get(k))
_RINvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB3_8Manifest3newNtNtCs71iYhC60HpU_5alloc6string6StringINtNtB12_3vec3VecTBY_INtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECs4ieSHZHrxF6_15direct_syscalls:
  100|    163|    pub fn new(iter: impl IntoIterator<Item = (impl Into<String>, Cid)>) -> anyhow::Result<Self> {
  101|    163|        let mut by_name = HashMap::new();
  102|    163|        let mut by_id = HashMap::new();
  103|    163|        let mut by_code = HashMap::new();
  104|       |
  105|       |        // Actors are indexed sequentially, starting at 1, in the order in which they appear in the
  106|       |        // manifest. 0 is reserved for "everything else" (i.e., not a builtin actor).
  107|  2.44k|        for ((name, code_cid), id) in iter.into_iter().zip(1u32..) {
  108|  2.44k|            let name = name.into();
  109|  2.44k|            by_id.insert(id, code_cid);
  110|  2.44k|            by_code.insert(code_cid, id);
  111|  2.44k|            by_name.insert(name, code_cid);
  112|  2.44k|        }
  113|       |
  114|    163|        let singletons = SINGLETON_ACTOR_NAMES
  115|    163|            .iter()
  116|    163|            .flat_map(|&k| by_name.get(k))
  117|    163|            .copied()
  118|    163|            .collect();
  119|       |
  120|    163|        let account_code = *by_name
  121|    163|            .get(ACCOUNT_ACTOR_NAME)
  122|    163|            .context("manifest missing account actor")?;
  123|       |
  124|    163|        let system_code = *by_name
  125|    163|            .get(SYSTEM_ACTOR_NAME)
  126|    163|            .context("manifest missing system actor")?;
  127|       |
  128|    163|        let init_code = *by_name
  129|    163|            .get(INIT_ACTOR_NAME)
  130|    163|            .context("manifest missing init actor")?;
  131|       |
  132|    163|        let embryo_code = *by_name
  133|    163|            .get(EMBRYO_ACTOR_NAME)
  134|    163|            .context("manifest missing embryo actor")?;
  135|       |
  136|    163|        let eam_code = *by_name
  137|    163|            .get(EAM_ACTOR_NAME)
  138|    163|            .context("manifest missing eam actor")?;
  139|       |
  140|    163|        let ethaccount_code = *by_name
  141|    163|            .get(ETHACCOUNT_ACTOR_NAME)
  142|    163|            .context("manifest missing ethaccount actor")?;
  143|       |
  144|    163|        Ok(Self {
  145|    163|            account_code,
  146|    163|            system_code,
  147|    163|            init_code,
  148|    163|            embryo_code,
  149|    163|            eam_code,
  150|    163|            ethaccount_code,
  151|    163|            singletons,
  152|    163|            by_id,
  153|    163|            by_code,
  154|    163|        })
  155|    163|    }
_RINvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB3_8Manifest4loadINtNtNtB7_10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreEECs4ieSHZHrxF6_15direct_syscalls:
   85|    163|    pub fn load<B: Blockstore>(bs: &B, root_cid: &Cid, ver: u32) -> anyhow::Result<Manifest> {
   86|    163|        if ver != 1 {
   87|      0|            return Err(anyhow!("unsupported manifest version {}", ver));
   88|    163|        }
   89|       |
   90|    163|        let vec: Vec<(String, Cid)> = match bs.get_cbor(root_cid)? {
   91|    163|            Some(vec) => vec,
   92|       |            None => {
   93|      0|                return Err(anyhow!("cannot find manifest root cid {}", root_cid));
   94|       |            }
   95|       |        };
   96|    163|        Manifest::new(vec)
   97|    163|    }
_RINvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB3_8Manifest3newNtNtCs71iYhC60HpU_5alloc6string6StringINtNtB12_3vec3VecTBY_INtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECsilvC8qPft2D_8fvm_fuzz:
  100|    163|    pub fn new(iter: impl IntoIterator<Item = (impl Into<String>, Cid)>) -> anyhow::Result<Self> {
  101|    163|        let mut by_name = HashMap::new();
  102|    163|        let mut by_id = HashMap::new();
  103|    163|        let mut by_code = HashMap::new();
  104|       |
  105|       |        // Actors are indexed sequentially, starting at 1, in the order in which they appear in the
  106|       |        // manifest. 0 is reserved for "everything else" (i.e., not a builtin actor).
  107|  2.44k|        for ((name, code_cid), id) in iter.into_iter().zip(1u32..) {
  108|  2.44k|            let name = name.into();
  109|  2.44k|            by_id.insert(id, code_cid);
  110|  2.44k|            by_code.insert(code_cid, id);
  111|  2.44k|            by_name.insert(name, code_cid);
  112|  2.44k|        }
  113|       |
  114|    163|        let singletons = SINGLETON_ACTOR_NAMES
  115|    163|            .iter()
  116|    163|            .flat_map(|&k| by_name.get(k))
  117|    163|            .copied()
  118|    163|            .collect();
  119|       |
  120|    163|        let account_code = *by_name
  121|    163|            .get(ACCOUNT_ACTOR_NAME)
  122|    163|            .context("manifest missing account actor")?;
  123|       |
  124|    163|        let system_code = *by_name
  125|    163|            .get(SYSTEM_ACTOR_NAME)
  126|    163|            .context("manifest missing system actor")?;
  127|       |
  128|    163|        let init_code = *by_name
  129|    163|            .get(INIT_ACTOR_NAME)
  130|    163|            .context("manifest missing init actor")?;
  131|       |
  132|    163|        let embryo_code = *by_name
  133|    163|            .get(EMBRYO_ACTOR_NAME)
  134|    163|            .context("manifest missing embryo actor")?;
  135|       |
  136|    163|        let eam_code = *by_name
  137|    163|            .get(EAM_ACTOR_NAME)
  138|    163|            .context("manifest missing eam actor")?;
  139|       |
  140|    163|        let ethaccount_code = *by_name
  141|    163|            .get(ETHACCOUNT_ACTOR_NAME)
  142|    163|            .context("manifest missing ethaccount actor")?;
  143|       |
  144|    163|        Ok(Self {
  145|    163|            account_code,
  146|    163|            system_code,
  147|    163|            init_code,
  148|    163|            embryo_code,
  149|    163|            eam_code,
  150|    163|            ethaccount_code,
  151|    163|            singletons,
  152|    163|            by_id,
  153|    163|            by_code,
  154|    163|        })
  155|    163|    }
_RINvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB3_8Manifest4loadNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
   85|    163|    pub fn load<B: Blockstore>(bs: &B, root_cid: &Cid, ver: u32) -> anyhow::Result<Manifest> {
   86|    163|        if ver != 1 {
   87|      0|            return Err(anyhow!("unsupported manifest version {}", ver));
   88|    163|        }
   89|       |
   90|    163|        let vec: Vec<(String, Cid)> = match bs.get_cbor(root_cid)? {
   91|    163|            Some(vec) => vec,
   92|       |            None => {
   93|      0|                return Err(anyhow!("cannot find manifest root cid {}", root_cid));
   94|       |            }
   95|       |        };
   96|    163|        Manifest::new(vec)
   97|    163|    }
_RNCINvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB5_8Manifest3newNtNtCs71iYhC60HpU_5alloc6string6StringINtNtB14_3vec3VecTB10_INtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEE0CsilvC8qPft2D_8fvm_fuzz:
  116|  1.30k|            .flat_map(|&k| by_name.get(k))
_RNvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB2_8Manifest15get_embryo_code:
  212|    163|    pub fn get_embryo_code(&self) -> &Cid {
  213|    163|        &self.embryo_code
  214|    163|    }
_RNvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB2_8Manifest15get_system_code:
  202|    163|    pub fn get_system_code(&self) -> &Cid {
  203|    163|        &self.system_code
  204|    163|    }
_RNvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB2_8Manifest12get_eam_code:
  207|    163|    pub fn get_eam_code(&self) -> &Cid {
  208|    163|        &self.eam_code
  209|    163|    }
_RNvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB2_8Manifest13get_init_code:
  197|    163|    pub fn get_init_code(&self) -> &Cid {
  198|    163|        &self.init_code
  199|    163|    }
_RNvMNtNtCsheoVkkQew6K_3fvm7machine8manifestNtB2_8Manifest16get_account_code:
  192|    163|    pub fn get_account_code(&self) -> &Cid {
  193|    163|        &self.account_code
  194|    163|    }

_RNvXs4_NtCsheoVkkQew6K_3fvm7machineNtB5_14MachineContextNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref:
  216|    652|#[derive(Clone, Debug, Deref, DerefMut)]
_RNvXs1_NtCsheoVkkQew6K_3fvm7machineNtB5_13NetworkConfigNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  104|    489|#[derive(Debug, Clone)]
_RNvXs2_NtCsheoVkkQew6K_3fvm7machineNtB5_14MachineContextNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  216|    163|#[derive(Clone, Debug, Deref, DerefMut)]
_RNvMNtCsheoVkkQew6K_3fvm7machineNtB2_13NetworkConfig22enable_actor_debugging:
  172|    163|    pub fn enable_actor_debugging(&mut self) -> &mut Self {
  173|    163|        self.actor_debugging = true;
  174|    163|        self
  175|    163|    }
_RNvMNtCsheoVkkQew6K_3fvm7machineNtB2_13NetworkConfig15override_actors:
  179|    163|    pub fn override_actors(&mut self, manifest: Cid) -> &mut Self {
  180|    163|        self.builtin_actors_override = Some(manifest);
  181|    163|        self
  182|    163|    }
_RNvMs_NtCsheoVkkQew6K_3fvm7machineNtB4_14MachineContext12set_base_fee:
  255|    163|    pub fn set_base_fee(&mut self, amt: TokenAmount) -> &mut Self {
  256|    163|        self.base_fee = amt;
  257|    163|        self
  258|    163|    }
_RNvMs_NtCsheoVkkQew6K_3fvm7machineNtB4_14MachineContext14enable_tracing:
  267|    163|    pub fn enable_tracing(&mut self) -> &mut Self {
  268|    163|        self.tracing = true;
  269|    163|        self
  270|    163|    }
_RNvMNtCsheoVkkQew6K_3fvm7machineNtB2_13NetworkConfig3new:
  155|    326|    pub fn new(network_version: NetworkVersion) -> Self {
  156|    326|        NetworkConfig {
  157|    326|            chain_id: ChainID::from(0u64),
  158|    326|            network_version,
  159|    326|            max_call_depth: 1024,
  160|    326|            max_wasm_stack: 2048,
  161|    326|            max_inst_memory_bytes: 512 * (1 << 20),
  162|    326|            max_exec_memory_bytes: 2 * (1 << 30),
  163|    326|            actor_debugging: false,
  164|    326|            builtin_actors_override: None,
  165|    326|            price_list: price_list_by_network_version(network_version),
  166|    326|            actor_redirect: vec![],
  167|    326|        }
  168|    326|    }
_RNvMNtCsheoVkkQew6K_3fvm7machineNtB2_13NetworkConfig9for_epoch:
  191|    163|    pub fn for_epoch(
  192|    163|        &self,
  193|    163|        epoch: ChainEpoch,
  194|    163|        timestamp: u64,
  195|    163|        initial_state: Cid,
  196|    163|    ) -> MachineContext {
  197|    163|        MachineContext {
  198|    163|            network: self.clone(),
  199|    163|            base_fee: TokenAmount::zero(),
  200|    163|            epoch,
  201|    163|            timestamp,
  202|    163|            initial_state_root: initial_state,
  203|    163|            circ_supply: fvm_shared::TOTAL_FILECOIN.clone(),
  204|    163|            tracing: false,
  205|    163|        }
  206|    163|    }

_RNvMs_NtCsheoVkkQew6K_3fvm10state_treeINtB4_9StateTreeINtNtNtB6_10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreEE13new_from_rootCs4ieSHZHrxF6_15direct_syscalls:
  254|    163|    pub fn new_from_root(store: S, c: &Cid) -> Result<Self> {
  255|       |        // Try to load state root, if versioned
  256|    163|        let (version, info, actors) = match store.get_cbor(c) {
  257|       |            Ok(Some(StateRoot {
  258|    163|                version,
  259|    163|                info,
  260|    163|                actors,
  261|    163|            })) => (version, Some(info), actors),
  262|       |            Ok(None) => {
  263|      0|                return Err(ExecutionError::Fatal(anyhow!(
  264|      0|                    "failed to find state tree {}",
  265|      0|                    c
  266|      0|                )))
  267|       |            }
  268|      0|            Err(e) => {
  269|      0|                return Err(ExecutionError::Fatal(anyhow!(
  270|      0|                    "failed to load state tree {}: {}",
  271|      0|                    c,
  272|      0|                    e
  273|      0|                )))
  274|       |            }
  275|       |        };
  276|       |
  277|    163|        match version {
  278|       |            StateTreeVersion::V0
  279|       |            | StateTreeVersion::V1
  280|       |            | StateTreeVersion::V2
  281|       |            | StateTreeVersion::V3
  282|      0|            | StateTreeVersion::V4 => Err(ExecutionError::Fatal(anyhow!(
  283|      0|                "unsupported state tree version: {:?}",
  284|      0|                version
  285|      0|            ))),
  286|       |
  287|       |            StateTreeVersion::V5 => {
  288|    163|                let hamt = Hamt::load_with_bit_width(&actors, store, HAMT_BIT_WIDTH)
  289|    163|                    .context("failed to load state tree")
  290|    163|                    .or_fatal()?;
  291|       |
  292|    163|                Ok(Self {
  293|    163|                    hamt,
  294|    163|                    version,
  295|    163|                    info,
  296|    163|                    snaps: StateSnapshots::new(),
  297|    163|                })
  298|       |            }
  299|       |        }
  300|    163|    }
_RINvXNvNvXs9_NtCsheoVkkQew6K_3fvm10state_treeNtBb_10ActorStateNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serialize1__NtB5_5InnerBY_9serializeINtCs6R461GKLOna_11serde_tuple10SerializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEEECs4ieSHZHrxF6_15direct_syscalls:
  510|    489|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCsheoVkkQew6K_3fvm10state_treeINtB4_9StateTreeNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE5flushCs4ieSHZHrxF6_15direct_syscalls:
  444|    163|    pub fn flush(&mut self) -> Result<Cid> {
  445|    163|        if self.snaps.layers.len() != 1 {
  446|      0|            return Err(ExecutionError::Fatal(anyhow!(
  447|      0|                "tried to flush state tree with snapshots on the stack: {:?}",
  448|      0|                self.snaps.layers.len()
  449|      0|            )));
  450|    163|        }
  451|       |
  452|    489|        for (&id, sto) in self.snaps.layers[0].actors.borrow().iter() {
  453|    489|            let addr = Address::new_id(id);
  454|    489|            match sto {
  455|       |                None => {
  456|      0|                    self.hamt.delete(&addr.to_bytes()).or_fatal()?;
  457|       |                }
  458|    489|                Some(ref state) => {
  459|    489|                    self.hamt
  460|    489|                        .set(addr.to_bytes().into(), state.clone())
  461|    489|                        .or_fatal()?;
  462|       |                }
  463|       |            }
  464|       |        }
  465|       |
  466|    163|        let root = self.hamt.flush().or_fatal()?;
  467|       |
  468|    163|        match self.version {
  469|      0|            StateTreeVersion::V0 => Ok(root),
  470|       |            _ => {
  471|    163|                let cid = self
  472|    163|                    .info
  473|    163|                    .expect("malformed state tree, version 1+ require info");
  474|    163|                let obj = &StateRoot {
  475|    163|                    version: self.version,
  476|    163|                    actors: root,
  477|    163|                    info: cid,
  478|    163|                };
  479|    163|                let root = self
  480|    163|                    .store()
  481|    163|                    .put_cbor(obj, multihash::Code::Blake2b256)
  482|    163|                    .or_fatal()?;
  483|    163|                Ok(root)
  484|       |            }
  485|       |        }
  486|    163|    }
_RNvMs_NtCsheoVkkQew6K_3fvm10state_treeINtB4_9StateTreeNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE10into_storeCs4ieSHZHrxF6_15direct_syscalls:
  489|    163|    pub fn into_store(self) -> S {
  490|    163|        self.hamt.into_store()
  491|    163|    }
_RINvXNvXNvNvXsa_NtCsheoVkkQew6K_3fvm10state_treeNtBe_10ActorStateNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize1__NtB8_5InnerB11_11deserializeNtB3_9___VisitorNtB13_7Visitor9visit_seqQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerECs4ieSHZHrxF6_15direct_syscalls:
  510|    489|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RINvXNvNvXsa_NtCsheoVkkQew6K_3fvm10state_treeNtBb_10ActorStateNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize1__NtB5_5InnerBY_11deserializeINtCs6R461GKLOna_11serde_tuple12DeserializerNtNtCsb605JUWHIii_12libipld_core4ipld4IpldEECs4ieSHZHrxF6_15direct_syscalls:
  510|    489|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCsheoVkkQew6K_3fvm10state_treeINtB4_9StateTreeINtNtNtB6_10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreEE5storeCs4ieSHZHrxF6_15direct_syscalls:
  303|    326|    pub fn store(&self) -> &S {
  304|    326|        self.hamt.store()
  305|    326|    }
_RINvXs9_NtCsheoVkkQew6K_3fvm10state_treeNtB6_10ActorStateNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  510|    489|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RINvXsa_NtCsheoVkkQew6K_3fvm10state_treeNtB6_10ActorStateNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  510|    489|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCsheoVkkQew6K_3fvm10state_treeINtB4_9StateTreeNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE5storeCs4ieSHZHrxF6_15direct_syscalls:
  303|    163|    pub fn store(&self) -> &S {
  304|    163|        self.hamt.store()
  305|    163|    }
_RNvXs7_NtCsheoVkkQew6K_3fvm10state_treeNtB5_10ActorStateNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
  510|    489|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCsheoVkkQew6K_3fvm10state_treeINtB4_9StateTreeNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE3newCsilvC8qPft2D_8fvm_fuzz:
  222|    163|    pub fn new(store: S, version: StateTreeVersion) -> Result<Self> {
  223|    163|        let info = match version {
  224|       |            StateTreeVersion::V0
  225|       |            | StateTreeVersion::V1
  226|       |            | StateTreeVersion::V2
  227|       |            | StateTreeVersion::V3
  228|       |            | StateTreeVersion::V4 => {
  229|      0|                return Err(ExecutionError::Fatal(anyhow!(
  230|      0|                    "unsupported state tree version: {:?}",
  231|      0|                    version
  232|      0|                )))
  233|       |            }
  234|       |            StateTreeVersion::V5 => {
  235|    163|                let cid = store
  236|    163|                    .put_cbor(&StateInfo0::default(), multihash::Code::Blake2b256)
  237|    163|                    .context("failed to put state info")
  238|    163|                    .or_fatal()?;
  239|    163|                Some(cid)
  240|    163|            }
  241|    163|        };
  242|    163|
  243|    163|        // Both V3 and V4 use bitwidt=5.
  244|    163|        let hamt = Hamt::new_with_bit_width(store, HAMT_BIT_WIDTH);
  245|    163|        Ok(Self {
  246|    163|            hamt,
  247|    163|            version,
  248|    163|            info,
  249|    163|            snaps: StateSnapshots::new(),
  250|    163|        })
  251|    163|    }
_RNvMs_NtCsheoVkkQew6K_3fvm10state_treeINtB4_9StateTreeNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE5storeCsilvC8qPft2D_8fvm_fuzz:
  303|    489|    pub fn store(&self) -> &S {
  304|    489|        self.hamt.store()
  305|    489|    }
_RNvMNtCsheoVkkQew6K_3fvm10state_treeNtB2_14StateSnapshots12is_read_only:
  152|    489|    fn is_read_only(&self) -> bool {
  153|    489|        self.read_only_layers > 0
  154|    489|    }
_RNvMs_NtCsheoVkkQew6K_3fvm10state_treeINtB4_9StateTreeNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE9set_actorCsilvC8qPft2D_8fvm_fuzz:
  344|    489|    pub fn set_actor(&mut self, id: ActorID, actor: ActorState) -> Result<()> {
  345|    489|        self.snaps.set_actor(id, actor)
  346|    489|    }
_RNvMNtCsheoVkkQew6K_3fvm10state_treeNtB2_14StateSnapshots9set_actor:
  200|    489|        self.assert_writable()?;
  201|       |
  202|    489|        self.top_layer()?
  203|       |            .actors
  204|    489|            .borrow_mut()
  205|    489|            .insert(id, Some(actor));
  206|    489|        Ok(())
  207|    489|    }
_RNvMNtCsheoVkkQew6K_3fvm10state_treeNtB2_14StateSnapshots15assert_writable:
  156|    489|    fn assert_writable(&self) -> Result<()> {
  157|    489|        if self.is_read_only() {
  158|      0|            Err(syscall_error!(ReadOnly; "cannot mutate state while in read-only mode").into())
  159|       |        } else {
  160|    489|            Ok(())
  161|       |        }
  162|    489|    }
_RNvMNtCsheoVkkQew6K_3fvm10state_treeNtB2_14StateSnapshots9top_layer:
  144|    489|    fn top_layer(&self) -> Result<&StateSnapLayer> {
  145|    489|        self.layers
  146|    489|            .last()
  147|    489|            .context("state snapshots empty")
  148|    489|            .or_fatal()
  149|    489|    }
_RNvMNtCsheoVkkQew6K_3fvm10state_treeNtB2_14StateSnapshots3new:
   65|    326|    fn new() -> Self {
   66|    326|        Self {
   67|    326|            layers: vec![StateSnapLayer::default()],
   68|    326|            read_only_layers: 0,
   69|    326|        }
   70|    326|    }
_RNvXs2_NtCsheoVkkQew6K_3fvm10state_treeNtB5_14StateSnapLayerNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   50|    326|#[derive(Debug, Default)]

_RNvMs0_NtNtCsheoVkkQew6K_3fvm8syscalls7contextNtB5_6Memory3new:
   40|    163|    pub fn new<'a>(m: &'a mut [u8]) -> &'a mut Memory {
   41|    163|        // We explicitly specify the lifetimes here to ensure that the cast doesn't inadvertently
   42|    163|        // change them.
   43|    163|        unsafe { &mut *(m as *mut [u8] as *mut Memory) }
   44|    163|    }
_RNvXNtNtCsheoVkkQew6K_3fvm8syscalls7contextNtB2_6MemoryNtNtNtCsdRJjCzU6nMS_4core3ops5deref5Deref5deref:
   27|    163|    fn deref(&self) -> &Self::Target {
   28|    163|        &self.0
   29|    163|    }
_RNvMs0_NtNtCsheoVkkQew6K_3fvm8syscalls7contextNtB5_6Memory9try_slice:
   57|    163|    pub fn try_slice(&self, offset: u32, len: u32) -> Result<&[u8]> {
   58|    163|        self.get(offset as usize..)
   59|    163|            .and_then(|data| data.get(..len as usize))
   60|    163|            .ok_or_else(|| format!("buffer {} (length {}) out of bounds", offset, len))
   61|    163|            .or_error(ErrorNumber::IllegalArgument)
   62|    163|    }
_RNCNvMs0_NtNtCsheoVkkQew6K_3fvm8syscalls7contextNtB7_6Memory9try_slice0Bb_:
   59|    163|            .and_then(|data| data.get(..len as usize))

_RINvNtNtCsheoVkkQew6K_3fvm8syscalls4ipld12block_createINtNtNtB6_6kernel7default13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9ModpadCpa2_21fvm_integration_tests5dummy12DummyExternsEEEECs4ieSHZHrxF6_15direct_syscalls:
   27|    163|pub fn block_create(
   28|    163|    context: Context<'_, impl Kernel>,
   29|    163|    codec: u64,
   30|    163|    data_off: u32,
   31|    163|    data_len: u32,
   32|    163|) -> Result<u32> {
   33|       |    #[cfg(feature = "instrument-syscalls")]
   34|       |    unsafe { set_syscall_probe("syscall.ipld.block_create") };
   35|    163|    let data = context.memory.try_slice(data_off, data_len)?;
   36|    163|    context.kernel.block_create(codec, data)
   37|    163|}

_RINvXs2_NtCsheoVkkQew6K_3fvm12system_actorNtB6_5StateNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   15|    163|#[derive(Default, Deserialize_tuple, Serialize_tuple)]
_RINvXNvNvXs2_NtCsheoVkkQew6K_3fvm12system_actorNtBb_5StateNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serialize1__NtB5_5InnerBU_9serializeINtCs6R461GKLOna_11serde_tuple10SerializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEEECsilvC8qPft2D_8fvm_fuzz:
   15|    163|#[derive(Default, Deserialize_tuple, Serialize_tuple)]

_RNvXs_NtCsf3d0o8dgc6o_19fvm_ipld_blockstore5blockINtB4_5BlockRINtNtCs71iYhC60HpU_5alloc3vec3VechEEINtNtCsdRJjCzU6nMS_4core7convert5AsRefShE6as_refCs4ieSHZHrxF6_15direct_syscalls:
   42|    326|    fn as_ref(&self) -> &[u8] {
   43|    326|        self.data.as_ref()
   44|    326|    }
_RNvMNtCsf3d0o8dgc6o_19fvm_ipld_blockstore5blockINtB2_5BlockRINtNtCs71iYhC60HpU_5alloc3vec3VechEE3cidCs4ieSHZHrxF6_15direct_syscalls:
   28|    326|    pub fn cid(&self, mh_code: multihash::Code) -> Cid {
   29|    326|        Cid::new_v1(self.codec, mh_code.digest(self.data.as_ref()))
   30|    326|    }
_RNvMNtCsf3d0o8dgc6o_19fvm_ipld_blockstore5blockINtB2_5BlockRINtNtCs71iYhC60HpU_5alloc3vec3VechEE3cidCsilvC8qPft2D_8fvm_fuzz:
   28|    815|    pub fn cid(&self, mh_code: multihash::Code) -> Cid {
   29|    815|        Cid::new_v1(self.codec, mh_code.digest(self.data.as_ref()))
   30|    815|    }
_RNvXs_NtCsf3d0o8dgc6o_19fvm_ipld_blockstore5blockINtB4_5BlockRINtNtCs71iYhC60HpU_5alloc3vec3VechEEINtNtCsdRJjCzU6nMS_4core7convert5AsRefShE6as_refCsilvC8qPft2D_8fvm_fuzz:
   42|    815|    fn as_ref(&self) -> &[u8] {
   43|    815|        self.data.as_ref()
   44|    815|    }

_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtB7_10Blockstore3putRINtNtCs71iYhC60HpU_5alloc3vec3VechEECs4ieSHZHrxF6_15direct_syscalls:
   39|    326|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
   40|    326|    where
   41|    326|        Self: Sized,
   42|    326|        D: AsRef<[u8]>,
   43|    326|    {
   44|    326|        let k = block.cid(mh_code);
   45|    326|        self.put_keyed(&k, block.as_ref())?;
   46|    326|        Ok(k)
   47|    326|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtB7_10Blockstore14put_many_keyedRINtNtCs71iYhC60HpU_5alloc3vec3VechEINtNtNtNtCsdRJjCzU6nMS_4core4iter8adapters3map3MapINtNtNtB2l_5slice4iter4IterTINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EB1D_EENCNCINvCs2NnW6XqvVM8_12fvm_ipld_car14load_car_innerRShB3_E0s0_0EECsilvC8qPft2D_8fvm_fuzz:
   73|    163|    fn put_many_keyed<D, I>(&self, blocks: I) -> Result<()>
   74|    163|    where
   75|    163|        Self: Sized,
   76|    163|        D: AsRef<[u8]>,
   77|    163|        I: IntoIterator<Item = (Cid, D)>,
   78|    163|    {
   79|  2.93k|        for (c, b) in blocks {
   80|  2.77k|            self.put_keyed(&c, b.as_ref())?
   81|       |        }
   82|    163|        Ok(())
   83|    163|    }
_RINvXCsf3d0o8dgc6o_19fvm_ipld_blockstoreRNtNtB3_6memory16MemoryBlockstoreNtB3_10Blockstore3putRINtNtCs71iYhC60HpU_5alloc3vec3VechEECsilvC8qPft2D_8fvm_fuzz:
  106|    163|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
  107|    163|    where
  108|    163|        Self: Sized,
  109|    163|        D: AsRef<[u8]>,
  110|    163|    {
  111|    163|        (*self).put(mh_code, block)
  112|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtB7_10Blockstore3putRINtNtCs71iYhC60HpU_5alloc3vec3VechEECsilvC8qPft2D_8fvm_fuzz:
   39|    815|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
   40|    815|    where
   41|    815|        Self: Sized,
   42|    815|        D: AsRef<[u8]>,
   43|    815|    {
   44|    815|        let k = block.cid(mh_code);
   45|    815|        self.put_keyed(&k, block.as_ref())?;
   46|    815|        Ok(k)
   47|    815|    }
_RINvXCsf3d0o8dgc6o_19fvm_ipld_blockstoreRRNtNtB3_6memory16MemoryBlockstoreNtB3_10Blockstore3putRINtNtCs71iYhC60HpU_5alloc3vec3VechEECsilvC8qPft2D_8fvm_fuzz:
  106|    163|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
  107|    163|    where
  108|    163|        Self: Sized,
  109|    163|        D: AsRef<[u8]>,
  110|    163|    {
  111|    163|        (*self).put(mh_code, block)
  112|    163|    }

_RNvXs1_NtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memoryNtB5_16MemoryBlockstoreNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   11|    163|#[derive(Debug, Default, Clone)]
_RNvXs_NtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore3get:
   27|    978|    fn get(&self, k: &Cid) -> Result<Option<Vec<u8>>> {
   28|    978|        Ok(self.blocks.borrow().get(k).cloned())
   29|    978|    }
_RNvXs_NtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore3has:
   23|    163|    fn has(&self, k: &Cid) -> Result<bool> {
   24|    163|        Ok(self.blocks.borrow().contains_key(k))
   25|    163|    }
_RNvXs_NtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore9put_keyed:
   31|  3.91k|    fn put_keyed(&self, k: &Cid, block: &[u8]) -> Result<()> {
   32|  3.91k|        self.blocks.borrow_mut().insert(*k, block.into());
   33|  3.91k|        Ok(())
   34|  3.91k|    }

_RNvMs0_Cs2NnW6XqvVM8_12fvm_ipld_carINtB5_9CarReaderRShE3newCsilvC8qPft2D_8fvm_fuzz:
   72|    163|    pub async fn new(mut reader: R) -> Result<Self, Error> {
_RINvCs2NnW6XqvVM8_12fvm_ipld_car14load_car_innerRShNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
  156|    163|async fn load_car_inner<R, B>(s: &B, reader: R, verify: bool) -> Result<Vec<Cid>, Error>
  157|    163|where
  158|    163|    B: Blockstore,
  159|    163|    R: AsyncRead + Send + Unpin,
  160|    163|{
_RINvCs2NnW6XqvVM8_12fvm_ipld_car18load_car_uncheckedRShNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
  148|    163|pub async fn load_car_unchecked<R, B>(s: &B, reader: R) -> Result<Vec<Cid>, Error>
  149|    163|where
  150|    163|    B: Blockstore,
  151|    163|    R: AsyncRead + Send + Unpin,
  152|    163|{
_RNCINvCs2NnW6XqvVM8_12fvm_ipld_car14load_car_innerRShNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0CsilvC8qPft2D_8fvm_fuzz:
  161|    163|    let mut car_reader = if verify {
  162|      0|        CarReader::new(reader).await
  163|       |    } else {
  164|    163|        CarReader::new_unchecked(reader).await
  165|      0|    }?;
  166|       |
  167|       |    // Batch write key value pairs from car file
  168|       |    // TODO: Stream the data once some of the stream APIs stabilize.
  169|    163|    let mut buf = Vec::with_capacity(100);
  170|  2.93k|    while let Some(block) = car_reader.next_block().await? {
  171|  2.77k|        buf.push((block.cid, block.data));
  172|  2.77k|        if buf.len() > 1000 {
  173|      0|            s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))
  174|      0|                .map_err(|e| Error::Other(e.to_string()))?;
  175|      0|            buf.clear();
  176|  2.77k|        }
  177|       |    }
  178|    163|    s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))
  179|    163|        .map_err(|e| Error::Other(e.to_string()))?;
  180|    163|    Ok(car_reader.header.roots)
  181|    163|}
_RINvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB5_9CarHeaderNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
   19|    163|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNCNvMs0_Cs2NnW6XqvVM8_12fvm_ipld_carINtB7_9CarReaderRShE10next_block0CsilvC8qPft2D_8fvm_fuzz:
  101|  2.93k|        if let Some((cid, data)) = read_node(&mut self.reader).await? {
  102|  2.77k|            if self.validate {
  103|      0|                match cid.hash().code() {
  104|       |                    0x0 => {
  105|      0|                        if cid.hash().digest() != data {
  106|      0|                            return Err(Error::InvalidFile(
  107|      0|                                "CAR has an identity CID that doesn't match the corresponding data"
  108|      0|                                    .into(),
  109|      0|                            ));
  110|      0|                        }
  111|       |                    }
  112|      0|                    code => {
  113|      0|                        let code = multihash::Code::try_from(code)?;
  114|      0|                        let actual = Cid::new_v1(cid.codec(), code.digest(&data));
  115|      0|                        if actual != cid {
  116|      0|                            return Err(Error::InvalidFile(format!(
  117|      0|                                "CAR has an incorrect CID: expected {}, found {}",
  118|      0|                                cid, actual,
  119|      0|                            )));
  120|      0|                        }
  121|       |                    }
  122|       |                }
  123|  2.77k|            }
  124|  2.77k|            Ok(Some(Block { cid, data }))
  125|       |        } else {
  126|    163|            Ok(None)
  127|       |        }
  128|  2.93k|    }
_RNvMs0_Cs2NnW6XqvVM8_12fvm_ipld_carINtB5_9CarReaderRShE13new_uncheckedCsilvC8qPft2D_8fvm_fuzz:
   91|    163|    pub async fn new_unchecked(reader: R) -> Result<Self, Error> {
_RINvXs0_NvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtBb_9CarHeaderNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB6_9___VisitorNtBZ_7Visitor9visit_mapINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
   19|    489|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNvMs0_Cs2NnW6XqvVM8_12fvm_ipld_carINtB5_9CarReaderRShE10next_blockCsilvC8qPft2D_8fvm_fuzz:
   98|  2.93k|    pub async fn next_block(&mut self) -> Result<Option<Block>, Error> {
_RINvXs_NvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtBa_9CarHeaderNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB5_7___FieldBW_11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECsilvC8qPft2D_8fvm_fuzz:
   19|    326|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNCINvCs2NnW6XqvVM8_12fvm_ipld_car18load_car_uncheckedRShNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0CsilvC8qPft2D_8fvm_fuzz:
  153|    163|    load_car_inner(s, reader, false).await
  154|    163|}
_RNCNvMs0_Cs2NnW6XqvVM8_12fvm_ipld_carINtB7_9CarReaderRShE3new0CsilvC8qPft2D_8fvm_fuzz:
   73|    163|        let buf = ld_read(&mut reader)
   74|      0|            .await?
   75|    163|            .ok_or_else(|| Error::ParsingError("failed to parse uvarint for header".to_string()))?;
   76|    163|        let header: CarHeader = from_slice(&buf).map_err(|e| Error::ParsingError(e.to_string()))?;
   77|    163|        if header.roots.is_empty() {
   78|      0|            return Err(Error::ParsingError("empty CAR file".to_owned()));
   79|    163|        }
   80|    163|        if header.version != 1 {
   81|      0|            return Err(Error::InvalidFile("CAR file version must be 1".to_owned()));
   82|    163|        }
   83|    163|        Ok(CarReader {
   84|    163|            reader,
   85|    163|            header,
   86|    163|            validate: true,
   87|    163|        })
   88|    163|    }
_RNCNvMs0_Cs2NnW6XqvVM8_12fvm_ipld_carINtB7_9CarReaderRShE13new_unchecked0CsilvC8qPft2D_8fvm_fuzz:
   92|    163|        let mut reader = Self::new(reader).await?;
   93|    163|        reader.validate = false;
   94|    163|        Ok(reader)
   95|    163|    }
_RINvXNvXNvCs2NnW6XqvVM8_12fvm_ipld_cars_1__NtB8_9CarHeaderNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtB3_14___FieldVisitorNtBW_7Visitor9visit_strINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECsilvC8qPft2D_8fvm_fuzz:
   19|    326|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNCNCINvCs2NnW6XqvVM8_12fvm_ipld_car14load_car_innerRShNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0s0_0CsilvC8qPft2D_8fvm_fuzz:
  178|  2.77k|    s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))

_RNCINvNtCs2NnW6XqvVM8_12fvm_ipld_car4util7ld_readRShE0CsilvC8qPft2D_8fvm_fuzz:
   16|  3.09k|    let l: usize = match VarIntAsyncReader::read_varint_async(&mut reader).await {
   17|  2.93k|        Ok(len) => len,
   18|    163|        Err(e) => {
   19|    163|            if e.kind() == std::io::ErrorKind::UnexpectedEof {
   20|    163|                return Ok(None);
   21|      0|            }
   22|      0|            return Err(Error::Other(e.to_string()));
   23|       |        }
   24|       |    };
   25|  2.93k|    let mut buf = Vec::with_capacity(std::cmp::min(l as usize, MAX_ALLOC));
   26|  2.93k|    let bytes_read = reader
   27|  2.93k|        .take(l as u64)
   28|  2.93k|        .read_to_end(&mut buf)
   29|      0|        .await
   30|  2.93k|        .map_err(|e| Error::Other(e.to_string()))?;
   31|  2.93k|    if bytes_read != l {
   32|      0|        return Err(Error::Io(std::io::Error::new(
   33|      0|            std::io::ErrorKind::UnexpectedEof,
   34|      0|            format!(
   35|      0|                "expected to read at least {} bytes, but read {}",
   36|      0|                l, bytes_read
   37|      0|            ),
   38|      0|        )));
   39|  2.93k|    }
   40|  2.93k|    Ok(Some(buf))
   41|  3.09k|}
_RINvNtCs2NnW6XqvVM8_12fvm_ipld_car4util7ld_readRShECsilvC8qPft2D_8fvm_fuzz:
   11|  3.09k|pub(crate) async fn ld_read<R>(mut reader: &mut R) -> Result<Option<Vec<u8>>, Error>
   12|  3.09k|where
   13|  3.09k|    R: AsyncRead + Send + Unpin,
   14|  3.09k|{
_RINvNtCs2NnW6XqvVM8_12fvm_ipld_car4util9read_nodeRShECsilvC8qPft2D_8fvm_fuzz:
   53|  2.93k|pub(crate) async fn read_node<R>(buf_reader: &mut R) -> Result<Option<(Cid, Vec<u8>)>, Error>
   54|  2.93k|where
   55|  2.93k|    R: AsyncRead + Send + Unpin,
   56|  2.93k|{
_RNCINvNtCs2NnW6XqvVM8_12fvm_ipld_car4util9read_nodeRShE0CsilvC8qPft2D_8fvm_fuzz:
   57|  2.93k|    match ld_read(buf_reader).await? {
   58|  2.77k|        Some(buf) => {
   59|  2.77k|            let mut cursor = std::io::Cursor::new(&buf);
   60|  2.77k|            let cid = Cid::read_bytes(&mut cursor)?;
   61|  2.77k|            Ok(Some((cid, buf[cursor.position() as usize..].to_vec())))
   62|       |        }
   63|    163|        None => Ok(None),
   64|       |    }
   65|  2.93k|}

_RINvXNvXs0_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc6borrow3CowShENtB9_11Deserialize11deserializeNtB3_10CowVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor11visit_bytesNtNtCsb605JUWHIii_12libipld_core5error10SerdeErrorECs4ieSHZHrxF6_15direct_syscalls:
   96|    489|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   97|    489|                where
   98|    489|                    E: Error,
   99|    489|                {
  100|    489|                    Ok(Cow::Owned(v.to_vec()))
  101|    489|                }
_RINvXNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesShNtB3_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   35|    163|        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   36|    163|        where
   37|    163|            S: Serializer,
   38|    163|        {
   39|    163|            serializer.serialize_bytes(self.as_ref())
   40|    163|        }
_RINvXNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc3vec3VechENtB3_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   35|    489|        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   36|    489|        where
   37|    489|            S: Serializer,
   38|    489|        {
   39|    489|            serializer.serialize_bytes(self.as_ref())
   40|    489|        }
_RINvXNvXs_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc3vec3VechENtB8_11Deserialize11deserializeNtB3_10VecVisitorNtNtCs2VpXLMAfFh1_5serde2de7Visitor11visit_bytesINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsdRJjCzU6nMS_4core7convert10InfallibleEECs4ieSHZHrxF6_15direct_syscalls:
   57|    163|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Vec<u8>, E>
   58|    163|                where
   59|    163|                    E: Error,
   60|    163|                {
   61|    163|                    Ok(v.into())
   62|    163|                }
_RINvXs0_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc6borrow3CowShENtB6_11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
   76|    489|        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   77|    489|        where
   78|    489|            D: Deserializer<'de>,
   79|    489|        {
   80|    489|            struct CowVisitor;
   81|    489|
   82|    489|            impl<'de> Visitor<'de> for CowVisitor {
   83|    489|                type Value = Cow<'de, [u8]>;
   84|    489|
   85|    489|                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
   86|    489|                    formatter.write_str("a byte array")
   87|    489|                }
   88|    489|
   89|    489|                fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
   90|    489|                where
   91|    489|                    E: Error,
   92|    489|                {
   93|    489|                    Ok(Cow::Borrowed(v))
   94|    489|                }
   95|    489|
   96|    489|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   97|    489|                where
   98|    489|                    E: Error,
   99|    489|                {
  100|    489|                    Ok(Cow::Owned(v.to_vec()))
  101|    489|                }
  102|    489|
  103|    489|                fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
  104|    489|                where
  105|    489|                    E: Error,
  106|    489|                {
  107|    489|                    Ok(Cow::Owned(v))
  108|    489|                }
  109|    489|            }
  110|    489|            deserializer.deserialize_bytes(CowVisitor)
  111|    489|        }
_RNCINvXNvNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytes1__NtB7_7ByteBufNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEE0Cs4ieSHZHrxF6_15direct_syscalls:
  144|    163|    #[derive(serde::Deserialize, serde::Serialize, Debug, Eq, PartialEq, Clone)]
_RINvXNvNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytes1__NtB5_7ByteBufNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  144|    163|    #[derive(serde::Deserialize, serde::Serialize, Debug, Eq, PartialEq, Clone)]
_RINvXs_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs71iYhC60HpU_5alloc3vec3VechENtB5_11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   44|    163|        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   45|    163|        where
   46|    163|            D: Deserializer<'de>,
   47|    163|        {
   48|    163|            struct VecVisitor;
   49|    163|
   50|    163|            impl<'de> Visitor<'de> for VecVisitor {
   51|    163|                type Value = Vec<u8>;
   52|    163|
   53|    163|                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
   54|    163|                    formatter.write_str("byte array")
   55|    163|                }
   56|    163|
   57|    163|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Vec<u8>, E>
   58|    163|                where
   59|    163|                    E: Error,
   60|    163|                {
   61|    163|                    Ok(v.into())
   62|    163|                }
   63|    163|
   64|    163|                fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Vec<u8>, E>
   65|    163|                where
   66|    163|                    E: Error,
   67|    163|                {
   68|    163|                    Ok(v)
   69|    163|                }
   70|    163|            }
   71|    163|            deserializer.deserialize_byte_buf(VecVisitor)
   72|    163|        }
_RINvNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytes11deserializeINtNtCs71iYhC60HpU_5alloc3vec3VechEQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
  162|    163|    pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
  163|    163|    where
  164|    163|        T: Deserialize<'de>,
  165|    163|        D: Deserializer<'de>,
  166|    163|    {
  167|    163|        Deserialize::deserialize(deserializer)
  168|    163|    }
_RINvXNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesShNtB3_9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   35|    163|        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   36|    163|        where
   37|    163|            S: Serializer,
   38|    163|        {
   39|    163|            serializer.serialize_bytes(self.as_ref())
   40|    163|        }
_RNvMs2_NtNtCs3KfY3H2jiW3_17fvm_ipld_encoding5bytes12strict_bytesNtB5_7ByteBuf8into_vec:
  149|    163|        pub fn into_vec(self) -> Vec<u8> {
  150|    163|            self.0
  151|    163|        }

_RINvYINtNtNtCsheoVkkQew6K_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtBa_10state_tree10ActorStateNtNtB3l_14hash_algorithm6Sha256EECs4ieSHZHrxF6_15direct_syscalls:
   16|    163|        match self.get(cid)? {
   17|    163|            Some(bz) => {
   18|    163|                let res = crate::from_slice(&bz)?;
   19|    163|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    163|    }
_RINvYINtNtNtCsheoVkkQew6K_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8get_cborTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
   16|    163|        match self.get(cid)? {
   17|    163|            Some(bz) => {
   18|    163|                let res = crate::from_slice(&bz)?;
   19|    163|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    163|    }
_RINvYINtNtNtCsheoVkkQew6K_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCs71iYhC60HpU_5alloc3vec3VecTNtNtB3l_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECs4ieSHZHrxF6_15direct_syscalls:
   16|    163|        match self.get(cid)? {
   17|    163|            Some(bz) => {
   18|    163|                let res = crate::from_slice(&bz)?;
   19|    163|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8put_cborINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB2g_14hash_algorithm6Sha256EECs4ieSHZHrxF6_15direct_syscalls:
   26|    163|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    163|    where
   28|    163|        S: ser::Serialize,
   29|    163|    {
   30|    163|        let bytes = crate::to_vec(obj)?;
   31|    163|        self.put(
   32|    163|            code,
   33|    163|            &Block {
   34|    163|                codec: DAG_CBOR,
   35|    163|                data: &bytes,
   36|    163|            },
   37|    163|        )
   38|    163|    }
_RINvYINtNtNtCsheoVkkQew6K_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8get_cborNtNtCsgTTZuTcaXZ2_10fvm_shared5state9StateRootECs4ieSHZHrxF6_15direct_syscalls:
   16|    163|        match self.get(cid)? {
   17|    163|            Some(bz) => {
   18|    163|                let res = crate::from_slice(&bz)?;
   19|    163|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCsgTTZuTcaXZ2_10fvm_shared5state9StateRootECs4ieSHZHrxF6_15direct_syscalls:
   26|    163|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    163|    where
   28|    163|        S: ser::Serialize,
   29|    163|    {
   30|    163|        let bytes = crate::to_vec(obj)?;
   31|    163|        self.put(
   32|    163|            code,
   33|    163|            &Block {
   34|    163|                codec: DAG_CBOR,
   35|    163|                data: &bytes,
   36|    163|            },
   37|    163|        )
   38|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8put_cborAuj0_ECsilvC8qPft2D_8fvm_fuzz:
   26|    163|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    163|    where
   28|    163|        S: ser::Serialize,
   29|    163|    {
   30|    163|        let bytes = crate::to_vec(obj)?;
   31|    163|        self.put(
   32|    163|            code,
   33|    163|            &Block {
   34|    163|                codec: DAG_CBOR,
   35|    163|                data: &bytes,
   36|    163|            },
   37|    163|        )
   38|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCs71iYhC60HpU_5alloc3vec3VecTNtNtB2g_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECsilvC8qPft2D_8fvm_fuzz:
   16|    163|        match self.get(cid)? {
   17|    163|            Some(bz) => {
   18|    163|                let res = crate::from_slice(&bz)?;
   19|    163|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8get_cborTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
   16|    163|        match self.get(cid)? {
   17|    163|            Some(bz) => {
   18|    163|                let res = crate::from_slice(&bz)?;
   19|    163|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCsheoVkkQew6K_3fvm10init_actor5StateECsilvC8qPft2D_8fvm_fuzz:
   26|    163|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    163|    where
   28|    163|        S: ser::Serialize,
   29|    163|    {
   30|    163|        let bytes = crate::to_vec(obj)?;
   31|    163|        self.put(
   32|    163|            code,
   33|    163|            &Block {
   34|    163|                codec: DAG_CBOR,
   35|    163|                data: &bytes,
   36|    163|            },
   37|    163|        )
   38|    163|    }
_RINvYRRNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8put_cborINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCs71iYhC60HpU_5alloc6string6StringNtNtB2i_14hash_algorithm6Sha256EECsilvC8qPft2D_8fvm_fuzz:
   26|    163|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    163|    where
   28|    163|        S: ser::Serialize,
   29|    163|    {
   30|    163|        let bytes = crate::to_vec(obj)?;
   31|    163|        self.put(
   32|    163|            code,
   33|    163|            &Block {
   34|    163|                codec: DAG_CBOR,
   35|    163|                data: &bytes,
   36|    163|            },
   37|    163|        )
   38|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCsgTTZuTcaXZ2_10fvm_shared5state10StateInfo0ECsilvC8qPft2D_8fvm_fuzz:
   26|    163|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    163|    where
   28|    163|        S: ser::Serialize,
   29|    163|    {
   30|    163|        let bytes = crate::to_vec(obj)?;
   31|    163|        self.put(
   32|    163|            code,
   33|    163|            &Block {
   34|    163|                codec: DAG_CBOR,
   35|    163|                data: &bytes,
   36|    163|            },
   37|    163|        )
   38|    163|    }
_RINvYNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs3KfY3H2jiW3_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCsheoVkkQew6K_3fvm12system_actor5StateECsilvC8qPft2D_8fvm_fuzz:
   26|    163|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    163|    where
   28|    163|        S: ser::Serialize,
   29|    163|    {
   30|    163|        let bytes = crate::to_vec(obj)?;
   31|    163|        self.put(
   32|    163|            code,
   33|    163|            &Block {
   34|    163|                codec: DAG_CBOR,
   35|    163|                data: &bytes,
   36|    163|            },
   37|    163|        )
   38|    163|    }

_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding10from_sliceINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtBQ_14hash_algorithm6Sha256EECs4ieSHZHrxF6_15direct_syscalls:
   50|    163|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    163|where
   52|    163|    T: de::Deserialize<'a>,
   53|    163|{
   54|    163|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding10from_sliceINtNtCs71iYhC60HpU_5alloc3vec3VecTNtNtBQ_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECs4ieSHZHrxF6_15direct_syscalls:
   50|    163|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    163|where
   52|    163|    T: de::Deserialize<'a>,
   53|    163|{
   54|    163|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding6to_vecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtBL_14hash_algorithm6Sha256EECs4ieSHZHrxF6_15direct_syscalls:
   33|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    163|where
   35|    163|    T: ser::Serialize + ?Sized,
   36|    163|{
   37|    163|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding6to_vecNtNtCsgTTZuTcaXZ2_10fvm_shared5state9StateRootECs4ieSHZHrxF6_15direct_syscalls:
   33|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    163|where
   35|    163|    T: ser::Serialize + ?Sized,
   36|    163|{
   37|    163|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding10from_sliceTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECs4ieSHZHrxF6_15direct_syscalls:
   50|    163|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    163|where
   52|    163|    T: de::Deserialize<'a>,
   53|    163|{
   54|    163|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding10from_sliceNtNtCsgTTZuTcaXZ2_10fvm_shared5state9StateRootECs4ieSHZHrxF6_15direct_syscalls:
   50|    163|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    163|where
   52|    163|    T: de::Deserialize<'a>,
   53|    163|{
   54|    163|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding6to_vecNtNtCsgTTZuTcaXZ2_10fvm_shared5state10StateInfo0ECsilvC8qPft2D_8fvm_fuzz:
   33|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    163|where
   35|    163|    T: ser::Serialize + ?Sized,
   36|    163|{
   37|    163|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding6to_vecNtNtCsheoVkkQew6K_3fvm12system_actor5StateECsilvC8qPft2D_8fvm_fuzz:
   33|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    163|where
   35|    163|    T: ser::Serialize + ?Sized,
   36|    163|{
   37|    163|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding10from_sliceINtNtCs71iYhC60HpU_5alloc3vec3VecTNtNtBQ_6string6StringINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEEECsilvC8qPft2D_8fvm_fuzz:
   50|    163|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    163|where
   52|    163|    T: de::Deserialize<'a>,
   53|    163|{
   54|    163|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding6to_vecINtNtCs6zZxOXcsMaf_13fvm_ipld_hamt4node4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCs71iYhC60HpU_5alloc6string6StringNtNtBL_14hash_algorithm6Sha256EECsilvC8qPft2D_8fvm_fuzz:
   33|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    163|where
   35|    163|    T: ser::Serialize + ?Sized,
   36|    163|{
   37|    163|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding6to_vecAuj0_ECsilvC8qPft2D_8fvm_fuzz:
   33|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    163|where
   35|    163|    T: ser::Serialize + ?Sized,
   36|    163|{
   37|    163|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding10from_sliceTmINtNtCseVyrqhqyiIX_3cid3cid3CidKj40_EEECsilvC8qPft2D_8fvm_fuzz:
   50|    163|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    163|where
   52|    163|    T: de::Deserialize<'a>,
   53|    163|{
   54|    163|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding6to_vecNtNtCsheoVkkQew6K_3fvm10init_actor5StateECsilvC8qPft2D_8fvm_fuzz:
   33|    163|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    163|where
   35|    163|    T: ser::Serialize + ?Sized,
   36|    163|{
   37|    163|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    163|}
_RINvCs3KfY3H2jiW3_17fvm_ipld_encoding10from_sliceNtCs2NnW6XqvVM8_12fvm_ipld_car9CarHeaderECsilvC8qPft2D_8fvm_fuzz:
   50|    163|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    163|where
   52|    163|    T: de::Deserialize<'a>,
   53|    163|{
   54|    163|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    163|}

_RINvXs_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB5_8BitfieldNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   38|    163|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   39|    163|    where
   40|    163|        D: Deserializer<'de>,
   41|    163|    {
   42|    163|        let mut res = Bitfield::zero();
   43|    163|        let bytes = strict_bytes::ByteBuf::deserialize(deserializer)?.into_vec();
   44|    163|
   45|    163|        let mut arr = [0u8; 4 * 8];
   46|    163|        let len = bytes.len();
   47|    489|        for (old, new) in bytes.iter().zip(arr[(32 - len)..].iter_mut()) {
   48|    489|            *new = *old;
   49|    489|        }
   50|    163|        res.0[3] = BigEndian::read_u64(&arr[..8]);
   51|    163|        res.0[2] = BigEndian::read_u64(&arr[8..16]);
   52|    163|        res.0[1] = BigEndian::read_u64(&arr[16..24]);
   53|    163|        res.0[0] = BigEndian::read_u64(&arr[24..]);
   54|    163|
   55|    163|        Ok(res)
   56|    163|    }
_RINvXNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB3_8BitfieldNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   16|    163|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   17|    163|    where
   18|    163|        S: Serializer,
   19|    163|    {
   20|    163|        let mut v = [0u8; 4 * 8];
   21|    163|        // Big endian ordering, to match go
   22|    163|        BigEndian::write_u64(&mut v[..8], self.0[3]);
   23|    163|        BigEndian::write_u64(&mut v[8..16], self.0[2]);
   24|    163|        BigEndian::write_u64(&mut v[16..24], self.0[1]);
   25|    163|        BigEndian::write_u64(&mut v[24..], self.0[0]);
   26|       |
   27|  4.89k|        for i in 0..v.len() {
   28|  4.89k|            if v[i] != 0 {
   29|    163|                return strict_bytes::Serialize::serialize(&v[i..], serializer);
   30|  4.72k|            }
   31|       |        }
   32|       |
   33|      0|        <[u8] as strict_bytes::Serialize>::serialize(&[], serializer)
   34|    163|    }
_RINvXNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB3_8BitfieldNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   16|    163|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   17|    163|    where
   18|    163|        S: Serializer,
   19|    163|    {
   20|    163|        let mut v = [0u8; 4 * 8];
   21|    163|        // Big endian ordering, to match go
   22|    163|        BigEndian::write_u64(&mut v[..8], self.0[3]);
   23|    163|        BigEndian::write_u64(&mut v[8..16], self.0[2]);
   24|    163|        BigEndian::write_u64(&mut v[16..24], self.0[1]);
   25|    163|        BigEndian::write_u64(&mut v[24..], self.0[0]);
   26|       |
   27|  5.21k|        for i in 0..v.len() {
   28|  5.21k|            if v[i] != 0 {
   29|      0|                return strict_bytes::Serialize::serialize(&v[i..], serializer);
   30|  5.21k|            }
   31|       |        }
   32|       |
   33|    163|        <[u8] as strict_bytes::Serialize>::serialize(&[], serializer)
   34|    163|    }
_RNvNtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfield12set_bits_leq:
  132|    489|fn set_bits_leq(v: u64, bit: u32) -> u64 {
  133|    489|    (v as u128 | ((1u128 << (1 + bit)) - 1)) as u64
  134|    489|}
_RNvMs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield12set_bits_leq:
  110|    489|    pub fn set_bits_leq(mut self, bit: u32) -> Self {
  111|    489|        if bit < 64 {
  112|    489|            self.0[0] = set_bits_leq(self.0[0], bit);
  113|    489|        } else if bit < 128 {
  114|      0|            self.0[0] = std::u64::MAX;
  115|      0|            self.0[1] = set_bits_leq(self.0[1], bit - 64);
  116|      0|        } else if bit < 192 {
  117|      0|            self.0[0] = std::u64::MAX;
  118|      0|            self.0[1] = std::u64::MAX;
  119|      0|            self.0[2] = set_bits_leq(self.0[2], bit - 128);
  120|      0|        } else {
  121|      0|            self.0[0] = std::u64::MAX;
  122|      0|            self.0[1] = std::u64::MAX;
  123|      0|            self.0[2] = std::u64::MAX;
  124|      0|            self.0[3] = set_bits_leq(self.0[3], bit - 192);
  125|      0|        }
  126|       |
  127|    489|        self
  128|    489|    }
_RNCNvMs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB7_8Bitfield10count_ones0B9_:
   87|  3.91k|        self.0.iter().map(|a| a.count_ones() as usize).sum()
_RNvMs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield11set_bits_le:
  103|    489|    pub fn set_bits_le(self, bit: u32) -> Self {
  104|    489|        if bit == 0 {
  105|      0|            return self;
  106|    489|        }
  107|    489|        self.set_bits_leq(bit - 1)
  108|    489|    }
_RNvMs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield4zero:
   99|    978|    pub fn zero() -> Self {
  100|    978|        Bitfield([0, 0, 0, 0])
  101|    978|    }
_RNvMs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield8test_bit:
   72|    489|    pub fn test_bit(&self, idx: u32) -> bool {
   73|    489|        let ai = idx / 64;
   74|    489|        let bi = idx % 64;
   75|    489|
   76|    489|        self.0[ai as usize] & (1 << bi as u32) != 0
   77|    489|    }
_RNvMs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield3and:
   90|    489|    pub fn and(self, other: &Self) -> Self {
   91|    489|        Bitfield([
   92|    489|            self.0[0] & other.0[0],
   93|    489|            self.0[1] & other.0[1],
   94|    489|            self.0[2] & other.0[2],
   95|    489|            self.0[3] & other.0[3],
   96|    489|        ])
   97|    489|    }
_RNvMs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield10count_ones:
   86|    978|    pub fn count_ones(&self) -> usize {
   87|    978|        self.0.iter().map(|a| a.count_ones() as usize).sum()
   88|    978|    }
_RNvMs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield7set_bit:
   79|    489|    pub fn set_bit(&mut self, idx: u32) {
   80|    489|        let ai = idx / 64;
   81|    489|        let bi = idx % 64;
   82|    489|
   83|    489|        self.0[ai as usize] |= 1 << bi as u32;
   84|    489|    }

_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateE5storeCs4ieSHZHrxF6_15direct_syscalls:
  141|    163|    pub fn store(&self) -> &BS {
  142|    163|        &self.store
  143|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateE5flushCs4ieSHZHrxF6_15direct_syscalls:
  320|    163|        if let Some(cid) = self.flushed_cid {
  321|      0|            return Ok(cid);
  322|    163|        }
  323|    163|        self.root.flush(self.store.borrow())?;
  324|    163|        let cid = self.store.put_cbor(&self.root, Code::Blake2b256)?;
  325|    163|        self.flushed_cid = Some(cid);
  326|    163|        Ok(cid)
  327|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateE10into_storeCs4ieSHZHrxF6_15direct_syscalls:
  366|    163|    pub fn into_store(self) -> BS {
  367|    163|        self.store
  368|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCsheoVkkQew6K_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE5storeCs4ieSHZHrxF6_15direct_syscalls:
  141|    326|    pub fn store(&self) -> &BS {
  142|    326|        &self.store
  143|    326|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCsheoVkkQew6K_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE16load_with_configCs4ieSHZHrxF6_15direct_syscalls:
  104|    163|        match store.get_cbor(cid)? {
  105|    163|            Some(root) => Ok(Self {
  106|    163|                root,
  107|    163|                store,
  108|    163|                conf,
  109|    163|                hash: Default::default(),
  110|    163|                flushed_cid: Some(*cid),
  111|    163|            }),
  112|      0|            None => Err(Error::CidNotFound(cid.to_string())),
  113|       |        }
  114|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateE3setCs4ieSHZHrxF6_15direct_syscalls:
  167|    489|    pub fn set(&mut self, key: K, value: V) -> Result<Option<V>, Error>
  168|    489|    where
  169|    489|        V: PartialEq,
  170|    489|    {
  171|    489|        let (old, modified) = self
  172|    489|            .root
  173|    489|            .set(key, value, self.store.borrow(), &self.conf, true)?;
  174|       |
  175|    489|        if modified {
  176|    489|            self.flushed_cid = None;
  177|    489|        }
  178|       |
  179|    489|        Ok(old)
  180|    489|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCsheoVkkQew6K_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE19load_with_bit_widthCs4ieSHZHrxF6_15direct_syscalls:
  116|    163|    pub fn load_with_bit_width(cid: &Cid, store: BS, bit_width: u32) -> Result<Self, Error> {
  117|    163|        Self::load_with_config(
  118|    163|            cid,
  119|    163|            store,
  120|    163|            Config {
  121|    163|                bit_width,
  122|    163|                ..Default::default()
  123|    163|            },
  124|    163|        )
  125|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs71iYhC60HpU_5alloc6string6StringE5flushCsilvC8qPft2D_8fvm_fuzz:
  320|    163|        if let Some(cid) = self.flushed_cid {
  321|      0|            return Ok(cid);
  322|    163|        }
  323|    163|        self.root.flush(self.store.borrow())?;
  324|    163|        let cid = self.store.put_cbor(&self.root, Code::Blake2b256)?;
  325|    163|        self.flushed_cid = Some(cid);
  326|    163|        Ok(cid)
  327|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs71iYhC60HpU_5alloc6string6StringE18new_with_bit_widthCsilvC8qPft2D_8fvm_fuzz:
   87|    163|    pub fn new_with_bit_width(store: BS, bit_width: u32) -> Self {
   88|    163|        Self::new_with_config(
   89|    163|            store,
   90|    163|            Config {
   91|    163|                bit_width,
   92|    163|                ..Default::default()
   93|    163|            },
   94|    163|        )
   95|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateE5storeCsilvC8qPft2D_8fvm_fuzz:
  141|    489|    pub fn store(&self) -> &BS {
  142|    489|        &self.store
  143|    489|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateE15new_with_configCsilvC8qPft2D_8fvm_fuzz:
   76|    163|    pub fn new_with_config(store: BS, conf: Config) -> Self {
   77|    163|        Self {
   78|    163|            root: Node::default(),
   79|    163|            store,
   80|    163|            conf,
   81|    163|            hash: Default::default(),
   82|    163|            flushed_cid: None,
   83|    163|        }
   84|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs71iYhC60HpU_5alloc6string6StringE15new_with_configCsilvC8qPft2D_8fvm_fuzz:
   76|    163|    pub fn new_with_config(store: BS, conf: Config) -> Self {
   77|    163|        Self {
   78|    163|            root: Node::default(),
   79|    163|            store,
   80|    163|            conf,
   81|    163|            hash: Default::default(),
   82|    163|            flushed_cid: None,
   83|    163|        }
   84|    163|    }
_RNvMs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateE18new_with_bit_widthCsilvC8qPft2D_8fvm_fuzz:
   87|    163|    pub fn new_with_bit_width(store: BS, bit_width: u32) -> Self {
   88|    163|        Self::new_with_config(
   89|    163|            store,
   90|    163|            Config {
   91|    163|                bit_width,
   92|    163|                ..Default::default()
   93|    163|            },
   94|    163|        )
   95|    163|    }

_RNvXs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt14hash_algorithmNtB5_17Sha2HasherWrapperNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   19|    489|#[derive(Default)]
_RINvXs_NtCs6zZxOXcsMaf_13fvm_ipld_hamt14hash_algorithmNtB5_6Sha256NtB5_13HashAlgorithm4hashNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyECs4ieSHZHrxF6_15direct_syscalls:
   38|    489|    fn hash<X: ?Sized>(key: &X) -> HashedKey
   39|    489|    where
   40|    489|        X: Hash,
   41|    489|    {
   42|    489|        let mut hasher = Sha2HasherWrapper::default();
   43|    489|        key.hash(&mut hasher);
   44|    489|        hasher.0.finalize().into()
   45|    489|    }
_RNvXNtCs6zZxOXcsMaf_13fvm_ipld_hamt14hash_algorithmNtB2_17Sha2HasherWrapperNtNtCsdRJjCzU6nMS_4core4hash6Hasher5write:
   28|    489|    fn write(&mut self, bytes: &[u8]) {
   29|    489|        self.0.update(bytes);
   30|    489|    }

_RNvMNtCs6zZxOXcsMaf_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits12new_at_index:
   30|    489|    pub fn new_at_index(hash_buffer: &'a HashedKey, consumed: u32) -> HashBits<'a> {
   31|    489|        Self {
   32|    489|            b: hash_buffer,
   33|    489|            consumed,
   34|    489|        }
   35|    489|    }
_RNvMNtCs6zZxOXcsMaf_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits3new:
   25|    489|    pub fn new(hash_buffer: &'a HashedKey) -> HashBits<'a> {
   26|    489|        Self::new_at_index(hash_buffer, 0)
   27|    489|    }
_RNvMNtCs6zZxOXcsMaf_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits4next:
   39|    489|    pub fn next(&mut self, i: u32) -> Result<u32, Error> {
   40|    489|        if i > 8 || i == 0 {
   41|      0|            return Err(Error::InvalidHashBitLen);
   42|    489|        }
   43|    489|        let maxi = (self.b.len() as u32) * 8 - self.consumed;
   44|    489|        if maxi == 0 {
   45|      0|            return Err(Error::MaxDepth);
   46|    489|        }
   47|    489|        // Only take what's left. If we consume 5 bits at a time from a 256 bit key,
   48|    489|        // there will be 1 bit left at the bottom.
   49|    489|        Ok(self.next_bits(std::cmp::min(i, maxi)))
   50|    489|    }
_RNvNtCs6zZxOXcsMaf_13fvm_ipld_hamt9hash_bits6mkmask:
   20|    978|pub(crate) fn mkmask(n: u32) -> u32 {
   21|    978|    ((1u64 << n) - 1) as u32
   22|    978|}
_RNvMNtCs6zZxOXcsMaf_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits9next_bits:
   52|    489|    fn next_bits(&mut self, i: u32) -> u32 {
   53|    489|        let curbi = self.consumed / 8;
   54|    489|        let leftb = 8 - (self.consumed % 8);
   55|    489|
   56|    489|        let curb = self.b[curbi as usize] as u32;
   57|    489|        match i.cmp(&leftb) {
   58|       |            Ordering::Equal => {
   59|       |                // bits to consume is equal to the bits remaining in the currently indexed byte
   60|      0|                let out = mkmask(i) & curb;
   61|      0|                self.consumed += i;
   62|      0|                out
   63|       |            }
   64|       |            Ordering::Less => {
   65|       |                // Consuming less than the remaining bits in the current byte
   66|    489|                let a = curb & mkmask(leftb);
   67|    489|                let b = a & !mkmask(leftb - i);
   68|    489|                let c = b >> (leftb - i);
   69|    489|                self.consumed += i;
   70|    489|                c
   71|       |            }
   72|       |            Ordering::Greater => {
   73|       |                // Consumes remaining bits and remaining bits from a recursive call
   74|      0|                let mut out = (mkmask(leftb) & curb) as u64;
   75|      0|                out <<= i - leftb;
   76|      0|                self.consumed += leftb;
   77|      0|                out += self.next_bits(i - leftb) as u64;
   78|      0|                out as u32
   79|       |            }
   80|       |        }
   81|    489|    }

_RINvXNvCs6zZxOXcsMaf_13fvm_ipld_hamts_1__INtB5_12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
   75|    489|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RNvMs0_Cs6zZxOXcsMaf_13fvm_ipld_hamtINtB5_12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateE3newCs4ieSHZHrxF6_15direct_syscalls:
   88|    489|    pub fn new(key: K, value: V) -> Self {
   89|    489|        KeyValuePair(key, value)
   90|    489|    }
_RINvXNvCs6zZxOXcsMaf_13fvm_ipld_hamt1__INtB5_12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateENtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   75|    489|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RINvXNvXNvCs6zZxOXcsMaf_13fvm_ipld_hamts_1__INtB8_12KeyValuePairppENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeINtB3_9___VisitorNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateENtB15_7Visitor9visit_seqQNtNtNtCsb605JUWHIii_12libipld_core5serde2de15SeqDeserializerECs4ieSHZHrxF6_15direct_syscalls:
   75|    489|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RNvXCs6zZxOXcsMaf_13fvm_ipld_hamtNtB2_6ConfigNtNtCsdRJjCzU6nMS_4core7default7Default7default:
   64|    489|    fn default() -> Self {
   65|    489|        Self {
   66|    489|            bit_width: DEFAULT_BIT_WIDTH,
   67|    489|            min_data_depth: 0,
   68|    489|            max_array_width: 3,
   69|    489|        }
   70|    489|    }

_RINvMs2_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E12modify_valueNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs4ieSHZHrxF6_15direct_syscalls:
  246|    489|    fn modify_value<S: Blockstore>(
  247|    489|        &mut self,
  248|    489|        hashed_key: &mut HashBits,
  249|    489|        conf: &Config,
  250|    489|        depth: u32,
  251|    489|        key: K,
  252|    489|        value: V,
  253|    489|        store: &S,
  254|    489|        overwrite: bool,
  255|    489|    ) -> Result<(Option<V>, bool), Error>
  256|    489|    where
  257|    489|        V: PartialEq,
  258|    489|    {
  259|    489|        let idx = hashed_key.next(conf.bit_width)?;
  260|       |
  261|       |        // No existing values at this point.
  262|    489|        if !self.bitfield.test_bit(idx) {
  263|    489|            if depth >= conf.min_data_depth {
  264|    489|                self.insert_child(idx, key, value);
  265|    489|            } else {
  266|       |                // Need to insert some empty nodes reserved for links.
  267|      0|                let mut sub = Node::<K, V, H>::default();
  268|      0|                sub.modify_value(hashed_key, conf, depth + 1, key, value, store, overwrite)?;
  269|      0|                self.insert_child_dirty(idx, Box::new(sub));
  270|       |            }
  271|    489|            return Ok((None, true));
  272|      0|        }
  273|      0|
  274|      0|        let cindex = self.index_for_bit_pos(idx);
  275|      0|        let child = self.get_child_mut(cindex);
  276|      0|
  277|      0|        match child {
  278|      0|            Pointer::Link { cid, cache } => {
  279|      0|                cache.get_or_try_init(|| {
  280|       |                    store
  281|       |                        .get_cbor(cid)?
  282|       |                        .ok_or_else(|| Error::CidNotFound(cid.to_string()))
  283|      0|                })?;
  284|      0|                let child_node = cache.get_mut().expect("filled line above");
  285|       |
  286|      0|                let (old, modified) = child_node.modify_value(
  287|      0|                    hashed_key,
  288|      0|                    conf,
  289|      0|                    depth + 1,
  290|      0|                    key,
  291|      0|                    value,
  292|      0|                    store,
  293|      0|                    overwrite,
  294|      0|                )?;
  295|      0|                if modified {
  296|      0|                    *child = Pointer::Dirty(std::mem::take(child_node));
  297|      0|                }
  298|      0|                Ok((old, modified))
  299|       |            }
  300|      0|            Pointer::Dirty(node) => {
  301|      0|                node.modify_value(hashed_key, conf, depth + 1, key, value, store, overwrite)
  302|       |            }
  303|      0|            Pointer::Values(vals) => {
  304|       |                // Update, if the key already exists.
  305|      0|                if let Some(i) = vals.iter().position(|p| p.key() == &key) {
  306|      0|                    if overwrite {
  307|       |                        // If value changed, the parent nodes need to be marked as dirty.
  308|       |                        // ! The assumption here is that `PartialEq` is implemented correctly,
  309|       |                        // ! and that if that is true, the serialized bytes are equal.
  310|       |                        // ! To be absolutely sure, can serialize each value and compare or
  311|       |                        // ! refactor the Hamt to not be type safe and serialize on entry and
  312|       |                        // ! exit. These both come at costs, and this isn't a concern.
  313|      0|                        let value_changed = vals[i].value() != &value;
  314|      0|                        return Ok((
  315|      0|                            Some(std::mem::replace(&mut vals[i].1, value)),
  316|      0|                            value_changed,
  317|      0|                        ));
  318|       |                    } else {
  319|       |                        // Can't overwrite, return None and false that the Node was not modified.
  320|      0|                        return Ok((None, false));
  321|       |                    }
  322|      0|                }
  323|      0|
  324|      0|                // If the array is full, create a subshard and insert everything
  325|      0|                if vals.len() >= conf.max_array_width {
  326|      0|                    let kvs = std::mem::take(vals);
  327|      0|                    let hashed_kvs = kvs.into_iter().map(|KeyValuePair(k, v)| {
  328|       |                        let hash = H::hash(&k);
  329|       |                        (k, v, hash)
  330|      0|                    });
  331|      0|
  332|      0|                    let consumed = hashed_key.consumed;
  333|      0|                    let mut sub = Node::<K, V, H>::default();
  334|      0|                    let modified = sub.modify_value(
  335|      0|                        hashed_key,
  336|      0|                        conf,
  337|      0|                        depth + 1,
  338|      0|                        key,
  339|      0|                        value,
  340|      0|                        store,
  341|      0|                        overwrite,
  342|      0|                    )?;
  343|       |
  344|      0|                    for (k, v, hash) in hashed_kvs {
  345|      0|                        sub.modify_value(
  346|      0|                            &mut HashBits::new_at_index(&hash, consumed),
  347|      0|                            conf,
  348|      0|                            depth + 1,
  349|      0|                            k,
  350|      0|                            v,
  351|      0|                            store,
  352|      0|                            overwrite,
  353|      0|                        )?;
  354|       |                    }
  355|       |
  356|      0|                    *child = Pointer::Dirty(Box::new(sub));
  357|      0|
  358|      0|                    return Ok(modified);
  359|      0|                }
  360|      0|
  361|      0|                // Otherwise insert the element into the array in order.
  362|      0|                let max = vals.len();
  363|      0|                let idx = vals.iter().position(|c| c.key() > &key).unwrap_or(max);
  364|      0|
  365|      0|                let np = KeyValuePair::new(key, value);
  366|      0|                vals.insert(idx, np);
  367|      0|
  368|      0|                Ok((None, true))
  369|       |            }
  370|       |        }
  371|    489|    }
_RINvXs_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   41|    163|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   42|    163|    where
   43|    163|        S: Serializer,
   44|    163|    {
   45|    163|        (&self.bitfield, &self.pointers).serialize(serializer)
   46|    163|    }
_RNvMs2_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E17index_for_bit_posCs4ieSHZHrxF6_15direct_syscalls:
  485|    489|    fn index_for_bit_pos(&self, bp: u32) -> usize {
  486|    489|        let mask = Bitfield::zero().set_bits_le(bp);
  487|    489|        assert_eq!(mask.count_ones(), bp as usize);
  488|    489|        mask.and(&self.bitfield).count_ones()
  489|    489|    }
_RNvMs2_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E12insert_childCs4ieSHZHrxF6_15direct_syscalls:
  473|    489|    fn insert_child(&mut self, idx: u32, key: K, value: V) {
  474|    489|        let i = self.index_for_bit_pos(idx);
  475|    489|        self.bitfield.set_bit(idx);
  476|    489|        self.pointers.insert(i, Pointer::from_key_value(key, value))
  477|    489|    }
_RINvMs2_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E5flushNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs4ieSHZHrxF6_15direct_syscalls:
  448|    163|    pub fn flush<S: Blockstore>(&mut self, store: &S) -> Result<(), Error> {
  449|    652|        for pointer in &mut self.pointers {
  450|    489|            if let Pointer::Dirty(node) = pointer {
  451|       |                // Flush cached sub node to clear it's cache
  452|      0|                node.flush(store)?;
  453|       |
  454|       |                // Put node in blockstore and retrieve Cid
  455|      0|                let cid = store.put_cbor(node, Code::Blake2b256)?;
  456|       |
  457|       |                // Can keep the flushed node in link cache
  458|      0|                let cache = OnceCell::from(std::mem::take(node));
  459|      0|
  460|      0|                // Replace cached node with Cid link
  461|      0|                *pointer = Pointer::Link { cid, cache };
  462|    489|            }
  463|       |        }
  464|       |
  465|    163|        Ok(())
  466|    163|    }
_RINvXs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256ENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   54|    163|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   55|    163|    where
   56|    163|        D: Deserializer<'de>,
   57|    163|    {
   58|    163|        let (bitfield, pointers) = Deserialize::deserialize(deserializer)?;
   59|    163|        Ok(Node {
   60|    163|            bitfield,
   61|    163|            pointers,
   62|    163|            hash: Default::default(),
   63|    163|        })
   64|    163|    }
_RINvMs2_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E3setNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs4ieSHZHrxF6_15direct_syscalls:
   83|    489|    pub fn set<S: Blockstore>(
   84|    489|        &mut self,
   85|    489|        key: K,
   86|    489|        value: V,
   87|    489|        store: &S,
   88|    489|        conf: &Config,
   89|    489|        overwrite: bool,
   90|    489|    ) -> Result<(Option<V>, bool), Error>
   91|    489|    where
   92|    489|        V: PartialEq,
   93|    489|    {
   94|    489|        let hash = H::hash(&key);
   95|    489|        self.modify_value(
   96|    489|            &mut HashBits::new(&hash),
   97|    489|            conf,
   98|    489|            0,
   99|    489|            key,
  100|    489|            value,
  101|    489|            store,
  102|    489|            overwrite,
  103|    489|        )
  104|    489|    }
_RINvXs_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCs71iYhC60HpU_5alloc6string6StringNtNtB7_14hash_algorithm6Sha256ENtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   41|    163|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   42|    163|    where
   43|    163|        S: Serializer,
   44|    163|    {
   45|    163|        (&self.bitfield, &self.pointers).serialize(serializer)
   46|    163|    }
_RINvMs2_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCs71iYhC60HpU_5alloc6string6StringNtNtB8_14hash_algorithm6Sha256E5flushRRNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
  448|    163|    pub fn flush<S: Blockstore>(&mut self, store: &S) -> Result<(), Error> {
  449|    163|        for pointer in &mut self.pointers {
  450|      0|            if let Pointer::Dirty(node) = pointer {
  451|       |                // Flush cached sub node to clear it's cache
  452|      0|                node.flush(store)?;
  453|       |
  454|       |                // Put node in blockstore and retrieve Cid
  455|      0|                let cid = store.put_cbor(node, Code::Blake2b256)?;
  456|       |
  457|       |                // Can keep the flushed node in link cache
  458|      0|                let cache = OnceCell::from(std::mem::take(node));
  459|      0|
  460|      0|                // Replace cached node with Cid link
  461|      0|                *pointer = Pointer::Link { cid, cache };
  462|      0|            }
  463|       |        }
  464|       |
  465|    163|        Ok(())
  466|    163|    }
_RNvXs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCs71iYhC60HpU_5alloc6string6StringNtNtB7_14hash_algorithm6Sha256ENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsilvC8qPft2D_8fvm_fuzz:
   68|    163|    fn default() -> Self {
   69|    163|        Node {
   70|    163|            bitfield: Bitfield::zero(),
   71|    163|            pointers: Vec::new(),
   72|    163|            hash: Default::default(),
   73|    163|        }
   74|    163|    }
_RNvXs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCsdRJjCzU6nMS_4core7default7Default7defaultCsilvC8qPft2D_8fvm_fuzz:
   68|    163|    fn default() -> Self {
   69|    163|        Node {
   70|    163|            bitfield: Bitfield::zero(),
   71|    163|            pointers: Vec::new(),
   72|    163|            hash: Default::default(),
   73|    163|        }
   74|    163|    }

_RINvNtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointer9from_ipldINtNtCs71iYhC60HpU_5alloc3vec3VecINtB4_12KeyValuePairNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateEEECs4ieSHZHrxF6_15direct_syscalls:
  181|    489|fn from_ipld<T: DeserializeOwned>(ipld: Ipld) -> Result<T, String> {
  182|    489|    Deserialize::deserialize(ipld).map_err(|error| error.to_string())
  183|    489|}
_RINvXs_NtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   46|    489|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   47|    489|    where
   48|    489|        S: Serializer,
   49|    489|    {
   50|    489|        match self {
   51|    489|            Pointer::Values(vals) => vals.serialize(serializer),
   52|      0|            Pointer::Link { cid, .. } => cid.serialize(serializer),
   53|      0|            Pointer::Dirty(_) => Err(ser::Error::custom("Cannot serialize cached values")),
   54|       |        }
   55|    489|    }
_RNvXs0_NtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256EINtNtCsdRJjCzU6nMS_4core7convert7TryFromNtNtCsb605JUWHIii_12libipld_core4ipld4IpldE8try_fromCs4ieSHZHrxF6_15direct_syscalls:
   65|    489|    fn try_from(ipld: Ipld) -> Result<Self, Self::Error> {
   66|    489|        match ipld {
   67|    489|            ipld_list @ Ipld::List(_) => {
   68|    489|                let values: Vec<KeyValuePair<K, V>> = from_ipld(ipld_list)?;
   69|    489|                Ok(Self::Values(values))
   70|       |            }
   71|      0|            Ipld::Link(cid) => Ok(Self::Link {
   72|      0|                cid,
   73|      0|                cache: Default::default(),
   74|      0|            }),
   75|      0|            other => Err(format!(
   76|      0|                "Expected `Ipld::List` or `Ipld::Link`, got {:#?}",
   77|      0|                other
   78|      0|            )),
   79|       |        }
   80|    489|    }
_RNCINvXs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointerINtB8_7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtBa_14hash_algorithm6Sha256ENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEE0Cs4ieSHZHrxF6_15direct_syscalls:
   93|    489|        Ipld::deserialize(deserializer).and_then(|ipld| ipld.try_into().map_err(de::Error::custom))
_RNvMs3_NtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E14from_key_valueCs4ieSHZHrxF6_15direct_syscalls:
  109|    489|    pub(crate) fn from_key_value(key: K, value: V) -> Self {
  110|    489|        Pointer::Values(vec![KeyValuePair::new(key, value)])
  111|    489|    }
_RINvXs1_NtCs6zZxOXcsMaf_13fvm_ipld_hamt7pointerINtB6_7PointerNtNtCs1RjYuNghyhv_17forest_hash_utils3key8BytesKeyNtNtCsheoVkkQew6K_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256ENtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   89|    489|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   90|    489|    where
   91|    489|        D: Deserializer<'de>,
   92|    489|    {
   93|    489|        Ipld::deserialize(deserializer).and_then(|ipld| ipld.try_into().map_err(de::Error::custom))
   94|    489|    }

_RNvNtCsgTTZuTcaXZ2_10fvm_shared7address12to_leb_bytes:
  371|    489|pub(crate) fn to_leb_bytes(id: u64) -> Vec<u8> {
  372|    489|    // write id to buffer in leb128 format
  373|    489|    unsigned_varint::encode::u64(id, &mut unsigned_varint::encode::u64_buffer()).into()
  374|    489|}
_RNvMs_NtCsgTTZuTcaXZ2_10fvm_shared7addressNtB4_7Address8to_bytes:
  170|    489|    pub fn to_bytes(self) -> Vec<u8> {
  171|    489|        self.payload.to_bytes()
  172|    489|    }
_RNvMs_NtCsgTTZuTcaXZ2_10fvm_shared7addressNtB4_7Address6new_id:
   98|    652|    pub const fn new_id(id: u64) -> Self {
   99|    652|        Self {
  100|    652|            payload: Payload::ID(id),
  101|    652|        }
  102|    652|    }

_RNvMs_NtNtCsgTTZuTcaXZ2_10fvm_shared7address7payloadNtB4_7Payload12to_raw_bytes:
  107|    489|    pub fn to_raw_bytes(self) -> Vec<u8> {
  108|    489|        use Payload::*;
  109|    489|        match self {
  110|    489|            ID(i) => to_leb_bytes(i),
  111|      0|            Secp256k1(arr) => arr.to_vec(),
  112|      0|            Actor(arr) => arr.to_vec(),
  113|      0|            BLS(arr) => arr.to_vec(),
  114|      0|            Delegated(addr) => {
  115|      0|                let mut buf = to_leb_bytes(addr.namespace());
  116|      0|                buf.extend(addr.subaddress());
  117|      0|                buf
  118|       |            }
  119|       |        }
  120|    489|    }
_RNvXs0_NtNtCsgTTZuTcaXZ2_10fvm_shared7address7payloadNtNtB7_8protocol8ProtocolINtNtCsdRJjCzU6nMS_4core7convert4FromNtB5_7PayloadE4from:
  158|    489|    fn from(pl: Payload) -> Self {
  159|    489|        match pl {
  160|    489|            Payload::ID(_) => Self::ID,
  161|      0|            Payload::Secp256k1(_) => Self::Secp256k1,
  162|      0|            Payload::Actor(_) => Self::Actor,
  163|      0|            Payload::BLS(_) => Self::BLS,
  164|      0|            Payload::Delegated { .. } => Self::Delegated,
  165|       |        }
  166|    489|    }
_RNvMs_NtNtCsgTTZuTcaXZ2_10fvm_shared7address7payloadNtB4_7Payload8to_bytes:
  123|    489|    pub fn to_bytes(self) -> Vec<u8> {
  124|    489|        let mut bz = self.to_raw_bytes();
  125|    489|        bz.insert(0, Protocol::from(self) as u8);
  126|    489|        bz
  127|    489|    }

_RINvNtNtCsgTTZuTcaXZ2_10fvm_shared6bigint10bigint_ser9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   24|    489|pub fn serialize<S>(int: &BigInt, serializer: S) -> Result<S::Ok, S::Error>
   25|    489|where
   26|    489|    S: serde::Serializer,
   27|    489|{
   28|    489|    let (sign, mut bz) = int.to_bytes_be();
   29|    489|
   30|    489|    // Insert sign byte at start of encoded bytes
   31|    489|    match sign {
   32|      0|        Sign::Minus => bz.insert(0, 1),
   33|      0|        Sign::Plus => bz.insert(0, 0),
   34|    489|        Sign::NoSign => bz = Vec::new(),
   35|       |    }
   36|       |
   37|    489|    if bz.len() > MAX_BIGINT_SIZE {
   38|      0|        return Err(<S::Error as serde::ser::Error>::custom("BigInt too large"));
   39|    489|    }
   40|    489|
   41|    489|    // Serialize as bytes
   42|    489|    strict_bytes::Serialize::serialize(&bz, serializer)
   43|    489|}
_RINvNtNtCsgTTZuTcaXZ2_10fvm_shared6bigint10bigint_ser11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
   46|    489|pub fn deserialize<'de, D>(deserializer: D) -> Result<BigInt, D::Error>
   47|    489|where
   48|    489|    D: serde::Deserializer<'de>,
   49|    489|{
   50|    489|    let bz: Cow<'de, [u8]> = strict_bytes::Deserialize::deserialize(deserializer)?;
   51|    489|    if bz.is_empty() {
   52|    489|        return Ok(BigInt::default());
   53|      0|    }
   54|      0|    let sign_byte = bz[0];
   55|      0|    let sign: Sign = match sign_byte {
   56|      0|        1 => Sign::Minus,
   57|      0|        0 => Sign::Plus,
   58|       |        _ => {
   59|      0|            return Err(serde::de::Error::custom(
   60|      0|                "First byte must be valid sign (0, 1)",
   61|      0|            ));
   62|       |        }
   63|       |    };
   64|       |
   65|      0|    if bz.len() > MAX_BIGINT_SIZE {
   66|      0|        return Err(<D::Error as serde::de::Error>::custom("BigInt too large"));
   67|      0|    }
   68|      0|
   69|      0|    Ok(BigInt::from_bytes_be(sign, &bz[1..]))
   70|    489|}

_RNvXs0_NtCsgTTZuTcaXZ2_10fvm_shared7chainidNtB5_7ChainIDNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
    4|    489|#[derive(Clone, Copy, Debug, Eq, PartialEq)]
_RNvXNtCsgTTZuTcaXZ2_10fvm_shared7chainidNtB2_7ChainIDINtNtCsdRJjCzU6nMS_4core7convert4FromyE4from:
    8|    326|    fn from(src: u64) -> Self {
    9|    326|        Self(src)
   10|    326|    }

_RINvXsh_NtCsgTTZuTcaXZ2_10fvm_shared4econNtB6_11TokenAmountNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
  353|    489|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  354|    489|    where
  355|    489|        S: Serializer,
  356|    489|    {
  357|    489|        bigint_ser::serialize(&self.atto, serializer)
  358|    489|    }
_RINvMNtCsgTTZuTcaXZ2_10fvm_shared4econNtB3_11TokenAmount9from_attoNtNtCsjt7ToAeDLbB_10num_bigint6bigint6BigIntECs4ieSHZHrxF6_15direct_syscalls:
   35|    326|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|    326|        Self { atto: atto.into() }
   37|    326|    }
_RNvXsj_NtCsgTTZuTcaXZ2_10fvm_shared4econNtB5_11TokenAmountNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   20|    978|#[derive(Clone, PartialEq, Eq, Hash)]
_RINvMNtCsgTTZuTcaXZ2_10fvm_shared4econNtB3_11TokenAmount9from_attoyECs4ieSHZHrxF6_15direct_syscalls:
   35|    163|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|    163|        Self { atto: atto.into() }
   37|    163|    }
_RNCINvXsi_NtCsgTTZuTcaXZ2_10fvm_shared4econNtB8_11TokenAmountNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldE0Cs4ieSHZHrxF6_15direct_syscalls:
  366|    489|        bigint_ser::deserialize(deserializer).map(|v| TokenAmount { atto: v })
_RINvXsi_NtCsgTTZuTcaXZ2_10fvm_shared4econNtB6_11TokenAmountNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeNtNtCsb605JUWHIii_12libipld_core4ipld4IpldECs4ieSHZHrxF6_15direct_syscalls:
  362|    489|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  363|    489|    where
  364|    489|        D: serde::Deserializer<'de>,
  365|    489|    {
  366|    489|        bigint_ser::deserialize(deserializer).map(|v| TokenAmount { atto: v })
  367|    489|    }
_RNvXs_NtCsgTTZuTcaXZ2_10fvm_shared4econNtB4_11TokenAmountNtNtCsfVZxj7gvuuV_10num_traits10identities4Zero4zero:
   72|    652|    fn zero() -> Self {
   73|    652|        Self {
   74|    652|            atto: BigInt::zero(),
   75|    652|        }
   76|    652|    }
_RNvXs2_NtCsgTTZuTcaXZ2_10fvm_shared4econNtB5_11TokenAmountNtNtCsdRJjCzU6nMS_4core7default7Default7default:
  100|    489|    fn default() -> TokenAmount {
  101|    489|        TokenAmount::zero()
  102|    489|    }
_RINvMNtCsgTTZuTcaXZ2_10fvm_shared4econNtB3_11TokenAmount10from_wholexEB5_:
   48|      1|    pub fn from_whole(tokens: impl Into<BigInt>) -> Self {
   49|      1|        Self::from_atto(tokens.into() * Self::PRECISION)
   50|      1|    }
_RINvMNtCsgTTZuTcaXZ2_10fvm_shared4econNtB3_11TokenAmount9from_attoNtNtCsjt7ToAeDLbB_10num_bigint6bigint6BigIntEB5_:
   35|      1|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|      1|        Self { atto: atto.into() }
   37|      1|    }
_RNvMNtCsgTTZuTcaXZ2_10fvm_shared4econNtB2_11TokenAmount4atto:
   53|    163|    pub fn atto(&self) -> &BigInt {
   54|    163|        &self.atto
   55|    163|    }
_RNvXs4_NtCsgTTZuTcaXZ2_10fvm_shared4econNtB5_11TokenAmountNtNtCsdRJjCzU6nMS_4core3fmt7Display3fmt:
  122|    163|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  123|    163|        // Implementation based on the bigdecimal library.
  124|    163|        let (q, r) = self.atto.div_rem(&BigInt::from(Self::PRECISION));
  125|    163|        let before_decimal = q.abs().to_str_radix(10);
  126|    163|        let after_decimal = if r.is_zero() {
  127|      0|            "0".to_string()
  128|       |        } else {
  129|    163|            let fraction_str = r.abs().to_str_radix(10);
  130|    163|            let render = "0".repeat(Self::DECIMALS - fraction_str.len()) + fraction_str.as_str();
  131|    163|            render.trim_end_matches('0').to_string()
  132|       |        };
  133|       |
  134|       |        // Alter precision after the decimal point
  135|    163|        let after_decimal = if let Some(precision) = f.precision() {
  136|      0|            let len = after_decimal.len();
  137|      0|            if len < precision {
  138|      0|                after_decimal + "0".repeat(precision - len).as_str()
  139|       |            } else {
  140|      0|                after_decimal[0..precision].to_string()
  141|       |            }
  142|       |        } else {
  143|    163|            after_decimal
  144|       |        };
  145|       |
  146|       |        // Always show the decimal point, even with ".0".
  147|    163|        let complete_without_sign = before_decimal + "." + after_decimal.as_str();
  148|    163|        // Padding works even though we have a decimal point.
  149|    163|        f.pad_integral(!self.atto().is_negative(), "", &complete_without_sign)
  150|    163|    }

_RINvXsl_NtNtCsgTTZuTcaXZ2_10fvm_shared6sector16registered_proofNtB6_19RegisteredSealProofNtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECsheoVkkQew6K_3fvm:
   15|      4|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]
_RNvXsj_NtNtCsgTTZuTcaXZ2_10fvm_shared6sector16registered_proofNtB5_19RegisteredSealProofNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   15|      2|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]
_RINvXst_NtNtCsgTTZuTcaXZ2_10fvm_shared6sector16registered_proofNtB6_19RegisteredPoStProofNtNtCsdRJjCzU6nMS_4core4hash4Hash4hashNtNtNtNtCslmThs0IH7zH_3std11collections4hash3map13DefaultHasherECsheoVkkQew6K_3fvm:
   98|      3|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]

_RINvXsa_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtB6_9StateRootNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   31|    163|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXs9_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtB6_9StateRootNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   31|    163|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXs7_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtB6_16StateTreeVersionNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECs4ieSHZHrxF6_15direct_syscalls:
   12|    163|#[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Serialize_repr, Deserialize_repr)]
_RINvXNvXNvNvXs9_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtBe_9StateRootNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize1__NtB8_5InnerB11_11deserializeNtB3_9___VisitorNtB13_7Visitor9visit_seqINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de8AccessorNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   31|    163|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXs8_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtB6_16StateTreeVersionNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEECs4ieSHZHrxF6_15direct_syscalls:
   12|    163|#[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Serialize_repr, Deserialize_repr)]
_RINvXNvNvXsa_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtBb_9StateRootNtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serialize1__NtB5_5InnerBY_9serializeINtCs6R461GKLOna_11serde_tuple10SerializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEEECs4ieSHZHrxF6_15direct_syscalls:
   31|    163|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXNvNvXs9_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtBb_9StateRootNtNtCs2VpXLMAfFh1_5serde2de11Deserialize11deserialize1__NtB5_5InnerBY_11deserializeINtCs6R461GKLOna_11serde_tuple12DeserializerQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils11SliceReaderEEECs4ieSHZHrxF6_15direct_syscalls:
   31|    163|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXNvNtCsgTTZuTcaXZ2_10fvm_shared5states_1__NtB5_10StateInfo0NtNtCs2VpXLMAfFh1_5serde3ser9Serialize9serializeQINtNtCsfJMW7pIFHVe_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs5rcRHic1w1p_7cbor4ii4core5utils9BufWriterEECsilvC8qPft2D_8fvm_fuzz:
   46|    163|#[derive(Default, Deserialize, Serialize)]
_RNvXsb_NtCsgTTZuTcaXZ2_10fvm_shared5stateNtB5_10StateInfo0NtNtCsdRJjCzU6nMS_4core7default7Default7default:
   46|    163|#[derive(Default, Deserialize, Serialize)]

_RNvXs8_NtCsgTTZuTcaXZ2_10fvm_shared7versionNtB5_14NetworkVersionNtNtCsdRJjCzU6nMS_4core3cmp10PartialOrd11partial_cmp:
   10|    326|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]
_RNvXs5_NtCsgTTZuTcaXZ2_10fvm_shared7versionNtB5_14NetworkVersionNtNtCsdRJjCzU6nMS_4core5clone5Clone5clone:
   10|    489|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]
_RNvXs0_NtCsgTTZuTcaXZ2_10fvm_shared7versionNtB5_14NetworkVersionNtNtCsdRJjCzU6nMS_4core3fmt5Debug3fmt:
   10|    163|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]

_RINvNtCs9ModpadCpa2_21fvm_integration_tests7builtin14set_init_actorNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
   54|    163|pub fn set_init_actor(
   55|    163|    state_tree: &mut StateTree<impl Blockstore>,
   56|    163|    init_code_cid: Cid,
   57|    163|    init_state: init_actor::State,
   58|    163|) -> Result<()> {
   59|    163|    let init_state_cid = state_tree
   60|    163|        .store()
   61|    163|        .put_cbor(&init_state, Code::Blake2b256)
   62|    163|        .context(FailedToSetState("init actor".to_owned()))?;
   63|       |
   64|    163|    let init_actor_state = ActorState {
   65|    163|        code: init_code_cid,
   66|    163|        state: init_state_cid,
   67|    163|        sequence: 0,
   68|    163|        balance: Default::default(),
   69|    163|        address: None,
   70|    163|    };
   71|    163|
   72|    163|    state_tree
   73|    163|        .set_actor(init_actor::INIT_ACTOR_ID, init_actor_state)
   74|    163|        .map_err(anyhow::Error::from)
   75|    163|        .context(FailedToSetActor("init actor".to_owned()))
   76|    163|}
_RINvNtCs9ModpadCpa2_21fvm_integration_tests7builtin13set_eam_actorNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
   78|    163|pub fn set_eam_actor(state_tree: &mut StateTree<impl Blockstore>, eam_code_cid: Cid) -> Result<()> {
   79|       |    const EAM_ACTOR_ID: ActorID = 10;
   80|       |
   81|    163|    let eam_state_cid = state_tree
   82|    163|        .store()
   83|    163|        .put_cbor(&[(); 0], Code::Blake2b256)
   84|    163|        .context(FailedToSetState("eam actor".to_owned()))?;
   85|       |
   86|    163|    let eam_actor_state = ActorState {
   87|    163|        code: eam_code_cid,
   88|    163|        state: eam_state_cid,
   89|    163|        sequence: 0,
   90|    163|        balance: Default::default(),
   91|    163|        address: None,
   92|    163|    };
   93|    163|
   94|    163|    state_tree
   95|    163|        .set_actor(EAM_ACTOR_ID, eam_actor_state)
   96|    163|        .map_err(anyhow::Error::from)
   97|    163|        .context(FailedToSetActor("eam actor".to_owned()))
   98|    163|}
_RINvNtCs9ModpadCpa2_21fvm_integration_tests7builtin22fetch_builtin_code_cidNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
   16|    163|pub fn fetch_builtin_code_cid(
   17|    163|    blockstore: &impl Blockstore,
   18|    163|    builtin_actors: &Cid,
   19|    163|    ver: u32,
   20|    163|) -> Result<(Cid, Cid, Cid, Cid, Cid)> {
   21|    163|    let manifest = Manifest::load(blockstore, builtin_actors, ver).context(FailedToLoadManifest)?;
   22|    163|    Ok((
   23|    163|        *manifest.get_system_code(),
   24|    163|        *manifest.get_init_code(),
   25|    163|        *manifest.get_account_code(),
   26|    163|        *manifest.get_embryo_code(),
   27|    163|        *manifest.get_eam_code(),
   28|    163|    ))
   29|    163|}
_RINvNtCs9ModpadCpa2_21fvm_integration_tests7builtin13set_sys_actorNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
   31|    163|pub fn set_sys_actor(
   32|    163|    state_tree: &mut StateTree<impl Blockstore>,
   33|    163|    sys_state: system_actor::State,
   34|    163|    sys_code_cid: Cid,
   35|    163|) -> Result<()> {
   36|    163|    let sys_state_cid = state_tree
   37|    163|        .store()
   38|    163|        .put_cbor(&sys_state, Code::Blake2b256)
   39|    163|        .context(FailedToSetState("system actor".to_owned()))?;
   40|       |
   41|    163|    let sys_actor_state = ActorState {
   42|    163|        code: sys_code_cid,
   43|    163|        state: sys_state_cid,
   44|    163|        sequence: 0,
   45|    163|        balance: Default::default(),
   46|    163|        address: None,
   47|    163|    };
   48|    163|    state_tree
   49|    163|        .set_actor(system_actor::SYSTEM_ACTOR_ID, sys_actor_state)
   50|    163|        .map_err(anyhow::Error::from)
   51|    163|        .context(FailedToSetActor("system actor".to_owned()))
   52|    163|}

_RINvNtCs9ModpadCpa2_21fvm_integration_tests6bundle13import_bundleNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsilvC8qPft2D_8fvm_fuzz:
   10|    163|pub fn import_bundle(blockstore: &impl Blockstore, bundle: &[u8]) -> anyhow::Result<Cid> {
   11|    163|    match &*block_on(async { load_car_unchecked(blockstore, bundle).await })? {
   12|    163|        [root] => Ok(*root),
   13|      0|        _ => Err(anyhow!("multiple root CIDs in bundle")),
   14|       |    }
   15|    163|}
_RNCINvNtCs9ModpadCpa2_21fvm_integration_tests6bundle13import_bundleNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0CsilvC8qPft2D_8fvm_fuzz:
   11|    163|    match &*block_on(async { load_car_unchecked(blockstore, bundle).await })? {

_RINvMNtCs9ModpadCpa2_21fvm_integration_tests6testerINtB3_6TesterNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB5_5dummy12DummyExternsE31instantiate_machine_with_configNCNvB2_19instantiate_machine0NCB33_s_0ECs4ieSHZHrxF6_15direct_syscalls:
  229|    163|    pub fn instantiate_machine_with_config<F, G>(
  230|    163|        &mut self,
  231|    163|        externs: E,
  232|    163|        configure_nc: F,
  233|    163|        configure_mc: G,
  234|    163|    ) -> Result<()>
  235|    163|    where
  236|    163|        F: FnOnce(&mut NetworkConfig),
  237|    163|        G: FnOnce(&mut MachineContext),
  238|    163|    {
  239|    163|        // Take the state tree and leave None behind.
  240|    163|        let mut state_tree = self.state_tree.take().unwrap();
  241|       |
  242|       |        // Calculate the state root.
  243|    163|        let state_root = state_tree
  244|    163|            .flush()
  245|    163|            .map_err(anyhow::Error::from)
  246|    163|            .context(FailedToFlushTree)?;
  247|       |
  248|       |        // Consume the state tree and take the blockstore.
  249|    163|        let blockstore = state_tree.into_store();
  250|    163|
  251|    163|        let mut nc = NetworkConfig::new(self.nv);
  252|    163|        nc.override_actors(self.builtin_actors);
  253|    163|        nc.enable_actor_debugging();
  254|    163|
  255|    163|        // Custom configuration.
  256|    163|        configure_nc(&mut nc);
  257|    163|
  258|    163|        let mut mc = nc.for_epoch(0, 0, state_root);
  259|    163|        mc.set_base_fee(TokenAmount::from_atto(DEFAULT_BASE_FEE))
  260|    163|            .enable_tracing();
  261|    163|
  262|    163|        // Custom configuration.
  263|    163|        configure_mc(&mut mc);
  264|       |
  265|    163|        let engine = EnginePool::new_default((&mc.network.clone()).into())?;
  266|    163|        engine.acquire().preload(&blockstore, &self.code_cids)?;
  267|       |
  268|    163|        let machine = DefaultMachine::new(&mc, blockstore, externs)?;
  269|       |
  270|    163|        let executor =
  271|    163|            DefaultExecutor::<DefaultKernel<DefaultCallManager<DefaultMachine<B, E>>>>::new(
  272|    163|                engine, machine,
  273|    163|            )?;
  274|       |
  275|    163|        self.executor = Some(executor);
  276|    163|
  277|    163|        Ok(())
  278|    163|    }
_RNCNvMNtCs9ModpadCpa2_21fvm_integration_tests6testerINtB4_6TesterNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB6_5dummy12DummyExternsE19instantiate_machines_0Cs4ieSHZHrxF6_15direct_syscalls:
  221|    163|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
_RNvMNtCs9ModpadCpa2_21fvm_integration_tests6testerINtB2_6TesterNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB4_5dummy12DummyExternsE19instantiate_machineCs4ieSHZHrxF6_15direct_syscalls:
  220|    163|    pub fn instantiate_machine(&mut self, externs: E) -> Result<()> {
  221|    163|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
  222|    163|    }
_RNCNvMNtCs9ModpadCpa2_21fvm_integration_tests6testerINtB4_6TesterNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB6_5dummy12DummyExternsE19instantiate_machine0Cs4ieSHZHrxF6_15direct_syscalls:
  221|    163|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
_RNvMNtCs9ModpadCpa2_21fvm_integration_tests6testerINtB2_6TesterNtNtCsf3d0o8dgc6o_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB4_5dummy12DummyExternsE3newCsilvC8qPft2D_8fvm_fuzz:
   61|    163|    pub fn new(
   62|    163|        nv: NetworkVersion,
   63|    163|        stv: StateTreeVersion,
   64|    163|        builtin_actors: Cid,
   65|    163|        blockstore: B,
   66|    163|    ) -> Result<Self> {
   67|    163|        let (manifest_version, manifest_data_cid): (u32, Cid) =
   68|    163|            match blockstore.get_cbor(&builtin_actors)? {
   69|    163|                Some((manifest_version, manifest_data)) => (manifest_version, manifest_data),
   70|      0|                None => return Err(NoManifestInformation(builtin_actors).into()),
   71|       |            };
   72|       |
   73|       |        // Get sys and init actors code cid
   74|    163|        let (sys_code_cid, init_code_cid, accounts_code_cid, embryo_code_cid, eam_code_cid) =
   75|    163|            fetch_builtin_code_cid(&blockstore, &manifest_data_cid, manifest_version)?;
   76|       |
   77|       |        // Initialize state tree
   78|    163|        let init_state = init_actor::State::new_test(&blockstore);
   79|    163|        let mut state_tree = StateTree::new(blockstore, stv).map_err(anyhow::Error::from)?;
   80|       |
   81|       |        // Deploy init, sys, and eam actors
   82|    163|        let sys_state = system_actor::State { builtin_actors };
   83|    163|        set_sys_actor(&mut state_tree, sys_state, sys_code_cid)?;
   84|    163|        set_init_actor(&mut state_tree, init_code_cid, init_state)?;
   85|    163|        set_eam_actor(&mut state_tree, eam_code_cid)?;
   86|       |
   87|    163|        Ok(Tester {
   88|    163|            nv,
   89|    163|            builtin_actors,
   90|    163|            executor: None,
   91|    163|            code_cids: vec![],
   92|    163|            state_tree: Some(state_tree),
   93|    163|            accounts_code_cid,
   94|    163|            embryo_code_cid,
   95|    163|        })
   96|    163|    }

