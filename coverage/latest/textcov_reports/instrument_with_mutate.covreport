_RNvXsI_Cseld4nSdqGci_9arbitraryyNtB5_9Arbitrary9arbitrary:
  309|    143|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    143|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    143|                    u.fill_buffer(&mut buf)?;
  312|    143|                    let mut x: $unsigned = 0;
  313|  1.14k|                    for i in 0..mem::size_of::<$ty>() {
  314|  1.14k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  1.14k|                    }
  316|    143|                    Ok(x as $ty)
  317|    143|                }

_RINvMNtCseld4nSdqGci_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryyECs2IPmB8bTu1k_22instrument_with_mutate:
  167|    143|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    143|    where
  169|    143|        A: Arbitrary<'a>,
  170|    143|    {
  171|    143|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    143|    }
_RNvXs6_NtCseld4nSdqGci_9arbitrary12unstructuredjNtB5_3Int10from_usize:
  840|    286|                fn from_usize(u: usize) -> Self {
  841|    286|                    u as Self
  842|    286|                }
_RNvXs6_NtCseld4nSdqGci_9arbitrary12unstructuredjNtB5_3Int11to_unsigned:
  856|    286|                fn to_unsigned(self) -> Self::Unsigned {
  857|    286|                    self as $unsigned_ty
  858|    286|                }
_RNvXs6_NtCseld4nSdqGci_9arbitrary12unstructuredjNtB5_3Int11checked_add:
  844|    143|                fn checked_add(self, rhs: Self) -> Option<Self> {
  845|    143|                    <$ty>::checked_add(self, rhs)
  846|    143|                }
_RNvMNtCseld4nSdqGci_9arbitrary12unstructuredNtB2_12Unstructured3new:
   85|    143|    pub fn new(data: &'a [u8]) -> Self {
   86|    143|        Unstructured { data }
   87|    143|    }
_RNvXs6_NtCseld4nSdqGci_9arbitrary12unstructuredjNtB5_3Int12wrapping_sub:
  852|    143|                fn wrapping_sub(self, rhs: Self) -> Self {
  853|    143|                    <$ty>::wrapping_sub(self, rhs)
  854|    143|                }
_RNvXs6_NtCseld4nSdqGci_9arbitrary12unstructuredjNtB5_3Int12wrapping_add:
  848|    143|                fn wrapping_add(self, rhs: Self) -> Self {
  849|    143|                    <$ty>::wrapping_add(self, rhs)
  850|    143|                }
_RNvXs6_NtCseld4nSdqGci_9arbitrary12unstructuredjNtB5_3Int7from_u8:
  836|    143|                fn from_u8(b: u8) -> Self {
  837|    143|                    b as Self
  838|    143|                }
_RNvMNtCseld4nSdqGci_9arbitrary12unstructuredNtB2_12Unstructured12choose_index:
  450|    143|    pub fn choose_index(&mut self, len: usize) -> Result<usize> {
  451|    143|        if len == 0 {
  452|      0|            return Err(Error::EmptyChoose);
  453|    143|        }
  454|    143|        let idx = self.int_in_range(0..=len - 1)?;
  455|    143|        Ok(idx)
  456|    143|    }
_RINvMNtCseld4nSdqGci_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_impljINtNtNtNtCs23Pu7RYaif7_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEEB5_:
  302|    143|    fn int_in_range_impl<T>(
  303|    143|        range: ops::RangeInclusive<T>,
  304|    143|        mut bytes: impl Iterator<Item = u8>,
  305|    143|    ) -> Result<(T, usize)>
  306|    143|    where
  307|    143|        T: Int,
  308|    143|    {
  309|    143|        let start = *range.start();
  310|    143|        let end = *range.end();
  311|    143|        assert!(
  312|    143|            start <= end,
  313|    143|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|    143|        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|    143|        if start == end {
  319|      0|            return Ok((start, 0));
  320|    143|        }
  321|    143|
  322|    143|        // From here on out we work with the unsigned representation. All of the
  323|    143|        // operations performed below work out just as well whether or not `T`
  324|    143|        // is a signed or unsigned integer.
  325|    143|        let start = start.to_unsigned();
  326|    143|        let end = end.to_unsigned();
  327|    143|
  328|    143|        let delta = end.wrapping_sub(start);
  329|    143|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|    143|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|    143|        let mut bytes_consumed: usize = 0;
  337|       |
  338|    286|        while (bytes_consumed < mem::size_of::<T>())
  339|    286|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|    143|            let byte = match bytes.next() {
  342|      0|                None => break,
  343|    143|                Some(b) => b,
  344|    143|            };
  345|    143|            bytes_consumed += 1;
  346|    143|
  347|    143|            // Combine this byte into our arbitrary integer, but avoid
  348|    143|            // overflowing the shift for `u8` and `i8`.
  349|    143|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|    143|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|    143|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|    143|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|    143|        let result = start.wrapping_add(offset);
  365|    143|
  366|    143|        // And convert back to our maybe-signed representation.
  367|    143|        let result = T::from_unsigned(result);
  368|    143|        debug_assert!(*range.start() <= result);
  369|    143|        debug_assert!(result <= *range.end());
  370|       |
  371|    143|        Ok((result, bytes_consumed))
  372|    143|    }
_RNvMNtCseld4nSdqGci_9arbitrary12unstructuredNtB2_12Unstructured11fill_buffer:
  521|    143|    pub fn fill_buffer(&mut self, buffer: &mut [u8]) -> Result<()> {
  522|    143|        let n = std::cmp::min(buffer.len(), self.data.len());
  523|    143|        buffer[..n].copy_from_slice(&self.data[..n]);
  524|    143|        for byte in buffer[n..].iter_mut() {
  525|      0|            *byte = 0;
  526|      0|        }
  527|    143|        self.data = &self.data[n..];
  528|    143|        Ok(())
  529|    143|    }
_RINvMNtCseld4nSdqGci_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangejEB5_:
  293|    143|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|    143|    where
  295|    143|        T: Int,
  296|    143|    {
  297|    143|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|    143|        self.data = &self.data[bytes_consumed..];
  299|    143|        Ok(result)
  300|    143|    }
_RNvXs6_NtCseld4nSdqGci_9arbitrary12unstructuredjNtB5_3Int13from_unsigned:
  860|    143|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  861|    143|                    unsigned as Self
  862|    143|                }

_RNvCsdZkZ1wcA3GQ_4atty2is:
   40|    143|pub fn is(stream: Stream) -> bool {
   41|       |    extern crate libc;
   42|       |
   43|    143|    let fd = match stream {
   44|      0|        Stream::Stdout => libc::STDOUT_FILENO,
   45|    143|        Stream::Stderr => libc::STDERR_FILENO,
   46|      0|        Stream::Stdin => libc::STDIN_FILENO,
   47|       |    };
   48|    143|    unsafe { libc::isatty(fd) != 0 }
   49|    143|}

_RNCNvMs_NtCsdsqPvVuyxCm_10env_logger6filterNtB6_7Builder5build0B8_:
  244|    572|                .map(|(name, level)| Directive { name, level })
_RNvNtCsdsqPvVuyxCm_10env_logger6filter7enabled:
  362|  1.14k|fn enabled(directives: &[Directive], level: Level, target: &str) -> bool {
  363|       |    // Search for the longest match, the vector is assumed to be pre-sorted.
  364|  2.57k|    for directive in directives.iter().rev() {
  365|  2.57k|        match directive.name {
  366|  2.57k|            Some(ref name) if !target.starts_with(&**name) => {}
  367|  1.00k|            Some(..) | None => return level <= directive.level,
  368|       |        }
  369|       |    }
  370|    142|    false
  371|  1.14k|}
_RNCNvNtCsdsqPvVuyxCm_10env_logger6filter10parse_specs_0B5_:
  313|    286|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
_RNvMNtCsdsqPvVuyxCm_10env_logger6filterNtB2_6Filter7matches:
  148|  1.14k|    pub fn matches(&self, record: &Record) -> bool {
  149|  1.14k|        if !self.enabled(record.metadata()) {
  150|    142|            return false;
  151|  1.00k|        }
  152|       |
  153|  1.00k|        if let Some(filter) = self.filter.as_ref() {
  154|      0|            if !filter.is_match(&record.args().to_string()) {
  155|      0|                return false;
  156|      0|            }
  157|  1.00k|        }
  158|       |
  159|  1.00k|        true
  160|  1.14k|    }
_RNCNvMs_NtCsdsqPvVuyxCm_10env_logger6filterNtB6_7Builder5builds_0B8_:
  248|    704|            directives.sort_by(|a, b| {
  249|    704|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|    704|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|    704|                alen.cmp(&blen)
  252|    704|            });
_RNCNCNvMs_NtCsdsqPvVuyxCm_10env_logger6filterNtB8_7Builder5builds_00Ba_:
  249|    704|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
_RNCNvNtCsdsqPvVuyxCm_10env_logger6filter10parse_specs0_0B5_:
  344|    572|                name: name.map(|s| s.to_string()),
_RNvMs_NtCsdsqPvVuyxCm_10env_logger6filterNtB4_7Builder5build:
  228|    143|    pub fn build(&mut self) -> Filter {
  229|    143|        assert!(!self.built, "attempt to re-use consumed builder");
  230|    143|        self.built = true;
  231|    143|
  232|    143|        let mut directives = Vec::new();
  233|    143|        if self.directives.is_empty() {
  234|      0|            // Adds the default filter if none exist
  235|      0|            directives.push(Directive {
  236|      0|                name: None,
  237|      0|                level: LevelFilter::Error,
  238|      0|            });
  239|    143|        } else {
  240|    143|            // Consume map of directives.
  241|    143|            let directives_map = mem::take(&mut self.directives);
  242|    143|            directives = directives_map
  243|    143|                .into_iter()
  244|    143|                .map(|(name, level)| Directive { name, level })
  245|    143|                .collect();
  246|    143|            // Sort the directives by length of their name, this allows a
  247|    143|            // little more efficient lookup at runtime.
  248|    143|            directives.sort_by(|a, b| {
  249|       |                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|       |                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|       |                alen.cmp(&blen)
  252|    143|            });
  253|    143|        }
  254|       |
  255|    143|        Filter {
  256|    143|            directives: mem::take(&mut directives),
  257|    143|            filter: mem::replace(&mut self.filter, None),
  258|    143|        }
  259|    143|    }
_RNvMNtCsdsqPvVuyxCm_10env_logger6filterNtB2_6Filter7enabled:
  163|  1.14k|    pub fn enabled(&self, metadata: &Metadata) -> bool {
  164|  1.14k|        let level = metadata.level();
  165|  1.14k|        let target = metadata.target();
  166|  1.14k|
  167|  1.14k|        enabled(&self.directives, level, target)
  168|  1.14k|    }
_RNvMs_NtCsdsqPvVuyxCm_10env_logger6filterNtB4_7Builder5parse:
  216|    143|    pub fn parse(&mut self, filters: &str) -> &mut Self {
  217|    143|        let (directives, filter) = parse_spec(filters);
  218|    143|
  219|    143|        self.filter = filter;
  220|       |
  221|    715|        for directive in directives {
  222|    572|            self.directives.insert(directive.name, directive.level);
  223|    572|        }
  224|    143|        self
  225|    143|    }
_RNCNCNvMs_NtCsdsqPvVuyxCm_10env_logger6filterNtB8_7Builder5builds_0s_0Ba_:
  250|    704|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
_RNvXs0_NtCsdsqPvVuyxCm_10env_logger6filterNtB5_7BuilderNtNtCs23Pu7RYaif7_4core7default7Default7default:
  263|    143|    fn default() -> Self {
  264|    143|        Builder::new()
  265|    143|    }
_RNvNtCsdsqPvVuyxCm_10env_logger6filter10parse_spec:
  292|    143|fn parse_spec(spec: &str) -> (Vec<Directive>, Option<inner::Filter>) {
  293|    143|    let mut dirs = Vec::new();
  294|    143|
  295|    143|    let mut parts = spec.split('/');
  296|    143|    let mods = parts.next();
  297|    143|    let filter = parts.next();
  298|    143|    if parts.next().is_some() {
  299|      0|        eprintln!(
  300|      0|            "warning: invalid logging spec '{}', \
  301|      0|             ignoring it (too many '/'s)",
  302|      0|            spec
  303|      0|        );
  304|      0|        return (dirs, None);
  305|    143|    }
  306|    143|    if let Some(m) = mods {
  307|    572|        for s in m.split(',').map(|ss| ss.trim()) {
  308|    572|            if s.is_empty() {
  309|      0|                continue;
  310|    572|            }
  311|    572|            let mut parts = s.split('=');
  312|    572|            let (log_level, name) =
  313|    572|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
  314|    286|                    (Some(part0), None, None) => {
  315|    286|                        // if the single argument is a log-level string or number,
  316|    286|                        // treat that as a global fallback
  317|    286|                        match part0.parse() {
  318|      0|                            Ok(num) => (num, None),
  319|    286|                            Err(_) => (LevelFilter::max(), Some(part0)),
  320|       |                        }
  321|       |                    }
  322|    286|                    (Some(part0), Some(""), None) => (LevelFilter::max(), Some(part0)),
  323|    286|                    (Some(part0), Some(part1), None) => match part1.parse() {
  324|    286|                        Ok(num) => (num, Some(part0)),
  325|       |                        _ => {
  326|      0|                            eprintln!(
  327|      0|                                "warning: invalid logging spec '{}', \
  328|      0|                                 ignoring it",
  329|      0|                                part1
  330|      0|                            );
  331|      0|                            continue;
  332|       |                        }
  333|       |                    },
  334|       |                    _ => {
  335|      0|                        eprintln!(
  336|      0|                            "warning: invalid logging spec '{}', \
  337|      0|                             ignoring it",
  338|      0|                            s
  339|      0|                        );
  340|      0|                        continue;
  341|       |                    }
  342|       |                };
  343|    572|            dirs.push(Directive {
  344|    572|                name: name.map(|s| s.to_string()),
  345|    572|                level: log_level,
  346|    572|            });
  347|       |        }
  348|      0|    }
  349|       |
  350|    143|    let filter = filter.and_then(|filter| match inner::Filter::new(filter) {
  351|       |        Ok(re) => Some(re),
  352|       |        Err(e) => {
  353|       |            eprintln!("warning: invalid regex filter - {}", e);
  354|       |            None
  355|       |        }
  356|    143|    });
  357|    143|
  358|    143|    (dirs, filter)
  359|    143|}
_RNCNvMNtCsdsqPvVuyxCm_10env_logger6filterNtB4_6Filter6filter0B6_:
  142|    572|            .map(|d| d.level)
_RNCNvNtCsdsqPvVuyxCm_10env_logger6filter10parse_spec0B5_:
  307|    572|        for s in m.split(',').map(|ss| ss.trim()) {
_RNvMs_NtCsdsqPvVuyxCm_10env_logger6filterNtB4_7Builder3new:
  173|    143|    pub fn new() -> Builder {
  174|    143|        Builder {
  175|    143|            directives: HashMap::new(),
  176|    143|            filter: None,
  177|    143|            built: false,
  178|    143|        }
  179|    143|    }
_RNvMNtCsdsqPvVuyxCm_10env_logger6filterNtB2_6Filter6filter:
  139|    143|    pub fn filter(&self) -> LevelFilter {
  140|    143|        self.directives
  141|    143|            .iter()
  142|    143|            .map(|d| d.level)
  143|    143|            .max()
  144|    143|            .unwrap_or(LevelFilter::Off)
  145|    143|    }

_RNvXs0_NtNtNtCsdsqPvVuyxCm_10env_logger3fmt9humantime3impNtB5_9TimestampNtNtCs23Pu7RYaif7_4core3fmt7Display3fmt:
  108|  1.00k|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  109|  1.00k|        let formatter = match self.precision {
  110|  1.00k|            TimestampPrecision::Seconds => format_rfc3339_seconds,
  111|      0|            TimestampPrecision::Millis => format_rfc3339_millis,
  112|      0|            TimestampPrecision::Micros => format_rfc3339_micros,
  113|      0|            TimestampPrecision::Nanos => format_rfc3339_nanos,
  114|       |        };
  115|       |
  116|  1.00k|        formatter(self.time).fmt(f)
  117|  1.00k|    }
_RNvMNtNtNtCsdsqPvVuyxCm_10env_logger3fmt9humantime3impNtB6_9Formatter17timestamp_seconds:
   43|  1.00k|    pub fn timestamp_seconds(&self) -> Timestamp {
   44|  1.00k|        Timestamp {
   45|  1.00k|            time: SystemTime::now(),
   46|  1.00k|            precision: TimestampPrecision::Seconds,
   47|  1.00k|        }
   48|  1.00k|    }

_RNvMs_NtCsdsqPvVuyxCm_10env_logger3fmtNtB4_9Formatter5print:
  114|  1.00k|    pub(crate) fn print(&self, writer: &Writer) -> io::Result<()> {
  115|  1.00k|        writer.print(&self.buf.borrow())
  116|  1.00k|    }
_RNvXs0_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_9FormatterNtNtCs8hfS0qQwSL8_3std2io5Write5write:
  124|  19.3k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  125|  19.3k|        self.buf.borrow_mut().write(buf)
  126|  19.3k|    }
_RNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_13DefaultFormat12write_target:
  319|  1.00k|    fn write_target(&mut self, record: &Record) -> io::Result<()> {
  320|  1.00k|        if !self.target {
  321|      0|            return Ok(());
  322|  1.00k|        }
  323|  1.00k|
  324|  1.00k|        match record.target() {
  325|  1.00k|            "" => Ok(()),
  326|  1.00k|            target => self.write_header_value(target),
  327|       |        }
  328|  1.00k|    }
_RNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_13DefaultFormat17write_module_path:
  307|  1.00k|    fn write_module_path(&mut self, record: &Record) -> io::Result<()> {
  308|  1.00k|        if !self.module_path {
  309|  1.00k|            return Ok(());
  310|      0|        }
  311|       |
  312|      0|        if let Some(module_path) = record.module_path() {
  313|      0|            self.write_header_value(module_path)
  314|       |        } else {
  315|      0|            Ok(())
  316|       |        }
  317|  1.00k|    }
_RNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_13DefaultFormat10write_args:
  339|  1.00k|    fn write_args(&mut self, record: &Record) -> io::Result<()> {
  340|  1.00k|        match self.indent {
  341|       |            // Fast path for no indentation
  342|      0|            None => write!(self.buf, "{}{}", record.args(), self.suffix),
  343|       |
  344|  1.00k|            Some(indent_count) => {
  345|  1.00k|                // Create a wrapper around the buffer only if we have to actually indent the message
  346|  1.00k|
  347|  1.00k|                struct IndentWrapper<'a, 'b: 'a> {
  348|  1.00k|                    fmt: &'a mut DefaultFormat<'b>,
  349|  1.00k|                    indent_count: usize,
  350|  1.00k|                }
  351|  1.00k|
  352|  1.00k|                impl<'a, 'b> Write for IndentWrapper<'a, 'b> {
  353|  1.00k|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|  1.00k|                        let mut first = true;
  355|  1.00k|                        for chunk in buf.split(|&x| x == b'\n') {
  356|  1.00k|                            if !first {
  357|  1.00k|                                write!(
  358|  1.00k|                                    self.fmt.buf,
  359|  1.00k|                                    "{}{:width$}",
  360|  1.00k|                                    self.fmt.suffix,
  361|  1.00k|                                    "",
  362|  1.00k|                                    width = self.indent_count
  363|  1.00k|                                )?;
  364|  1.00k|                            }
  365|  1.00k|                            self.fmt.buf.write_all(chunk)?;
  366|  1.00k|                            first = false;
  367|  1.00k|                        }
  368|  1.00k|
  369|  1.00k|                        Ok(buf.len())
  370|  1.00k|                    }
  371|  1.00k|
  372|  1.00k|                    fn flush(&mut self) -> io::Result<()> {
  373|  1.00k|                        self.fmt.buf.flush()
  374|  1.00k|                    }
  375|  1.00k|                }
  376|  1.00k|
  377|  1.00k|                // The explicit scope here is just to make older versions of Rust happy
  378|  1.00k|                {
  379|  1.00k|                    let mut wrapper = IndentWrapper {
  380|  1.00k|                        fmt: self,
  381|  1.00k|                        indent_count,
  382|  1.00k|                    };
  383|  1.00k|                    write!(wrapper, "{}", record.args())?;
  384|       |                }
  385|       |
  386|  1.00k|                write!(self.buf, "{}", self.suffix)?;
  387|       |
  388|  1.00k|                Ok(())
  389|       |            }
  390|       |        }
  391|  1.00k|    }
_RNCNvMs3_NtCsdsqPvVuyxCm_10env_logger3fmtNtB7_7Builder5build0B9_:
  187|  1.00k|            Box::new(move |buf, record| {
  188|  1.00k|                let fmt = DefaultFormat {
  189|  1.00k|                    timestamp: built.format_timestamp,
  190|  1.00k|                    module_path: built.format_module_path,
  191|  1.00k|                    target: built.format_target,
  192|  1.00k|                    level: built.format_level,
  193|  1.00k|                    written_header_value: false,
  194|  1.00k|                    indent: built.format_indent,
  195|  1.00k|                    suffix: built.format_suffix,
  196|  1.00k|                    buf,
  197|  1.00k|                };
  198|  1.00k|
  199|  1.00k|                fmt.write(record)
  200|  1.00k|            })
_RINvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtNtB6_9humantime3imp9TimestampEB8_:
  251|  1.00k|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|  1.00k|    where
  253|  1.00k|        T: Display,
  254|  1.00k|    {
  255|  1.00k|        if !self.written_header_value {
  256|  1.00k|            self.written_header_value = true;
  257|  1.00k|
  258|  1.00k|            let open_brace = self.subtle_style("[");
  259|  1.00k|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|      0|            write!(self.buf, " {}", value)
  262|       |        }
  263|  1.00k|    }
_RNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_13DefaultFormat5write:
  226|  1.00k|        self.write_timestamp()?;
  227|  1.00k|        self.write_level(record)?;
  228|  1.00k|        self.write_module_path(record)?;
  229|  1.00k|        self.write_target(record)?;
  230|  1.00k|        self.finish_header()?;
  231|       |
  232|  1.00k|        self.write_args(record)
  233|  1.00k|    }
_RNvXs2_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_7BuilderNtNtCs23Pu7RYaif7_4core7default7Default7default:
  153|    286|    fn default() -> Self {
  154|    286|        Builder {
  155|    286|            format_timestamp: Some(Default::default()),
  156|    286|            format_module_path: false,
  157|    286|            format_target: true,
  158|    286|            format_level: true,
  159|    286|            format_indent: Some(4),
  160|    286|            custom_format: None,
  161|    286|            format_suffix: "\n",
  162|    286|            built: false,
  163|    286|        }
  164|    286|    }
_RINvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtCs23Pu7RYaif7_4core3fmt9ArgumentsEB8_:
  251|  1.00k|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|  1.00k|    where
  253|  1.00k|        T: Display,
  254|  1.00k|    {
  255|  1.00k|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|  1.00k|            write!(self.buf, " {}", value)
  262|       |        }
  263|  1.00k|    }
_RNCNvXNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtBa_13DefaultFormat10write_argsNtB4_13IndentWrapperNtNtCs8hfS0qQwSL8_3std2io5Write5write0Bc_:
  355|  75.3k|                        for chunk in buf.split(|&x| x == b'\n') {
_RNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_13DefaultFormat15write_timestamp:
  284|  1.00k|    fn write_timestamp(&mut self) -> io::Result<()> {
  285|       |        #[cfg(feature = "humantime")]
  286|       |        {
  287|       |            use self::TimestampPrecision::*;
  288|  1.00k|            let ts = match self.timestamp {
  289|      0|                None => return Ok(()),
  290|  1.00k|                Some(Seconds) => self.buf.timestamp_seconds(),
  291|      0|                Some(Millis) => self.buf.timestamp_millis(),
  292|      0|                Some(Micros) => self.buf.timestamp_micros(),
  293|      0|                Some(Nanos) => self.buf.timestamp_nanos(),
  294|       |            };
  295|       |
  296|  1.00k|            self.write_header_value(ts)
  297|       |        }
  298|       |        #[cfg(not(feature = "humantime"))]
  299|       |        {
  300|       |            // Trick the compiler to think we have used self.timestamp
  301|       |            // Workaround for "field is never used: `timestamp`" compiler nag.
  302|       |            let _ = self.timestamp;
  303|       |            Ok(())
  304|       |        }
  305|  1.00k|    }
_RNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_13DefaultFormat12subtle_style:
  235|  2.00k|    fn subtle_style(&self, text: &'static str) -> SubtleStyle {
  236|  2.00k|        #[cfg(feature = "termcolor")]
  237|  2.00k|        {
  238|  2.00k|            self.buf
  239|  2.00k|                .style()
  240|  2.00k|                .set_color(Color::Black)
  241|  2.00k|                .set_intense(true)
  242|  2.00k|                .clone()
  243|  2.00k|                .into_value(text)
  244|  2.00k|        }
  245|  2.00k|        #[cfg(not(feature = "termcolor"))]
  246|  2.00k|        {
  247|  2.00k|            text
  248|  2.00k|        }
  249|  2.00k|    }
_RINvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueReEB8_:
  251|  1.00k|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|  1.00k|    where
  253|  1.00k|        T: Display,
  254|  1.00k|    {
  255|  1.00k|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|  1.00k|            write!(self.buf, " {}", value)
  262|       |        }
  263|  1.00k|    }
_RNvMs_NtCsdsqPvVuyxCm_10env_logger3fmtNtB4_9Formatter11write_style:
  110|  1.00k|    pub(crate) fn write_style(&self) -> WriteStyle {
  111|  1.00k|        self.write_style
  112|  1.00k|    }
_RNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_13DefaultFormat11write_level:
  265|  1.00k|    fn write_level(&mut self, record: &Record) -> io::Result<()> {
  266|  1.00k|        if !self.level {
  267|      0|            return Ok(());
  268|  1.00k|        }
  269|  1.00k|
  270|  1.00k|        let level = {
  271|  1.00k|            #[cfg(feature = "termcolor")]
  272|  1.00k|            {
  273|  1.00k|                self.buf.default_styled_level(record.level())
  274|  1.00k|            }
  275|  1.00k|            #[cfg(not(feature = "termcolor"))]
  276|  1.00k|            {
  277|  1.00k|                record.level()
  278|  1.00k|            }
  279|  1.00k|        };
  280|  1.00k|
  281|  1.00k|        self.write_header_value(format_args!("{:<5}", level))
  282|  1.00k|    }
_RNvMs_NtCsdsqPvVuyxCm_10env_logger3fmtNtB4_9Formatter3new:
  103|      1|    pub(crate) fn new(writer: &Writer) -> Self {
  104|      1|        Formatter {
  105|      1|            buf: Rc::new(RefCell::new(writer.buffer())),
  106|      1|            write_style: writer.write_style(),
  107|      1|        }
  108|      1|    }
_RNvXNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB8_13DefaultFormat10write_argsNtB2_13IndentWrapperNtNtCs8hfS0qQwSL8_3std2io5Write5write:
  353|  10.3k|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|  10.3k|                        let mut first = true;
  355|  10.3k|                        for chunk in buf.split(|&x| x == b'\n') {
  356|  10.3k|                            if !first {
  357|      0|                                write!(
  358|      0|                                    self.fmt.buf,
  359|      0|                                    "{}{:width$}",
  360|      0|                                    self.fmt.suffix,
  361|      0|                                    "",
  362|      0|                                    width = self.indent_count
  363|      0|                                )?;
  364|  10.3k|                            }
  365|  10.3k|                            self.fmt.buf.write_all(chunk)?;
  366|  10.3k|                            first = false;
  367|       |                        }
  368|       |
  369|  10.3k|                        Ok(buf.len())
  370|  10.3k|                    }
_RNvMs4_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_13DefaultFormat13finish_header:
  330|  1.00k|    fn finish_header(&mut self) -> io::Result<()> {
  331|  1.00k|        if self.written_header_value {
  332|  1.00k|            let close_brace = self.subtle_style("]");
  333|  1.00k|            write!(self.buf, "{} ", close_brace)
  334|       |        } else {
  335|      0|            Ok(())
  336|       |        }
  337|  1.00k|    }
_RNvMs3_NtCsdsqPvVuyxCm_10env_logger3fmtNtB5_7Builder5build:
  173|    143|    pub fn build(&mut self) -> FormatFn {
  174|    143|        assert!(!self.built, "attempt to re-use consumed builder");
  175|       |
  176|    143|        let built = mem::replace(
  177|    143|            self,
  178|    143|            Builder {
  179|    143|                built: true,
  180|    143|                ..Default::default()
  181|    143|            },
  182|    143|        );
  183|       |
  184|    143|        if let Some(fmt) = built.custom_format {
  185|      0|            fmt
  186|       |        } else {
  187|    143|            Box::new(move |buf, record| {
  188|       |                let fmt = DefaultFormat {
  189|       |                    timestamp: built.format_timestamp,
  190|       |                    module_path: built.format_module_path,
  191|       |                    target: built.format_target,
  192|       |                    level: built.format_level,
  193|       |                    written_header_value: false,
  194|       |                    indent: built.format_indent,
  195|       |                    suffix: built.format_suffix,
  196|       |                    buf,
  197|       |                };
  198|       |
  199|       |                fmt.write(record)
  200|    143|            })
  201|       |        }
  202|    143|    }
_RNvXNtCsdsqPvVuyxCm_10env_logger3fmtNtB2_18TimestampPrecisionNtNtCs23Pu7RYaif7_4core7default7Default7default:
   71|    286|    fn default() -> Self {
   72|    286|        TimestampPrecision::Seconds
   73|    286|    }
_RNvMs_NtCsdsqPvVuyxCm_10env_logger3fmtNtB4_9Formatter5clear:
  118|  1.00k|    pub(crate) fn clear(&mut self) {
  119|  1.00k|        self.buf.borrow_mut().clear()
  120|  1.00k|    }

_RNvNtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer4atty3imp9is_stderr:
   16|    143|    pub(in crate::fmt) fn is_stderr() -> bool {
   17|    143|        atty::is(atty::Stream::Stderr)
   18|    143|    }

_RNvMs4_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_6Writer5print:
  119|  1.00k|    pub(super) fn print(&self, buf: &Buffer) -> io::Result<()> {
  120|  1.00k|        self.inner.print(buf)
  121|  1.00k|    }
_RNvXs3_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCs23Pu7RYaif7_4core7default7Default7default:
   99|    143|    fn default() -> Self {
  100|    143|        WriteStyle::Auto
  101|    143|    }
_RNvXs1_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_14WritableTargetNtNtCs23Pu7RYaif7_4core7default7Default7default:
   69|    286|    fn default() -> Self {
   70|    286|        Self::from(Target::default())
   71|    286|    }
_RNvMs5_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_7Builder3new:
  137|    143|    pub(crate) fn new() -> Self {
  138|    143|        Builder {
  139|    143|            target: Default::default(),
  140|    143|            write_style: Default::default(),
  141|    143|            is_test: false,
  142|    143|            built: false,
  143|    143|        }
  144|    143|    }
_RNvXs6_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_7BuilderNtNtCs23Pu7RYaif7_4core7default7Default7default:
  207|    143|    fn default() -> Self {
  208|    143|        Builder::new()
  209|    143|    }
_RNvMs4_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_6Writer6buffer:
  115|      1|    pub(super) fn buffer(&self) -> Buffer {
  116|      1|        self.inner.buffer()
  117|      1|    }
_RNvMs4_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_6Writer11write_style:
  111|  1.00k|    pub fn write_style(&self) -> WriteStyle {
  112|  1.00k|        self.write_style
  113|  1.00k|    }
_RNvMs5_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_7Builder5build:
  174|    143|    pub(crate) fn build(&mut self) -> Writer {
  175|    143|        assert!(!self.built, "attempt to re-use consumed builder");
  176|    143|        self.built = true;
  177|       |
  178|    143|        let color_choice = match self.write_style {
  179|       |            WriteStyle::Auto => {
  180|    143|                if match &self.target {
  181|    143|                    WritableTarget::Stderr => is_stderr(),
  182|      0|                    WritableTarget::Stdout => is_stdout(),
  183|      0|                    WritableTarget::Pipe(_) => false,
  184|       |                } {
  185|      0|                    WriteStyle::Auto
  186|       |                } else {
  187|    143|                    WriteStyle::Never
  188|       |                }
  189|       |            }
  190|      0|            color_choice => color_choice,
  191|       |        };
  192|       |
  193|    143|        let writer = match mem::take(&mut self.target) {
  194|    143|            WritableTarget::Stderr => BufferWriter::stderr(self.is_test, color_choice),
  195|      0|            WritableTarget::Stdout => BufferWriter::stdout(self.is_test, color_choice),
  196|      0|            WritableTarget::Pipe(pipe) => BufferWriter::pipe(color_choice, pipe),
  197|       |        };
  198|       |
  199|    143|        Writer {
  200|    143|            inner: writer,
  201|    143|            write_style: self.write_style,
  202|    143|        }
  203|    143|    }
_RNvXNtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB2_6TargetNtNtCs23Pu7RYaif7_4core7default7Default7default:
   27|    286|    fn default() -> Self {
   28|    286|        Target::Stderr
   29|    286|    }
_RNvXs0_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_14WritableTargetINtNtCs23Pu7RYaif7_4core7convert4FromNtB5_6TargetE4from:
   59|    286|    fn from(target: Target) -> Self {
   60|    286|        match target {
   61|      0|            Target::Stdout => Self::Stdout,
   62|    286|            Target::Stderr => Self::Stderr,
   63|      0|            Target::Pipe(pipe) => Self::Pipe(Box::new(Mutex::new(pipe))),
   64|       |        }
   65|    286|    }
_RNvXsf_NtNtCsdsqPvVuyxCm_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCs23Pu7RYaif7_4core3cmp9PartialEq2eq:
   88|  1.00k|#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]

_RNvMs2_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB5_5Style9set_color:
  278|  3.00k|    pub fn set_color(&mut self, color: Color) -> &mut Style {
  279|  3.00k|        self.spec.set_fg(Some(color.into_termcolor()));
  280|  3.00k|        self
  281|  3.00k|    }
_RNvMNtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter20default_styled_level:
   67|  1.00k|    pub fn default_styled_level(&self, level: Level) -> StyledValue<'static, Level> {
   68|  1.00k|        self.default_level_style(level).into_value(level)
   69|  1.00k|    }
_RNvMs0_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5clear:
  144|  1.00k|    pub(in crate::fmt) fn clear(&mut self) {
  145|  1.00k|        self.inner.clear()
  146|  1.00k|    }
_RNvMNtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter5style:
   42|  3.00k|    pub fn style(&self) -> Style {
   43|  3.00k|        Style {
   44|  3.00k|            buf: self.buf.clone(),
   45|  3.00k|            spec: ColorSpec::new(),
   46|  3.00k|        }
   47|  3.00k|    }
_RINvMs3_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueReE9write_fmtNCNvXs8_B6_B13_NtNtCs23Pu7RYaif7_4core3fmt7Display3fmt0EBe_:
  434|  2.00k|        self.style
  435|  2.00k|            .buf
  436|  2.00k|            .borrow_mut()
  437|  2.00k|            .set_color(&self.style.spec)
  438|  2.00k|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|  2.00k|        let write = f();
  442|  2.00k|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|  2.00k|
  444|  2.00k|        write.and(reset)
  445|  2.00k|    }
_RNCNvXs8_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueNtCsfMHHUF7r9BK_3log5LevelENtNtCs23Pu7RYaif7_4core3fmt7Display3fmt0Bf_:
  466|  1.00k|impl_styled_value_fmt!(
  467|  1.00k|    fmt::Debug,
  468|  1.00k|    fmt::Display,
  469|  1.00k|    fmt::Pointer,
  470|  1.00k|    fmt::Octal,
  471|  1.00k|    fmt::Binary,
  472|  1.00k|    fmt::UpperHex,
  473|  1.00k|    fmt::LowerHex,
  474|  1.00k|    fmt::UpperExp,
  475|  1.00k|    fmt::LowerExp
  476|  1.00k|);
_RNCNvXs8_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueReENtNtCs23Pu7RYaif7_4core3fmt7Display3fmt0Bf_:
  466|  2.00k|impl_styled_value_fmt!(
  467|  2.00k|    fmt::Debug,
  468|  2.00k|    fmt::Display,
  469|  2.00k|    fmt::Pointer,
  470|  2.00k|    fmt::Octal,
  471|  2.00k|    fmt::Binary,
  472|  2.00k|    fmt::UpperHex,
  473|  2.00k|    fmt::LowerHex,
  474|  2.00k|    fmt::UpperExp,
  475|  2.00k|    fmt::LowerExp
  476|  2.00k|);
_RNvXs8_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueNtCsfMHHUF7r9BK_3log5LevelENtNtCs23Pu7RYaif7_4core3fmt7Display3fmtBd_:
  458|  1.00k|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|  1.00k|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|  1.00k|                }
_RNvMs1_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB9_10WriteStyle17into_color_choice:
  180|    143|    fn into_color_choice(self) -> ColorChoice {
  181|    143|        match self {
  182|      0|            WriteStyle::Always => ColorChoice::Always,
  183|      0|            WriteStyle::Auto => ColorChoice::Auto,
  184|    143|            WriteStyle::Never => ColorChoice::Never,
  185|       |        }
  186|    143|    }
_RNvMNtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter19default_level_style:
   52|  1.00k|    pub fn default_level_style(&self, level: Level) -> Style {
   53|  1.00k|        let mut level_style = self.style();
   54|  1.00k|        match level {
   55|      0|            Level::Trace => level_style.set_color(Color::Cyan),
   56|  1.00k|            Level::Debug => level_style.set_color(Color::Blue),
   57|      0|            Level::Info => level_style.set_color(Color::Green),
   58|      0|            Level::Warn => level_style.set_color(Color::Yellow),
   59|      0|            Level::Error => level_style.set_color(Color::Red).set_bold(true),
   60|       |        };
   61|  1.00k|        level_style
   62|  1.00k|    }
_RNvMs0_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5reset:
  169|  3.00k|    fn reset(&mut self) -> io::Result<()> {
  170|  3.00k|        // Ignore styles for test captured logs because they can't be printed
  171|  3.00k|        if !self.has_uncolored_target {
  172|  3.00k|            self.inner.reset()
  173|       |        } else {
  174|      0|            Ok(())
  175|       |        }
  176|  3.00k|    }
_RNvXs8_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueReENtNtCs23Pu7RYaif7_4core3fmt7Display3fmtBd_:
  458|  2.00k|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|  2.00k|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|  2.00k|                }
_RNvMs0_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer9set_color:
  160|  3.00k|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
  161|  3.00k|        // Ignore styles for test captured logs because they can't be printed
  162|  3.00k|        if !self.has_uncolored_target {
  163|  3.00k|            self.inner.set_color(spec)
  164|       |        } else {
  165|      0|            Ok(())
  166|       |        }
  167|  3.00k|    }
_RINvMs3_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueNtCsfMHHUF7r9BK_3log5LevelE9write_fmtNCNvXs8_B6_B13_NtNtCs23Pu7RYaif7_4core3fmt7Display3fmt0EBe_:
  434|  1.00k|        self.style
  435|  1.00k|            .buf
  436|  1.00k|            .borrow_mut()
  437|  1.00k|            .set_color(&self.style.spec)
  438|  1.00k|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|  1.00k|        let write = f();
  442|  1.00k|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|  1.00k|
  444|  1.00k|        write.and(reset)
  445|  1.00k|    }
_RNvMs_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter5print:
  124|  1.00k|        if let Some(target) = &self.uncolored_target {
  125|       |            // This impl uses the `eprint` and `print` macros
  126|       |            // instead of `termcolor`'s buffer.
  127|       |            // This is so their output can be captured by `cargo test`
  128|      0|            let log = String::from_utf8_lossy(buf.bytes());
  129|      0|
  130|      0|            match target {
  131|      0|                WritableTarget::Stderr => eprint!("{}", log),
  132|      0|                WritableTarget::Stdout => print!("{}", log),
  133|      0|                WritableTarget::Pipe(pipe) => write!(pipe.lock().unwrap(), "{}", log)?,
  134|       |            }
  135|       |
  136|      0|            Ok(())
  137|       |        } else {
  138|  1.00k|            self.inner.print(&buf.inner)
  139|       |        }
  140|  1.00k|    }
_RNvMs5_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB5_5Color14into_termcolor:
  518|  3.00k|    fn into_termcolor(self) -> termcolor::Color {
  519|  3.00k|        match self {
  520|  2.00k|            Color::Black => termcolor::Color::Black,
  521|  1.00k|            Color::Blue => termcolor::Color::Blue,
  522|      0|            Color::Green => termcolor::Color::Green,
  523|      0|            Color::Red => termcolor::Color::Red,
  524|      0|            Color::Cyan => termcolor::Color::Cyan,
  525|      0|            Color::Magenta => termcolor::Color::Magenta,
  526|      0|            Color::Yellow => termcolor::Color::Yellow,
  527|      0|            Color::White => termcolor::Color::White,
  528|      0|            Color::Ansi256(value) => termcolor::Color::Ansi256(value),
  529|      0|            Color::Rgb(r, g, b) => termcolor::Color::Rgb(r, g, b),
  530|       |        }
  531|  3.00k|    }
_RNvMs_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6buffer:
  116|      1|    pub(in crate::fmt::writer) fn buffer(&self) -> Buffer {
  117|      1|        Buffer {
  118|      1|            inner: self.inner.buffer(),
  119|      1|            has_uncolored_target: self.uncolored_target.is_some(),
  120|      1|        }
  121|      1|    }
_RNvMs_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6stderr:
   83|    143|    pub(in crate::fmt::writer) fn stderr(is_test: bool, write_style: WriteStyle) -> Self {
   84|    143|        BufferWriter {
   85|    143|            inner: termcolor::BufferWriter::stderr(write_style.into_color_choice()),
   86|    143|            uncolored_target: if is_test {
   87|      0|                Some(WritableTarget::Stderr)
   88|       |            } else {
   89|    143|                None
   90|       |            },
   91|       |        }
   92|    143|    }
_RNvMs0_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5write:
  148|  19.3k|    pub(in crate::fmt) fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  149|  19.3k|        self.inner.write(buf)
  150|  19.3k|    }
_RNvXs6_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB5_5StyleNtNtCs23Pu7RYaif7_4core5clone5Clone5clone:
  241|  2.00k|#[derive(Clone)]
_RINvMs2_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueNtCsfMHHUF7r9BK_3log5LevelEBe_:
  421|  1.00k|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|  1.00k|        StyledValue {
  423|  1.00k|            style: Cow::Owned(self),
  424|  1.00k|            value,
  425|  1.00k|        }
  426|  1.00k|    }
_RNvMs2_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB5_5Style11set_intense:
  332|  2.00k|    pub fn set_intense(&mut self, yes: bool) -> &mut Style {
  333|  2.00k|        self.spec.set_intense(yes);
  334|  2.00k|        self
  335|  2.00k|    }
_RINvMs2_NtNtNtNtCsdsqPvVuyxCm_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueReEBe_:
  421|  2.00k|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|  2.00k|        StyledValue {
  423|  2.00k|            style: Cow::Owned(self),
  424|  2.00k|            value,
  425|  2.00k|        }
  426|  2.00k|    }

_RNvXs7_CsdsqPvVuyxCm_10env_loggerNtB5_7BuilderNtNtCs23Pu7RYaif7_4core7default7Default7default:
  376|    143|#[derive(Default)]
_RNCNvXs0_CsdsqPvVuyxCm_10env_loggerNtB7_6LoggerNtCsfMHHUF7r9BK_3log3Log3log0B7_:
  922|  1.00k|            let print = |formatter: &mut Formatter, record: &Record| {
  923|  1.00k|                let _ =
  924|  1.00k|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|  1.00k|
  926|  1.00k|                // Always clear the buffer afterwards
  927|  1.00k|                formatter.clear();
  928|  1.00k|            };
_RNvMCsdsqPvVuyxCm_10env_loggerNtB2_7Builder13parse_filters:
  716|    143|    pub fn parse_filters(&mut self, filters: &str) -> &mut Self {
  717|    143|        self.filter.parse(filters);
  718|    143|        self
  719|    143|    }
_RINvCsdsqPvVuyxCm_10env_logger17try_init_from_envNtB2_3EnvEB2_:
 1185|    143|pub fn try_init_from_env<'a, E>(env: E) -> Result<(), SetLoggerError>
 1186|    143|where
 1187|    143|    E: Into<Env<'a>>,
 1188|    143|{
 1189|    143|    let mut builder = Builder::from_env(env);
 1190|    143|
 1191|    143|    builder.try_init()
 1192|    143|}
_RNvMs1_CsdsqPvVuyxCm_10env_loggerNtB5_3Env15get_write_style:
 1053|    143|    fn get_write_style(&self) -> Option<String> {
 1054|    143|        self.write_style.get()
 1055|    143|    }
_RNvXs4_CsdsqPvVuyxCm_10env_loggerNtB5_3EnvNtNtCs23Pu7RYaif7_4core7default7Default7default:
 1097|    143|    fn default() -> Self {
 1098|    143|        Env {
 1099|    143|            filter: Var::new(DEFAULT_FILTER_ENV),
 1100|    143|            write_style: Var::new(DEFAULT_WRITE_STYLE_ENV),
 1101|    143|        }
 1102|    143|    }
_RNvMs_CsdsqPvVuyxCm_10env_loggerNtB4_6Logger6filter:
  892|    143|    pub fn filter(&self) -> LevelFilter {
  893|    143|        self.filter.filter()
  894|    143|    }
_RNvMs1_CsdsqPvVuyxCm_10env_loggerNtB5_3Env10get_filter:
 1014|    143|    fn get_filter(&self) -> Option<String> {
 1015|    143|        self.filter.get()
 1016|    143|    }
_RNvMCsdsqPvVuyxCm_10env_loggerNtB2_7Builder5build:
  823|    143|    pub fn build(&mut self) -> Logger {
  824|    143|        assert!(!self.built, "attempt to re-use consumed builder");
  825|    143|        self.built = true;
  826|    143|
  827|    143|        Logger {
  828|    143|            writer: self.writer.build(),
  829|    143|            filter: self.filter.build(),
  830|    143|            format: self.format.build(),
  831|    143|        }
  832|    143|    }
_RNvMs2_CsdsqPvVuyxCm_10env_loggerNtB5_3Var3get:
 1080|    286|    fn get(&self) -> Option<String> {
 1081|    286|        env::var(&*self.name)
 1082|    286|            .ok()
 1083|    286|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
 1084|    286|    }
_RNvXs0_CsdsqPvVuyxCm_10env_loggerNtB5_6LoggerNtCsfMHHUF7r9BK_3log3Log3log:
  907|  1.14k|    fn log(&self, record: &Record) {
  908|  1.14k|        if self.matches(record) {
  909|       |            // Log records are written to a thread-local buffer before being printed
  910|       |            // to the terminal. We clear these buffers afterwards, but they aren't shrinked
  911|       |            // so will always at least have capacity for the largest log record formatted
  912|       |            // on that thread.
  913|       |            //
  914|       |            // If multiple `Logger`s are used by the same threads then the thread-local
  915|       |            // formatter might have different color support. If this is the case the
  916|       |            // formatter and its buffer are discarded and recreated.
  917|       |
  918|       |            thread_local! {
  919|       |                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|       |            }
  921|       |
  922|  1.00k|            let print = |formatter: &mut Formatter, record: &Record| {
  923|       |                let _ =
  924|       |                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|       |
  926|       |                // Always clear the buffer afterwards
  927|       |                formatter.clear();
  928|       |            };
  929|       |
  930|  1.00k|            let printed = FORMATTER
  931|  1.00k|                .try_with(|tl_buf| {
  932|       |                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|       |                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|       |                            Some(ref mut formatter) => {
  937|       |                                // Check the buffer style. If it's different from the logger's
  938|       |                                // style then drop the buffer and recreate it.
  939|       |                                if formatter.write_style() != self.writer.write_style() {
  940|       |                                    *formatter = Formatter::new(&self.writer);
  941|       |                                }
  942|       |
  943|       |                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|       |                            None => {
  947|       |                                let mut formatter = Formatter::new(&self.writer);
  948|       |                                print(&mut formatter, record);
  949|       |
  950|       |                                *tl_buf = Some(formatter);
  951|       |                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|       |                        Err(_) => {
  955|       |                            print(&mut Formatter::new(&self.writer), record);
  956|       |                        }
  957|       |                    }
  958|  1.00k|                })
  959|  1.00k|                .is_ok();
  960|  1.00k|
  961|  1.00k|            if !printed {
  962|      0|                // The thread-local storage was not available (because its
  963|      0|                // destructor has already run). Create a new single-use
  964|      0|                // Formatter on the stack for this call.
  965|      0|                print(&mut Formatter::new(&self.writer), record);
  966|  1.00k|            }
  967|    142|        }
  968|  1.14k|    }
_RNvMs_CsdsqPvVuyxCm_10env_loggerNtB4_6Logger7matches:
  897|  1.14k|    pub fn matches(&self, record: &Record) -> bool {
  898|  1.14k|        self.filter.matches(record)
  899|  1.14k|    }
_RNvMCsdsqPvVuyxCm_10env_loggerNtB2_7Builder8try_init:
  792|    143|    pub fn try_init(&mut self) -> Result<(), SetLoggerError> {
  793|    143|        let logger = self.build();
  794|    143|
  795|    143|        let max_level = logger.filter();
  796|    143|        let r = log::set_boxed_logger(Box::new(logger));
  797|    143|
  798|    143|        if r.is_ok() {
  799|      1|            log::set_max_level(max_level);
  800|    142|        }
  801|       |
  802|    143|        r
  803|    143|    }
_RINvMs2_CsdsqPvVuyxCm_10env_loggerNtB6_3Var3newReEB6_:
 1059|    286|    fn new<E>(name: E) -> Self
 1060|    286|    where
 1061|    286|        E: Into<Cow<'a, str>>,
 1062|    286|    {
 1063|    286|        Var {
 1064|    286|            name: name.into(),
 1065|    286|            default: None,
 1066|    286|        }
 1067|    286|    }
_RINvMCsdsqPvVuyxCm_10env_loggerNtB3_7Builder9parse_envNtB3_3EnvEB3_:
  488|    143|    pub fn parse_env<'a, E>(&mut self, env: E) -> &mut Self
  489|    143|    where
  490|    143|        E: Into<Env<'a>>,
  491|    143|    {
  492|    143|        let env = env.into();
  493|       |
  494|    143|        if let Some(s) = env.get_filter() {
  495|    143|            self.parse_filters(&s);
  496|    143|        }
  497|       |
  498|    143|        if let Some(s) = env.get_write_style() {
  499|      0|            self.parse_write_style(&s);
  500|    143|        }
  501|       |
  502|    143|        self
  503|    143|    }
_RNCNvNvNvXs0_CsdsqPvVuyxCm_10env_loggerNtBb_6LoggerNtCsfMHHUF7r9BK_3log3Log3log9FORMATTER7___getit0Bb_:
  918|      1|            thread_local! {
  919|      1|                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|      1|            }
_RNCNvXs0_CsdsqPvVuyxCm_10env_loggerNtB7_6LoggerNtCsfMHHUF7r9BK_3log3Log3logs_0B7_:
  931|  1.00k|                .try_with(|tl_buf| {
  932|  1.00k|                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|  1.00k|                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|  1.00k|                            Some(ref mut formatter) => {
  937|  1.00k|                                // Check the buffer style. If it's different from the logger's
  938|  1.00k|                                // style then drop the buffer and recreate it.
  939|  1.00k|                                if formatter.write_style() != self.writer.write_style() {
  940|      0|                                    *formatter = Formatter::new(&self.writer);
  941|  1.00k|                                }
  942|       |
  943|  1.00k|                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|      1|                            None => {
  947|      1|                                let mut formatter = Formatter::new(&self.writer);
  948|      1|                                print(&mut formatter, record);
  949|      1|
  950|      1|                                *tl_buf = Some(formatter);
  951|      1|                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|      0|                        Err(_) => {
  955|      0|                            print(&mut Formatter::new(&self.writer), record);
  956|      0|                        }
  957|       |                    }
  958|  1.00k|                })
_RNCNCNvXs0_CsdsqPvVuyxCm_10env_loggerNtB9_6LoggerNtCsfMHHUF7r9BK_3log3Log3log00B9_:
  924|  1.00k|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
_RINvMCsdsqPvVuyxCm_10env_loggerNtB3_7Builder8from_envNtB3_3EnvEB3_:
  443|    143|    pub fn from_env<'a, E>(env: E) -> Self
  444|    143|    where
  445|    143|        E: Into<Env<'a>>,
  446|    143|    {
  447|    143|        let mut builder = Builder::new();
  448|    143|        builder.parse_env(env);
  449|    143|        builder
  450|    143|    }
_RNvMCsdsqPvVuyxCm_10env_loggerNtB2_7Builder3new:
  411|    143|    pub fn new() -> Builder {
  412|    143|        Default::default()
  413|    143|    }
_RNvCsdsqPvVuyxCm_10env_logger8try_init:
 1140|    143|pub fn try_init() -> Result<(), SetLoggerError> {
 1141|    143|    try_init_from_env(Env::default())
 1142|    143|}
_RNCNvMs2_CsdsqPvVuyxCm_10env_loggerNtB7_3Var3get0B7_:
 1083|    143|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))

_RNvNtCsjOa6rDDMm87_9humantime4date22format_rfc3339_seconds:
  212|  1.00k|pub fn format_rfc3339_seconds(system_time: SystemTime) -> Rfc3339Timestamp {
  213|  1.00k|    Rfc3339Timestamp(system_time, Precision::Seconds)
  214|  1.00k|}
_RNvXsa_NtCsjOa6rDDMm87_9humantime4dateNtB5_9PrecisionNtNtCs23Pu7RYaif7_4core3cmp9PartialEq2eq:
   58|  1.00k|#[derive(Debug, Clone, PartialEq, Eq)]
_RNvXs1_NtCsjOa6rDDMm87_9humantime4dateNtB5_16Rfc3339TimestampNtNtCs23Pu7RYaif7_4core3fmt7Display3fmt:
  251|  1.00k|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  252|  1.00k|        use self::Precision::*;
  253|  1.00k|
  254|  1.00k|        let dur = self.0.duration_since(UNIX_EPOCH)
  255|  1.00k|            .expect("all times should be after the epoch");
  256|  1.00k|        let secs_since_epoch = dur.as_secs();
  257|  1.00k|        let nanos = dur.subsec_nanos();
  258|  1.00k|
  259|  1.00k|        if secs_since_epoch >= 253_402_300_800 { // year 9999
  260|      0|            return Err(fmt::Error);
  261|  1.00k|        }
  262|  1.00k|
  263|  1.00k|        /* 2000-03-01 (mod 400 year, immediately after feb29 */
  264|  1.00k|        const LEAPOCH: i64 = 11017;
  265|  1.00k|        const DAYS_PER_400Y: i64 = 365*400 + 97;
  266|  1.00k|        const DAYS_PER_100Y: i64 = 365*100 + 24;
  267|  1.00k|        const DAYS_PER_4Y: i64 = 365*4 + 1;
  268|  1.00k|
  269|  1.00k|        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;
  270|  1.00k|        let secs_of_day = secs_since_epoch % 86400;
  271|  1.00k|
  272|  1.00k|        let mut qc_cycles = days / DAYS_PER_400Y;
  273|  1.00k|        let mut remdays = days % DAYS_PER_400Y;
  274|  1.00k|
  275|  1.00k|        if remdays < 0 {
  276|      0|            remdays += DAYS_PER_400Y;
  277|      0|            qc_cycles -= 1;
  278|  1.00k|        }
  279|       |
  280|  1.00k|        let mut c_cycles = remdays / DAYS_PER_100Y;
  281|  1.00k|        if c_cycles == 4 { c_cycles -= 1; }
  282|  1.00k|        remdays -= c_cycles * DAYS_PER_100Y;
  283|  1.00k|
  284|  1.00k|        let mut q_cycles = remdays / DAYS_PER_4Y;
  285|  1.00k|        if q_cycles == 25 { q_cycles -= 1; }
  286|  1.00k|        remdays -= q_cycles * DAYS_PER_4Y;
  287|  1.00k|
  288|  1.00k|        let mut remyears = remdays / 365;
  289|  1.00k|        if remyears == 4 { remyears -= 1; }
  290|  1.00k|        remdays -= remyears * 365;
  291|  1.00k|
  292|  1.00k|        let mut year = 2000 +
  293|  1.00k|            remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;
  294|  1.00k|
  295|  1.00k|        let months = [31,30,31,30,31,31,30,31,30,31,31,29];
  296|  1.00k|        let mut mon = 0;
  297|  9.00k|        for mon_len in months.iter() {
  298|  9.00k|            mon += 1;
  299|  9.00k|            if remdays < *mon_len {
  300|  1.00k|                break;
  301|  8.00k|            }
  302|  8.00k|            remdays -= *mon_len;
  303|       |        }
  304|  1.00k|        let mday = remdays+1;
  305|  1.00k|        let mon = if mon + 2 > 12 {
  306|      0|            year += 1;
  307|      0|            mon - 10
  308|       |        } else {
  309|  1.00k|            mon + 2
  310|       |        };
  311|       |
  312|  1.00k|        let mut buf: [u8; 30] = [
  313|  1.00k|            // Too long to write as: b"0000-00-00T00:00:00.000000000Z"
  314|  1.00k|            b'0', b'0', b'0', b'0', b'-', b'0', b'0', b'-', b'0', b'0', b'T',
  315|  1.00k|            b'0', b'0', b':', b'0', b'0', b':', b'0', b'0',
  316|  1.00k|            b'.', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'Z',
  317|  1.00k|        ];
  318|  1.00k|        buf[0] = b'0' + (year / 1000) as u8;
  319|  1.00k|        buf[1] = b'0' + (year / 100 % 10) as u8;
  320|  1.00k|        buf[2] = b'0' + (year / 10 % 10) as u8;
  321|  1.00k|        buf[3] = b'0' + (year % 10) as u8;
  322|  1.00k|        buf[5] = b'0' + (mon / 10) as u8;
  323|  1.00k|        buf[6] = b'0' + (mon % 10) as u8;
  324|  1.00k|        buf[8] = b'0' + (mday / 10) as u8;
  325|  1.00k|        buf[9] = b'0' + (mday % 10) as u8;
  326|  1.00k|        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;
  327|  1.00k|        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;
  328|  1.00k|        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;
  329|  1.00k|        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;
  330|  1.00k|        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;
  331|  1.00k|        buf[18] = b'0' + (secs_of_day % 10) as u8;
  332|       |
  333|  1.00k|        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {
  334|  1.00k|            buf[19] = b'Z';
  335|  1.00k|            19
  336|      0|        } else if self.1 == Millis {
  337|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  338|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  339|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  340|      0|            buf[23] = b'Z';
  341|      0|            23
  342|      0|        } else if self.1 == Micros {
  343|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  344|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  345|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  346|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  347|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  348|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  349|      0|            buf[26] = b'Z';
  350|      0|            26
  351|       |        } else {
  352|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  353|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  354|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  355|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  356|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  357|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  358|      0|            buf[26] = b'0' + (nanos / 100 % 10) as u8;
  359|      0|            buf[27] = b'0' + (nanos / 10 % 10) as u8;
  360|      0|            buf[28] = b'0' + (nanos / 1 % 10) as u8;
  361|      0|            // 29th is 'Z'
  362|      0|            29
  363|       |        };
  364|       |
  365|       |        // we know our chars are all ascii
  366|  1.00k|        f.write_str(str::from_utf8(&buf[..=offset]).expect("Conversion to utf8 failed"))
  367|  1.00k|    }

_RNvNvCs2IPmB8bTu1k_22instrument_with_mutate1__3run:
  241|    285|            fn run($bytes: &[u8]) {
rust_fuzzer_test_input:
  215|    143|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  216|       |                    use std::io::Write;
  217|      0|                    let mut file = std::fs::File::create(path)
  218|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  219|      0|                    writeln!(&mut file, "{:?}", bytes)
  220|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  221|      0|                    return 0;
  222|    143|                }
  223|    143|
  224|    143|                run(bytes);
  225|    143|                0
  226|    143|            }
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}
LLVMFuzzerTestOneInput:
   58|    143|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|    143|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|    143|    });
   63|    143|
   64|    143|    match test_input {
   65|    143|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|    143|}
_RNCNvCs5kJPt813uPw_13libfuzzer_sys15test_input_wrap0B3_:
   59|    143|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|    143|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|    143|        rust_fuzzer_test_input(data_slice)
   62|    143|    });

_RNvXs2_CsfMHHUF7r9BK_3logNtB5_5LevelINtNtCs23Pu7RYaif7_4core3cmp10PartialOrdNtB5_11LevelFilterE2le:
  511|  3.28k|    fn le(&self, other: &LevelFilter) -> bool {
  512|  3.28k|        *self as usize <= *other as usize
  513|  3.28k|    }
_RNvCsfMHHUF7r9BK_3log9max_level:
 1383|  1.14k|pub fn max_level() -> LevelFilter {
 1384|  1.14k|    // Since `LevelFilter` is `repr(usize)`,
 1385|  1.14k|    // this transmute is sound if and only if `MAX_LOG_LEVEL_FILTER`
 1386|  1.14k|    // is set to a usize that is a valid discriminant for `LevelFilter`.
 1387|  1.14k|    // Since `MAX_LOG_LEVEL_FILTER` is private, the only time it's set
 1388|  1.14k|    // is by `set_max_level` above, i.e. by casting a `LevelFilter` to `usize`.
 1389|  1.14k|    // So any usize stored in `MAX_LOG_LEVEL_FILTER` is a valid discriminant.
 1390|  1.14k|    unsafe { mem::transmute(MAX_LOG_LEVEL_FILTER.load(Ordering::Relaxed)) }
 1391|  1.14k|}
_RNvMsh_CsfMHHUF7r9BK_3logNtB5_6Record4args:
  910|  1.00k|    pub fn args(&self) -> &fmt::Arguments<'a> {
  911|  1.00k|        &self.args
  912|  1.00k|    }
_RNvMsh_CsfMHHUF7r9BK_3logNtB5_6Record5level:
  922|  1.00k|    pub fn level(&self) -> Level {
  923|  1.00k|        self.metadata.level()
  924|  1.00k|    }
_RNvMsj_CsfMHHUF7r9BK_3logNtB5_8Metadata6target:
 1204|  2.14k|    pub fn target(&self) -> &'a str {
 1205|  2.14k|        self.target
 1206|  2.14k|    }
_RNvXsc_CsfMHHUF7r9BK_3logNtB5_11LevelFilterNtNtCs23Pu7RYaif7_4core3cmp3Ord3cmp:
  735|    429|    fn cmp(&self, other: &LevelFilter) -> cmp::Ordering {
  736|    429|        (*self as usize).cmp(&(*other as usize))
  737|    429|    }
_RNvMsh_CsfMHHUF7r9BK_3logNtB5_6Record8metadata:
  916|  1.14k|    pub fn metadata(&self) -> &Metadata<'a> {
  917|  1.14k|        &self.metadata
  918|  1.14k|    }
_RNvMsf_CsfMHHUF7r9BK_3logNtB5_11LevelFilter3max:
  774|    286|    pub fn max() -> LevelFilter {
  775|    286|        LevelFilter::Trace
  776|    286|    }
_RNvCsfMHHUF7r9BK_3log13set_max_level:
 1365|      1|pub fn set_max_level(level: LevelFilter) {
 1366|      1|    MAX_LOG_LEVEL_FILTER.store(level as usize, Ordering::Relaxed)
 1367|      1|}
_RNvMsj_CsfMHHUF7r9BK_3logNtB5_8Metadata5level:
 1198|  2.14k|    pub fn level(&self) -> Level {
 1199|  2.14k|        self.level
 1200|  2.14k|    }
_RNvMsh_CsfMHHUF7r9BK_3logNtB5_6Record6target:
  928|  1.00k|    pub fn target(&self) -> &'a str {
  929|  1.00k|        self.metadata.target()
  930|  1.00k|    }
_RNvXsQ_CsfMHHUF7r9BK_3logNtB5_8MetadataNtNtCs23Pu7RYaif7_4core5clone5Clone5clone:
 1183|  2.28k|#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvMsh_CsfMHHUF7r9BK_3logNtB5_6Record7builder:
  904|  1.14k|    pub fn builder() -> RecordBuilder<'a> {
  905|  1.14k|        RecordBuilder::new()
  906|  1.14k|    }
_RNvMsi_CsfMHHUF7r9BK_3logNtB5_13RecordBuilder5level:
 1083|  1.14k|    pub fn level(&mut self, level: Level) -> &mut RecordBuilder<'a> {
 1084|  1.14k|        self.record.metadata.level = level;
 1085|  1.14k|        self
 1086|  1.14k|    }
_RNCNvXsd_CsfMHHUF7r9BK_3logNtB7_11LevelFilterNtNtNtCs23Pu7RYaif7_4core3str6traits7FromStr8from_strs_0B7_:
  747|    286|                .map(|p| LevelFilter::from_usize(p).unwrap()),
_RNvMsi_CsfMHHUF7r9BK_3logNtB5_13RecordBuilder4args:
 1069|  1.14k|    pub fn args(&mut self, args: fmt::Arguments<'a>) -> &mut RecordBuilder<'a> {
 1070|  1.14k|        self.record.args = args;
 1071|  1.14k|        self
 1072|  1.14k|    }
_RNvCsfMHHUF7r9BK_3log16set_boxed_logger:
 1407|    143|pub fn set_boxed_logger(logger: Box<dyn Log>) -> Result<(), SetLoggerError> {
 1408|    143|    set_logger_inner(|| Box::leak(logger))
 1409|    143|}
_RNvXCsfMHHUF7r9BK_3logNtB2_5LevelNtNtCs23Pu7RYaif7_4core5clone5Clone5clone:
  453|  2.28k|    fn clone(&self) -> Level {
  454|  2.28k|        *self
  455|  2.28k|    }
_RNvCsfMHHUF7r9BK_3log17___private_api_log:
 1591|  1.14k|    if kvs.is_some() {
 1592|      0|        panic!(
 1593|      0|            "key-value support is experimental and must be enabled using the `kv_unstable` feature"
 1594|      0|        )
 1595|  1.14k|    }
 1596|  1.14k|
 1597|  1.14k|    logger().log(
 1598|  1.14k|        &Record::builder()
 1599|  1.14k|            .args(args)
 1600|  1.14k|            .level(level)
 1601|  1.14k|            .target(target)
 1602|  1.14k|            .module_path_static(Some(module_path))
 1603|  1.14k|            .file_static(Some(file))
 1604|  1.14k|            .line(Some(line))
 1605|  1.14k|            .build(),
 1606|  1.14k|    );
 1607|  1.14k|}
_RNvMsk_CsfMHHUF7r9BK_3logNtB5_15MetadataBuilder5build:
 1263|  1.14k|    pub fn build(&self) -> Metadata<'a> {
 1264|  1.14k|        self.metadata.clone()
 1265|  1.14k|    }
_RNvMsi_CsfMHHUF7r9BK_3logNtB5_13RecordBuilder11file_static:
 1118|  1.14k|    pub fn file_static(&mut self, file: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1119|  1.14k|        self.record.file = file.map(MaybeStaticStr::Static);
 1120|  1.14k|        self
 1121|  1.14k|    }
_RINvCsfMHHUF7r9BK_3log5ok_orNtB2_11LevelFilterNtB2_15ParseLevelErrorEB2_:
  533|    572|fn ok_or<T, E>(t: Option<T>, e: E) -> Result<T, E> {
  534|    572|    match t {
  535|    286|        Some(t) => Ok(t),
  536|    286|        None => Err(e),
  537|       |    }
  538|    572|}
_RNvMsf_CsfMHHUF7r9BK_3logNtB5_11LevelFilter10from_usize:
  760|    286|    fn from_usize(u: usize) -> Option<LevelFilter> {
  761|    286|        match u {
  762|      0|            0 => Some(LevelFilter::Off),
  763|      0|            1 => Some(LevelFilter::Error),
  764|      0|            2 => Some(LevelFilter::Warn),
  765|      0|            3 => Some(LevelFilter::Info),
  766|    143|            4 => Some(LevelFilter::Debug),
  767|    143|            5 => Some(LevelFilter::Trace),
  768|      0|            _ => None,
  769|       |        }
  770|    286|    }
_RNvNvCsfMHHUF7r9BK_3log20eq_ignore_ascii_case18to_ascii_uppercase:
  542|  3.71k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  3.71k|        if c >= b'a' && c <= b'z' {
  544|  1.85k|            c - b'a' + b'A'
  545|       |        } else {
  546|  1.85k|            c
  547|       |        }
  548|  3.71k|    }
_RNvXsE_CsfMHHUF7r9BK_3logNtB5_14MaybeStaticStrNtNtCs23Pu7RYaif7_4core5clone5Clone5clone:
  812|  2.28k|#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvMsj_CsfMHHUF7r9BK_3logNtB5_8Metadata7builder:
 1192|  1.14k|    pub fn builder() -> MetadataBuilder<'a> {
 1193|  1.14k|        MetadataBuilder::new()
 1194|  1.14k|    }
_RNvMsk_CsfMHHUF7r9BK_3logNtB5_15MetadataBuilder3new:
 1238|  1.14k|    pub fn new() -> MetadataBuilder<'a> {
 1239|  1.14k|        MetadataBuilder {
 1240|  1.14k|            metadata: Metadata {
 1241|  1.14k|                level: Level::Info,
 1242|  1.14k|                target: "",
 1243|  1.14k|            },
 1244|  1.14k|        }
 1245|  1.14k|    }
_RNvMsi_CsfMHHUF7r9BK_3logNtB5_13RecordBuilder5build:
 1140|  1.14k|    pub fn build(&self) -> Record<'a> {
 1141|  1.14k|        self.record.clone()
 1142|  1.14k|    }
_RNCNvCsfMHHUF7r9BK_3log20eq_ignore_ascii_case0B3_:
  553|  1.85k|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
_RNvMsi_CsfMHHUF7r9BK_3logNtB5_13RecordBuilder4line:
 1125|  1.14k|    pub fn line(&mut self, line: Option<u32>) -> &mut RecordBuilder<'a> {
 1126|  1.14k|        self.record.line = line;
 1127|  1.14k|        self
 1128|  1.14k|    }
_RINvCsfMHHUF7r9BK_3log16set_logger_innerNCNvB2_16set_boxed_logger0EB2_:
 1470|    143|fn set_logger_inner<F>(make_logger: F) -> Result<(), SetLoggerError>
 1471|    143|where
 1472|    143|    F: FnOnce() -> &'static dyn Log,
 1473|    143|{
 1474|    143|    let old_state = match STATE.compare_exchange(
 1475|    143|        UNINITIALIZED,
 1476|    143|        INITIALIZING,
 1477|    143|        Ordering::SeqCst,
 1478|    143|        Ordering::SeqCst,
 1479|    143|    ) {
 1480|    143|        Ok(s) | Err(s) => s,
 1481|    143|    };
 1482|    143|    match old_state {
 1483|       |        UNINITIALIZED => {
 1484|      1|            unsafe {
 1485|      1|                LOGGER = make_logger();
 1486|      1|            }
 1487|      1|            STATE.store(INITIALIZED, Ordering::SeqCst);
 1488|      1|            Ok(())
 1489|       |        }
 1490|       |        INITIALIZING => {
 1491|      0|            while STATE.load(Ordering::SeqCst) == INITIALIZING {
 1492|      0|                // TODO: replace with `hint::spin_loop` once MSRV is 1.49.0.
 1493|      0|                #[allow(deprecated)]
 1494|      0|                std::sync::atomic::spin_loop_hint();
 1495|      0|            }
 1496|      0|            Err(SetLoggerError(()))
 1497|       |        }
 1498|    142|        _ => Err(SetLoggerError(())),
 1499|       |    }
 1500|    143|}
_RNvXs5_CsfMHHUF7r9BK_3logNtB5_5LevelNtNtCs23Pu7RYaif7_4core3fmt7Display3fmt:
  576|  1.00k|    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
  577|  1.00k|        fmt.pad(self.as_str())
  578|  1.00k|    }
_RNvMsi_CsfMHHUF7r9BK_3logNtB5_13RecordBuilder18module_path_static:
 1104|  1.14k|    pub fn module_path_static(&mut self, path: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1105|  1.14k|        self.record.module_path = path.map(MaybeStaticStr::Static);
 1106|  1.14k|        self
 1107|  1.14k|    }
_RNvMsi_CsfMHHUF7r9BK_3logNtB5_13RecordBuilder3new:
 1053|  1.14k|    pub fn new() -> RecordBuilder<'a> {
 1054|  1.14k|        RecordBuilder {
 1055|  1.14k|            record: Record {
 1056|  1.14k|                args: format_args!(""),
 1057|  1.14k|                metadata: Metadata::builder().build(),
 1058|  1.14k|                module_path: None,
 1059|  1.14k|                file: None,
 1060|  1.14k|                line: None,
 1061|  1.14k|                #[cfg(feature = "kv_unstable")]
 1062|  1.14k|                key_values: KeyValues(&Option::None::<(kv::Key, kv::Value)>),
 1063|  1.14k|            },
 1064|  1.14k|        }
 1065|  1.14k|    }
_RNvXsN_CsfMHHUF7r9BK_3logNtB5_6RecordNtNtCs23Pu7RYaif7_4core5clone5Clone5clone:
  873|  1.14k|#[derive(Clone, Debug)]
_RNvCsfMHHUF7r9BK_3log20eq_ignore_ascii_case:
  541|  3.28k|fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {
  542|  3.28k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  3.28k|        if c >= b'a' && c <= b'z' {
  544|  3.28k|            c - b'a' + b'A'
  545|  3.28k|        } else {
  546|  3.28k|            c
  547|  3.28k|        }
  548|  3.28k|    }
  549|  3.28k|
  550|  3.28k|    if a.len() == b.len() {
  551|    715|        a.bytes()
  552|    715|            .zip(b.bytes())
  553|    715|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
  554|       |    } else {
  555|  2.57k|        false
  556|       |    }
  557|  3.28k|}
_RNvCsfMHHUF7r9BK_3log6logger:
 1573|  1.14k|pub fn logger() -> &'static dyn Log {
 1574|  1.14k|    if STATE.load(Ordering::SeqCst) != INITIALIZED {
 1575|       |        static NOP: NopLogger = NopLogger;
 1576|      0|        &NOP
 1577|       |    } else {
 1578|  1.14k|        unsafe { LOGGER }
 1579|       |    }
 1580|  1.14k|}
_RNCNvXsd_CsfMHHUF7r9BK_3logNtB7_11LevelFilterNtNtNtCs23Pu7RYaif7_4core3str6traits7FromStr8from_str0B7_:
  746|  3.28k|                .position(|&name| eq_ignore_ascii_case(name, level))
_RNCNvCsfMHHUF7r9BK_3log16set_boxed_logger0B3_:
 1408|      1|    set_logger_inner(|| Box::leak(logger))
_RNvMsi_CsfMHHUF7r9BK_3logNtB5_13RecordBuilder6target:
 1090|  1.14k|    pub fn target(&mut self, target: &'a str) -> &mut RecordBuilder<'a> {
 1091|  1.14k|        self.record.metadata.target = target;
 1092|  1.14k|        self
 1093|  1.14k|    }
_RNvXsd_CsfMHHUF7r9BK_3logNtB5_11LevelFilterNtNtNtCs23Pu7RYaif7_4core3str6traits7FromStr8from_str:
  742|    572|    fn from_str(level: &str) -> Result<LevelFilter, Self::Err> {
  743|    572|        ok_or(
  744|    572|            LOG_LEVEL_NAMES
  745|    572|                .iter()
  746|    572|                .position(|&name| eq_ignore_ascii_case(name, level))
  747|    572|                .map(|p| LevelFilter::from_usize(p).unwrap()),
  748|    572|            ParseLevelError(()),
  749|    572|        )
  750|    572|    }
_RNvMs6_CsfMHHUF7r9BK_3logNtB5_5Level6as_str:
  608|  1.00k|    pub fn as_str(&self) -> &'static str {
  609|  1.00k|        LOG_LEVEL_NAMES[*self as usize]
  610|  1.00k|    }

_RNvMs2_NtCsgtPjL2G9icq_9once_cell3impINtB5_8OnceCellNtNtCsg2DHIZY9C0C_5alloc6string6StringE14is_initializedCs2IPmB8bTu1k_22instrument_with_mutate:
   59|    143|    pub(crate) fn is_initialized(&self) -> bool {
   60|    143|        // An `Acquire` load is enough because that makes all the initialization
   61|    143|        // operations visible to us, and, this being a fast path, weaker
   62|    143|        // ordering helps with performance. This `Acquire` synchronizes with
   63|    143|        // `SeqCst` operations on the slow path.
   64|    143|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   65|    143|    }

_RNvMs4_NtCsgtPjL2G9icq_9once_cell4syncINtB5_8OnceCellNtNtCsg2DHIZY9C0C_5alloc6string6StringE3getCs2IPmB8bTu1k_22instrument_with_mutate:
  922|    143|        pub fn get(&self) -> Option<&T> {
  923|    143|            if self.0.is_initialized() {
  924|       |                // Safe b/c value is initialized.
  925|      0|                Some(unsafe { self.get_unchecked() })
  926|       |            } else {
  927|    143|                None
  928|       |            }
  929|    143|        }

_RINvXs0_NtNtCsP6cTLbJoEl_4rand13distributions7integerNtB8_8StandardINtNtB8_12distribution12DistributionmE6sampleNtNtNtBa_4rngs5small8SmallRngECs2IPmB8bTu1k_22instrument_with_mutate:
   37|    302|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u32 {
   38|    302|        rng.next_u32()
   39|    302|    }
_RINvXs1_NtNtCsP6cTLbJoEl_4rand13distributions7integerNtB8_8StandardINtNtB8_12distribution12DistributionyE6sampleNtNtNtBa_4rngs5small8SmallRngECs2IPmB8bTu1k_22instrument_with_mutate:
   44|    286|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u64 {
   45|    286|        rng.next_u64()
   46|    286|    }

_RNvXs4_NtNtCsP6cTLbJoEl_4rand13distributions7uniformINtNtNtCs23Pu7RYaif7_4core3ops5range5RangemEINtB5_11SampleRangemE8is_emptyCs2IPmB8bTu1k_22instrument_with_mutate:
  364|    143|    fn is_empty(&self) -> bool {
  365|    143|        !(self.start < self.end)
  366|    143|    }
_RNvXs2_NtNtCsP6cTLbJoEl_4rand13distributions7uniformmINtB5_12SampleBorrowmE6borrowCs2IPmB8bTu1k_22instrument_with_mutate:
  332|    572|    fn borrow(&self) -> &Borrowed {
  333|    572|        self
  334|    572|    }
_RINvXsB_NtNtCsP6cTLbJoEl_4rand13distributions7uniformINtB6_10UniformIntmENtB6_14UniformSampler13sample_singleNtNtNtBa_4rngs5small8SmallRngmmECs2IPmB8bTu1k_22instrument_with_mutate:
  507|    143|            fn sample_single<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Self::X
  508|    143|            where
  509|    143|                B1: SampleBorrow<Self::X> + Sized,
  510|    143|                B2: SampleBorrow<Self::X> + Sized,
  511|    143|            {
  512|    143|                let low = *low_b.borrow();
  513|    143|                let high = *high_b.borrow();
  514|    143|                assert!(low < high, "UniformSampler::sample_single: low >= high");
  515|    143|                Self::sample_single_inclusive(low, high - 1, rng)
  516|    143|            }
_RINvXsB_NtNtCsP6cTLbJoEl_4rand13distributions7uniformINtB6_10UniformIntmENtB6_14UniformSampler23sample_single_inclusiveNtNtNtBa_4rngs5small8SmallRngmmECs2IPmB8bTu1k_22instrument_with_mutate:
  519|    143|            fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Self::X
  520|    143|            where
  521|    143|                B1: SampleBorrow<Self::X> + Sized,
  522|    143|                B2: SampleBorrow<Self::X> + Sized,
  523|    143|            {
  524|    143|                let low = *low_b.borrow();
  525|    143|                let high = *high_b.borrow();
  526|    143|                assert!(low <= high, "UniformSampler::sample_single_inclusive: low > high");
  527|    143|                let range = high.wrapping_sub(low).wrapping_add(1) as $unsigned as $u_large;
  528|    143|                // If the above resulted in wrap-around to 0, the range is $ty::MIN..=$ty::MAX,
  529|    143|                // and any integer will do.
  530|    143|                if range == 0 {
  531|      0|                    return rng.gen();
  532|    143|                }
  533|       |
  534|    143|                let zone = if ::core::$unsigned::MAX <= ::core::u16::MAX as $unsigned {
  535|       |                    // Using a modulus is faster than the approximation for
  536|       |                    // i8 and i16. I suppose we trade the cost of one
  537|       |                    // modulus for near-perfect branch prediction.
  538|      0|                    let unsigned_max: $u_large = ::core::$u_large::MAX;
  539|      0|                    let ints_to_reject = (unsigned_max - range + 1) % range;
  540|      0|                    unsigned_max - ints_to_reject
  541|       |                } else {
  542|       |                    // conservative but fast approximation. `- 1` is necessary to allow the
  543|       |                    // same comparison without bias.
  544|    143|                    (range << range.leading_zeros()).wrapping_sub(1)
  545|       |                };
  546|       |
  547|    302|                loop {
  548|    302|                    let v: $u_large = rng.gen();
  549|    302|                    let (hi, lo) = v.wmul(range);
  550|    302|                    if lo <= zone {
  551|    143|                        return low.wrapping_add(hi as $ty);
  552|    159|                    }
  553|       |                }
  554|    143|            }
_RINvXs4_NtNtCsP6cTLbJoEl_4rand13distributions7uniformINtNtNtCs23Pu7RYaif7_4core3ops5range5RangemEINtB6_11SampleRangemE13sample_singleNtNtNtBa_4rngs5small8SmallRngECs2IPmB8bTu1k_22instrument_with_mutate:
  359|    143|    fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> T {
  360|    143|        T::Sampler::sample_single(self.start, self.end, rng)
  361|    143|    }

_RNvXs1_NtNtCsP6cTLbJoEl_4rand13distributions5utilsmNtB5_16WideningMultiply4wmul:
   26|    302|            fn wmul(self, x: $ty) -> Self::Output {
   27|    302|                let tmp = (self as $wide) * (x as $wide);
   28|    302|                ((tmp >> $shift) as $ty, tmp as $ty)
   29|    302|            }

_RINvYNtNtNtCsP6cTLbJoEl_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng3genmECs2IPmB8bTu1k_22instrument_with_mutate:
   93|    302|    fn gen<T>(&mut self) -> T
   94|    302|    where Standard: Distribution<T> {
   95|    302|        Standard.sample(self)
   96|    302|    }
_RINvYNtNtNtCsP6cTLbJoEl_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng9gen_rangemINtNtNtCs23Pu7RYaif7_4core3ops5range5RangemEECs2IPmB8bTu1k_22instrument_with_mutate:
  129|    143|    fn gen_range<T, R>(&mut self, range: R) -> T
  130|    143|    where
  131|    143|        T: SampleUniform,
  132|    143|        R: SampleRange<T>
  133|    143|    {
  134|    143|        assert!(!range.is_empty(), "cannot sample empty range");
  135|    143|        range.sample_single(self)
  136|    143|    }
_RINvYNtNtNtCsP6cTLbJoEl_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng3genyECs2IPmB8bTu1k_22instrument_with_mutate:
   93|    286|    fn gen<T>(&mut self) -> T
   94|    286|    where Standard: Distribution<T> {
   95|    286|        Standard.sample(self)
   96|    286|    }

_RNvXs_NtNtCsP6cTLbJoEl_4rand4rngs5smallNtB4_8SmallRngNtCsjaZ4UGpljng_9rand_core11SeedableRng9from_seed:
  109|    143|    fn from_seed(seed: Self::Seed) -> Self {
  110|    143|        SmallRng(Rng::from_seed(seed))
  111|    143|    }
_RNvXNtNtCsP6cTLbJoEl_4rand4rngs5smallNtB2_8SmallRngNtCsjaZ4UGpljng_9rand_core7RngCore8next_u64:
   90|    286|    fn next_u64(&mut self) -> u64 {
   91|    286|        self.0.next_u64()
   92|    286|    }
_RNvXNtNtCsP6cTLbJoEl_4rand4rngs5smallNtB2_8SmallRngNtCsjaZ4UGpljng_9rand_core7RngCore8next_u32:
   85|    302|    fn next_u32(&mut self) -> u32 {
   86|    302|        self.0.next_u32()
   87|    302|    }

_RNCNvXNtNtCsP6cTLbJoEl_4rand4rngs18xoshiro256plusplusNtB4_18Xoshiro256PlusPlusNtCsjaZ4UGpljng_9rand_core11SeedableRng9from_seed0Cs2IPmB8bTu1k_22instrument_with_mutate:
   35|    143|        if seed.iter().all(|&x| x == 0) {
_RNvXNtNtCsP6cTLbJoEl_4rand4rngs18xoshiro256plusplusNtB2_18Xoshiro256PlusPlusNtCsjaZ4UGpljng_9rand_core11SeedableRng9from_seed:
   34|    143|    fn from_seed(seed: [u8; 32]) -> Xoshiro256PlusPlus {
   35|    143|        if seed.iter().all(|&x| x == 0) {
   36|      0|            return Self::seed_from_u64(0);
   37|    143|        }
   38|    143|        let mut state = [0; 4];
   39|    143|        read_u64_into(&seed, &mut state);
   40|    143|        Xoshiro256PlusPlus { s: state }
   41|    143|    }
_RNvXs_NtNtCsP6cTLbJoEl_4rand4rngs18xoshiro256plusplusNtB4_18Xoshiro256PlusPlusNtCsjaZ4UGpljng_9rand_core7RngCore8next_u64:
   70|    588|    fn next_u64(&mut self) -> u64 {
   71|    588|        let result_plusplus = self.s[0]
   72|    588|            .wrapping_add(self.s[3])
   73|    588|            .rotate_left(23)
   74|    588|            .wrapping_add(self.s[0]);
   75|    588|
   76|    588|        let t = self.s[1] << 17;
   77|    588|
   78|    588|        self.s[2] ^= self.s[0];
   79|    588|        self.s[3] ^= self.s[1];
   80|    588|        self.s[1] ^= self.s[2];
   81|    588|        self.s[0] ^= self.s[3];
   82|    588|
   83|    588|        self.s[2] ^= t;
   84|    588|
   85|    588|        self.s[3] = self.s[3].rotate_left(45);
   86|    588|
   87|    588|        result_plusplus
   88|    588|    }
_RNvXs_NtNtCsP6cTLbJoEl_4rand4rngs18xoshiro256plusplusNtB4_18Xoshiro256PlusPlusNtCsjaZ4UGpljng_9rand_core7RngCore8next_u32:
   63|    302|    fn next_u32(&mut self) -> u32 {
   64|    302|        // The lowest bits have some linear dependencies, so we use the
   65|    302|        // upper bits instead.
   66|    302|        (self.next_u64() >> 32) as u32
   67|    302|    }

_RNvNtCsjaZ4UGpljng_9rand_core2le13read_u64_into:
   27|    143|pub fn read_u64_into(src: &[u8], dst: &mut [u64]) {
   28|    143|    assert!(src.len() >= 8 * dst.len());
   29|    572|    for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(8)) {
   30|    572|        *out = u64::from_le_bytes(chunk.try_into().unwrap());
   31|    572|    }
   32|    143|}

_RNvYNtNtNtCsP6cTLbJoEl_4rand4rngs5small8SmallRngNtCsjaZ4UGpljng_9rand_core11SeedableRng13seed_from_u64Cs2IPmB8bTu1k_22instrument_with_mutate:
  335|    143|    fn seed_from_u64(mut state: u64) -> Self {
  336|    143|        // We use PCG32 to generate a u32 sequence, and copy to the seed
  337|    143|        fn pcg32(state: &mut u64) -> [u8; 4] {
  338|    143|            const MUL: u64 = 6364136223846793005;
  339|    143|            const INC: u64 = 11634580027462260723;
  340|    143|
  341|    143|            // We advance the state first (to get away from the input value,
  342|    143|            // in case it has low Hamming Weight).
  343|    143|            *state = state.wrapping_mul(MUL).wrapping_add(INC);
  344|    143|            let state = *state;
  345|    143|
  346|    143|            // Use PCG output function with to_le to generate x:
  347|    143|            let xorshifted = (((state >> 18) ^ state) >> 27) as u32;
  348|    143|            let rot = (state >> 59) as u32;
  349|    143|            let x = xorshifted.rotate_right(rot);
  350|    143|            x.to_le_bytes()
  351|    143|        }
  352|    143|
  353|    143|        let mut seed = Self::Seed::default();
  354|    143|        let mut iter = seed.as_mut().chunks_exact_mut(4);
  355|  1.28k|        for chunk in &mut iter {
  356|  1.14k|            chunk.copy_from_slice(&pcg32(&mut state));
  357|  1.14k|        }
  358|    143|        let rem = iter.into_remainder();
  359|    143|        if !rem.is_empty() {
  360|      0|            rem.copy_from_slice(&pcg32(&mut state)[..rem.len()]);
  361|    143|        }
  362|       |
  363|    143|        Self::from_seed(seed)
  364|    143|    }
_RNvNvNtCsjaZ4UGpljng_9rand_core11SeedableRng13seed_from_u645pcg32:
  337|  1.14k|        fn pcg32(state: &mut u64) -> [u8; 4] {
  338|  1.14k|            const MUL: u64 = 6364136223846793005;
  339|  1.14k|            const INC: u64 = 11634580027462260723;
  340|  1.14k|
  341|  1.14k|            // We advance the state first (to get away from the input value,
  342|  1.14k|            // in case it has low Hamming Weight).
  343|  1.14k|            *state = state.wrapping_mul(MUL).wrapping_add(INC);
  344|  1.14k|            let state = *state;
  345|  1.14k|
  346|  1.14k|            // Use PCG output function with to_le to generate x:
  347|  1.14k|            let xorshifted = (((state >> 18) ^ state) >> 27) as u32;
  348|  1.14k|            let rot = (state >> 59) as u32;
  349|  1.14k|            let x = xorshifted.rotate_right(rot);
  350|  1.14k|            x.to_le_bytes()
  351|  1.14k|        }

_RNvXsL_Cs8FC0zPCsnJs_9termcolorNtB5_9ColorSpecNtNtCs23Pu7RYaif7_4core5clone5Clone5clone:
 1579|  2.00k|#[derive(Clone, Debug, Eq, PartialEq)]
_RNvXsl_Cs8FC0zPCsnJs_9termcolorNtB5_6BufferNtB5_10WriteColor9set_color:
 1172|  3.00k|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
 1173|  3.00k|        match self.0 {
 1174|  3.00k|            BufferInner::NoColor(ref mut w) => w.set_color(spec),
 1175|      0|            BufferInner::Ansi(ref mut w) => w.set_color(spec),
 1176|       |            #[cfg(windows)]
 1177|       |            BufferInner::Windows(ref mut w) => w.set_color(spec),
 1178|       |        }
 1179|  3.00k|    }
_RNvXso_Cs8FC0zPCsnJs_9termcolorINtB5_7NoColorINtNtCsg2DHIZY9C0C_5alloc3vec3VechEENtB5_10WriteColor9set_colorCsdsqPvVuyxCm_10env_logger:
 1242|  3.00k|    fn set_color(&mut self, _: &ColorSpec) -> io::Result<()> {
 1243|  3.00k|        Ok(())
 1244|  3.00k|    }
_RNvXsk_Cs8FC0zPCsnJs_9termcolorNtB5_6BufferNtNtCs8hfS0qQwSL8_3std2io5Write5write:
 1140|  19.3k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1141|  19.3k|        match self.0 {
 1142|  19.3k|            BufferInner::NoColor(ref mut w) => w.write(buf),
 1143|      0|            BufferInner::Ansi(ref mut w) => w.write(buf),
 1144|       |            #[cfg(windows)]
 1145|       |            BufferInner::Windows(ref mut w) => w.write(buf),
 1146|       |        }
 1147|  19.3k|    }
_RNvXsR_Cs8FC0zPCsnJs_9termcolorNtB5_5ColorNtNtCs23Pu7RYaif7_4core5clone5Clone5clone:
 1805|  2.00k|#[derive(Clone, Copy, Debug, Eq, PartialEq)]
_RNvXso_Cs8FC0zPCsnJs_9termcolorINtB5_7NoColorINtNtCsg2DHIZY9C0C_5alloc3vec3VechEENtB5_10WriteColor5resetCsdsqPvVuyxCm_10env_logger:
 1247|  3.00k|    fn reset(&mut self) -> io::Result<()> {
 1248|  3.00k|        Ok(())
 1249|  3.00k|    }
_RNvXsn_Cs8FC0zPCsnJs_9termcolorINtB5_7NoColorINtNtCsg2DHIZY9C0C_5alloc3vec3VechEENtNtCs8hfS0qQwSL8_3std2io5Write5writeCsdsqPvVuyxCm_10env_logger:
 1225|  19.3k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1226|  19.3k|        self.0.write(buf)
 1227|  19.3k|    }
_RNvXsl_Cs8FC0zPCsnJs_9termcolorNtB5_6BufferNtB5_10WriteColor5reset:
 1182|  3.00k|    fn reset(&mut self) -> io::Result<()> {
 1183|  3.00k|        match self.0 {
 1184|  3.00k|            BufferInner::NoColor(ref mut w) => w.reset(),
 1185|      0|            BufferInner::Ansi(ref mut w) => w.reset(),
 1186|       |            #[cfg(windows)]
 1187|       |            BufferInner::Windows(ref mut w) => w.reset(),
 1188|       |        }
 1189|  3.00k|    }
_RNvMsv_Cs8FC0zPCsnJs_9termcolorNtB5_9ColorSpec3new:
 1608|  3.00k|    pub fn new() -> ColorSpec {
 1609|  3.00k|        ColorSpec::default()
 1610|  3.00k|    }
_RNvMsj_Cs8FC0zPCsnJs_9termcolorNtB5_6Buffer3len:
 1085|  1.00k|    pub fn len(&self) -> usize {
 1086|  1.00k|        match self.0 {
 1087|  1.00k|            BufferInner::NoColor(ref b) => b.0.len(),
 1088|      0|            BufferInner::Ansi(ref b) => b.0.len(),
 1089|       |            #[cfg(windows)]
 1090|       |            BufferInner::Windows(ref b) => b.buf.len(),
 1091|       |        }
 1092|  1.00k|    }
_RNvMsi_Cs8FC0zPCsnJs_9termcolorNtB5_12BufferWriter5print:
  974|  1.00k|    pub fn print(&self, buf: &Buffer) -> io::Result<()> {
  975|  1.00k|        if buf.is_empty() {
  976|      0|            return Ok(());
  977|  1.00k|        }
  978|  1.00k|        let mut stream = self.stream.wrap(self.stream.get_ref().lock());
  979|  1.00k|        if let Some(ref sep) = self.separator {
  980|      0|            if self.printed.load(Ordering::SeqCst) {
  981|      0|                stream.write_all(sep)?;
  982|      0|                stream.write_all(b"\n")?;
  983|      0|            }
  984|  1.00k|        }
  985|  1.00k|        match buf.0 {
  986|  1.00k|            BufferInner::NoColor(ref b) => stream.write_all(&b.0)?,
  987|      0|            BufferInner::Ansi(ref b) => stream.write_all(&b.0)?,
  988|       |            #[cfg(windows)]
  989|       |            BufferInner::Windows(ref b) => {
  990|       |                // We guarantee by construction that we have a console here.
  991|       |                // Namely, a BufferWriter is the only way to produce a Buffer.
  992|       |                let console_mutex = self
  993|       |                    .console
  994|       |                    .as_ref()
  995|       |                    .expect("got Windows buffer but have no Console");
  996|       |                let mut console = console_mutex.lock().unwrap();
  997|       |                b.print(&mut *console, &mut stream)?;
  998|       |            }
  999|       |        }
 1000|  1.00k|        self.printed.store(true, Ordering::SeqCst);
 1001|  1.00k|        Ok(())
 1002|  1.00k|    }
_RNvMsj_Cs8FC0zPCsnJs_9termcolorNtB5_6Buffer8is_empty:
 1080|  1.00k|    pub fn is_empty(&self) -> bool {
 1081|  1.00k|        self.len() == 0
 1082|  1.00k|    }
_RNvMsi_Cs8FC0zPCsnJs_9termcolorNtB5_12BufferWriter6buffer:
  956|      1|    pub fn buffer(&self) -> Buffer {
  957|      1|        Buffer::new(self.color_choice)
  958|      1|    }
_RINvMsB_Cs8FC0zPCsnJs_9termcolorINtB6_19LossyStandardStreamNtB6_16IoStandardStreamE4wrapNtB6_20IoStandardStreamLockEB6_:
 2022|  1.00k|    fn wrap<Q: io::Write>(&self, wtr: Q) -> LossyStandardStream<Q> {
 2023|  1.00k|        LossyStandardStream::new(wtr)
 2024|  1.00k|    }
_RNvMsv_Cs8FC0zPCsnJs_9termcolorNtB5_9ColorSpec11set_intense:
 1741|  2.00k|    pub fn set_intense(&mut self, yes: bool) -> &mut ColorSpec {
 1742|  2.00k|        self.intense = yes;
 1743|  2.00k|        self
 1744|  2.00k|    }
_RNvMs1_Cs8FC0zPCsnJs_9termcolorNtB5_16IoStandardStream4lock:
  332|  1.00k|    fn lock(&self) -> IoStandardStreamLock<'_> {
  333|  1.00k|        match *self {
  334|      0|            IoStandardStream::Stdout(ref s) => {
  335|      0|                IoStandardStreamLock::StdoutLock(s.lock())
  336|       |            }
  337|  1.00k|            IoStandardStream::Stderr(ref s) => {
  338|  1.00k|                IoStandardStreamLock::StderrLock(s.lock())
  339|       |            }
  340|       |            IoStandardStream::StdoutBuffered(_)
  341|       |            | IoStandardStream::StderrBuffered(_) => {
  342|       |                // We don't permit this case to ever occur in the public API,
  343|       |                // so it's OK to panic.
  344|      0|                panic!("cannot lock a buffered standard stream")
  345|       |            }
  346|       |        }
  347|  1.00k|    }
_RNvXs3_Cs8FC0zPCsnJs_9termcolorNtB5_20IoStandardStreamLockNtNtCs8hfS0qQwSL8_3std2io5Write5write:
  381|  1.00k|    fn write(&mut self, b: &[u8]) -> io::Result<usize> {
  382|  1.00k|        match *self {
  383|      0|            IoStandardStreamLock::StdoutLock(ref mut s) => s.write(b),
  384|  1.00k|            IoStandardStreamLock::StderrLock(ref mut s) => s.write(b),
  385|       |        }
  386|  1.00k|    }
_RNvXsu_Cs8FC0zPCsnJs_9termcolorNtB5_9ColorSpecNtNtCs23Pu7RYaif7_4core7default7Default7default:
 1592|  3.00k|    fn default() -> ColorSpec {
 1593|  3.00k|        ColorSpec {
 1594|  3.00k|            fg_color: None,
 1595|  3.00k|            bg_color: None,
 1596|  3.00k|            bold: false,
 1597|  3.00k|            intense: false,
 1598|  3.00k|            underline: false,
 1599|  3.00k|            dimmed: false,
 1600|  3.00k|            italic: false,
 1601|  3.00k|            reset: true,
 1602|  3.00k|        }
 1603|  3.00k|    }
_RNvMs1_Cs8FC0zPCsnJs_9termcolorNtB5_16IoStandardStream3new:
  313|    143|    fn new(sty: StandardStreamType) -> IoStandardStream {
  314|    143|        match sty {
  315|       |            StandardStreamType::Stdout => {
  316|      0|                IoStandardStream::Stdout(io::stdout())
  317|       |            }
  318|       |            StandardStreamType::Stderr => {
  319|    143|                IoStandardStream::Stderr(io::stderr())
  320|       |            }
  321|       |            StandardStreamType::StdoutBuffered => {
  322|      0|                let wtr = io::BufWriter::new(io::stdout());
  323|      0|                IoStandardStream::StdoutBuffered(wtr)
  324|       |            }
  325|       |            StandardStreamType::StderrBuffered => {
  326|      0|                let wtr = io::BufWriter::new(io::stderr());
  327|      0|                IoStandardStream::StderrBuffered(wtr)
  328|       |            }
  329|       |        }
  330|    143|    }
_RNvMs0_Cs8FC0zPCsnJs_9termcolorNtB5_11ColorChoice20should_attempt_color:
  224|      1|    fn should_attempt_color(&self) -> bool {
  225|      1|        match *self {
  226|      0|            ColorChoice::Always => true,
  227|      0|            ColorChoice::AlwaysAnsi => true,
  228|      1|            ColorChoice::Never => false,
  229|      0|            ColorChoice::Auto => self.env_allows_color(),
  230|       |        }
  231|      1|    }
_RNvMsj_Cs8FC0zPCsnJs_9termcolorNtB5_6Buffer8no_color:
 1064|      1|    pub fn no_color() -> Buffer {
 1065|      1|        Buffer(BufferInner::NoColor(NoColor(vec![])))
 1066|      1|    }
_RNvMsi_Cs8FC0zPCsnJs_9termcolorNtB5_12BufferWriter6stderr:
  939|    143|    pub fn stderr(choice: ColorChoice) -> BufferWriter {
  940|    143|        BufferWriter::create(StandardStreamType::Stderr, choice)
  941|    143|    }
_RNvMsB_Cs8FC0zPCsnJs_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockE3newB5_:
 2010|  1.00k|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|  1.00k|        LossyStandardStream { wtr: wtr }
 2012|  1.00k|    }
_RNvMsj_Cs8FC0zPCsnJs_9termcolorNtB5_6Buffer3new:
 1035|      1|    fn new(choice: ColorChoice) -> Buffer {
 1036|      1|        if choice.should_attempt_color() {
 1037|      0|            Buffer::ansi()
 1038|       |        } else {
 1039|      1|            Buffer::no_color()
 1040|       |        }
 1041|      1|    }
_RNvXsD_Cs8FC0zPCsnJs_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockENtNtCs8hfS0qQwSL8_3std2io5Write5writeB5_:
 2053|  1.00k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 2054|  1.00k|        self.wtr.write(buf)
 2055|  1.00k|    }
_RNvMsi_Cs8FC0zPCsnJs_9termcolorNtB5_12BufferWriter6create:
  874|    143|    fn create(sty: StandardStreamType, choice: ColorChoice) -> BufferWriter {
  875|    143|        BufferWriter {
  876|    143|            stream: LossyStandardStream::new(IoStandardStream::new(sty)),
  877|    143|            printed: AtomicBool::new(false),
  878|    143|            separator: None,
  879|    143|            color_choice: choice,
  880|    143|        }
  881|    143|    }
_RNvMsB_Cs8FC0zPCsnJs_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE7get_refB5_:
 2031|  1.00k|    fn get_ref(&self) -> &W {
 2032|  1.00k|        &self.wtr
 2033|  1.00k|    }
_RNvMsj_Cs8FC0zPCsnJs_9termcolorNtB5_6Buffer5clear:
 1095|  1.00k|    pub fn clear(&mut self) {
 1096|  1.00k|        match self.0 {
 1097|  1.00k|            BufferInner::NoColor(ref mut b) => b.0.clear(),
 1098|      0|            BufferInner::Ansi(ref mut b) => b.0.clear(),
 1099|       |            #[cfg(windows)]
 1100|       |            BufferInner::Windows(ref mut b) => b.clear(),
 1101|       |        }
 1102|  1.00k|    }
_RNvMsv_Cs8FC0zPCsnJs_9termcolorNtB5_9ColorSpec6set_fg:
 1618|  3.00k|    pub fn set_fg(&mut self, color: Option<Color>) -> &mut ColorSpec {
 1619|  3.00k|        self.fg_color = color;
 1620|  3.00k|        self
 1621|  3.00k|    }
_RNvMsB_Cs8FC0zPCsnJs_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE3newB5_:
 2010|    143|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|    143|        LossyStandardStream { wtr: wtr }
 2012|    143|    }

_RNvNvNvXs0_CsdsqPvVuyxCm_10env_loggerNtB9_6LoggerNtCsfMHHUF7r9BK_3log3Log3log9FORMATTER7___getit:
  319|  1.00k|            unsafe fn __getit(
  320|  1.00k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|  1.00k|            ) -> $crate::option::Option<&'static $t> {
  322|  1.00k|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|  1.00k|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|  1.00k|                    $crate::thread::__StaticLocalKeyInner::new();
  325|  1.00k|
  326|  1.00k|                #[thread_local]
  327|  1.00k|                #[cfg(all(
  328|  1.00k|                    target_thread_local,
  329|  1.00k|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|  1.00k|                ))]
  331|  1.00k|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|  1.00k|                    $crate::thread::__FastLocalKeyInner::new();
  333|  1.00k|
  334|  1.00k|                #[cfg(all(
  335|  1.00k|                    not(target_thread_local),
  336|  1.00k|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|  1.00k|                ))]
  338|  1.00k|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|  1.00k|                    $crate::thread::__OsLocalKeyInner::new();
  340|  1.00k|
  341|  1.00k|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|  1.00k|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|  1.00k|                // See https://github.com/rust-lang/rust/issues/74838.
  344|  1.00k|                #[allow(unused_unsafe)]
  345|  1.00k|                unsafe {
  346|  1.00k|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|  1.00k|                    })
  356|  1.00k|                }
  357|  1.00k|            }
_RNvNvNvXs0_CsdsqPvVuyxCm_10env_loggerNtB9_6LoggerNtCsfMHHUF7r9BK_3log3Log3log9FORMATTER6___init:
  294|      1|            fn __init() -> $t { $init }

_RINvCs1dKyaqKDWqM_8fvm_fuzz15stack_mutationsNCNvNvCs2IPmB8bTu1k_22instrument_with_mutate1__3run0EBM_:
   96|    143|pub fn stack_mutations<'a>(
   97|    143|    bin: Vec<u8>,
   98|    143|    raw: &mut Unstructured<'a>,
   99|    143|    mut action: impl FnMut(Vec<u8>, u64, u32, u32),
  100|    143|    max_stacked_mutations: u32,
  101|    143|    max_siblings_exploration: u32,
  102|    143|) -> Vec<u8> {
  103|    143|    let preseed: u64 = raw.arbitrary().unwrap();
  104|    143|    let mut rng = SmallRng::seed_from_u64(preseed);
  105|    143|    let mut cp = bin;
  106|    143|
  107|    143|    log::debug!("Preseed {:?}", preseed);
  108|    143|    let stacked_mutations: u32 = rng.gen_range(1..max_stacked_mutations);
  109|    143|    log::debug!("stacked_mutations: {}", stacked_mutations);
  110|       |
  111|    286|    for i in 0..=stacked_mutations {
  112|    286|        let seed = rng.gen();
  113|    286|        let mut wasm_mutate = Box::<wasm_mutate::WasmMutate<'_>>::default();
  114|    286|        wasm_mutate.seed(seed);
  115|    286|        log::debug!("Seed: {}", seed);
  116|    286|        wasm_mutate.preserve_semantics(true);
  117|    286|
  118|    286|        // TODO, set fuel as a parameter of the fuzzer, lets the fuzzer to determine if more fuel is needed
  119|    286|        wasm_mutate.fuel(500);
  120|    286|        let tomutate = cp.clone();
  121|    286|        let mut_iterator = wasm_mutate.run(&tomutate);
  122|    286|
  123|    286|        match mut_iterator {
  124|      0|            Ok(mut it) => {
  125|      0|                // lateral traversing
  126|      0|                let check_siblings: u32 = rng.gen_range(1..max_siblings_exploration);
  127|      0|                log::debug!("check_siblings: {}", check_siblings);
  128|      0|                for j in 0..=check_siblings {
  129|      0|                    let mutated_bin = it.next();
  130|       |
  131|      0|                    if let Some(mutated_bin) = mutated_bin {
  132|      0|                        match mutated_bin {
  133|      0|                            Ok(mutated_bin) => {
  134|      0|                                action(mutated_bin.clone(), seed, i, j);
  135|      0|                                swap(&mut cp, mutated_bin);
  136|      0|                            }
  137|      0|                            Err(e) => {
  138|      0|                                // Do nothing
  139|      0|                                log::debug!("Error: {:?}", e);
  140|       |                            }
  141|       |                        }
  142|      0|                    }
  143|       |                }
  144|       |            }
  145|    286|            Err(e) => {
  146|    286|                // do nothing continue
  147|    286|                log::debug!("Error: {:?}", e);
  148|       |            }
  149|       |        }
  150|       |    }
  151|    143|    cp
  152|    143|}
_RNvCs1dKyaqKDWqM_8fvm_fuzz18get_random_fixture:
  169|    143|pub fn get_random_fixture<'a>(raw: &mut Unstructured<'a>) -> AResult<(Vec<u8>, PathBuf)> {
  170|    143|    let files = get_wasm_dir()
  171|    143|        .read_dir()
  172|    143|        .unwrap()
  173|    143|        .into_iter()
  174|    143|        .map(|r| r.unwrap())
  175|    143|        .collect::<Vec<_>>();
  176|       |
  177|    143|    let idx = raw.choose_index(files.len())?;
  178|    143|    let random_file = files[idx].path();
  179|    143|    log::debug!("Random fixture: {:?}", random_file);
  180|       |
  181|    143|    let bytes = std::fs::read(&random_file)?;
  182|       |
  183|    143|    Ok((bytes, random_file))
  184|    143|}
_RNCNvCs1dKyaqKDWqM_8fvm_fuzz18get_random_fixture0B3_:
  174|  27.7k|        .map(|r| r.unwrap())
_RNvCs1dKyaqKDWqM_8fvm_fuzz12get_wasm_dir:
  154|    143|fn get_wasm_dir() -> PathBuf {
  155|    143|    match env::var("OUT") {
  156|    143|        Ok(out) => {
  157|    143|            let path: PathBuf = out.into();
  158|    143|            path
  159|       |        }
  160|      0|        Err(e) => {
  161|      0|            log::debug!("Error {:?}", e);
  162|       |            // gracefully exit
  163|      0|            std::process::exit(0)
  164|       |        }
  165|       |    }
  166|    143|}

_RNvXs7_NtCshXjMhLniWvt_11wasm_mutate5errorNtB5_9ErrorKindNtNtCs23Pu7RYaif7_4core3fmt5Debug3fmt:
   60|    286|#[derive(thiserror::Error, Debug)]
_RNvXs3_NtCshXjMhLniWvt_11wasm_mutate5errorNtB5_5ErrorNtNtCs23Pu7RYaif7_4core3fmt5Debug3fmt:
    2|    286|#[derive(thiserror::Error, Debug)]
_RNvXs_NtCshXjMhLniWvt_11wasm_mutate5errorNtB4_5ErrorINtNtCs23Pu7RYaif7_4core7convert4FromNtB4_9ErrorKindE4from:
   46|    286|    fn from(kind: ErrorKind) -> Self {
   47|    286|        Error {
   48|    286|            kind: Box::new(kind),
   49|    286|        }
   50|    286|    }
_RNvXs0_NtCshXjMhLniWvt_11wasm_mutate5errorNtB5_5ErrorINtNtCs23Pu7RYaif7_4core7convert4FromNtNtCsdSXEL0kkvTs_10wasmparser13binary_reader17BinaryReaderErrorE4from:
   54|    286|    fn from(e: wasmparser::BinaryReaderError) -> Self {
   55|    286|        ErrorKind::Parse(e).into()
   56|    286|    }

_RNvMNtCshXjMhLniWvt_11wasm_mutate4infoNtB2_10ModuleInfo3new:
   63|    286|    pub fn new(input_wasm: &[u8]) -> Result<ModuleInfo> {
   64|    286|        let mut parser = Parser::new(0);
   65|    286|        let mut info = ModuleInfo::default();
   66|    286|        let mut wasm = input_wasm;
   67|    286|        info.input_wasm = wasm;
   68|       |
   69|       |        loop {
   70|    286|            let (payload, consumed) = match parser.parse(wasm, true)? {
   71|      0|                Chunk::NeedMoreData(hint) => {
   72|      0|                    panic!("Invalid Wasm module {:?}", hint);
   73|       |                }
   74|      0|                Chunk::Parsed { consumed, payload } => (payload, consumed),
   75|      0|            };
   76|      0|            match payload {
   77|       |                Payload::CodeSectionStart {
   78|       |                    count: _,
   79|      0|                    range,
   80|      0|                    size: _,
   81|      0|                } => {
   82|      0|                    info.code = Some(info.raw_sections.len());
   83|      0|                    info.section(SectionId::Code.into(), range.clone(), input_wasm);
   84|      0|                    parser.skip_section();
   85|      0|                    // update slice, bypass the section
   86|      0|                    wasm = &input_wasm[range.end..];
   87|      0|
   88|      0|                    continue;
   89|       |                }
   90|      0|                Payload::TypeSection(mut reader) => {
   91|      0|                    info.types = Some(info.raw_sections.len());
   92|      0|                    info.section(SectionId::Type.into(), reader.range(), input_wasm);
   93|      0|
   94|      0|                    // Save function types
   95|      0|                    for _ in 0..reader.get_count() {
   96|      0|                        reader.read().map(|ty| {
   97|       |                            let typeinfo = TypeInfo::try_from(ty).unwrap();
   98|       |                            info.types_map.push(typeinfo);
   99|      0|                        })?;
  100|       |                    }
  101|       |                }
  102|      0|                Payload::ImportSection(mut reader) => {
  103|      0|                    info.imports = Some(info.raw_sections.len());
  104|      0|                    info.section(SectionId::Import.into(), reader.range(), input_wasm);
  105|      0|
  106|      0|                    for _ in 0..reader.get_count() {
  107|      0|                        let ty = reader.read()?;
  108|      0|                        match ty.ty {
  109|      0|                            wasmparser::TypeRef::Func(ty) => {
  110|      0|                                // Save imported functions
  111|      0|                                info.function_map.push(ty);
  112|      0|                                info.imported_functions_count += 1;
  113|      0|                            }
  114|      0|                            wasmparser::TypeRef::Global(ty) => {
  115|      0|                                let ty = PrimitiveTypeInfo::try_from(ty.content_type).unwrap();
  116|      0|                                info.global_types.push(ty);
  117|      0|                                info.imported_globals_count += 1;
  118|      0|                            }
  119|      0|                            wasmparser::TypeRef::Memory(ty) => {
  120|      0|                                info.memory_count += 1;
  121|      0|                                info.imported_memories_count += 1;
  122|      0|                                info.memory_types.push(ty);
  123|      0|                            }
  124|      0|                            wasmparser::TypeRef::Table(ty) => {
  125|      0|                                info.table_count += 1;
  126|      0|                                info.imported_tables_count += 1;
  127|      0|                                info.table_elem_types.push(ty.element_type.into());
  128|      0|                            }
  129|      0|                            wasmparser::TypeRef::Tag(_ty) => {
  130|      0|                                info.tag_count += 1;
  131|      0|                                info.imported_tags_count += 1;
  132|      0|                            }
  133|       |                        }
  134|       |                    }
  135|       |                }
  136|      0|                Payload::FunctionSection(mut reader) => {
  137|      0|                    info.functions = Some(info.raw_sections.len());
  138|      0|                    info.section(SectionId::Function.into(), reader.range(), input_wasm);
  139|      0|
  140|      0|                    for _ in 0..reader.get_count() {
  141|      0|                        reader.read().map(|ty| {
  142|       |                            info.function_map.push(ty);
  143|      0|                        })?;
  144|       |                    }
  145|       |                }
  146|      0|                Payload::TableSection(mut reader) => {
  147|      0|                    info.tables = Some(info.raw_sections.len());
  148|      0|                    info.table_count += reader.get_count();
  149|      0|                    info.section(SectionId::Table.into(), reader.range(), input_wasm);
  150|      0|
  151|      0|                    for _ in 0..reader.get_count() {
  152|      0|                        let ty = reader.read()?;
  153|      0|                        let ty = PrimitiveTypeInfo::try_from(ty.element_type).unwrap();
  154|      0|                        info.table_elem_types.push(ty);
  155|       |                    }
  156|       |                }
  157|      0|                Payload::MemorySection(mut reader) => {
  158|      0|                    info.memories = Some(info.raw_sections.len());
  159|      0|                    info.memory_count += reader.get_count();
  160|      0|                    info.section(SectionId::Memory.into(), reader.range(), input_wasm);
  161|      0|
  162|      0|                    for _ in 0..reader.get_count() {
  163|      0|                        let ty = reader.read()?;
  164|      0|                        info.memory_types.push(ty);
  165|       |                    }
  166|       |                }
  167|      0|                Payload::GlobalSection(mut reader) => {
  168|      0|                    info.globals = Some(info.raw_sections.len());
  169|      0|                    info.section(SectionId::Global.into(), reader.range(), input_wasm);
  170|      0|
  171|      0|                    for _ in 0..reader.get_count() {
  172|      0|                        let ty = reader.read()?;
  173|       |                        // We only need the type of the global, not necessarily if is mutable or not
  174|      0|                        let ty = PrimitiveTypeInfo::try_from(ty.ty.content_type).unwrap();
  175|      0|                        info.global_types.push(ty);
  176|       |                    }
  177|       |                }
  178|      0|                Payload::ExportSection(mut reader) => {
  179|      0|                    info.exports = Some(info.raw_sections.len());
  180|      0|                    info.exports_count = reader.get_count();
  181|      0|
  182|      0|                    for _ in 0..reader.get_count() {
  183|      0|                        let entry = reader.read()?;
  184|      0|                        info.export_names.insert(entry.name.into());
  185|       |                    }
  186|       |
  187|      0|                    info.section(SectionId::Export.into(), reader.range(), input_wasm);
  188|       |                }
  189|      0|                Payload::StartSection { func, range } => {
  190|      0|                    info.start = Some(info.raw_sections.len());
  191|      0|                    info.start_function = Some(func);
  192|      0|                    info.section(SectionId::Start.into(), range, input_wasm);
  193|      0|                }
  194|      0|                Payload::ElementSection(reader) => {
  195|      0|                    info.elements = Some(info.raw_sections.len());
  196|      0|                    info.elements_count = reader.get_count();
  197|      0|                    info.section(SectionId::Element.into(), reader.range(), input_wasm);
  198|      0|                }
  199|      0|                Payload::DataSection(reader) => {
  200|      0|                    info.data = Some(info.raw_sections.len());
  201|      0|                    info.data_segments_count = reader.get_count();
  202|      0|                    info.section(SectionId::Data.into(), reader.range(), input_wasm);
  203|      0|                }
  204|      0|                Payload::CustomSection(c) => {
  205|      0|                    info.section(SectionId::Custom.into(), c.range(), input_wasm);
  206|      0|                }
  207|       |                Payload::UnknownSection {
  208|      0|                    id,
  209|      0|                    contents: _,
  210|      0|                    range,
  211|      0|                } => {
  212|      0|                    info.section(id, range, input_wasm);
  213|      0|                }
  214|      0|                Payload::DataCountSection { count: _, range } => {
  215|      0|                    info.data_count = Some(info.raw_sections.len());
  216|      0|                    info.section(SectionId::DataCount.into(), range, input_wasm);
  217|      0|                }
  218|      0|                Payload::Version { .. } => {}
  219|       |                Payload::End(_) => {
  220|      0|                    break;
  221|       |                }
  222|      0|                _ => todo!("{:?} not implemented", payload),
  223|       |            }
  224|      0|            wasm = &wasm[consumed..];
  225|       |        }
  226|       |
  227|      0|        Ok(info)
  228|    286|    }
_RNvXs_NtCshXjMhLniWvt_11wasm_mutate4infoNtB4_10ModuleInfoNtNtCs23Pu7RYaif7_4core7default7Default7default:
   13|    286|#[derive(Default, Clone, Debug)]

_RNvMs_CshXjMhLniWvt_11wasm_mutateNtB4_10WasmMutate18preserve_semantics:
  225|    286|    pub fn preserve_semantics(&mut self, preserve_semantics: bool) -> &mut Self {
  226|    286|        self.preserve_semantics = preserve_semantics;
  227|    286|        self
  228|    286|    }
_RNvMs_CshXjMhLniWvt_11wasm_mutateNtB4_10WasmMutate5setup:
  325|    286|    fn setup(&mut self, input_wasm: &'wasm [u8]) -> Result<()> {
  326|    286|        self.info = Some(ModuleInfo::new(input_wasm)?);
  327|      0|        self.rng = Some(SmallRng::seed_from_u64(self.seed));
  328|      0|        Ok(())
  329|    286|    }
_RNvMs_CshXjMhLniWvt_11wasm_mutateNtB4_10WasmMutate3run:
  280|    286|        self.setup(input_wasm)?;
  281|       |
  282|       |        // This macro just expands the logic to return an iterator form the
  283|       |        // mutators
  284|       |        // It simulates a circular checking of the mutators starting by a random
  285|       |        // one, returning the first one that can provides a mutation.
  286|       |        // All possible start indexes are calculated at compilation time, if N
  287|       |        // is the number of mutataros, N possible starting indexes are injected
  288|       |        // and compiled to the final code
  289|      0|        define_mutators!(
  290|       |            self,
  291|       |            (
  292|      0|                PeepholeMutator::new(2),
  293|      0|                RemoveExportMutator,
  294|      0|                RenameExportMutator { max_name_size: 100 },
  295|      0|                SnipMutator,
  296|      0|                CodemotionMutator,
  297|      0|                FunctionBodyUnreachable,
  298|      0|                AddTypeMutator {
  299|      0|                    max_params: 20,
  300|      0|                    max_results: 20,
  301|      0|                },
  302|      0|                AddFunctionMutator,
  303|      0|                RemoveSection::Custom,
  304|      0|                RemoveSection::Empty,
  305|      0|                ConstExpressionMutator::Global,
  306|      0|                ConstExpressionMutator::ElementOffset,
  307|      0|                ConstExpressionMutator::ElementFunc,
  308|      0|                RemoveItemMutator(Item::Function),
  309|      0|                RemoveItemMutator(Item::Global),
  310|      0|                RemoveItemMutator(Item::Memory),
  311|      0|                RemoveItemMutator(Item::Table),
  312|      0|                RemoveItemMutator(Item::Type),
  313|      0|                RemoveItemMutator(Item::Data),
  314|      0|                RemoveItemMutator(Item::Element),
  315|      0|                RemoveItemMutator(Item::Tag),
  316|       |                ModifyDataMutator {
  317|      0|                    max_data_size: 10 << 20, // 10MB
  318|       |                },
  319|       |            )
  320|       |        );
  321|       |
  322|      0|        Err(Error::no_mutations_applicable())
  323|    286|    }
_RNvMs_CshXjMhLniWvt_11wasm_mutateNtB4_10WasmMutate4fuel:
  231|    286|    pub fn fuel(&mut self, fuel: u64) -> &mut Self {
  232|    286|        self.fuel = fuel;
  233|    286|        self
  234|    286|    }
_RNvXCshXjMhLniWvt_11wasm_mutateNtB2_10WasmMutateNtNtCs23Pu7RYaif7_4core7default7Default7default:
  199|    286|    fn default() -> Self {
  200|    286|        let seed = 3;
  201|    286|        WasmMutate {
  202|    286|            seed,
  203|    286|            preserve_semantics: false,
  204|    286|            reduce: false,
  205|    286|            raw_mutate_func: None,
  206|    286|            fuel: u64::MAX,
  207|    286|            rng: None,
  208|    286|            info: None,
  209|    286|        }
  210|    286|    }
_RNvMs_CshXjMhLniWvt_11wasm_mutateNtB4_10WasmMutate4seed:
  218|    286|    pub fn seed(&mut self, seed: u64) -> &mut Self {
  219|    286|        self.seed = seed;
  220|    286|        self
  221|    286|    }

_RNvMs1_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB5_12BinaryReader19read_header_version:
 2139|    286|    pub(crate) fn read_header_version(&mut self) -> Result<u32> {
 2140|    286|        let magic_number = self.read_bytes(4)?;
 2141|    276|        if magic_number != WASM_MAGIC_NUMBER {
 2142|    276|            return Err(BinaryReaderError::new(
 2143|    276|                "magic header not detected: bad magic number",
 2144|    276|                self.original_position() - 4,
 2145|    276|            ));
 2146|      0|        }
 2147|      0|        self.read_u32()
 2148|    286|    }
_RNvMs0_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB5_17BinaryReaderError3eof:
   83|     10|    pub(crate) fn eof(offset: usize, needed_hint: usize) -> Self {
   84|     10|        BinaryReaderError {
   85|     10|            inner: Box::new(BinaryReaderErrorInner {
   86|     10|                message: "unexpected end-of-file".to_string(),
   87|     10|                offset,
   88|     10|                needed_hint: Some(needed_hint),
   89|     10|            }),
   90|     10|        }
   91|     10|    }
_RNvMs1_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB5_12BinaryReader16ensure_has_bytes:
  175|    286|    pub(crate) fn ensure_has_bytes(&self, len: usize) -> Result<()> {
  176|    286|        if self.position + len <= self.buffer.len() {
  177|    276|            Ok(())
  178|       |        } else {
  179|     10|            let hint = self.position + len - self.buffer.len();
  180|     10|            Err(BinaryReaderError::eof(self.original_position(), hint))
  181|       |        }
  182|    286|    }
_RNvXs9_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB5_22BinaryReaderErrorInnerNtNtCs23Pu7RYaif7_4core3fmt5Debug3fmt:
   42|    286|#[derive(Debug, Clone)]
_RNvMs1_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB5_12BinaryReader15new_with_offset:
  135|    286|    pub fn new_with_offset(data: &[u8], original_offset: usize) -> BinaryReader {
  136|    286|        BinaryReader {
  137|    286|            buffer: data,
  138|    286|            position: 0,
  139|    286|            original_offset,
  140|    286|            allow_memarg64: false,
  141|    286|        }
  142|    286|    }
_RNvMs1_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB5_12BinaryReader10read_bytes:
  972|    286|        self.ensure_has_bytes(size)?;
  973|    276|        let start = self.position;
  974|    276|        self.position += size;
  975|    276|        Ok(&self.buffer[start..self.position])
  976|    286|    }
_RNvMs1_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB5_12BinaryReader17original_position:
  146|    572|    pub fn original_position(&self) -> usize {
  147|    572|        self.original_offset + self.position
  148|    572|    }
_RNvXs7_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB5_17BinaryReaderErrorNtNtCs23Pu7RYaif7_4core3fmt5Debug3fmt:
   34|    286|#[derive(Debug, Clone)]
_RINvMs0_NtCsdSXEL0kkvTs_10wasmparser13binary_readerNtB6_17BinaryReaderError3newReEB8_:
   66|    276|    pub(crate) fn new(message: impl Into<String>, offset: usize) -> Self {
   67|    276|        let message = message.into();
   68|    276|        BinaryReaderError {
   69|    276|            inner: Box::new(BinaryReaderErrorInner {
   70|    276|                message,
   71|    276|                offset,
   72|    276|                needed_hint: None,
   73|    276|            }),
   74|    276|        }
   75|    276|    }

_RNvMNtCsdSXEL0kkvTs_10wasmparser6parserNtB2_6Parser3new:
  316|    286|    pub fn new(offset: u64) -> Parser {
  317|    286|        Parser {
  318|    286|            state: State::Header,
  319|    286|            offset,
  320|    286|            max_size: u64::MAX,
  321|    286|            // Assume the encoding is a module until we know otherwise
  322|    286|            encoding: Encoding::Module,
  323|    286|        }
  324|    286|    }
_RNvMNtCsdSXEL0kkvTs_10wasmparser6parserNtB2_6Parser5parse:
  467|    286|    pub fn parse<'a>(&mut self, data: &'a [u8], eof: bool) -> Result<Chunk<'a>> {
  468|    286|        let (data, eof) = if usize_to_u64(data.len()) > self.max_size {
  469|      0|            (&data[..(self.max_size as usize)], true)
  470|       |        } else {
  471|    286|            (data, eof)
  472|       |        };
  473|       |        // TODO: thread through `offset: u64` to `BinaryReader`, remove
  474|       |        // the cast here.
  475|    286|        let mut reader = BinaryReader::new_with_offset(data, self.offset as usize);
  476|    286|        match self.parse_reader(&mut reader, eof) {
  477|      0|            Ok(payload) => {
  478|      0|                // Be sure to update our offset with how far we got in the
  479|      0|                // reader
  480|      0|                self.offset += usize_to_u64(reader.position);
  481|      0|                self.max_size -= usize_to_u64(reader.position);
  482|      0|                Ok(Chunk::Parsed {
  483|      0|                    consumed: reader.position,
  484|      0|                    payload,
  485|      0|                })
  486|       |            }
  487|    286|            Err(e) => {
  488|    286|                // If we're at EOF then there's no way we can recover from any
  489|    286|                // error, so continue to propagate it.
  490|    286|                if eof {
  491|    286|                    return Err(e);
  492|      0|                }
  493|      0|
  494|      0|                // If our error doesn't look like it can be resolved with more
  495|      0|                // data being pulled down, then propagate it, otherwise switch
  496|      0|                // the error to "feed me please"
  497|      0|                match e.inner.needed_hint {
  498|      0|                    Some(hint) => Ok(Chunk::NeedMoreData(usize_to_u64(hint))),
  499|      0|                    None => Err(e),
  500|       |                }
  501|       |            }
  502|       |        }
  503|    286|    }
_RNvNtCsdSXEL0kkvTs_10wasmparser6parser12usize_to_u64:
  875|    286|fn usize_to_u64(a: usize) -> u64 {
  876|    286|    a.try_into().unwrap()
  877|    286|}
_RNvMNtCsdSXEL0kkvTs_10wasmparser6parserNtB2_6Parser12parse_reader:
  505|    286|    fn parse_reader<'a>(
  506|    286|        &mut self,
  507|    286|        reader: &mut BinaryReader<'a>,
  508|    286|        eof: bool,
  509|    286|    ) -> Result<Payload<'a>> {
  510|    286|        use Payload::*;
  511|    286|
  512|    286|        match self.state {
  513|       |            State::Header => {
  514|    286|                let start = reader.original_position();
  515|    286|                let num = reader.read_header_version()?;
  516|      0|                self.encoding = match num {
  517|      0|                    WASM_EXPERIMENTAL_VERSION | WASM_MODULE_VERSION => Encoding::Module,
  518|      0|                    WASM_COMPONENT_VERSION => Encoding::Component,
  519|       |                    _ => {
  520|      0|                        return Err(BinaryReaderError::new(
  521|      0|                            "unknown binary version",
  522|      0|                            reader.original_position() - 4,
  523|      0|                        ))
  524|       |                    }
  525|       |                };
  526|      0|                self.state = State::SectionStart;
  527|      0|                Ok(Version {
  528|      0|                    num,
  529|      0|                    encoding: self.encoding,
  530|      0|                    range: start..reader.original_position(),
  531|      0|                })
  532|       |            }
  533|       |            State::SectionStart => {
  534|       |                // If we're at eof and there are no bytes in our buffer, then
  535|       |                // that means we reached the end of the data since it's
  536|       |                // just a bunch of sections concatenated after the header.
  537|      0|                if eof && reader.bytes_remaining() == 0 {
  538|      0|                    return Ok(Payload::End(reader.original_position()));
  539|      0|                }
  540|      0|
  541|      0|                let id_pos = reader.position;
  542|      0|                let id = reader.read_u8()?;
  543|      0|                if id & 0x80 != 0 {
  544|      0|                    return Err(BinaryReaderError::new("malformed section id", id_pos));
  545|      0|                }
  546|      0|                let len_pos = reader.position;
  547|      0|                let mut len = reader.read_var_u32()?;
  548|       |
  549|       |                // Test to make sure that this section actually fits within
  550|       |                // `Parser::max_size`. This doesn't matter for top-level modules
  551|       |                // but it is required for nested modules/components to correctly ensure
  552|       |                // that all sections live entirely within their section of the
  553|       |                // file.
  554|      0|                let section_overflow = self
  555|      0|                    .max_size
  556|      0|                    .checked_sub(usize_to_u64(reader.position))
  557|      0|                    .and_then(|s| s.checked_sub(len.into()))
  558|      0|                    .is_none();
  559|      0|                if section_overflow {
  560|      0|                    return Err(BinaryReaderError::new("section too large", len_pos));
  561|      0|                }
  562|      0|
  563|      0|                // Check for custom sections (supported by all encodings)
  564|      0|                if id == 0 {}
  565|       |
  566|      0|                match (self.encoding, id) {
  567|       |                    // Sections for both modules and components.
  568|      0|                    (_, 0) => section(reader, len, CustomSectionReader::new, CustomSection),
  569|       |
  570|       |                    // Module sections
  571|       |                    (Encoding::Module, TYPE_SECTION) => {
  572|      0|                        section(reader, len, TypeSectionReader::new, TypeSection)
  573|       |                    }
  574|       |                    (Encoding::Module, IMPORT_SECTION) => {
  575|      0|                        section(reader, len, ImportSectionReader::new, ImportSection)
  576|       |                    }
  577|       |                    (Encoding::Module, FUNCTION_SECTION) => {
  578|      0|                        section(reader, len, FunctionSectionReader::new, FunctionSection)
  579|       |                    }
  580|       |                    (Encoding::Module, TABLE_SECTION) => {
  581|      0|                        section(reader, len, TableSectionReader::new, TableSection)
  582|       |                    }
  583|       |                    (Encoding::Module, MEMORY_SECTION) => {
  584|      0|                        section(reader, len, MemorySectionReader::new, MemorySection)
  585|       |                    }
  586|       |                    (Encoding::Module, GLOBAL_SECTION) => {
  587|      0|                        section(reader, len, GlobalSectionReader::new, GlobalSection)
  588|       |                    }
  589|       |                    (Encoding::Module, EXPORT_SECTION) => {
  590|      0|                        section(reader, len, ExportSectionReader::new, ExportSection)
  591|       |                    }
  592|       |                    (Encoding::Module, START_SECTION) => {
  593|      0|                        let (func, range) = single_u32(reader, len, "start")?;
  594|      0|                        Ok(StartSection { func, range })
  595|       |                    }
  596|       |                    (Encoding::Module, ELEMENT_SECTION) => {
  597|      0|                        section(reader, len, ElementSectionReader::new, ElementSection)
  598|       |                    }
  599|       |                    (Encoding::Module, CODE_SECTION) => {
  600|      0|                        let start = reader.original_position();
  601|      0|                        let count = delimited(reader, &mut len, |r| r.read_var_u32())?;
  602|      0|                        let range = start..reader.original_position() + len as usize;
  603|      0|                        self.state = State::FunctionBody {
  604|      0|                            remaining: count,
  605|      0|                            len,
  606|      0|                        };
  607|      0|                        Ok(CodeSectionStart {
  608|      0|                            count,
  609|      0|                            range,
  610|      0|                            size: len,
  611|      0|                        })
  612|       |                    }
  613|       |                    (Encoding::Module, DATA_SECTION) => {
  614|      0|                        section(reader, len, DataSectionReader::new, DataSection)
  615|       |                    }
  616|       |                    (Encoding::Module, DATA_COUNT_SECTION) => {
  617|      0|                        let (count, range) = single_u32(reader, len, "data count")?;
  618|      0|                        Ok(DataCountSection { count, range })
  619|       |                    }
  620|       |                    (Encoding::Module, TAG_SECTION) => {
  621|      0|                        section(reader, len, TagSectionReader::new, TagSection)
  622|       |                    }
  623|       |
  624|       |                    // Component sections
  625|       |                    (Encoding::Component, COMPONENT_MODULE_SECTION)
  626|       |                    | (Encoding::Component, COMPONENT_SECTION) => {
  627|      0|                        if len as usize > MAX_WASM_MODULE_SIZE {
  628|      0|                            bail!(
  629|      0|                                len_pos,
  630|      0|                                "{} section is too large",
  631|      0|                                if id == 1 { "module" } else { "component " }
  632|       |                            );
  633|      0|                        }
  634|      0|
  635|      0|                        let range =
  636|      0|                            reader.original_position()..reader.original_position() + len as usize;
  637|      0|                        self.max_size -= u64::from(len);
  638|      0|                        self.offset += u64::from(len);
  639|      0|                        let mut parser = Parser::new(usize_to_u64(reader.original_position()));
  640|      0|                        parser.max_size = len.into();
  641|      0|
  642|      0|                        Ok(match id {
  643|      0|                            1 => ModuleSection { parser, range },
  644|      0|                            4 => ComponentSection { parser, range },
  645|      0|                            _ => unreachable!(),
  646|       |                        })
  647|       |                    }
  648|       |                    (Encoding::Component, COMPONENT_CORE_INSTANCE_SECTION) => {
  649|      0|                        section(reader, len, InstanceSectionReader::new, InstanceSection)
  650|       |                    }
  651|       |                    (Encoding::Component, COMPONENT_CORE_TYPE_SECTION) => {
  652|      0|                        section(reader, len, CoreTypeSectionReader::new, CoreTypeSection)
  653|       |                    }
  654|      0|                    (Encoding::Component, COMPONENT_INSTANCE_SECTION) => section(
  655|      0|                        reader,
  656|      0|                        len,
  657|      0|                        ComponentInstanceSectionReader::new,
  658|      0|                        ComponentInstanceSection,
  659|      0|                    ),
  660|      0|                    (Encoding::Component, COMPONENT_ALIAS_SECTION) => section(
  661|      0|                        reader,
  662|      0|                        len,
  663|      0|                        ComponentAliasSectionReader::new,
  664|      0|                        ComponentAliasSection,
  665|      0|                    ),
  666|      0|                    (Encoding::Component, COMPONENT_TYPE_SECTION) => section(
  667|      0|                        reader,
  668|      0|                        len,
  669|      0|                        ComponentTypeSectionReader::new,
  670|      0|                        ComponentTypeSection,
  671|      0|                    ),
  672|      0|                    (Encoding::Component, COMPONENT_CANONICAL_SECTION) => section(
  673|      0|                        reader,
  674|      0|                        len,
  675|      0|                        ComponentCanonicalSectionReader::new,
  676|      0|                        ComponentCanonicalSection,
  677|      0|                    ),
  678|      0|                    (Encoding::Component, COMPONENT_START_SECTION) => section(
  679|      0|                        reader,
  680|      0|                        len,
  681|      0|                        ComponentStartSectionReader::new,
  682|      0|                        ComponentStartSection,
  683|      0|                    ),
  684|      0|                    (Encoding::Component, COMPONENT_IMPORT_SECTION) => section(
  685|      0|                        reader,
  686|      0|                        len,
  687|      0|                        ComponentImportSectionReader::new,
  688|      0|                        ComponentImportSection,
  689|      0|                    ),
  690|      0|                    (Encoding::Component, COMPONENT_EXPORT_SECTION) => section(
  691|      0|                        reader,
  692|      0|                        len,
  693|      0|                        ComponentExportSectionReader::new,
  694|      0|                        ComponentExportSection,
  695|      0|                    ),
  696|      0|                    (_, id) => {
  697|      0|                        let offset = reader.original_position();
  698|      0|                        let contents = reader.read_bytes(len as usize)?;
  699|      0|                        let range = offset..offset + len as usize;
  700|      0|                        Ok(UnknownSection {
  701|      0|                            id,
  702|      0|                            contents,
  703|      0|                            range,
  704|      0|                        })
  705|       |                    }
  706|       |                }
  707|       |            }
  708|       |
  709|       |            // Once we hit 0 remaining incrementally parsed items, with 0
  710|       |            // remaining bytes in each section, we're done and can switch back
  711|       |            // to parsing sections.
  712|       |            State::FunctionBody {
  713|       |                remaining: 0,
  714|       |                len: 0,
  715|       |            } => {
  716|      0|                self.state = State::SectionStart;
  717|      0|                self.parse_reader(reader, eof)
  718|       |            }
  719|       |
  720|       |            // ... otherwise trailing bytes with no remaining entries in these
  721|       |            // sections indicates an error.
  722|      0|            State::FunctionBody { remaining: 0, len } => {
  723|      0|                debug_assert!(len > 0);
  724|      0|                let offset = reader.original_position();
  725|      0|                Err(BinaryReaderError::new(
  726|      0|                    "trailing bytes at end of section",
  727|      0|                    offset,
  728|      0|                ))
  729|       |            }
  730|       |
  731|       |            // Functions are relatively easy to parse when we know there's at
  732|       |            // least one remaining and at least one byte available to read
  733|       |            // things.
  734|       |            //
  735|       |            // We use the remaining length try to read a u32 size of the
  736|       |            // function, and using that size we require the entire function be
  737|       |            // resident in memory. This means that we're reading whole chunks of
  738|       |            // functions at a time.
  739|       |            //
  740|       |            // Limiting via `Parser::max_size` (nested parsing) happens above in
  741|       |            // `fn parse`, and limiting by our section size happens via
  742|       |            // `delimited`. Actual parsing of the function body is delegated to
  743|       |            // the caller to iterate over the `FunctionBody` structure.
  744|      0|            State::FunctionBody { remaining, mut len } => {
  745|      0|                let body = delimited(reader, &mut len, |r| {
  746|       |                    let size = r.read_var_u32()?;
  747|       |                    let offset = r.original_position();
  748|       |                    Ok(FunctionBody::new(offset, r.read_bytes(size as usize)?))
  749|      0|                })?;
  750|      0|                self.state = State::FunctionBody {
  751|      0|                    remaining: remaining - 1,
  752|      0|                    len,
  753|      0|                };
  754|      0|                Ok(CodeSectionEntry(body))
  755|       |            }
  756|       |        }
  757|    286|    }

