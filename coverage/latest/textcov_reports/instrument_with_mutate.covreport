_RNvXsI_Cs7Vxs5wU22nm_9arbitraryyNtB5_9Arbitrary9arbitrary:
  309|    122|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    122|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    122|                    u.fill_buffer(&mut buf)?;
  312|    122|                    let mut x: $unsigned = 0;
  313|    976|                    for i in 0..mem::size_of::<$ty>() {
  314|    976|                        x |= buf[i] as $unsigned << (i * 8);
  315|    976|                    }
  316|    122|                    Ok(x as $ty)
  317|    122|                }

_RINvMNtCs7Vxs5wU22nm_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryyECs7xWdtGLRam0_22instrument_with_mutate:
  167|    122|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    122|    where
  169|    122|        A: Arbitrary<'a>,
  170|    122|    {
  171|    122|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    122|    }
_RINvMNtCs7Vxs5wU22nm_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_impljINtNtNtNtCsg994vJE3n1e_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEEB5_:
  302|    122|    fn int_in_range_impl<T>(
  303|    122|        range: ops::RangeInclusive<T>,
  304|    122|        mut bytes: impl Iterator<Item = u8>,
  305|    122|    ) -> Result<(T, usize)>
  306|    122|    where
  307|    122|        T: Int,
  308|    122|    {
  309|    122|        let start = *range.start();
  310|    122|        let end = *range.end();
  311|    122|        assert!(
  312|    122|            start <= end,
  313|    122|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|    122|        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|    122|        if start == end {
  319|      0|            return Ok((start, 0));
  320|    122|        }
  321|    122|
  322|    122|        // From here on out we work with the unsigned representation. All of the
  323|    122|        // operations performed below work out just as well whether or not `T`
  324|    122|        // is a signed or unsigned integer.
  325|    122|        let start = start.to_unsigned();
  326|    122|        let end = end.to_unsigned();
  327|    122|
  328|    122|        let delta = end.wrapping_sub(start);
  329|    122|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|    122|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|    122|        let mut bytes_consumed: usize = 0;
  337|       |
  338|    244|        while (bytes_consumed < mem::size_of::<T>())
  339|    244|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|    122|            let byte = match bytes.next() {
  342|      0|                None => break,
  343|    122|                Some(b) => b,
  344|    122|            };
  345|    122|            bytes_consumed += 1;
  346|    122|
  347|    122|            // Combine this byte into our arbitrary integer, but avoid
  348|    122|            // overflowing the shift for `u8` and `i8`.
  349|    122|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|    122|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|    122|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|    122|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|    122|        let result = start.wrapping_add(offset);
  365|    122|
  366|    122|        // And convert back to our maybe-signed representation.
  367|    122|        let result = T::from_unsigned(result);
  368|    122|        debug_assert!(*range.start() <= result);
  369|    122|        debug_assert!(result <= *range.end());
  370|       |
  371|    122|        Ok((result, bytes_consumed))
  372|    122|    }
_RNvXs6_NtCs7Vxs5wU22nm_9arbitrary12unstructuredjNtB5_3Int13from_unsigned:
  860|    122|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  861|    122|                    unsigned as Self
  862|    122|                }
_RINvMNtCs7Vxs5wU22nm_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangejEB5_:
  293|    122|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|    122|    where
  295|    122|        T: Int,
  296|    122|    {
  297|    122|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|    122|        self.data = &self.data[bytes_consumed..];
  299|    122|        Ok(result)
  300|    122|    }
_RNvMNtCs7Vxs5wU22nm_9arbitrary12unstructuredNtB2_12Unstructured12choose_index:
  450|    122|    pub fn choose_index(&mut self, len: usize) -> Result<usize> {
  451|    122|        if len == 0 {
  452|      0|            return Err(Error::EmptyChoose);
  453|    122|        }
  454|    122|        let idx = self.int_in_range(0..=len - 1)?;
  455|    122|        Ok(idx)
  456|    122|    }
_RNvXs6_NtCs7Vxs5wU22nm_9arbitrary12unstructuredjNtB5_3Int11to_unsigned:
  856|    244|                fn to_unsigned(self) -> Self::Unsigned {
  857|    244|                    self as $unsigned_ty
  858|    244|                }
_RNvMNtCs7Vxs5wU22nm_9arbitrary12unstructuredNtB2_12Unstructured11fill_buffer:
  521|    122|    pub fn fill_buffer(&mut self, buffer: &mut [u8]) -> Result<()> {
  522|    122|        let n = std::cmp::min(buffer.len(), self.data.len());
  523|    122|        buffer[..n].copy_from_slice(&self.data[..n]);
  524|    122|        for byte in buffer[n..].iter_mut() {
  525|      0|            *byte = 0;
  526|      0|        }
  527|    122|        self.data = &self.data[n..];
  528|    122|        Ok(())
  529|    122|    }
_RNvXs6_NtCs7Vxs5wU22nm_9arbitrary12unstructuredjNtB5_3Int12wrapping_add:
  848|    122|                fn wrapping_add(self, rhs: Self) -> Self {
  849|    122|                    <$ty>::wrapping_add(self, rhs)
  850|    122|                }
_RNvXs6_NtCs7Vxs5wU22nm_9arbitrary12unstructuredjNtB5_3Int11checked_add:
  844|    122|                fn checked_add(self, rhs: Self) -> Option<Self> {
  845|    122|                    <$ty>::checked_add(self, rhs)
  846|    122|                }
_RNvXs6_NtCs7Vxs5wU22nm_9arbitrary12unstructuredjNtB5_3Int12wrapping_sub:
  852|    122|                fn wrapping_sub(self, rhs: Self) -> Self {
  853|    122|                    <$ty>::wrapping_sub(self, rhs)
  854|    122|                }
_RNvXs6_NtCs7Vxs5wU22nm_9arbitrary12unstructuredjNtB5_3Int7from_u8:
  836|    122|                fn from_u8(b: u8) -> Self {
  837|    122|                    b as Self
  838|    122|                }
_RNvMNtCs7Vxs5wU22nm_9arbitrary12unstructuredNtB2_12Unstructured3new:
   85|    122|    pub fn new(data: &'a [u8]) -> Self {
   86|    122|        Unstructured { data }
   87|    122|    }
_RNvXs6_NtCs7Vxs5wU22nm_9arbitrary12unstructuredjNtB5_3Int10from_usize:
  840|    244|                fn from_usize(u: usize) -> Self {
  841|    244|                    u as Self
  842|    244|                }

_RNvCs71Cmd9aHYHP_4atty2is:
   40|    122|pub fn is(stream: Stream) -> bool {
   41|       |    extern crate libc;
   42|       |
   43|    122|    let fd = match stream {
   44|      0|        Stream::Stdout => libc::STDOUT_FILENO,
   45|    122|        Stream::Stderr => libc::STDERR_FILENO,
   46|      0|        Stream::Stdin => libc::STDIN_FILENO,
   47|       |    };
   48|    122|    unsafe { libc::isatty(fd) != 0 }
   49|    122|}

_RNCNvNtCsgSpm5FkEyyU_10env_logger6filter10parse_specs0_0B5_:
  344|    488|                name: name.map(|s| s.to_string()),
_RNvMs_NtCsgSpm5FkEyyU_10env_logger6filterNtB4_7Builder5parse:
  216|    122|    pub fn parse(&mut self, filters: &str) -> &mut Self {
  217|    122|        let (directives, filter) = parse_spec(filters);
  218|    122|
  219|    122|        self.filter = filter;
  220|       |
  221|    610|        for directive in directives {
  222|    488|            self.directives.insert(directive.name, directive.level);
  223|    488|        }
  224|    122|        self
  225|    122|    }
_RNvXs0_NtCsgSpm5FkEyyU_10env_logger6filterNtB5_7BuilderNtNtCsg994vJE3n1e_4core7default7Default7default:
  263|    122|    fn default() -> Self {
  264|    122|        Builder::new()
  265|    122|    }
_RNCNCNvMs_NtCsgSpm5FkEyyU_10env_logger6filterNtB8_7Builder5builds_00Ba_:
  249|    600|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
_RNvMNtCsgSpm5FkEyyU_10env_logger6filterNtB2_6Filter6filter:
  139|    122|    pub fn filter(&self) -> LevelFilter {
  140|    122|        self.directives
  141|    122|            .iter()
  142|    122|            .map(|d| d.level)
  143|    122|            .max()
  144|    122|            .unwrap_or(LevelFilter::Off)
  145|    122|    }
_RNvMs_NtCsgSpm5FkEyyU_10env_logger6filterNtB4_7Builder5build:
  228|    122|    pub fn build(&mut self) -> Filter {
  229|    122|        assert!(!self.built, "attempt to re-use consumed builder");
  230|    122|        self.built = true;
  231|    122|
  232|    122|        let mut directives = Vec::new();
  233|    122|        if self.directives.is_empty() {
  234|      0|            // Adds the default filter if none exist
  235|      0|            directives.push(Directive {
  236|      0|                name: None,
  237|      0|                level: LevelFilter::Error,
  238|      0|            });
  239|    122|        } else {
  240|    122|            // Consume map of directives.
  241|    122|            let directives_map = mem::take(&mut self.directives);
  242|    122|            directives = directives_map
  243|    122|                .into_iter()
  244|    122|                .map(|(name, level)| Directive { name, level })
  245|    122|                .collect();
  246|    122|            // Sort the directives by length of their name, this allows a
  247|    122|            // little more efficient lookup at runtime.
  248|    122|            directives.sort_by(|a, b| {
  249|       |                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|       |                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|       |                alen.cmp(&blen)
  252|    122|            });
  253|    122|        }
  254|       |
  255|    122|        Filter {
  256|    122|            directives: mem::take(&mut directives),
  257|    122|            filter: mem::replace(&mut self.filter, None),
  258|    122|        }
  259|    122|    }
_RNvMNtCsgSpm5FkEyyU_10env_logger6filterNtB2_6Filter7enabled:
  163|    986|    pub fn enabled(&self, metadata: &Metadata) -> bool {
  164|    986|        let level = metadata.level();
  165|    986|        let target = metadata.target();
  166|    986|
  167|    986|        enabled(&self.directives, level, target)
  168|    986|    }
_RNvNtCsgSpm5FkEyyU_10env_logger6filter10parse_spec:
  292|    122|fn parse_spec(spec: &str) -> (Vec<Directive>, Option<inner::Filter>) {
  293|    122|    let mut dirs = Vec::new();
  294|    122|
  295|    122|    let mut parts = spec.split('/');
  296|    122|    let mods = parts.next();
  297|    122|    let filter = parts.next();
  298|    122|    if parts.next().is_some() {
  299|      0|        eprintln!(
  300|      0|            "warning: invalid logging spec '{}', \
  301|      0|             ignoring it (too many '/'s)",
  302|      0|            spec
  303|      0|        );
  304|      0|        return (dirs, None);
  305|    122|    }
  306|    122|    if let Some(m) = mods {
  307|    488|        for s in m.split(',').map(|ss| ss.trim()) {
  308|    488|            if s.is_empty() {
  309|      0|                continue;
  310|    488|            }
  311|    488|            let mut parts = s.split('=');
  312|    488|            let (log_level, name) =
  313|    488|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
  314|    244|                    (Some(part0), None, None) => {
  315|    244|                        // if the single argument is a log-level string or number,
  316|    244|                        // treat that as a global fallback
  317|    244|                        match part0.parse() {
  318|      0|                            Ok(num) => (num, None),
  319|    244|                            Err(_) => (LevelFilter::max(), Some(part0)),
  320|       |                        }
  321|       |                    }
  322|    244|                    (Some(part0), Some(""), None) => (LevelFilter::max(), Some(part0)),
  323|    244|                    (Some(part0), Some(part1), None) => match part1.parse() {
  324|    244|                        Ok(num) => (num, Some(part0)),
  325|       |                        _ => {
  326|      0|                            eprintln!(
  327|      0|                                "warning: invalid logging spec '{}', \
  328|      0|                                 ignoring it",
  329|      0|                                part1
  330|      0|                            );
  331|      0|                            continue;
  332|       |                        }
  333|       |                    },
  334|       |                    _ => {
  335|      0|                        eprintln!(
  336|      0|                            "warning: invalid logging spec '{}', \
  337|      0|                             ignoring it",
  338|      0|                            s
  339|      0|                        );
  340|      0|                        continue;
  341|       |                    }
  342|       |                };
  343|    488|            dirs.push(Directive {
  344|    488|                name: name.map(|s| s.to_string()),
  345|    488|                level: log_level,
  346|    488|            });
  347|       |        }
  348|      0|    }
  349|       |
  350|    122|    let filter = filter.and_then(|filter| match inner::Filter::new(filter) {
  351|       |        Ok(re) => Some(re),
  352|       |        Err(e) => {
  353|       |            eprintln!("warning: invalid regex filter - {}", e);
  354|       |            None
  355|       |        }
  356|    122|    });
  357|    122|
  358|    122|    (dirs, filter)
  359|    122|}
_RNCNvNtCsgSpm5FkEyyU_10env_logger6filter10parse_specs_0B5_:
  313|    244|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
_RNCNCNvMs_NtCsgSpm5FkEyyU_10env_logger6filterNtB8_7Builder5builds_0s_0Ba_:
  250|    600|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
_RNvMs_NtCsgSpm5FkEyyU_10env_logger6filterNtB4_7Builder3new:
  173|    122|    pub fn new() -> Builder {
  174|    122|        Builder {
  175|    122|            directives: HashMap::new(),
  176|    122|            filter: None,
  177|    122|            built: false,
  178|    122|        }
  179|    122|    }
_RNCNvNtCsgSpm5FkEyyU_10env_logger6filter10parse_spec0B5_:
  307|    488|        for s in m.split(',').map(|ss| ss.trim()) {
_RNCNvMNtCsgSpm5FkEyyU_10env_logger6filterNtB4_6Filter6filter0B6_:
  142|    488|            .map(|d| d.level)
_RNCNvMs_NtCsgSpm5FkEyyU_10env_logger6filterNtB6_7Builder5builds_0B8_:
  248|    600|            directives.sort_by(|a, b| {
  249|    600|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|    600|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|    600|                alen.cmp(&blen)
  252|    600|            });
_RNvNtCsgSpm5FkEyyU_10env_logger6filter7enabled:
  362|    986|fn enabled(directives: &[Directive], level: Level, target: &str) -> bool {
  363|       |    // Search for the longest match, the vector is assumed to be pre-sorted.
  364|  2.23k|    for directive in directives.iter().rev() {
  365|  2.23k|        match directive.name {
  366|  2.23k|            Some(ref name) if !target.starts_with(&**name) => {}
  367|    854|            Some(..) | None => return level <= directive.level,
  368|       |        }
  369|       |    }
  370|    132|    false
  371|    986|}
_RNvMNtCsgSpm5FkEyyU_10env_logger6filterNtB2_6Filter7matches:
  148|    986|    pub fn matches(&self, record: &Record) -> bool {
  149|    986|        if !self.enabled(record.metadata()) {
  150|    132|            return false;
  151|    854|        }
  152|       |
  153|    854|        if let Some(filter) = self.filter.as_ref() {
  154|      0|            if !filter.is_match(&record.args().to_string()) {
  155|      0|                return false;
  156|      0|            }
  157|    854|        }
  158|       |
  159|    854|        true
  160|    986|    }
_RNCNvMs_NtCsgSpm5FkEyyU_10env_logger6filterNtB6_7Builder5build0B8_:
  244|    488|                .map(|(name, level)| Directive { name, level })

_RNvXs0_NtNtNtCsgSpm5FkEyyU_10env_logger3fmt9humantime3impNtB5_9TimestampNtNtCsg994vJE3n1e_4core3fmt7Display3fmt:
  108|    854|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  109|    854|        let formatter = match self.precision {
  110|    854|            TimestampPrecision::Seconds => format_rfc3339_seconds,
  111|      0|            TimestampPrecision::Millis => format_rfc3339_millis,
  112|      0|            TimestampPrecision::Micros => format_rfc3339_micros,
  113|      0|            TimestampPrecision::Nanos => format_rfc3339_nanos,
  114|       |        };
  115|       |
  116|    854|        formatter(self.time).fmt(f)
  117|    854|    }
_RNvMNtNtNtCsgSpm5FkEyyU_10env_logger3fmt9humantime3impNtB6_9Formatter17timestamp_seconds:
   43|    854|    pub fn timestamp_seconds(&self) -> Timestamp {
   44|    854|        Timestamp {
   45|    854|            time: SystemTime::now(),
   46|    854|            precision: TimestampPrecision::Seconds,
   47|    854|        }
   48|    854|    }

_RNvXNtCsgSpm5FkEyyU_10env_logger3fmtNtB2_18TimestampPrecisionNtNtCsg994vJE3n1e_4core7default7Default7default:
   71|    244|    fn default() -> Self {
   72|    244|        TimestampPrecision::Seconds
   73|    244|    }
_RNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_13DefaultFormat5write:
  226|    854|        self.write_timestamp()?;
  227|    854|        self.write_level(record)?;
  228|    854|        self.write_module_path(record)?;
  229|    854|        self.write_target(record)?;
  230|    854|        self.finish_header()?;
  231|       |
  232|    854|        self.write_args(record)
  233|    854|    }
_RNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_13DefaultFormat15write_timestamp:
  284|    854|    fn write_timestamp(&mut self) -> io::Result<()> {
  285|       |        #[cfg(feature = "humantime")]
  286|       |        {
  287|       |            use self::TimestampPrecision::*;
  288|    854|            let ts = match self.timestamp {
  289|      0|                None => return Ok(()),
  290|    854|                Some(Seconds) => self.buf.timestamp_seconds(),
  291|      0|                Some(Millis) => self.buf.timestamp_millis(),
  292|      0|                Some(Micros) => self.buf.timestamp_micros(),
  293|      0|                Some(Nanos) => self.buf.timestamp_nanos(),
  294|       |            };
  295|       |
  296|    854|            self.write_header_value(ts)
  297|       |        }
  298|       |        #[cfg(not(feature = "humantime"))]
  299|       |        {
  300|       |            // Trick the compiler to think we have used self.timestamp
  301|       |            // Workaround for "field is never used: `timestamp`" compiler nag.
  302|       |            let _ = self.timestamp;
  303|       |            Ok(())
  304|       |        }
  305|    854|    }
_RNvXs2_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_7BuilderNtNtCsg994vJE3n1e_4core7default7Default7default:
  153|    244|    fn default() -> Self {
  154|    244|        Builder {
  155|    244|            format_timestamp: Some(Default::default()),
  156|    244|            format_module_path: false,
  157|    244|            format_target: true,
  158|    244|            format_level: true,
  159|    244|            format_indent: Some(4),
  160|    244|            custom_format: None,
  161|    244|            format_suffix: "\n",
  162|    244|            built: false,
  163|    244|        }
  164|    244|    }
_RNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_13DefaultFormat12write_target:
  319|    854|    fn write_target(&mut self, record: &Record) -> io::Result<()> {
  320|    854|        if !self.target {
  321|      0|            return Ok(());
  322|    854|        }
  323|    854|
  324|    854|        match record.target() {
  325|    854|            "" => Ok(()),
  326|    854|            target => self.write_header_value(target),
  327|       |        }
  328|    854|    }
_RNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_13DefaultFormat17write_module_path:
  307|    854|    fn write_module_path(&mut self, record: &Record) -> io::Result<()> {
  308|    854|        if !self.module_path {
  309|    854|            return Ok(());
  310|      0|        }
  311|       |
  312|      0|        if let Some(module_path) = record.module_path() {
  313|      0|            self.write_header_value(module_path)
  314|       |        } else {
  315|      0|            Ok(())
  316|       |        }
  317|    854|    }
_RINvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtCsg994vJE3n1e_4core3fmt9ArgumentsEB8_:
  251|    854|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    854|    where
  253|    854|        T: Display,
  254|    854|    {
  255|    854|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|    854|            write!(self.buf, " {}", value)
  262|       |        }
  263|    854|    }
_RNvMs_NtCsgSpm5FkEyyU_10env_logger3fmtNtB4_9Formatter3new:
  103|      1|    pub(crate) fn new(writer: &Writer) -> Self {
  104|      1|        Formatter {
  105|      1|            buf: Rc::new(RefCell::new(writer.buffer())),
  106|      1|            write_style: writer.write_style(),
  107|      1|        }
  108|      1|    }
_RNCNvXNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtBa_13DefaultFormat10write_argsNtB4_13IndentWrapperNtNtCsbtOQBIHS4qd_3std2io5Write5write0Bc_:
  355|  62.8k|                        for chunk in buf.split(|&x| x == b'\n') {
_RINvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueReEB8_:
  251|    854|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    854|    where
  253|    854|        T: Display,
  254|    854|    {
  255|    854|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|    854|            write!(self.buf, " {}", value)
  262|       |        }
  263|    854|    }
_RNvXNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB8_13DefaultFormat10write_argsNtB2_13IndentWrapperNtNtCsbtOQBIHS4qd_3std2io5Write5write:
  353|  8.94k|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|  8.94k|                        let mut first = true;
  355|  8.94k|                        for chunk in buf.split(|&x| x == b'\n') {
  356|  8.94k|                            if !first {
  357|      0|                                write!(
  358|      0|                                    self.fmt.buf,
  359|      0|                                    "{}{:width$}",
  360|      0|                                    self.fmt.suffix,
  361|      0|                                    "",
  362|      0|                                    width = self.indent_count
  363|      0|                                )?;
  364|  8.94k|                            }
  365|  8.94k|                            self.fmt.buf.write_all(chunk)?;
  366|  8.94k|                            first = false;
  367|       |                        }
  368|       |
  369|  8.94k|                        Ok(buf.len())
  370|  8.94k|                    }
_RNvMs3_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_7Builder5build:
  173|    122|    pub fn build(&mut self) -> FormatFn {
  174|    122|        assert!(!self.built, "attempt to re-use consumed builder");
  175|       |
  176|    122|        let built = mem::replace(
  177|    122|            self,
  178|    122|            Builder {
  179|    122|                built: true,
  180|    122|                ..Default::default()
  181|    122|            },
  182|    122|        );
  183|       |
  184|    122|        if let Some(fmt) = built.custom_format {
  185|      0|            fmt
  186|       |        } else {
  187|    122|            Box::new(move |buf, record| {
  188|       |                let fmt = DefaultFormat {
  189|       |                    timestamp: built.format_timestamp,
  190|       |                    module_path: built.format_module_path,
  191|       |                    target: built.format_target,
  192|       |                    level: built.format_level,
  193|       |                    written_header_value: false,
  194|       |                    indent: built.format_indent,
  195|       |                    suffix: built.format_suffix,
  196|       |                    buf,
  197|       |                };
  198|       |
  199|       |                fmt.write(record)
  200|    122|            })
  201|       |        }
  202|    122|    }
_RNvMs_NtCsgSpm5FkEyyU_10env_logger3fmtNtB4_9Formatter11write_style:
  110|    853|    pub(crate) fn write_style(&self) -> WriteStyle {
  111|    853|        self.write_style
  112|    853|    }
_RNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_13DefaultFormat12subtle_style:
  235|  1.70k|    fn subtle_style(&self, text: &'static str) -> SubtleStyle {
  236|  1.70k|        #[cfg(feature = "termcolor")]
  237|  1.70k|        {
  238|  1.70k|            self.buf
  239|  1.70k|                .style()
  240|  1.70k|                .set_color(Color::Black)
  241|  1.70k|                .set_intense(true)
  242|  1.70k|                .clone()
  243|  1.70k|                .into_value(text)
  244|  1.70k|        }
  245|  1.70k|        #[cfg(not(feature = "termcolor"))]
  246|  1.70k|        {
  247|  1.70k|            text
  248|  1.70k|        }
  249|  1.70k|    }
_RNvMs_NtCsgSpm5FkEyyU_10env_logger3fmtNtB4_9Formatter5clear:
  118|    854|    pub(crate) fn clear(&mut self) {
  119|    854|        self.buf.borrow_mut().clear()
  120|    854|    }
_RNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_13DefaultFormat11write_level:
  265|    854|    fn write_level(&mut self, record: &Record) -> io::Result<()> {
  266|    854|        if !self.level {
  267|      0|            return Ok(());
  268|    854|        }
  269|    854|
  270|    854|        let level = {
  271|    854|            #[cfg(feature = "termcolor")]
  272|    854|            {
  273|    854|                self.buf.default_styled_level(record.level())
  274|    854|            }
  275|    854|            #[cfg(not(feature = "termcolor"))]
  276|    854|            {
  277|    854|                record.level()
  278|    854|            }
  279|    854|        };
  280|    854|
  281|    854|        self.write_header_value(format_args!("{:<5}", level))
  282|    854|    }
_RNvMs_NtCsgSpm5FkEyyU_10env_logger3fmtNtB4_9Formatter5print:
  114|    854|    pub(crate) fn print(&self, writer: &Writer) -> io::Result<()> {
  115|    854|        writer.print(&self.buf.borrow())
  116|    854|    }
_RNCNvMs3_NtCsgSpm5FkEyyU_10env_logger3fmtNtB7_7Builder5build0B9_:
  187|    854|            Box::new(move |buf, record| {
  188|    854|                let fmt = DefaultFormat {
  189|    854|                    timestamp: built.format_timestamp,
  190|    854|                    module_path: built.format_module_path,
  191|    854|                    target: built.format_target,
  192|    854|                    level: built.format_level,
  193|    854|                    written_header_value: false,
  194|    854|                    indent: built.format_indent,
  195|    854|                    suffix: built.format_suffix,
  196|    854|                    buf,
  197|    854|                };
  198|    854|
  199|    854|                fmt.write(record)
  200|    854|            })
_RNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_13DefaultFormat10write_args:
  339|    854|    fn write_args(&mut self, record: &Record) -> io::Result<()> {
  340|    854|        match self.indent {
  341|       |            // Fast path for no indentation
  342|      0|            None => write!(self.buf, "{}{}", record.args(), self.suffix),
  343|       |
  344|    854|            Some(indent_count) => {
  345|    854|                // Create a wrapper around the buffer only if we have to actually indent the message
  346|    854|
  347|    854|                struct IndentWrapper<'a, 'b: 'a> {
  348|    854|                    fmt: &'a mut DefaultFormat<'b>,
  349|    854|                    indent_count: usize,
  350|    854|                }
  351|    854|
  352|    854|                impl<'a, 'b> Write for IndentWrapper<'a, 'b> {
  353|    854|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|    854|                        let mut first = true;
  355|    854|                        for chunk in buf.split(|&x| x == b'\n') {
  356|    854|                            if !first {
  357|    854|                                write!(
  358|    854|                                    self.fmt.buf,
  359|    854|                                    "{}{:width$}",
  360|    854|                                    self.fmt.suffix,
  361|    854|                                    "",
  362|    854|                                    width = self.indent_count
  363|    854|                                )?;
  364|    854|                            }
  365|    854|                            self.fmt.buf.write_all(chunk)?;
  366|    854|                            first = false;
  367|    854|                        }
  368|    854|
  369|    854|                        Ok(buf.len())
  370|    854|                    }
  371|    854|
  372|    854|                    fn flush(&mut self) -> io::Result<()> {
  373|    854|                        self.fmt.buf.flush()
  374|    854|                    }
  375|    854|                }
  376|    854|
  377|    854|                // The explicit scope here is just to make older versions of Rust happy
  378|    854|                {
  379|    854|                    let mut wrapper = IndentWrapper {
  380|    854|                        fmt: self,
  381|    854|                        indent_count,
  382|    854|                    };
  383|    854|                    write!(wrapper, "{}", record.args())?;
  384|       |                }
  385|       |
  386|    854|                write!(self.buf, "{}", self.suffix)?;
  387|       |
  388|    854|                Ok(())
  389|       |            }
  390|       |        }
  391|    854|    }
_RNvXs0_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_9FormatterNtNtCsbtOQBIHS4qd_3std2io5Write5write:
  124|  16.6k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  125|  16.6k|        self.buf.borrow_mut().write(buf)
  126|  16.6k|    }
_RNvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB5_13DefaultFormat13finish_header:
  330|    854|    fn finish_header(&mut self) -> io::Result<()> {
  331|    854|        if self.written_header_value {
  332|    854|            let close_brace = self.subtle_style("]");
  333|    854|            write!(self.buf, "{} ", close_brace)
  334|       |        } else {
  335|      0|            Ok(())
  336|       |        }
  337|    854|    }
_RINvMs4_NtCsgSpm5FkEyyU_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtNtB6_9humantime3imp9TimestampEB8_:
  251|    854|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    854|    where
  253|    854|        T: Display,
  254|    854|    {
  255|    854|        if !self.written_header_value {
  256|    854|            self.written_header_value = true;
  257|    854|
  258|    854|            let open_brace = self.subtle_style("[");
  259|    854|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|      0|            write!(self.buf, " {}", value)
  262|       |        }
  263|    854|    }

_RNvNtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer4atty3imp9is_stderr:
   16|    122|    pub(in crate::fmt) fn is_stderr() -> bool {
   17|    122|        atty::is(atty::Stream::Stderr)
   18|    122|    }

_RNvXs3_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCsg994vJE3n1e_4core7default7Default7default:
   99|    122|    fn default() -> Self {
  100|    122|        WriteStyle::Auto
  101|    122|    }
_RNvXs1_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_14WritableTargetNtNtCsg994vJE3n1e_4core7default7Default7default:
   69|    244|    fn default() -> Self {
   70|    244|        Self::from(Target::default())
   71|    244|    }
_RNvMs5_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_7Builder3new:
  137|    122|    pub(crate) fn new() -> Self {
  138|    122|        Builder {
  139|    122|            target: Default::default(),
  140|    122|            write_style: Default::default(),
  141|    122|            is_test: false,
  142|    122|            built: false,
  143|    122|        }
  144|    122|    }
_RNvXs6_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_7BuilderNtNtCsg994vJE3n1e_4core7default7Default7default:
  207|    122|    fn default() -> Self {
  208|    122|        Builder::new()
  209|    122|    }
_RNvMs4_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_6Writer11write_style:
  111|    854|    pub fn write_style(&self) -> WriteStyle {
  112|    854|        self.write_style
  113|    854|    }
_RNvXNtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB2_6TargetNtNtCsg994vJE3n1e_4core7default7Default7default:
   27|    244|    fn default() -> Self {
   28|    244|        Target::Stderr
   29|    244|    }
_RNvMs4_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_6Writer6buffer:
  115|      1|    pub(super) fn buffer(&self) -> Buffer {
  116|      1|        self.inner.buffer()
  117|      1|    }
_RNvMs5_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_7Builder5build:
  174|    122|    pub(crate) fn build(&mut self) -> Writer {
  175|    122|        assert!(!self.built, "attempt to re-use consumed builder");
  176|    122|        self.built = true;
  177|       |
  178|    122|        let color_choice = match self.write_style {
  179|       |            WriteStyle::Auto => {
  180|    122|                if match &self.target {
  181|    122|                    WritableTarget::Stderr => is_stderr(),
  182|      0|                    WritableTarget::Stdout => is_stdout(),
  183|      0|                    WritableTarget::Pipe(_) => false,
  184|       |                } {
  185|      0|                    WriteStyle::Auto
  186|       |                } else {
  187|    122|                    WriteStyle::Never
  188|       |                }
  189|       |            }
  190|      0|            color_choice => color_choice,
  191|       |        };
  192|       |
  193|    122|        let writer = match mem::take(&mut self.target) {
  194|    122|            WritableTarget::Stderr => BufferWriter::stderr(self.is_test, color_choice),
  195|      0|            WritableTarget::Stdout => BufferWriter::stdout(self.is_test, color_choice),
  196|      0|            WritableTarget::Pipe(pipe) => BufferWriter::pipe(color_choice, pipe),
  197|       |        };
  198|       |
  199|    122|        Writer {
  200|    122|            inner: writer,
  201|    122|            write_style: self.write_style,
  202|    122|        }
  203|    122|    }
_RNvXsf_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCsg994vJE3n1e_4core3cmp9PartialEq2eq:
   88|    853|#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
_RNvMs4_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_6Writer5print:
  119|    854|    pub(super) fn print(&self, buf: &Buffer) -> io::Result<()> {
  120|    854|        self.inner.print(buf)
  121|    854|    }
_RNvXs0_NtNtCsgSpm5FkEyyU_10env_logger3fmt6writerNtB5_14WritableTargetINtNtCsg994vJE3n1e_4core7convert4FromNtB5_6TargetE4from:
   59|    244|    fn from(target: Target) -> Self {
   60|    244|        match target {
   61|      0|            Target::Stdout => Self::Stdout,
   62|    244|            Target::Stderr => Self::Stderr,
   63|      0|            Target::Pipe(pipe) => Self::Pipe(Box::new(Mutex::new(pipe))),
   64|       |        }
   65|    244|    }

_RNvMNtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter5style:
   42|  2.56k|    pub fn style(&self) -> Style {
   43|  2.56k|        Style {
   44|  2.56k|            buf: self.buf.clone(),
   45|  2.56k|            spec: ColorSpec::new(),
   46|  2.56k|        }
   47|  2.56k|    }
_RNvMs2_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB5_5Style11set_intense:
  332|  1.70k|    pub fn set_intense(&mut self, yes: bool) -> &mut Style {
  333|  1.70k|        self.spec.set_intense(yes);
  334|  1.70k|        self
  335|  1.70k|    }
_RNvXs8_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueNtCscNjeUWn5y3T_3log5LevelENtNtCsg994vJE3n1e_4core3fmt7Display3fmtBd_:
  458|    854|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|    854|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|    854|                }
_RINvMs3_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueNtCscNjeUWn5y3T_3log5LevelE9write_fmtNCNvXs8_B6_B13_NtNtCsg994vJE3n1e_4core3fmt7Display3fmt0EBe_:
  434|    854|        self.style
  435|    854|            .buf
  436|    854|            .borrow_mut()
  437|    854|            .set_color(&self.style.spec)
  438|    854|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|    854|        let write = f();
  442|    854|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|    854|
  444|    854|        write.and(reset)
  445|    854|    }
_RNvMs2_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB5_5Style9set_color:
  278|  2.56k|    pub fn set_color(&mut self, color: Color) -> &mut Style {
  279|  2.56k|        self.spec.set_fg(Some(color.into_termcolor()));
  280|  2.56k|        self
  281|  2.56k|    }
_RINvMs3_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueReE9write_fmtNCNvXs8_B6_B13_NtNtCsg994vJE3n1e_4core3fmt7Display3fmt0EBe_:
  434|  1.70k|        self.style
  435|  1.70k|            .buf
  436|  1.70k|            .borrow_mut()
  437|  1.70k|            .set_color(&self.style.spec)
  438|  1.70k|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|  1.70k|        let write = f();
  442|  1.70k|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|  1.70k|
  444|  1.70k|        write.and(reset)
  445|  1.70k|    }
_RINvMs2_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueReEBe_:
  421|  1.70k|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|  1.70k|        StyledValue {
  423|  1.70k|            style: Cow::Owned(self),
  424|  1.70k|            value,
  425|  1.70k|        }
  426|  1.70k|    }
_RNvMs0_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5clear:
  144|    854|    pub(in crate::fmt) fn clear(&mut self) {
  145|    854|        self.inner.clear()
  146|    854|    }
_RNCNvXs8_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueReENtNtCsg994vJE3n1e_4core3fmt7Display3fmt0Bf_:
  466|  1.70k|impl_styled_value_fmt!(
  467|  1.70k|    fmt::Debug,
  468|  1.70k|    fmt::Display,
  469|  1.70k|    fmt::Pointer,
  470|  1.70k|    fmt::Octal,
  471|  1.70k|    fmt::Binary,
  472|  1.70k|    fmt::UpperHex,
  473|  1.70k|    fmt::LowerHex,
  474|  1.70k|    fmt::UpperExp,
  475|  1.70k|    fmt::LowerExp
  476|  1.70k|);
_RNvXs8_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueReENtNtCsg994vJE3n1e_4core3fmt7Display3fmtBd_:
  458|  1.70k|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|  1.70k|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|  1.70k|                }
_RINvMs2_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueNtCscNjeUWn5y3T_3log5LevelEBe_:
  421|    854|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|    854|        StyledValue {
  423|    854|            style: Cow::Owned(self),
  424|    854|            value,
  425|    854|        }
  426|    854|    }
_RNCNvXs8_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueNtCscNjeUWn5y3T_3log5LevelENtNtCsg994vJE3n1e_4core3fmt7Display3fmt0Bf_:
  466|    854|impl_styled_value_fmt!(
  467|    854|    fmt::Debug,
  468|    854|    fmt::Display,
  469|    854|    fmt::Pointer,
  470|    854|    fmt::Octal,
  471|    854|    fmt::Binary,
  472|    854|    fmt::UpperHex,
  473|    854|    fmt::LowerHex,
  474|    854|    fmt::UpperExp,
  475|    854|    fmt::LowerExp
  476|    854|);
_RNvMs0_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer9set_color:
  160|  2.56k|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
  161|  2.56k|        // Ignore styles for test captured logs because they can't be printed
  162|  2.56k|        if !self.has_uncolored_target {
  163|  2.56k|            self.inner.set_color(spec)
  164|       |        } else {
  165|      0|            Ok(())
  166|       |        }
  167|  2.56k|    }
_RNvMs1_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB9_10WriteStyle17into_color_choice:
  180|    122|    fn into_color_choice(self) -> ColorChoice {
  181|    122|        match self {
  182|      0|            WriteStyle::Always => ColorChoice::Always,
  183|      0|            WriteStyle::Auto => ColorChoice::Auto,
  184|    122|            WriteStyle::Never => ColorChoice::Never,
  185|       |        }
  186|    122|    }
_RNvMs_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6buffer:
  116|      1|    pub(in crate::fmt::writer) fn buffer(&self) -> Buffer {
  117|      1|        Buffer {
  118|      1|            inner: self.inner.buffer(),
  119|      1|            has_uncolored_target: self.uncolored_target.is_some(),
  120|      1|        }
  121|      1|    }
_RNvMNtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter19default_level_style:
   52|    854|    pub fn default_level_style(&self, level: Level) -> Style {
   53|    854|        let mut level_style = self.style();
   54|    854|        match level {
   55|      0|            Level::Trace => level_style.set_color(Color::Cyan),
   56|    854|            Level::Debug => level_style.set_color(Color::Blue),
   57|      0|            Level::Info => level_style.set_color(Color::Green),
   58|      0|            Level::Warn => level_style.set_color(Color::Yellow),
   59|      0|            Level::Error => level_style.set_color(Color::Red).set_bold(true),
   60|       |        };
   61|    854|        level_style
   62|    854|    }
_RNvMs0_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5reset:
  169|  2.56k|    fn reset(&mut self) -> io::Result<()> {
  170|  2.56k|        // Ignore styles for test captured logs because they can't be printed
  171|  2.56k|        if !self.has_uncolored_target {
  172|  2.56k|            self.inner.reset()
  173|       |        } else {
  174|      0|            Ok(())
  175|       |        }
  176|  2.56k|    }
_RNvXs6_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB5_5StyleNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
  241|  1.70k|#[derive(Clone)]
_RNvMs_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter5print:
  124|    854|        if let Some(target) = &self.uncolored_target {
  125|       |            // This impl uses the `eprint` and `print` macros
  126|       |            // instead of `termcolor`'s buffer.
  127|       |            // This is so their output can be captured by `cargo test`
  128|      0|            let log = String::from_utf8_lossy(buf.bytes());
  129|      0|
  130|      0|            match target {
  131|      0|                WritableTarget::Stderr => eprint!("{}", log),
  132|      0|                WritableTarget::Stdout => print!("{}", log),
  133|      0|                WritableTarget::Pipe(pipe) => write!(pipe.lock().unwrap(), "{}", log)?,
  134|       |            }
  135|       |
  136|      0|            Ok(())
  137|       |        } else {
  138|    854|            self.inner.print(&buf.inner)
  139|       |        }
  140|    854|    }
_RNvMs5_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB5_5Color14into_termcolor:
  518|  2.56k|    fn into_termcolor(self) -> termcolor::Color {
  519|  2.56k|        match self {
  520|  1.70k|            Color::Black => termcolor::Color::Black,
  521|    854|            Color::Blue => termcolor::Color::Blue,
  522|      0|            Color::Green => termcolor::Color::Green,
  523|      0|            Color::Red => termcolor::Color::Red,
  524|      0|            Color::Cyan => termcolor::Color::Cyan,
  525|      0|            Color::Magenta => termcolor::Color::Magenta,
  526|      0|            Color::Yellow => termcolor::Color::Yellow,
  527|      0|            Color::White => termcolor::Color::White,
  528|      0|            Color::Ansi256(value) => termcolor::Color::Ansi256(value),
  529|      0|            Color::Rgb(r, g, b) => termcolor::Color::Rgb(r, g, b),
  530|       |        }
  531|  2.56k|    }
_RNvMNtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter20default_styled_level:
   67|    854|    pub fn default_styled_level(&self, level: Level) -> StyledValue<'static, Level> {
   68|    854|        self.default_level_style(level).into_value(level)
   69|    854|    }
_RNvMs_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6stderr:
   83|    122|    pub(in crate::fmt::writer) fn stderr(is_test: bool, write_style: WriteStyle) -> Self {
   84|    122|        BufferWriter {
   85|    122|            inner: termcolor::BufferWriter::stderr(write_style.into_color_choice()),
   86|    122|            uncolored_target: if is_test {
   87|      0|                Some(WritableTarget::Stderr)
   88|       |            } else {
   89|    122|                None
   90|       |            },
   91|       |        }
   92|    122|    }
_RNvMs0_NtNtNtNtCsgSpm5FkEyyU_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5write:
  148|  16.6k|    pub(in crate::fmt) fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  149|  16.6k|        self.inner.write(buf)
  150|  16.6k|    }

_RNCNCNvXs0_CsgSpm5FkEyyU_10env_loggerNtB9_6LoggerNtCscNjeUWn5y3T_3log3Log3log00B9_:
  924|    854|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
_RNvCsgSpm5FkEyyU_10env_logger8try_init:
 1140|    122|pub fn try_init() -> Result<(), SetLoggerError> {
 1141|    122|    try_init_from_env(Env::default())
 1142|    122|}
_RNvMs1_CsgSpm5FkEyyU_10env_loggerNtB5_3Env10get_filter:
 1014|    122|    fn get_filter(&self) -> Option<String> {
 1015|    122|        self.filter.get()
 1016|    122|    }
_RNCNvXs0_CsgSpm5FkEyyU_10env_loggerNtB7_6LoggerNtCscNjeUWn5y3T_3log3Log3log0B7_:
  922|    854|            let print = |formatter: &mut Formatter, record: &Record| {
  923|    854|                let _ =
  924|    854|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|    854|
  926|    854|                // Always clear the buffer afterwards
  927|    854|                formatter.clear();
  928|    854|            };
_RNvMs2_CsgSpm5FkEyyU_10env_loggerNtB5_3Var3get:
 1080|    244|    fn get(&self) -> Option<String> {
 1081|    244|        env::var(&*self.name)
 1082|    244|            .ok()
 1083|    244|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
 1084|    244|    }
_RINvMCsgSpm5FkEyyU_10env_loggerNtB3_7Builder9parse_envNtB3_3EnvEB3_:
  488|    122|    pub fn parse_env<'a, E>(&mut self, env: E) -> &mut Self
  489|    122|    where
  490|    122|        E: Into<Env<'a>>,
  491|    122|    {
  492|    122|        let env = env.into();
  493|       |
  494|    122|        if let Some(s) = env.get_filter() {
  495|    122|            self.parse_filters(&s);
  496|    122|        }
  497|       |
  498|    122|        if let Some(s) = env.get_write_style() {
  499|      0|            self.parse_write_style(&s);
  500|    122|        }
  501|       |
  502|    122|        self
  503|    122|    }
_RNvMs_CsgSpm5FkEyyU_10env_loggerNtB4_6Logger6filter:
  892|    122|    pub fn filter(&self) -> LevelFilter {
  893|    122|        self.filter.filter()
  894|    122|    }
_RNvMCsgSpm5FkEyyU_10env_loggerNtB2_7Builder13parse_filters:
  716|    122|    pub fn parse_filters(&mut self, filters: &str) -> &mut Self {
  717|    122|        self.filter.parse(filters);
  718|    122|        self
  719|    122|    }
_RNCNvMs2_CsgSpm5FkEyyU_10env_loggerNtB7_3Var3get0B7_:
 1083|    122|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
_RNCNvXs0_CsgSpm5FkEyyU_10env_loggerNtB7_6LoggerNtCscNjeUWn5y3T_3log3Log3logs_0B7_:
  931|    854|                .try_with(|tl_buf| {
  932|    854|                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|    854|                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|    853|                            Some(ref mut formatter) => {
  937|    853|                                // Check the buffer style. If it's different from the logger's
  938|    853|                                // style then drop the buffer and recreate it.
  939|    853|                                if formatter.write_style() != self.writer.write_style() {
  940|      0|                                    *formatter = Formatter::new(&self.writer);
  941|    853|                                }
  942|       |
  943|    853|                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|      1|                            None => {
  947|      1|                                let mut formatter = Formatter::new(&self.writer);
  948|      1|                                print(&mut formatter, record);
  949|      1|
  950|      1|                                *tl_buf = Some(formatter);
  951|      1|                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|      0|                        Err(_) => {
  955|      0|                            print(&mut Formatter::new(&self.writer), record);
  956|      0|                        }
  957|       |                    }
  958|    854|                })
_RNvXs0_CsgSpm5FkEyyU_10env_loggerNtB5_6LoggerNtCscNjeUWn5y3T_3log3Log3log:
  907|    986|    fn log(&self, record: &Record) {
  908|    986|        if self.matches(record) {
  909|       |            // Log records are written to a thread-local buffer before being printed
  910|       |            // to the terminal. We clear these buffers afterwards, but they aren't shrinked
  911|       |            // so will always at least have capacity for the largest log record formatted
  912|       |            // on that thread.
  913|       |            //
  914|       |            // If multiple `Logger`s are used by the same threads then the thread-local
  915|       |            // formatter might have different color support. If this is the case the
  916|       |            // formatter and its buffer are discarded and recreated.
  917|       |
  918|       |            thread_local! {
  919|       |                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|       |            }
  921|       |
  922|    854|            let print = |formatter: &mut Formatter, record: &Record| {
  923|       |                let _ =
  924|       |                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|       |
  926|       |                // Always clear the buffer afterwards
  927|       |                formatter.clear();
  928|       |            };
  929|       |
  930|    854|            let printed = FORMATTER
  931|    854|                .try_with(|tl_buf| {
  932|       |                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|       |                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|       |                            Some(ref mut formatter) => {
  937|       |                                // Check the buffer style. If it's different from the logger's
  938|       |                                // style then drop the buffer and recreate it.
  939|       |                                if formatter.write_style() != self.writer.write_style() {
  940|       |                                    *formatter = Formatter::new(&self.writer);
  941|       |                                }
  942|       |
  943|       |                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|       |                            None => {
  947|       |                                let mut formatter = Formatter::new(&self.writer);
  948|       |                                print(&mut formatter, record);
  949|       |
  950|       |                                *tl_buf = Some(formatter);
  951|       |                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|       |                        Err(_) => {
  955|       |                            print(&mut Formatter::new(&self.writer), record);
  956|       |                        }
  957|       |                    }
  958|    854|                })
  959|    854|                .is_ok();
  960|    854|
  961|    854|            if !printed {
  962|      0|                // The thread-local storage was not available (because its
  963|      0|                // destructor has already run). Create a new single-use
  964|      0|                // Formatter on the stack for this call.
  965|      0|                print(&mut Formatter::new(&self.writer), record);
  966|    854|            }
  967|    132|        }
  968|    986|    }
_RNvXs4_CsgSpm5FkEyyU_10env_loggerNtB5_3EnvNtNtCsg994vJE3n1e_4core7default7Default7default:
 1097|    122|    fn default() -> Self {
 1098|    122|        Env {
 1099|    122|            filter: Var::new(DEFAULT_FILTER_ENV),
 1100|    122|            write_style: Var::new(DEFAULT_WRITE_STYLE_ENV),
 1101|    122|        }
 1102|    122|    }
_RNCNvNvNvXs0_CsgSpm5FkEyyU_10env_loggerNtBb_6LoggerNtCscNjeUWn5y3T_3log3Log3log9FORMATTER7___getit0Bb_:
  918|      1|            thread_local! {
  919|      1|                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|      1|            }
_RNvMCsgSpm5FkEyyU_10env_loggerNtB2_7Builder5build:
  823|    122|    pub fn build(&mut self) -> Logger {
  824|    122|        assert!(!self.built, "attempt to re-use consumed builder");
  825|    122|        self.built = true;
  826|    122|
  827|    122|        Logger {
  828|    122|            writer: self.writer.build(),
  829|    122|            filter: self.filter.build(),
  830|    122|            format: self.format.build(),
  831|    122|        }
  832|    122|    }
_RINvMCsgSpm5FkEyyU_10env_loggerNtB3_7Builder8from_envNtB3_3EnvEB3_:
  443|    122|    pub fn from_env<'a, E>(env: E) -> Self
  444|    122|    where
  445|    122|        E: Into<Env<'a>>,
  446|    122|    {
  447|    122|        let mut builder = Builder::new();
  448|    122|        builder.parse_env(env);
  449|    122|        builder
  450|    122|    }
_RNvMs_CsgSpm5FkEyyU_10env_loggerNtB4_6Logger7matches:
  897|    986|    pub fn matches(&self, record: &Record) -> bool {
  898|    986|        self.filter.matches(record)
  899|    986|    }
_RNvMCsgSpm5FkEyyU_10env_loggerNtB2_7Builder8try_init:
  792|    122|    pub fn try_init(&mut self) -> Result<(), SetLoggerError> {
  793|    122|        let logger = self.build();
  794|    122|
  795|    122|        let max_level = logger.filter();
  796|    122|        let r = log::set_boxed_logger(Box::new(logger));
  797|    122|
  798|    122|        if r.is_ok() {
  799|      1|            log::set_max_level(max_level);
  800|    121|        }
  801|       |
  802|    122|        r
  803|    122|    }
_RNvMCsgSpm5FkEyyU_10env_loggerNtB2_7Builder3new:
  411|    122|    pub fn new() -> Builder {
  412|    122|        Default::default()
  413|    122|    }
_RINvCsgSpm5FkEyyU_10env_logger17try_init_from_envNtB2_3EnvEB2_:
 1185|    122|pub fn try_init_from_env<'a, E>(env: E) -> Result<(), SetLoggerError>
 1186|    122|where
 1187|    122|    E: Into<Env<'a>>,
 1188|    122|{
 1189|    122|    let mut builder = Builder::from_env(env);
 1190|    122|
 1191|    122|    builder.try_init()
 1192|    122|}
_RNvXs7_CsgSpm5FkEyyU_10env_loggerNtB5_7BuilderNtNtCsg994vJE3n1e_4core7default7Default7default:
  376|    122|#[derive(Default)]
_RNvMs1_CsgSpm5FkEyyU_10env_loggerNtB5_3Env15get_write_style:
 1053|    122|    fn get_write_style(&self) -> Option<String> {
 1054|    122|        self.write_style.get()
 1055|    122|    }
_RINvMs2_CsgSpm5FkEyyU_10env_loggerNtB6_3Var3newReEB6_:
 1059|    244|    fn new<E>(name: E) -> Self
 1060|    244|    where
 1061|    244|        E: Into<Cow<'a, str>>,
 1062|    244|    {
 1063|    244|        Var {
 1064|    244|            name: name.into(),
 1065|    244|            default: None,
 1066|    244|        }
 1067|    244|    }

_RNvXse_NtNtCsfhhu5hQVlEh_9hashbrown3raw5innerINtB5_8RawTablejENtNtNtCsg994vJE3n1e_4core3ops4drop4Drop4dropCs7xWdtGLRam0_22instrument_with_mutate:
 1815|      2|    fn drop(&mut self) {
 1816|      2|        if !self.table.is_empty_singleton() {
 1817|      0|            unsafe {
 1818|      0|                self.drop_elements();
 1819|      0|                self.free_buckets();
 1820|      0|            }
 1821|      2|        }
 1822|      2|    }
_RNvMs9_NtNtCsfhhu5hQVlEh_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE18is_empty_singletonCs7xWdtGLRam0_22instrument_with_mutate:
 1338|      2|    fn is_empty_singleton(&self) -> bool {
 1339|      2|        self.bucket_mask == 0
 1340|      2|    }
_RNvMs8_NtNtCsfhhu5hQVlEh_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE6new_inCs1pefSkL8zGS_10wasmparser:
 1043|      2|    const fn new_in(alloc: A) -> Self {
 1044|      2|        Self {
 1045|      2|            // Be careful to cast the entire slice to a raw pointer.
 1046|      2|            ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
 1047|      2|            bucket_mask: 0,
 1048|      2|            items: 0,
 1049|      2|            growth_left: 0,
 1050|      2|            alloc,
 1051|      2|        }
 1052|      2|    }
_RNvMs4_NtNtCsfhhu5hQVlEh_9hashbrown3raw5innerINtB5_8RawTablejE3newCs1pefSkL8zGS_10wasmparser:
  394|      2|    pub const fn new() -> Self {
  395|      2|        Self {
  396|      2|            table: RawTableInner::new_in(Global),
  397|      2|            marker: PhantomData,
  398|      2|        }
  399|      2|    }

_RNvMNtNtNtCsfhhu5hQVlEh_9hashbrown3raw5inner4sse2NtB2_5Group12static_empty:
   33|      2|    pub const fn static_empty() -> &'static [u8; Group::WIDTH] {
   34|      2|        #[repr(C)]
   35|      2|        struct AlignedBytes {
   36|      2|            _align: [Group; 0],
   37|      2|            bytes: [u8; Group::WIDTH],
   38|      2|        }
   39|      2|        const ALIGNED_BYTES: AlignedBytes = AlignedBytes {
   40|      2|            _align: [],
   41|      2|            bytes: [EMPTY; Group::WIDTH],
   42|      2|        };
   43|      2|        &ALIGNED_BYTES.bytes
   44|      2|    }

_RNvXsa_NtCsbYfomez99t6_9humantime4dateNtB5_9PrecisionNtNtCsg994vJE3n1e_4core3cmp9PartialEq2eq:
   58|    854|#[derive(Debug, Clone, PartialEq, Eq)]
_RNvXs1_NtCsbYfomez99t6_9humantime4dateNtB5_16Rfc3339TimestampNtNtCsg994vJE3n1e_4core3fmt7Display3fmt:
  251|    854|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  252|    854|        use self::Precision::*;
  253|    854|
  254|    854|        let dur = self.0.duration_since(UNIX_EPOCH)
  255|    854|            .expect("all times should be after the epoch");
  256|    854|        let secs_since_epoch = dur.as_secs();
  257|    854|        let nanos = dur.subsec_nanos();
  258|    854|
  259|    854|        if secs_since_epoch >= 253_402_300_800 { // year 9999
  260|      0|            return Err(fmt::Error);
  261|    854|        }
  262|    854|
  263|    854|        /* 2000-03-01 (mod 400 year, immediately after feb29 */
  264|    854|        const LEAPOCH: i64 = 11017;
  265|    854|        const DAYS_PER_400Y: i64 = 365*400 + 97;
  266|    854|        const DAYS_PER_100Y: i64 = 365*100 + 24;
  267|    854|        const DAYS_PER_4Y: i64 = 365*4 + 1;
  268|    854|
  269|    854|        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;
  270|    854|        let secs_of_day = secs_since_epoch % 86400;
  271|    854|
  272|    854|        let mut qc_cycles = days / DAYS_PER_400Y;
  273|    854|        let mut remdays = days % DAYS_PER_400Y;
  274|    854|
  275|    854|        if remdays < 0 {
  276|      0|            remdays += DAYS_PER_400Y;
  277|      0|            qc_cycles -= 1;
  278|    854|        }
  279|       |
  280|    854|        let mut c_cycles = remdays / DAYS_PER_100Y;
  281|    854|        if c_cycles == 4 { c_cycles -= 1; }
  282|    854|        remdays -= c_cycles * DAYS_PER_100Y;
  283|    854|
  284|    854|        let mut q_cycles = remdays / DAYS_PER_4Y;
  285|    854|        if q_cycles == 25 { q_cycles -= 1; }
  286|    854|        remdays -= q_cycles * DAYS_PER_4Y;
  287|    854|
  288|    854|        let mut remyears = remdays / 365;
  289|    854|        if remyears == 4 { remyears -= 1; }
  290|    854|        remdays -= remyears * 365;
  291|    854|
  292|    854|        let mut year = 2000 +
  293|    854|            remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;
  294|    854|
  295|    854|        let months = [31,30,31,30,31,31,30,31,30,31,31,29];
  296|    854|        let mut mon = 0;
  297|  7.68k|        for mon_len in months.iter() {
  298|  7.68k|            mon += 1;
  299|  7.68k|            if remdays < *mon_len {
  300|    854|                break;
  301|  6.83k|            }
  302|  6.83k|            remdays -= *mon_len;
  303|       |        }
  304|    854|        let mday = remdays+1;
  305|    854|        let mon = if mon + 2 > 12 {
  306|      0|            year += 1;
  307|      0|            mon - 10
  308|       |        } else {
  309|    854|            mon + 2
  310|       |        };
  311|       |
  312|    854|        let mut buf: [u8; 30] = [
  313|    854|            // Too long to write as: b"0000-00-00T00:00:00.000000000Z"
  314|    854|            b'0', b'0', b'0', b'0', b'-', b'0', b'0', b'-', b'0', b'0', b'T',
  315|    854|            b'0', b'0', b':', b'0', b'0', b':', b'0', b'0',
  316|    854|            b'.', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'Z',
  317|    854|        ];
  318|    854|        buf[0] = b'0' + (year / 1000) as u8;
  319|    854|        buf[1] = b'0' + (year / 100 % 10) as u8;
  320|    854|        buf[2] = b'0' + (year / 10 % 10) as u8;
  321|    854|        buf[3] = b'0' + (year % 10) as u8;
  322|    854|        buf[5] = b'0' + (mon / 10) as u8;
  323|    854|        buf[6] = b'0' + (mon % 10) as u8;
  324|    854|        buf[8] = b'0' + (mday / 10) as u8;
  325|    854|        buf[9] = b'0' + (mday % 10) as u8;
  326|    854|        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;
  327|    854|        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;
  328|    854|        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;
  329|    854|        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;
  330|    854|        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;
  331|    854|        buf[18] = b'0' + (secs_of_day % 10) as u8;
  332|       |
  333|    854|        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {
  334|    854|            buf[19] = b'Z';
  335|    854|            19
  336|      0|        } else if self.1 == Millis {
  337|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  338|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  339|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  340|      0|            buf[23] = b'Z';
  341|      0|            23
  342|      0|        } else if self.1 == Micros {
  343|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  344|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  345|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  346|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  347|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  348|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  349|      0|            buf[26] = b'Z';
  350|      0|            26
  351|       |        } else {
  352|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  353|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  354|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  355|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  356|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  357|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  358|      0|            buf[26] = b'0' + (nanos / 100 % 10) as u8;
  359|      0|            buf[27] = b'0' + (nanos / 10 % 10) as u8;
  360|      0|            buf[28] = b'0' + (nanos / 1 % 10) as u8;
  361|      0|            // 29th is 'Z'
  362|      0|            29
  363|       |        };
  364|       |
  365|       |        // we know our chars are all ascii
  366|    854|        f.write_str(str::from_utf8(&buf[..=offset]).expect("Conversion to utf8 failed"))
  367|    854|    }
_RNvNtCsbYfomez99t6_9humantime4date22format_rfc3339_seconds:
  212|    854|pub fn format_rfc3339_seconds(system_time: SystemTime) -> Rfc3339Timestamp {
  213|    854|    Rfc3339Timestamp(system_time, Precision::Seconds)
  214|    854|}

_RNvXs12_NtCs1FM8xyLjQX_8indexmap3mapINtB6_8IndexMapNtNtCskqQrqCZBh0M_5alloc6string6StringNtNtNtCs1pefSkL8zGS_10wasmparser9validator5types10EntityTypeENtNtCsg994vJE3n1e_4core7default7Default7defaultB1v_:
 1495|      1|    fn default() -> Self {
 1496|      1|        Self::with_capacity_and_hasher(0, S::default())
 1497|      1|    }
_RNvMs2_NtCs1FM8xyLjQX_8indexmap3mapINtB5_8IndexMapNtNtCskqQrqCZBh0M_5alloc6string6StringNtNtNtCs1pefSkL8zGS_10wasmparser9validator5types10EntityTypeE24with_capacity_and_hasherB1u_:
  167|      1|    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {
  168|      1|        if n == 0 {
  169|      1|            Self::with_hasher(hash_builder)
  170|       |        } else {
  171|      0|            IndexMap {
  172|      0|                core: IndexMapCore::with_capacity(n),
  173|      0|                hash_builder,
  174|      0|            }
  175|       |        }
  176|      1|    }
_RNvXs12_NtCs1FM8xyLjQX_8indexmap3mapINtB6_8IndexMapTNtNtCskqQrqCZBh0M_5alloc6string6StringBO_EINtNtBS_3vec3VecNtNtNtCs1pefSkL8zGS_10wasmparser9validator5types10EntityTypeEENtNtCsg994vJE3n1e_4core7default7Default7defaultB1Q_:
 1495|      1|    fn default() -> Self {
 1496|      1|        Self::with_capacity_and_hasher(0, S::default())
 1497|      1|    }
_RNvMs2_NtCs1FM8xyLjQX_8indexmap3mapINtB5_8IndexMapNtNtCskqQrqCZBh0M_5alloc6string6StringNtNtNtCs1pefSkL8zGS_10wasmparser9validator5types10EntityTypeE11with_hasherB1u_:
  182|      1|    pub const fn with_hasher(hash_builder: S) -> Self {
  183|      1|        IndexMap {
  184|      1|            core: IndexMapCore::new(),
  185|      1|            hash_builder,
  186|      1|        }
  187|      1|    }
_RNvMs2_NtCs1FM8xyLjQX_8indexmap3mapINtB5_8IndexMapTNtNtCskqQrqCZBh0M_5alloc6string6StringBN_EINtNtBR_3vec3VecNtNtNtCs1pefSkL8zGS_10wasmparser9validator5types10EntityTypeEE11with_hasherB1P_:
  182|      1|    pub const fn with_hasher(hash_builder: S) -> Self {
  183|      1|        IndexMap {
  184|      1|            core: IndexMapCore::new(),
  185|      1|            hash_builder,
  186|      1|        }
  187|      1|    }
_RNvMs2_NtCs1FM8xyLjQX_8indexmap3mapINtB5_8IndexMapTNtNtCskqQrqCZBh0M_5alloc6string6StringBN_EINtNtBR_3vec3VecNtNtNtCs1pefSkL8zGS_10wasmparser9validator5types10EntityTypeEE24with_capacity_and_hasherB1P_:
  167|      1|    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {
  168|      1|        if n == 0 {
  169|      1|            Self::with_hasher(hash_builder)
  170|       |        } else {
  171|      0|            IndexMap {
  172|      0|                core: IndexMapCore::with_capacity(n),
  173|      0|                hash_builder,
  174|      0|            }
  175|       |        }
  176|      1|    }

_RNvMs1_NtNtCs1FM8xyLjQX_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCskqQrqCZBh0M_5alloc6string6StringNtNtNtCs1pefSkL8zGS_10wasmparser9validator5types10EntityTypeE3newB1G_:
  124|      1|    pub(crate) const fn new() -> Self {
  125|      1|        IndexMapCore {
  126|      1|            indices: RawTable::new(),
  127|      1|            entries: Vec::new(),
  128|      1|        }
  129|      1|    }
_RNvMs1_NtNtCs1FM8xyLjQX_8indexmap3map4coreINtB5_12IndexMapCoreTNtNtCskqQrqCZBh0M_5alloc6string6StringBZ_EINtNtB13_3vec3VecNtNtNtCs1pefSkL8zGS_10wasmparser9validator5types10EntityTypeEE3newB22_:
  124|      1|    pub(crate) const fn new() -> Self {
  125|      1|        IndexMapCore {
  126|      1|            indices: RawTable::new(),
  127|      1|            entries: Vec::new(),
  128|      1|        }
  129|      1|    }

_RNvCs2gWCgLw9rOz_6leb12815low_bits_of_u64:
   58|     70|pub fn low_bits_of_u64(val: u64) -> u8 {
   59|     70|    let byte = val & (std::u8::MAX as u64);
   60|     70|    low_bits_of_byte(byte as u8)
   61|     70|}
_RNvCs2gWCgLw9rOz_6leb12816low_bits_of_byte:
   52|     70|pub fn low_bits_of_byte(byte: u8) -> u8 {
   53|     70|    byte & !CONTINUATION_BIT
   54|     70|}
_RINvNtCs2gWCgLw9rOz_6leb1285write8unsignedQShECskTcFVVikGfm_12wasm_encoder:
  187|      5|    pub fn unsigned<W>(w: &mut W, mut val: u64) -> Result<usize, io::Error>
  188|      5|    where
  189|      5|        W: ?Sized + io::Write,
  190|      5|    {
  191|      5|        let mut bytes_written = 0;
  192|      5|        loop {
  193|      5|            let mut byte = low_bits_of_u64(val);
  194|      5|            val >>= 7;
  195|      5|            if val != 0 {
  196|      0|                // More bytes to come, so set the continuation bit.
  197|      0|                byte |= CONTINUATION_BIT;
  198|      5|            }
  199|       |
  200|      5|            let buf = [byte];
  201|      5|            w.write_all(&buf)?;
  202|      5|            bytes_written += 1;
  203|      5|
  204|      5|            if val == 0 {
  205|      5|                return Ok(bytes_written);
  206|      0|            }
  207|       |        }
  208|      5|    }
_RINvNtCs2gWCgLw9rOz_6leb1285write8unsignedINtNtCskqQrqCZBh0M_5alloc3vec3VechEECskTcFVVikGfm_12wasm_encoder:
  187|     63|    pub fn unsigned<W>(w: &mut W, mut val: u64) -> Result<usize, io::Error>
  188|     63|    where
  189|     63|        W: ?Sized + io::Write,
  190|     63|    {
  191|     63|        let mut bytes_written = 0;
  192|     65|        loop {
  193|     65|            let mut byte = low_bits_of_u64(val);
  194|     65|            val >>= 7;
  195|     65|            if val != 0 {
  196|      2|                // More bytes to come, so set the continuation bit.
  197|      2|                byte |= CONTINUATION_BIT;
  198|     63|            }
  199|       |
  200|     65|            let buf = [byte];
  201|     65|            w.write_all(&buf)?;
  202|     65|            bytes_written += 1;
  203|     65|
  204|     65|            if val == 0 {
  205|     63|                return Ok(bytes_written);
  206|      2|            }
  207|       |        }
  208|     63|    }

rust_fuzzer_test_input:
  215|    122|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  216|       |                    use std::io::Write;
  217|      0|                    let mut file = std::fs::File::create(path)
  218|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  219|      0|                    writeln!(&mut file, "{:?}", bytes)
  220|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  221|      0|                    return 0;
  222|    122|                }
  223|    122|
  224|    122|                run(bytes);
  225|    122|                0
  226|    122|            }
_RNvNvCs7xWdtGLRam0_22instrument_with_mutate1__3run:
  241|    243|            fn run($bytes: &[u8]) {
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}
LLVMFuzzerTestOneInput:
   58|    122|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|    122|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|    122|    });
   63|    122|
   64|    122|    match test_input {
   65|    122|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|    122|}
_RNCNvCsbM62d8HmELp_13libfuzzer_sys15test_input_wrap0B3_:
   59|    122|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|    122|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|    122|        rust_fuzzer_test_input(data_slice)
   62|    122|    });

_RNvCscNjeUWn5y3T_3log9max_level:
 1383|    987|pub fn max_level() -> LevelFilter {
 1384|    987|    // Since `LevelFilter` is `repr(usize)`,
 1385|    987|    // this transmute is sound if and only if `MAX_LOG_LEVEL_FILTER`
 1386|    987|    // is set to a usize that is a valid discriminant for `LevelFilter`.
 1387|    987|    // Since `MAX_LOG_LEVEL_FILTER` is private, the only time it's set
 1388|    987|    // is by `set_max_level` above, i.e. by casting a `LevelFilter` to `usize`.
 1389|    987|    // So any usize stored in `MAX_LOG_LEVEL_FILTER` is a valid discriminant.
 1390|    987|    unsafe { mem::transmute(MAX_LOG_LEVEL_FILTER.load(Ordering::Relaxed)) }
 1391|    987|}
_RNvXs2_CscNjeUWn5y3T_3logNtB5_5LevelINtNtCsg994vJE3n1e_4core3cmp10PartialOrdNtB5_11LevelFilterE2le:
  511|  2.82k|    fn le(&self, other: &LevelFilter) -> bool {
  512|  2.82k|        *self as usize <= *other as usize
  513|  2.82k|    }
_RNvMsh_CscNjeUWn5y3T_3logNtB5_6Record5level:
  922|    854|    pub fn level(&self) -> Level {
  923|    854|        self.metadata.level()
  924|    854|    }
_RNvMsh_CscNjeUWn5y3T_3logNtB5_6Record8metadata:
  916|    986|    pub fn metadata(&self) -> &Metadata<'a> {
  917|    986|        &self.metadata
  918|    986|    }
_RNvMsj_CscNjeUWn5y3T_3logNtB5_8Metadata5level:
 1198|  1.84k|    pub fn level(&self) -> Level {
 1199|  1.84k|        self.level
 1200|  1.84k|    }
_RNvXsc_CscNjeUWn5y3T_3logNtB5_11LevelFilterNtNtCsg994vJE3n1e_4core3cmp3Ord3cmp:
  735|    366|    fn cmp(&self, other: &LevelFilter) -> cmp::Ordering {
  736|    366|        (*self as usize).cmp(&(*other as usize))
  737|    366|    }
_RNvMsh_CscNjeUWn5y3T_3logNtB5_6Record4args:
  910|    854|    pub fn args(&self) -> &fmt::Arguments<'a> {
  911|    854|        &self.args
  912|    854|    }
_RNvMsj_CscNjeUWn5y3T_3logNtB5_8Metadata6target:
 1204|  1.84k|    pub fn target(&self) -> &'a str {
 1205|  1.84k|        self.target
 1206|  1.84k|    }
_RNvMsh_CscNjeUWn5y3T_3logNtB5_6Record6target:
  928|    854|    pub fn target(&self) -> &'a str {
  929|    854|        self.metadata.target()
  930|    854|    }
_RNvCscNjeUWn5y3T_3log13set_max_level:
 1365|      1|pub fn set_max_level(level: LevelFilter) {
 1366|      1|    MAX_LOG_LEVEL_FILTER.store(level as usize, Ordering::Relaxed)
 1367|      1|}
_RNvMsf_CscNjeUWn5y3T_3logNtB5_11LevelFilter3max:
  774|    244|    pub fn max() -> LevelFilter {
  775|    244|        LevelFilter::Trace
  776|    244|    }
_RNvMsf_CscNjeUWn5y3T_3logNtB5_11LevelFilter10from_usize:
  760|    244|    fn from_usize(u: usize) -> Option<LevelFilter> {
  761|    244|        match u {
  762|      0|            0 => Some(LevelFilter::Off),
  763|      0|            1 => Some(LevelFilter::Error),
  764|      0|            2 => Some(LevelFilter::Warn),
  765|      0|            3 => Some(LevelFilter::Info),
  766|    122|            4 => Some(LevelFilter::Debug),
  767|    122|            5 => Some(LevelFilter::Trace),
  768|      0|            _ => None,
  769|       |        }
  770|    244|    }
_RNvMsi_CscNjeUWn5y3T_3logNtB5_13RecordBuilder6target:
 1090|    986|    pub fn target(&mut self, target: &'a str) -> &mut RecordBuilder<'a> {
 1091|    986|        self.record.metadata.target = target;
 1092|    986|        self
 1093|    986|    }
_RNCNvXsd_CscNjeUWn5y3T_3logNtB7_11LevelFilterNtNtNtCsg994vJE3n1e_4core3str6traits7FromStr8from_str0B7_:
  746|  2.80k|                .position(|&name| eq_ignore_ascii_case(name, level))
_RINvCscNjeUWn5y3T_3log16set_logger_innerNCNvB2_16set_boxed_logger0EB2_:
 1470|    122|fn set_logger_inner<F>(make_logger: F) -> Result<(), SetLoggerError>
 1471|    122|where
 1472|    122|    F: FnOnce() -> &'static dyn Log,
 1473|    122|{
 1474|    122|    let old_state = match STATE.compare_exchange(
 1475|    122|        UNINITIALIZED,
 1476|    122|        INITIALIZING,
 1477|    122|        Ordering::SeqCst,
 1478|    122|        Ordering::SeqCst,
 1479|    122|    ) {
 1480|    122|        Ok(s) | Err(s) => s,
 1481|    122|    };
 1482|    122|    match old_state {
 1483|       |        UNINITIALIZED => {
 1484|      1|            unsafe {
 1485|      1|                LOGGER = make_logger();
 1486|      1|            }
 1487|      1|            STATE.store(INITIALIZED, Ordering::SeqCst);
 1488|      1|            Ok(())
 1489|       |        }
 1490|       |        INITIALIZING => {
 1491|      0|            while STATE.load(Ordering::SeqCst) == INITIALIZING {
 1492|      0|                // TODO: replace with `hint::spin_loop` once MSRV is 1.49.0.
 1493|      0|                #[allow(deprecated)]
 1494|      0|                std::sync::atomic::spin_loop_hint();
 1495|      0|            }
 1496|      0|            Err(SetLoggerError(()))
 1497|       |        }
 1498|    121|        _ => Err(SetLoggerError(())),
 1499|       |    }
 1500|    122|}
_RNCNvCscNjeUWn5y3T_3log20eq_ignore_ascii_case0B3_:
  553|  1.58k|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
_RNvMsi_CscNjeUWn5y3T_3logNtB5_13RecordBuilder5level:
 1083|    986|    pub fn level(&mut self, level: Level) -> &mut RecordBuilder<'a> {
 1084|    986|        self.record.metadata.level = level;
 1085|    986|        self
 1086|    986|    }
_RNvMs6_CscNjeUWn5y3T_3logNtB5_5Level6as_str:
  608|    854|    pub fn as_str(&self) -> &'static str {
  609|    854|        LOG_LEVEL_NAMES[*self as usize]
  610|    854|    }
_RNCNvCscNjeUWn5y3T_3log16set_boxed_logger0B3_:
 1408|      1|    set_logger_inner(|| Box::leak(logger))
_RNvCscNjeUWn5y3T_3log16set_boxed_logger:
 1407|    122|pub fn set_boxed_logger(logger: Box<dyn Log>) -> Result<(), SetLoggerError> {
 1408|    122|    set_logger_inner(|| Box::leak(logger))
 1409|    122|}
_RNvNvCscNjeUWn5y3T_3log20eq_ignore_ascii_case18to_ascii_uppercase:
  542|  3.17k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  3.17k|        if c >= b'a' && c <= b'z' {
  544|  1.58k|            c - b'a' + b'A'
  545|       |        } else {
  546|  1.58k|            c
  547|       |        }
  548|  3.17k|    }
_RNvMsi_CscNjeUWn5y3T_3logNtB5_13RecordBuilder3new:
 1053|    986|    pub fn new() -> RecordBuilder<'a> {
 1054|    986|        RecordBuilder {
 1055|    986|            record: Record {
 1056|    986|                args: format_args!(""),
 1057|    986|                metadata: Metadata::builder().build(),
 1058|    986|                module_path: None,
 1059|    986|                file: None,
 1060|    986|                line: None,
 1061|    986|                #[cfg(feature = "kv_unstable")]
 1062|    986|                key_values: KeyValues(&Option::None::<(kv::Key, kv::Value)>),
 1063|    986|            },
 1064|    986|        }
 1065|    986|    }
_RNCNvXsd_CscNjeUWn5y3T_3logNtB7_11LevelFilterNtNtNtCsg994vJE3n1e_4core3str6traits7FromStr8from_strs_0B7_:
  747|    244|                .map(|p| LevelFilter::from_usize(p).unwrap()),
_RNvCscNjeUWn5y3T_3log20eq_ignore_ascii_case:
  541|  2.80k|fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {
  542|  2.80k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  2.80k|        if c >= b'a' && c <= b'z' {
  544|  2.80k|            c - b'a' + b'A'
  545|  2.80k|        } else {
  546|  2.80k|            c
  547|  2.80k|        }
  548|  2.80k|    }
  549|  2.80k|
  550|  2.80k|    if a.len() == b.len() {
  551|    610|        a.bytes()
  552|    610|            .zip(b.bytes())
  553|    610|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
  554|       |    } else {
  555|  2.19k|        false
  556|       |    }
  557|  2.80k|}
_RNvMsi_CscNjeUWn5y3T_3logNtB5_13RecordBuilder11file_static:
 1118|    986|    pub fn file_static(&mut self, file: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1119|    986|        self.record.file = file.map(MaybeStaticStr::Static);
 1120|    986|        self
 1121|    986|    }
_RNvCscNjeUWn5y3T_3log6logger:
 1573|    986|pub fn logger() -> &'static dyn Log {
 1574|    986|    if STATE.load(Ordering::SeqCst) != INITIALIZED {
 1575|       |        static NOP: NopLogger = NopLogger;
 1576|      0|        &NOP
 1577|       |    } else {
 1578|    986|        unsafe { LOGGER }
 1579|       |    }
 1580|    986|}
_RINvCscNjeUWn5y3T_3log5ok_orNtB2_11LevelFilterNtB2_15ParseLevelErrorEB2_:
  533|    488|fn ok_or<T, E>(t: Option<T>, e: E) -> Result<T, E> {
  534|    488|    match t {
  535|    244|        Some(t) => Ok(t),
  536|    244|        None => Err(e),
  537|       |    }
  538|    488|}
_RNvXsd_CscNjeUWn5y3T_3logNtB5_11LevelFilterNtNtNtCsg994vJE3n1e_4core3str6traits7FromStr8from_str:
  742|    488|    fn from_str(level: &str) -> Result<LevelFilter, Self::Err> {
  743|    488|        ok_or(
  744|    488|            LOG_LEVEL_NAMES
  745|    488|                .iter()
  746|    488|                .position(|&name| eq_ignore_ascii_case(name, level))
  747|    488|                .map(|p| LevelFilter::from_usize(p).unwrap()),
  748|    488|            ParseLevelError(()),
  749|    488|        )
  750|    488|    }
_RNvXsE_CscNjeUWn5y3T_3logNtB5_14MaybeStaticStrNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
  812|  1.97k|#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvXCscNjeUWn5y3T_3logNtB2_5LevelNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
  453|  1.97k|    fn clone(&self) -> Level {
  454|  1.97k|        *self
  455|  1.97k|    }
_RNvMsi_CscNjeUWn5y3T_3logNtB5_13RecordBuilder18module_path_static:
 1104|    986|    pub fn module_path_static(&mut self, path: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1105|    986|        self.record.module_path = path.map(MaybeStaticStr::Static);
 1106|    986|        self
 1107|    986|    }
_RNvXsQ_CscNjeUWn5y3T_3logNtB5_8MetadataNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
 1183|  1.97k|#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvMsh_CscNjeUWn5y3T_3logNtB5_6Record7builder:
  904|    986|    pub fn builder() -> RecordBuilder<'a> {
  905|    986|        RecordBuilder::new()
  906|    986|    }
_RNvMsj_CscNjeUWn5y3T_3logNtB5_8Metadata7builder:
 1192|    986|    pub fn builder() -> MetadataBuilder<'a> {
 1193|    986|        MetadataBuilder::new()
 1194|    986|    }
_RNvMsk_CscNjeUWn5y3T_3logNtB5_15MetadataBuilder3new:
 1238|    986|    pub fn new() -> MetadataBuilder<'a> {
 1239|    986|        MetadataBuilder {
 1240|    986|            metadata: Metadata {
 1241|    986|                level: Level::Info,
 1242|    986|                target: "",
 1243|    986|            },
 1244|    986|        }
 1245|    986|    }
_RNvXs5_CscNjeUWn5y3T_3logNtB5_5LevelNtNtCsg994vJE3n1e_4core3fmt7Display3fmt:
  576|    854|    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
  577|    854|        fmt.pad(self.as_str())
  578|    854|    }
_RNvMsi_CscNjeUWn5y3T_3logNtB5_13RecordBuilder5build:
 1140|    986|    pub fn build(&self) -> Record<'a> {
 1141|    986|        self.record.clone()
 1142|    986|    }
_RNvCscNjeUWn5y3T_3log17___private_api_log:
 1591|    986|    if kvs.is_some() {
 1592|      0|        panic!(
 1593|      0|            "key-value support is experimental and must be enabled using the `kv_unstable` feature"
 1594|      0|        )
 1595|    986|    }
 1596|    986|
 1597|    986|    logger().log(
 1598|    986|        &Record::builder()
 1599|    986|            .args(args)
 1600|    986|            .level(level)
 1601|    986|            .target(target)
 1602|    986|            .module_path_static(Some(module_path))
 1603|    986|            .file_static(Some(file))
 1604|    986|            .line(Some(line))
 1605|    986|            .build(),
 1606|    986|    );
 1607|    986|}
_RNvXsN_CscNjeUWn5y3T_3logNtB5_6RecordNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
  873|    986|#[derive(Clone, Debug)]
_RNvMsi_CscNjeUWn5y3T_3logNtB5_13RecordBuilder4args:
 1069|    986|    pub fn args(&mut self, args: fmt::Arguments<'a>) -> &mut RecordBuilder<'a> {
 1070|    986|        self.record.args = args;
 1071|    986|        self
 1072|    986|    }
_RNvMsi_CscNjeUWn5y3T_3logNtB5_13RecordBuilder4line:
 1125|    986|    pub fn line(&mut self, line: Option<u32>) -> &mut RecordBuilder<'a> {
 1126|    986|        self.record.line = line;
 1127|    986|        self
 1128|    986|    }
_RNvMsk_CscNjeUWn5y3T_3logNtB5_15MetadataBuilder5build:
 1263|    986|    pub fn build(&self) -> Metadata<'a> {
 1264|    986|        self.metadata.clone()
 1265|    986|    }

_RNvMs2_NtCs9d4qotYaTIf_9once_cell3impINtB5_8OnceCellNtNtCskqQrqCZBh0M_5alloc6string6StringE14is_initializedCs7xWdtGLRam0_22instrument_with_mutate:
   59|    122|    pub(crate) fn is_initialized(&self) -> bool {
   60|    122|        // An `Acquire` load is enough because that makes all the initialization
   61|    122|        // operations visible to us, and, this being a fast path, weaker
   62|    122|        // ordering helps with performance. This `Acquire` synchronizes with
   63|    122|        // `SeqCst` operations on the slow path.
   64|    122|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   65|    122|    }

_RNvMs4_NtCs9d4qotYaTIf_9once_cell4syncINtB5_8OnceCellNtNtCskqQrqCZBh0M_5alloc6string6StringE3getCs7xWdtGLRam0_22instrument_with_mutate:
  922|    122|        pub fn get(&self) -> Option<&T> {
  923|    122|            if self.0.is_initialized() {
  924|       |                // Safe b/c value is initialized.
  925|      0|                Some(unsafe { self.get_unchecked() })
  926|       |            } else {
  927|    122|                None
  928|       |            }
  929|    122|        }

_RINvXs0_NtNtCsjh8jLldxRdx_4rand13distributions7integerNtB8_8StandardINtNtB8_12distribution12DistributionmE6sampleNtNtNtBa_4rngs5small8SmallRngECs7xWdtGLRam0_22instrument_with_mutate:
   37|    255|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u32 {
   38|    255|        rng.next_u32()
   39|    255|    }
_RINvXs1_NtNtCsjh8jLldxRdx_4rand13distributions7integerNtB8_8StandardINtNtB8_12distribution12DistributionyE6sampleNtNtNtBa_4rngs5small8SmallRngECs7xWdtGLRam0_22instrument_with_mutate:
   44|    244|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u64 {
   45|    244|        rng.next_u64()
   46|    244|    }
_RINvXs0_NtNtCsjh8jLldxRdx_4rand13distributions7integerNtB8_8StandardINtNtB8_12distribution12DistributionmE6sampleNtNtNtBa_4rngs5small8SmallRngECsb6KoqmGnaUT_11wasm_mutate:
   37|     39|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u32 {
   38|     39|        rng.next_u32()
   39|     39|    }
_RINvXs3_NtNtCsjh8jLldxRdx_4rand13distributions7integerNtB8_8StandardINtNtB8_12distribution12DistributionjE6sampleNtNtNtBa_4rngs5small8SmallRngECsb6KoqmGnaUT_11wasm_mutate:
   68|      4|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> usize {
   69|      4|        rng.next_u64() as usize
   70|      4|    }

_RINvXs4_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtNtNtCsg994vJE3n1e_4core3ops5range5RangemEINtB6_11SampleRangemE13sample_singleNtNtNtBa_4rngs5small8SmallRngECs7xWdtGLRam0_22instrument_with_mutate:
  359|    123|    fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> T {
  360|    123|        T::Sampler::sample_single(self.start, self.end, rng)
  361|    123|    }
_RNvXs2_NtNtCsjh8jLldxRdx_4rand13distributions7uniformmINtB5_12SampleBorrowmE6borrowCs7xWdtGLRam0_22instrument_with_mutate:
  332|    492|    fn borrow(&self) -> &Borrowed {
  333|    492|        self
  334|    492|    }
_RINvXsB_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtB6_10UniformIntmENtB6_14UniformSampler13sample_singleNtNtNtBa_4rngs5small8SmallRngmmECs7xWdtGLRam0_22instrument_with_mutate:
  507|    123|            fn sample_single<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Self::X
  508|    123|            where
  509|    123|                B1: SampleBorrow<Self::X> + Sized,
  510|    123|                B2: SampleBorrow<Self::X> + Sized,
  511|    123|            {
  512|    123|                let low = *low_b.borrow();
  513|    123|                let high = *high_b.borrow();
  514|    123|                assert!(low < high, "UniformSampler::sample_single: low >= high");
  515|    123|                Self::sample_single_inclusive(low, high - 1, rng)
  516|    123|            }
_RNvXs4_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtNtNtCsg994vJE3n1e_4core3ops5range5RangemEINtB5_11SampleRangemE8is_emptyCs7xWdtGLRam0_22instrument_with_mutate:
  364|    123|    fn is_empty(&self) -> bool {
  365|    123|        !(self.start < self.end)
  366|    123|    }
_RINvXsB_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtB6_10UniformIntmENtB6_14UniformSampler23sample_single_inclusiveNtNtNtBa_4rngs5small8SmallRngmmECs7xWdtGLRam0_22instrument_with_mutate:
  519|    123|            fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Self::X
  520|    123|            where
  521|    123|                B1: SampleBorrow<Self::X> + Sized,
  522|    123|                B2: SampleBorrow<Self::X> + Sized,
  523|    123|            {
  524|    123|                let low = *low_b.borrow();
  525|    123|                let high = *high_b.borrow();
  526|    123|                assert!(low <= high, "UniformSampler::sample_single_inclusive: low > high");
  527|    123|                let range = high.wrapping_sub(low).wrapping_add(1) as $unsigned as $u_large;
  528|    123|                // If the above resulted in wrap-around to 0, the range is $ty::MIN..=$ty::MAX,
  529|    123|                // and any integer will do.
  530|    123|                if range == 0 {
  531|      0|                    return rng.gen();
  532|    123|                }
  533|       |
  534|    123|                let zone = if ::core::$unsigned::MAX <= ::core::u16::MAX as $unsigned {
  535|       |                    // Using a modulus is faster than the approximation for
  536|       |                    // i8 and i16. I suppose we trade the cost of one
  537|       |                    // modulus for near-perfect branch prediction.
  538|      0|                    let unsigned_max: $u_large = ::core::$u_large::MAX;
  539|      0|                    let ints_to_reject = (unsigned_max - range + 1) % range;
  540|      0|                    unsigned_max - ints_to_reject
  541|       |                } else {
  542|       |                    // conservative but fast approximation. `- 1` is necessary to allow the
  543|       |                    // same comparison without bias.
  544|    123|                    (range << range.leading_zeros()).wrapping_sub(1)
  545|       |                };
  546|       |
  547|    255|                loop {
  548|    255|                    let v: $u_large = rng.gen();
  549|    255|                    let (hi, lo) = v.wmul(range);
  550|    255|                    if lo <= zone {
  551|    123|                        return low.wrapping_add(hi as $ty);
  552|    132|                    }
  553|       |                }
  554|    123|            }
_RINvXs5_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtNtNtCsg994vJE3n1e_4core3ops5range14RangeInclusivelEINtB6_11SampleRangelE13sample_singleNtNtNtBa_4rngs5small8SmallRngECsb6KoqmGnaUT_11wasm_mutate:
  371|     28|    fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> T {
  372|     28|        T::Sampler::sample_single_inclusive(self.start(), self.end(), rng)
  373|     28|    }
_RINvXsF_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtB6_10UniformIntjENtB6_14UniformSampler23sample_single_inclusiveNtNtNtBa_4rngs5small8SmallRngRjB2n_ECsb6KoqmGnaUT_11wasm_mutate:
  519|      2|            fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Self::X
  520|      2|            where
  521|      2|                B1: SampleBorrow<Self::X> + Sized,
  522|      2|                B2: SampleBorrow<Self::X> + Sized,
  523|      2|            {
  524|      2|                let low = *low_b.borrow();
  525|      2|                let high = *high_b.borrow();
  526|      2|                assert!(low <= high, "UniformSampler::sample_single_inclusive: low > high");
  527|      2|                let range = high.wrapping_sub(low).wrapping_add(1) as $unsigned as $u_large;
  528|      2|                // If the above resulted in wrap-around to 0, the range is $ty::MIN..=$ty::MAX,
  529|      2|                // and any integer will do.
  530|      2|                if range == 0 {
  531|      0|                    return rng.gen();
  532|      2|                }
  533|       |
  534|      2|                let zone = if ::core::$unsigned::MAX <= ::core::u16::MAX as $unsigned {
  535|       |                    // Using a modulus is faster than the approximation for
  536|       |                    // i8 and i16. I suppose we trade the cost of one
  537|       |                    // modulus for near-perfect branch prediction.
  538|      0|                    let unsigned_max: $u_large = ::core::$u_large::MAX;
  539|      0|                    let ints_to_reject = (unsigned_max - range + 1) % range;
  540|      0|                    unsigned_max - ints_to_reject
  541|       |                } else {
  542|       |                    // conservative but fast approximation. `- 1` is necessary to allow the
  543|       |                    // same comparison without bias.
  544|      2|                    (range << range.leading_zeros()).wrapping_sub(1)
  545|       |                };
  546|       |
  547|      4|                loop {
  548|      4|                    let v: $u_large = rng.gen();
  549|      4|                    let (hi, lo) = v.wmul(range);
  550|      4|                    if lo <= zone {
  551|      2|                        return low.wrapping_add(hi as $ty);
  552|      2|                    }
  553|       |                }
  554|      2|            }
_RINvXsB_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtB6_10UniformIntmENtB6_14UniformSampler23sample_single_inclusiveNtNtNtBa_4rngs5small8SmallRngmmECsb6KoqmGnaUT_11wasm_mutate:
  519|      3|            fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Self::X
  520|      3|            where
  521|      3|                B1: SampleBorrow<Self::X> + Sized,
  522|      3|                B2: SampleBorrow<Self::X> + Sized,
  523|      3|            {
  524|      3|                let low = *low_b.borrow();
  525|      3|                let high = *high_b.borrow();
  526|      3|                assert!(low <= high, "UniformSampler::sample_single_inclusive: low > high");
  527|      3|                let range = high.wrapping_sub(low).wrapping_add(1) as $unsigned as $u_large;
  528|      3|                // If the above resulted in wrap-around to 0, the range is $ty::MIN..=$ty::MAX,
  529|      3|                // and any integer will do.
  530|      3|                if range == 0 {
  531|      0|                    return rng.gen();
  532|      3|                }
  533|       |
  534|      3|                let zone = if ::core::$unsigned::MAX <= ::core::u16::MAX as $unsigned {
  535|       |                    // Using a modulus is faster than the approximation for
  536|       |                    // i8 and i16. I suppose we trade the cost of one
  537|       |                    // modulus for near-perfect branch prediction.
  538|      0|                    let unsigned_max: $u_large = ::core::$u_large::MAX;
  539|      0|                    let ints_to_reject = (unsigned_max - range + 1) % range;
  540|      0|                    unsigned_max - ints_to_reject
  541|       |                } else {
  542|       |                    // conservative but fast approximation. `- 1` is necessary to allow the
  543|       |                    // same comparison without bias.
  544|      3|                    (range << range.leading_zeros()).wrapping_sub(1)
  545|       |                };
  546|       |
  547|      6|                loop {
  548|      6|                    let v: $u_large = rng.gen();
  549|      6|                    let (hi, lo) = v.wmul(range);
  550|      6|                    if lo <= zone {
  551|      3|                        return low.wrapping_add(hi as $ty);
  552|      3|                    }
  553|       |                }
  554|      3|            }
_RINvXs5_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtNtNtCsg994vJE3n1e_4core3ops5range14RangeInclusivejEINtB6_11SampleRangejE13sample_singleNtNtNtBa_4rngs5small8SmallRngECsb6KoqmGnaUT_11wasm_mutate:
  371|      2|    fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> T {
  372|      2|        T::Sampler::sample_single_inclusive(self.start(), self.end(), rng)
  373|      2|    }
_RNvXs2_NtNtCsjh8jLldxRdx_4rand13distributions7uniformmINtB5_12SampleBorrowmE6borrowCsb6KoqmGnaUT_11wasm_mutate:
  332|     12|    fn borrow(&self) -> &Borrowed {
  333|     12|        self
  334|     12|    }
_RNvXs5_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtNtNtCsg994vJE3n1e_4core3ops5range14RangeInclusivejEINtB5_11SampleRangejE8is_emptyCsb6KoqmGnaUT_11wasm_mutate:
  376|      2|    fn is_empty(&self) -> bool {
  377|      2|        !(self.start() <= self.end())
  378|      2|    }
_RINvXs4_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtNtNtCsg994vJE3n1e_4core3ops5range5RangemEINtB6_11SampleRangemE13sample_singleNtNtNtBa_4rngs5small8SmallRngECsb6KoqmGnaUT_11wasm_mutate:
  359|      3|    fn sample_single<R: RngCore + ?Sized>(self, rng: &mut R) -> T {
  360|      3|        T::Sampler::sample_single(self.start, self.end, rng)
  361|      3|    }
_RINvXsB_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtB6_10UniformIntmENtB6_14UniformSampler13sample_singleNtNtNtBa_4rngs5small8SmallRngmmECsb6KoqmGnaUT_11wasm_mutate:
  507|      3|            fn sample_single<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Self::X
  508|      3|            where
  509|      3|                B1: SampleBorrow<Self::X> + Sized,
  510|      3|                B2: SampleBorrow<Self::X> + Sized,
  511|      3|            {
  512|      3|                let low = *low_b.borrow();
  513|      3|                let high = *high_b.borrow();
  514|      3|                assert!(low < high, "UniformSampler::sample_single: low >= high");
  515|      3|                Self::sample_single_inclusive(low, high - 1, rng)
  516|      3|            }
_RNvXs4_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtNtNtCsg994vJE3n1e_4core3ops5range5RangemEINtB5_11SampleRangemE8is_emptyCsb6KoqmGnaUT_11wasm_mutate:
  364|      3|    fn is_empty(&self) -> bool {
  365|      3|        !(self.start < self.end)
  366|      3|    }
_RNvXs3_NtNtCsjh8jLldxRdx_4rand13distributions7uniformRlINtB5_12SampleBorrowlE6borrowCsb6KoqmGnaUT_11wasm_mutate:
  340|     56|    fn borrow(&self) -> &Borrowed {
  341|     56|        *self
  342|     56|    }
_RNvXs5_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtNtNtCsg994vJE3n1e_4core3ops5range14RangeInclusivelEINtB5_11SampleRangelE8is_emptyCsb6KoqmGnaUT_11wasm_mutate:
  376|     28|    fn is_empty(&self) -> bool {
  377|     28|        !(self.start() <= self.end())
  378|     28|    }
_RNvXs3_NtNtCsjh8jLldxRdx_4rand13distributions7uniformRjINtB5_12SampleBorrowjE6borrowCsb6KoqmGnaUT_11wasm_mutate:
  340|      4|    fn borrow(&self) -> &Borrowed {
  341|      4|        *self
  342|      4|    }
_RINvXsp_NtNtCsjh8jLldxRdx_4rand13distributions7uniformINtB6_10UniformIntlENtB6_14UniformSampler23sample_single_inclusiveNtNtNtBa_4rngs5small8SmallRngRlB2n_ECsb6KoqmGnaUT_11wasm_mutate:
  519|     28|            fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>(low_b: B1, high_b: B2, rng: &mut R) -> Self::X
  520|     28|            where
  521|     28|                B1: SampleBorrow<Self::X> + Sized,
  522|     28|                B2: SampleBorrow<Self::X> + Sized,
  523|     28|            {
  524|     28|                let low = *low_b.borrow();
  525|     28|                let high = *high_b.borrow();
  526|     28|                assert!(low <= high, "UniformSampler::sample_single_inclusive: low > high");
  527|     28|                let range = high.wrapping_sub(low).wrapping_add(1) as $unsigned as $u_large;
  528|     28|                // If the above resulted in wrap-around to 0, the range is $ty::MIN..=$ty::MAX,
  529|     28|                // and any integer will do.
  530|     28|                if range == 0 {
  531|      0|                    return rng.gen();
  532|     28|                }
  533|       |
  534|     28|                let zone = if ::core::$unsigned::MAX <= ::core::u16::MAX as $unsigned {
  535|       |                    // Using a modulus is faster than the approximation for
  536|       |                    // i8 and i16. I suppose we trade the cost of one
  537|       |                    // modulus for near-perfect branch prediction.
  538|      0|                    let unsigned_max: $u_large = ::core::$u_large::MAX;
  539|      0|                    let ints_to_reject = (unsigned_max - range + 1) % range;
  540|      0|                    unsigned_max - ints_to_reject
  541|       |                } else {
  542|       |                    // conservative but fast approximation. `- 1` is necessary to allow the
  543|       |                    // same comparison without bias.
  544|     28|                    (range << range.leading_zeros()).wrapping_sub(1)
  545|       |                };
  546|       |
  547|     33|                loop {
  548|     33|                    let v: $u_large = rng.gen();
  549|     33|                    let (hi, lo) = v.wmul(range);
  550|     33|                    if lo <= zone {
  551|     28|                        return low.wrapping_add(hi as $ty);
  552|      5|                    }
  553|       |                }
  554|     28|            }

_RNvXs1_NtNtCsjh8jLldxRdx_4rand13distributions5utilsmNtB5_16WideningMultiply4wmul:
   26|    294|            fn wmul(self, x: $ty) -> Self::Output {
   27|    294|                let tmp = (self as $wide) * (x as $wide);
   28|    294|                ((tmp >> $shift) as $ty, tmp as $ty)
   29|    294|            }
_RNvXs2_NtNtCsjh8jLldxRdx_4rand13distributions5utilsyNtB5_16WideningMultiply4wmul:
   26|      4|            fn wmul(self, x: $ty) -> Self::Output {
   27|      4|                let tmp = (self as $wide) * (x as $wide);
   28|      4|                ((tmp >> $shift) as $ty, tmp as $ty)
   29|      4|            }
_RNvXs4_NtNtCsjh8jLldxRdx_4rand13distributions5utilsjNtB5_16WideningMultiply4wmul:
  130|      4|            fn wmul(self, x: usize) -> Self::Output {
  131|      4|                let (high, low) = (self as $ty).wmul(x as $ty);
  132|      4|                (high as usize, low as usize)
  133|      4|            }

_RINvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng9gen_rangemINtNtNtCsg994vJE3n1e_4core3ops5range5RangemEECs7xWdtGLRam0_22instrument_with_mutate:
  129|    123|    fn gen_range<T, R>(&mut self, range: R) -> T
  130|    123|    where
  131|    123|        T: SampleUniform,
  132|    123|        R: SampleRange<T>
  133|    123|    {
  134|    123|        assert!(!range.is_empty(), "cannot sample empty range");
  135|    123|        range.sample_single(self)
  136|    123|    }
_RINvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng3genmECs7xWdtGLRam0_22instrument_with_mutate:
   93|    255|    fn gen<T>(&mut self) -> T
   94|    255|    where Standard: Distribution<T> {
   95|    255|        Standard.sample(self)
   96|    255|    }
_RINvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng3genyECs7xWdtGLRam0_22instrument_with_mutate:
   93|    244|    fn gen<T>(&mut self) -> T
   94|    244|    where Standard: Distribution<T> {
   95|    244|        Standard.sample(self)
   96|    244|    }
_RINvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng3genmECsb6KoqmGnaUT_11wasm_mutate:
   93|     39|    fn gen<T>(&mut self) -> T
   94|     39|    where Standard: Distribution<T> {
   95|     39|        Standard.sample(self)
   96|     39|    }
_RINvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng3genjECsb6KoqmGnaUT_11wasm_mutate:
   93|      4|    fn gen<T>(&mut self) -> T
   94|      4|    where Standard: Distribution<T> {
   95|      4|        Standard.sample(self)
   96|      4|    }
_RINvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng9gen_rangemINtNtNtCsg994vJE3n1e_4core3ops5range5RangemEECsb6KoqmGnaUT_11wasm_mutate:
  129|      3|    fn gen_range<T, R>(&mut self, range: R) -> T
  130|      3|    where
  131|      3|        T: SampleUniform,
  132|      3|        R: SampleRange<T>
  133|      3|    {
  134|      3|        assert!(!range.is_empty(), "cannot sample empty range");
  135|      3|        range.sample_single(self)
  136|      3|    }
_RINvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng9gen_rangelINtNtNtCsg994vJE3n1e_4core3ops5range14RangeInclusivelEECsb6KoqmGnaUT_11wasm_mutate:
  129|     28|    fn gen_range<T, R>(&mut self, range: R) -> T
  130|     28|    where
  131|     28|        T: SampleUniform,
  132|     28|        R: SampleRange<T>
  133|     28|    {
  134|     28|        assert!(!range.is_empty(), "cannot sample empty range");
  135|     28|        range.sample_single(self)
  136|     28|    }
_RINvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtNtB9_3rng3Rng9gen_rangejINtNtNtCsg994vJE3n1e_4core3ops5range14RangeInclusivejEECsb6KoqmGnaUT_11wasm_mutate:
  129|      2|    fn gen_range<T, R>(&mut self, range: R) -> T
  130|      2|    where
  131|      2|        T: SampleUniform,
  132|      2|        R: SampleRange<T>
  133|      2|    {
  134|      2|        assert!(!range.is_empty(), "cannot sample empty range");
  135|      2|        range.sample_single(self)
  136|      2|    }

_RNvXs_NtNtCsjh8jLldxRdx_4rand4rngs5smallNtB4_8SmallRngNtCscdvH8mb3oAi_9rand_core11SeedableRng9from_seed:
  109|    124|    fn from_seed(seed: Self::Seed) -> Self {
  110|    124|        SmallRng(Rng::from_seed(seed))
  111|    124|    }
_RNvXNtNtCsjh8jLldxRdx_4rand4rngs5smallNtB2_8SmallRngNtCscdvH8mb3oAi_9rand_core7RngCore8next_u64:
   90|    248|    fn next_u64(&mut self) -> u64 {
   91|    248|        self.0.next_u64()
   92|    248|    }
_RNvXNtNtCsjh8jLldxRdx_4rand4rngs5smallNtB2_8SmallRngNtCscdvH8mb3oAi_9rand_core7RngCore8next_u32:
   85|    294|    fn next_u32(&mut self) -> u32 {
   86|    294|        self.0.next_u32()
   87|    294|    }

_RNvXs_NtNtCsjh8jLldxRdx_4rand4rngs18xoshiro256plusplusNtB4_18Xoshiro256PlusPlusNtCscdvH8mb3oAi_9rand_core7RngCore8next_u32:
   63|    294|    fn next_u32(&mut self) -> u32 {
   64|    294|        // The lowest bits have some linear dependencies, so we use the
   65|    294|        // upper bits instead.
   66|    294|        (self.next_u64() >> 32) as u32
   67|    294|    }
_RNCNvXNtNtCsjh8jLldxRdx_4rand4rngs18xoshiro256plusplusNtB4_18Xoshiro256PlusPlusNtCscdvH8mb3oAi_9rand_core11SeedableRng9from_seed0Cs7xWdtGLRam0_22instrument_with_mutate:
   35|    122|        if seed.iter().all(|&x| x == 0) {
_RNvXNtNtCsjh8jLldxRdx_4rand4rngs18xoshiro256plusplusNtB2_18Xoshiro256PlusPlusNtCscdvH8mb3oAi_9rand_core11SeedableRng9from_seed:
   34|    124|    fn from_seed(seed: [u8; 32]) -> Xoshiro256PlusPlus {
   35|    124|        if seed.iter().all(|&x| x == 0) {
   36|      0|            return Self::seed_from_u64(0);
   37|    124|        }
   38|    124|        let mut state = [0; 4];
   39|    124|        read_u64_into(&seed, &mut state);
   40|    124|        Xoshiro256PlusPlus { s: state }
   41|    124|    }
_RNvXs_NtNtCsjh8jLldxRdx_4rand4rngs18xoshiro256plusplusNtB4_18Xoshiro256PlusPlusNtCscdvH8mb3oAi_9rand_core7RngCore8next_u64:
   70|    542|    fn next_u64(&mut self) -> u64 {
   71|    542|        let result_plusplus = self.s[0]
   72|    542|            .wrapping_add(self.s[3])
   73|    542|            .rotate_left(23)
   74|    542|            .wrapping_add(self.s[0]);
   75|    542|
   76|    542|        let t = self.s[1] << 17;
   77|    542|
   78|    542|        self.s[2] ^= self.s[0];
   79|    542|        self.s[3] ^= self.s[1];
   80|    542|        self.s[1] ^= self.s[2];
   81|    542|        self.s[0] ^= self.s[3];
   82|    542|
   83|    542|        self.s[2] ^= t;
   84|    542|
   85|    542|        self.s[3] = self.s[3].rotate_left(45);
   86|    542|
   87|    542|        result_plusplus
   88|    542|    }
_RNCNvXNtNtCsjh8jLldxRdx_4rand4rngs18xoshiro256plusplusNtB4_18Xoshiro256PlusPlusNtCscdvH8mb3oAi_9rand_core11SeedableRng9from_seed0Csb6KoqmGnaUT_11wasm_mutate:
   35|      2|        if seed.iter().all(|&x| x == 0) {

_RNvNtCscdvH8mb3oAi_9rand_core2le13read_u64_into:
   27|    124|pub fn read_u64_into(src: &[u8], dst: &mut [u64]) {
   28|    124|    assert!(src.len() >= 8 * dst.len());
   29|    496|    for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(8)) {
   30|    496|        *out = u64::from_le_bytes(chunk.try_into().unwrap());
   31|    496|    }
   32|    124|}

_RNvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtCscdvH8mb3oAi_9rand_core11SeedableRng13seed_from_u64Cs7xWdtGLRam0_22instrument_with_mutate:
  335|    122|    fn seed_from_u64(mut state: u64) -> Self {
  336|    122|        // We use PCG32 to generate a u32 sequence, and copy to the seed
  337|    122|        fn pcg32(state: &mut u64) -> [u8; 4] {
  338|    122|            const MUL: u64 = 6364136223846793005;
  339|    122|            const INC: u64 = 11634580027462260723;
  340|    122|
  341|    122|            // We advance the state first (to get away from the input value,
  342|    122|            // in case it has low Hamming Weight).
  343|    122|            *state = state.wrapping_mul(MUL).wrapping_add(INC);
  344|    122|            let state = *state;
  345|    122|
  346|    122|            // Use PCG output function with to_le to generate x:
  347|    122|            let xorshifted = (((state >> 18) ^ state) >> 27) as u32;
  348|    122|            let rot = (state >> 59) as u32;
  349|    122|            let x = xorshifted.rotate_right(rot);
  350|    122|            x.to_le_bytes()
  351|    122|        }
  352|    122|
  353|    122|        let mut seed = Self::Seed::default();
  354|    122|        let mut iter = seed.as_mut().chunks_exact_mut(4);
  355|  1.09k|        for chunk in &mut iter {
  356|    976|            chunk.copy_from_slice(&pcg32(&mut state));
  357|    976|        }
  358|    122|        let rem = iter.into_remainder();
  359|    122|        if !rem.is_empty() {
  360|      0|            rem.copy_from_slice(&pcg32(&mut state)[..rem.len()]);
  361|    122|        }
  362|       |
  363|    122|        Self::from_seed(seed)
  364|    122|    }
_RNvYNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngNtCscdvH8mb3oAi_9rand_core11SeedableRng13seed_from_u64Csb6KoqmGnaUT_11wasm_mutate:
  335|      2|    fn seed_from_u64(mut state: u64) -> Self {
  336|      2|        // We use PCG32 to generate a u32 sequence, and copy to the seed
  337|      2|        fn pcg32(state: &mut u64) -> [u8; 4] {
  338|      2|            const MUL: u64 = 6364136223846793005;
  339|      2|            const INC: u64 = 11634580027462260723;
  340|      2|
  341|      2|            // We advance the state first (to get away from the input value,
  342|      2|            // in case it has low Hamming Weight).
  343|      2|            *state = state.wrapping_mul(MUL).wrapping_add(INC);
  344|      2|            let state = *state;
  345|      2|
  346|      2|            // Use PCG output function with to_le to generate x:
  347|      2|            let xorshifted = (((state >> 18) ^ state) >> 27) as u32;
  348|      2|            let rot = (state >> 59) as u32;
  349|      2|            let x = xorshifted.rotate_right(rot);
  350|      2|            x.to_le_bytes()
  351|      2|        }
  352|      2|
  353|      2|        let mut seed = Self::Seed::default();
  354|      2|        let mut iter = seed.as_mut().chunks_exact_mut(4);
  355|     18|        for chunk in &mut iter {
  356|     16|            chunk.copy_from_slice(&pcg32(&mut state));
  357|     16|        }
  358|      2|        let rem = iter.into_remainder();
  359|      2|        if !rem.is_empty() {
  360|      0|            rem.copy_from_slice(&pcg32(&mut state)[..rem.len()]);
  361|      2|        }
  362|       |
  363|      2|        Self::from_seed(seed)
  364|      2|    }
_RNvNvNtCscdvH8mb3oAi_9rand_core11SeedableRng13seed_from_u645pcg32:
  337|    992|        fn pcg32(state: &mut u64) -> [u8; 4] {
  338|    992|            const MUL: u64 = 6364136223846793005;
  339|    992|            const INC: u64 = 11634580027462260723;
  340|    992|
  341|    992|            // We advance the state first (to get away from the input value,
  342|    992|            // in case it has low Hamming Weight).
  343|    992|            *state = state.wrapping_mul(MUL).wrapping_add(INC);
  344|    992|            let state = *state;
  345|    992|
  346|    992|            // Use PCG output function with to_le to generate x:
  347|    992|            let xorshifted = (((state >> 18) ^ state) >> 27) as u32;
  348|    992|            let rot = (state >> 59) as u32;
  349|    992|            let x = xorshifted.rotate_right(rot);
  350|    992|            x.to_le_bytes()
  351|    992|        }

_RNvXsl_Cs5gFEH6UN2j3_9termcolorNtB5_6BufferNtB5_10WriteColor9set_color:
 1172|  2.56k|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
 1173|  2.56k|        match self.0 {
 1174|  2.56k|            BufferInner::NoColor(ref mut w) => w.set_color(spec),
 1175|      0|            BufferInner::Ansi(ref mut w) => w.set_color(spec),
 1176|       |            #[cfg(windows)]
 1177|       |            BufferInner::Windows(ref mut w) => w.set_color(spec),
 1178|       |        }
 1179|  2.56k|    }
_RNvXsn_Cs5gFEH6UN2j3_9termcolorINtB5_7NoColorINtNtCskqQrqCZBh0M_5alloc3vec3VechEENtNtCsbtOQBIHS4qd_3std2io5Write5writeCsgSpm5FkEyyU_10env_logger:
 1225|  16.6k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1226|  16.6k|        self.0.write(buf)
 1227|  16.6k|    }
_RNvXsk_Cs5gFEH6UN2j3_9termcolorNtB5_6BufferNtNtCsbtOQBIHS4qd_3std2io5Write5write:
 1140|  16.6k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1141|  16.6k|        match self.0 {
 1142|  16.6k|            BufferInner::NoColor(ref mut w) => w.write(buf),
 1143|      0|            BufferInner::Ansi(ref mut w) => w.write(buf),
 1144|       |            #[cfg(windows)]
 1145|       |            BufferInner::Windows(ref mut w) => w.write(buf),
 1146|       |        }
 1147|  16.6k|    }
_RNvXsL_Cs5gFEH6UN2j3_9termcolorNtB5_9ColorSpecNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
 1579|  1.70k|#[derive(Clone, Debug, Eq, PartialEq)]
_RNvXsR_Cs5gFEH6UN2j3_9termcolorNtB5_5ColorNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
 1805|  1.70k|#[derive(Clone, Copy, Debug, Eq, PartialEq)]
_RNvXso_Cs5gFEH6UN2j3_9termcolorINtB5_7NoColorINtNtCskqQrqCZBh0M_5alloc3vec3VechEENtB5_10WriteColor9set_colorCsgSpm5FkEyyU_10env_logger:
 1242|  2.56k|    fn set_color(&mut self, _: &ColorSpec) -> io::Result<()> {
 1243|  2.56k|        Ok(())
 1244|  2.56k|    }
_RNvXso_Cs5gFEH6UN2j3_9termcolorINtB5_7NoColorINtNtCskqQrqCZBh0M_5alloc3vec3VechEENtB5_10WriteColor5resetCsgSpm5FkEyyU_10env_logger:
 1247|  2.56k|    fn reset(&mut self) -> io::Result<()> {
 1248|  2.56k|        Ok(())
 1249|  2.56k|    }
_RNvXsl_Cs5gFEH6UN2j3_9termcolorNtB5_6BufferNtB5_10WriteColor5reset:
 1182|  2.56k|    fn reset(&mut self) -> io::Result<()> {
 1183|  2.56k|        match self.0 {
 1184|  2.56k|            BufferInner::NoColor(ref mut w) => w.reset(),
 1185|      0|            BufferInner::Ansi(ref mut w) => w.reset(),
 1186|       |            #[cfg(windows)]
 1187|       |            BufferInner::Windows(ref mut w) => w.reset(),
 1188|       |        }
 1189|  2.56k|    }
_RNvMsB_Cs5gFEH6UN2j3_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE3newB5_:
 2010|    122|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|    122|        LossyStandardStream { wtr: wtr }
 2012|    122|    }
_RNvMs0_Cs5gFEH6UN2j3_9termcolorNtB5_11ColorChoice20should_attempt_color:
  224|      1|    fn should_attempt_color(&self) -> bool {
  225|      1|        match *self {
  226|      0|            ColorChoice::Always => true,
  227|      0|            ColorChoice::AlwaysAnsi => true,
  228|      1|            ColorChoice::Never => false,
  229|      0|            ColorChoice::Auto => self.env_allows_color(),
  230|       |        }
  231|      1|    }
_RNvMsB_Cs5gFEH6UN2j3_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE7get_refB5_:
 2031|    854|    fn get_ref(&self) -> &W {
 2032|    854|        &self.wtr
 2033|    854|    }
_RNvMsi_Cs5gFEH6UN2j3_9termcolorNtB5_12BufferWriter6stderr:
  939|    122|    pub fn stderr(choice: ColorChoice) -> BufferWriter {
  940|    122|        BufferWriter::create(StandardStreamType::Stderr, choice)
  941|    122|    }
_RNvMsj_Cs5gFEH6UN2j3_9termcolorNtB5_6Buffer3new:
 1035|      1|    fn new(choice: ColorChoice) -> Buffer {
 1036|      1|        if choice.should_attempt_color() {
 1037|      0|            Buffer::ansi()
 1038|       |        } else {
 1039|      1|            Buffer::no_color()
 1040|       |        }
 1041|      1|    }
_RNvMsv_Cs5gFEH6UN2j3_9termcolorNtB5_9ColorSpec6set_fg:
 1618|  2.56k|    pub fn set_fg(&mut self, color: Option<Color>) -> &mut ColorSpec {
 1619|  2.56k|        self.fg_color = color;
 1620|  2.56k|        self
 1621|  2.56k|    }
_RNvMsv_Cs5gFEH6UN2j3_9termcolorNtB5_9ColorSpec3new:
 1608|  2.56k|    pub fn new() -> ColorSpec {
 1609|  2.56k|        ColorSpec::default()
 1610|  2.56k|    }
_RNvMsi_Cs5gFEH6UN2j3_9termcolorNtB5_12BufferWriter5print:
  974|    854|    pub fn print(&self, buf: &Buffer) -> io::Result<()> {
  975|    854|        if buf.is_empty() {
  976|      0|            return Ok(());
  977|    854|        }
  978|    854|        let mut stream = self.stream.wrap(self.stream.get_ref().lock());
  979|    854|        if let Some(ref sep) = self.separator {
  980|      0|            if self.printed.load(Ordering::SeqCst) {
  981|      0|                stream.write_all(sep)?;
  982|      0|                stream.write_all(b"\n")?;
  983|      0|            }
  984|    854|        }
  985|    854|        match buf.0 {
  986|    854|            BufferInner::NoColor(ref b) => stream.write_all(&b.0)?,
  987|      0|            BufferInner::Ansi(ref b) => stream.write_all(&b.0)?,
  988|       |            #[cfg(windows)]
  989|       |            BufferInner::Windows(ref b) => {
  990|       |                // We guarantee by construction that we have a console here.
  991|       |                // Namely, a BufferWriter is the only way to produce a Buffer.
  992|       |                let console_mutex = self
  993|       |                    .console
  994|       |                    .as_ref()
  995|       |                    .expect("got Windows buffer but have no Console");
  996|       |                let mut console = console_mutex.lock().unwrap();
  997|       |                b.print(&mut *console, &mut stream)?;
  998|       |            }
  999|       |        }
 1000|    854|        self.printed.store(true, Ordering::SeqCst);
 1001|    854|        Ok(())
 1002|    854|    }
_RNvMsi_Cs5gFEH6UN2j3_9termcolorNtB5_12BufferWriter6create:
  874|    122|    fn create(sty: StandardStreamType, choice: ColorChoice) -> BufferWriter {
  875|    122|        BufferWriter {
  876|    122|            stream: LossyStandardStream::new(IoStandardStream::new(sty)),
  877|    122|            printed: AtomicBool::new(false),
  878|    122|            separator: None,
  879|    122|            color_choice: choice,
  880|    122|        }
  881|    122|    }
_RNvMsj_Cs5gFEH6UN2j3_9termcolorNtB5_6Buffer8is_empty:
 1080|    854|    pub fn is_empty(&self) -> bool {
 1081|    854|        self.len() == 0
 1082|    854|    }
_RNvXsu_Cs5gFEH6UN2j3_9termcolorNtB5_9ColorSpecNtNtCsg994vJE3n1e_4core7default7Default7default:
 1592|  2.56k|    fn default() -> ColorSpec {
 1593|  2.56k|        ColorSpec {
 1594|  2.56k|            fg_color: None,
 1595|  2.56k|            bg_color: None,
 1596|  2.56k|            bold: false,
 1597|  2.56k|            intense: false,
 1598|  2.56k|            underline: false,
 1599|  2.56k|            dimmed: false,
 1600|  2.56k|            italic: false,
 1601|  2.56k|            reset: true,
 1602|  2.56k|        }
 1603|  2.56k|    }
_RNvMs1_Cs5gFEH6UN2j3_9termcolorNtB5_16IoStandardStream3new:
  313|    122|    fn new(sty: StandardStreamType) -> IoStandardStream {
  314|    122|        match sty {
  315|       |            StandardStreamType::Stdout => {
  316|      0|                IoStandardStream::Stdout(io::stdout())
  317|       |            }
  318|       |            StandardStreamType::Stderr => {
  319|    122|                IoStandardStream::Stderr(io::stderr())
  320|       |            }
  321|       |            StandardStreamType::StdoutBuffered => {
  322|      0|                let wtr = io::BufWriter::new(io::stdout());
  323|      0|                IoStandardStream::StdoutBuffered(wtr)
  324|       |            }
  325|       |            StandardStreamType::StderrBuffered => {
  326|      0|                let wtr = io::BufWriter::new(io::stderr());
  327|      0|                IoStandardStream::StderrBuffered(wtr)
  328|       |            }
  329|       |        }
  330|    122|    }
_RINvMsB_Cs5gFEH6UN2j3_9termcolorINtB6_19LossyStandardStreamNtB6_16IoStandardStreamE4wrapNtB6_20IoStandardStreamLockEB6_:
 2022|    854|    fn wrap<Q: io::Write>(&self, wtr: Q) -> LossyStandardStream<Q> {
 2023|    854|        LossyStandardStream::new(wtr)
 2024|    854|    }
_RNvMsj_Cs5gFEH6UN2j3_9termcolorNtB5_6Buffer8no_color:
 1064|      1|    pub fn no_color() -> Buffer {
 1065|      1|        Buffer(BufferInner::NoColor(NoColor(vec![])))
 1066|      1|    }
_RNvMsj_Cs5gFEH6UN2j3_9termcolorNtB5_6Buffer5clear:
 1095|    854|    pub fn clear(&mut self) {
 1096|    854|        match self.0 {
 1097|    854|            BufferInner::NoColor(ref mut b) => b.0.clear(),
 1098|      0|            BufferInner::Ansi(ref mut b) => b.0.clear(),
 1099|       |            #[cfg(windows)]
 1100|       |            BufferInner::Windows(ref mut b) => b.clear(),
 1101|       |        }
 1102|    854|    }
_RNvXs3_Cs5gFEH6UN2j3_9termcolorNtB5_20IoStandardStreamLockNtNtCsbtOQBIHS4qd_3std2io5Write5write:
  381|    854|    fn write(&mut self, b: &[u8]) -> io::Result<usize> {
  382|    854|        match *self {
  383|      0|            IoStandardStreamLock::StdoutLock(ref mut s) => s.write(b),
  384|    854|            IoStandardStreamLock::StderrLock(ref mut s) => s.write(b),
  385|       |        }
  386|    854|    }
_RNvMsj_Cs5gFEH6UN2j3_9termcolorNtB5_6Buffer3len:
 1085|    854|    pub fn len(&self) -> usize {
 1086|    854|        match self.0 {
 1087|    854|            BufferInner::NoColor(ref b) => b.0.len(),
 1088|      0|            BufferInner::Ansi(ref b) => b.0.len(),
 1089|       |            #[cfg(windows)]
 1090|       |            BufferInner::Windows(ref b) => b.buf.len(),
 1091|       |        }
 1092|    854|    }
_RNvMsi_Cs5gFEH6UN2j3_9termcolorNtB5_12BufferWriter6buffer:
  956|      1|    pub fn buffer(&self) -> Buffer {
  957|      1|        Buffer::new(self.color_choice)
  958|      1|    }
_RNvMsB_Cs5gFEH6UN2j3_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockE3newB5_:
 2010|    854|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|    854|        LossyStandardStream { wtr: wtr }
 2012|    854|    }
_RNvMsv_Cs5gFEH6UN2j3_9termcolorNtB5_9ColorSpec11set_intense:
 1741|  1.70k|    pub fn set_intense(&mut self, yes: bool) -> &mut ColorSpec {
 1742|  1.70k|        self.intense = yes;
 1743|  1.70k|        self
 1744|  1.70k|    }
_RNvMs1_Cs5gFEH6UN2j3_9termcolorNtB5_16IoStandardStream4lock:
  332|    854|    fn lock(&self) -> IoStandardStreamLock<'_> {
  333|    854|        match *self {
  334|      0|            IoStandardStream::Stdout(ref s) => {
  335|      0|                IoStandardStreamLock::StdoutLock(s.lock())
  336|       |            }
  337|    854|            IoStandardStream::Stderr(ref s) => {
  338|    854|                IoStandardStreamLock::StderrLock(s.lock())
  339|       |            }
  340|       |            IoStandardStream::StdoutBuffered(_)
  341|       |            | IoStandardStream::StderrBuffered(_) => {
  342|       |                // We don't permit this case to ever occur in the public API,
  343|       |                // so it's OK to panic.
  344|      0|                panic!("cannot lock a buffered standard stream")
  345|       |            }
  346|       |        }
  347|    854|    }
_RNvXsD_Cs5gFEH6UN2j3_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockENtNtCsbtOQBIHS4qd_3std2io5Write5writeB5_:
 2053|    854|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 2054|    854|        self.wtr.write(buf)
 2055|    854|    }

_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader13read_val_type:
  196|     50|    pub fn read_val_type(&mut self) -> Result<ValType> {
  197|     50|        match Self::val_type_from_byte(self.peek()?) {
  198|     50|            Some(ty) => {
  199|     50|                self.position += 1;
  200|     50|                Ok(ty)
  201|       |            }
  202|      0|            None => Err(BinaryReaderError::new(
  203|      0|                "invalid value type",
  204|      0|                self.original_position(),
  205|      0|            )),
  206|       |        }
  207|     50|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader17original_position:
  146|      9|    pub fn original_position(&self) -> usize {
  147|      9|        self.original_offset + self.position
  148|      9|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader14read_func_type:
  280|      6|    pub(crate) fn read_func_type(&mut self) -> Result<FuncType> {
  281|      6|        let len_params = self.read_size(MAX_WASM_FUNCTION_PARAMS, "function params")?;
  282|      6|        let mut params_results = Vec::with_capacity(len_params);
  283|      6|        for _ in 0..len_params {
  284|     29|            params_results.push(self.read_val_type()?);
  285|       |        }
  286|      6|        let len_results = self.read_size(MAX_WASM_FUNCTION_RETURNS, "function returns")?;
  287|      6|        params_results.reserve(len_results);
  288|      6|        for _ in 0..len_results {
  289|     21|            params_results.push(self.read_val_type()?);
  290|       |        }
  291|      6|        Ok(FuncType::from_raw_parts(params_results.into(), len_params))
  292|      6|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader15bytes_remaining:
  961|      1|    pub fn bytes_remaining(&self) -> usize {
  962|      1|        self.buffer.len() - self.position
  963|      1|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader5range:
  159|      1|    pub fn range(&self) -> Range<usize> {
  160|      1|        self.original_offset..self.original_offset + self.buffer.len()
  161|      1|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader16ensure_has_bytes:
  175|      3|    pub(crate) fn ensure_has_bytes(&self, len: usize) -> Result<()> {
  176|      3|        if self.position + len <= self.buffer.len() {
  177|      3|            Ok(())
  178|       |        } else {
  179|      0|            let hint = self.position + len - self.buffer.len();
  180|      0|            Err(BinaryReaderError::eof(self.original_position(), hint))
  181|       |        }
  182|      3|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader10read_bytes:
  971|      2|        self.ensure_has_bytes(size)?;
  972|      2|        let start = self.position;
  973|      2|        self.position += size;
  974|      2|        Ok(&self.buffer[start..self.position])
  975|      2|    }
_RNvXsb_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReaderNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
  105|      1|#[derive(Clone, Debug, Hash)]
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader12read_var_u32:
 1033|     14|    pub fn read_var_u32(&mut self) -> Result<u32> {
 1034|       |        // Optimization for single byte i32.
 1035|     14|        let byte = self.read_u8()?;
 1036|     14|        if (byte & 0x80) == 0 {
 1037|     14|            Ok(u32::from(byte))
 1038|       |        } else {
 1039|      0|            self.read_var_u32_big(byte)
 1040|       |        }
 1041|     14|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader9read_type:
  294|      6|    pub(crate) fn read_type(&mut self) -> Result<Type> {
  295|      6|        Ok(match self.read_u8()? {
  296|      6|            0x60 => Type::Func(self.read_func_type()?),
  297|      0|            x => return self.invalid_leading_byte(x, "type"),
  298|       |        })
  299|      6|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader9read_size:
  856|     12|    fn read_size(&mut self, limit: usize, desc: &str) -> Result<usize> {
  857|     12|        let size = self.read_var_u32()? as usize;
  858|     12|        if size > limit {
  859|      0|            bail!(self.original_position() - 4, "{desc} size is out of bounds");
  860|     12|        }
  861|     12|        Ok(size)
  862|     12|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader15new_with_offset:
  135|      3|    pub fn new_with_offset(data: &[u8], original_offset: usize) -> BinaryReader {
  136|      3|        BinaryReader {
  137|      3|            buffer: data,
  138|      3|            position: 0,
  139|      3|            original_offset,
  140|      3|            allow_memarg64: false,
  141|      3|        }
  142|      3|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader8read_u32:
  981|      1|        self.ensure_has_bytes(4)?;
  982|      1|        let word = u32::from_le_bytes(
  983|      1|            self.buffer[self.position..self.position + 4]
  984|      1|                .try_into()
  985|      1|                .unwrap(),
  986|      1|        );
  987|      1|        self.position += 4;
  988|      1|        Ok(word)
  989|      1|    }
_RINvMs0_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB6_17BinaryReaderError3newReEB8_:
   66|      1|    pub(crate) fn new(message: impl Into<String>, offset: usize) -> Self {
   67|      1|        let message = message.into();
   68|      1|        BinaryReaderError {
   69|      1|            inner: Box::new(BinaryReaderErrorInner {
   70|      1|                message,
   71|      1|                offset,
   72|      1|                needed_hint: None,
   73|      1|            }),
   74|      1|        }
   75|      1|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader4peek:
 1328|     50|        self.ensure_has_byte()?;
 1329|     50|        Ok(self.buffer[self.position])
 1330|     50|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader19read_header_version:
 2113|      1|    pub(crate) fn read_header_version(&mut self) -> Result<u32> {
 2114|      1|        let magic_number = self.read_bytes(4)?;
 2115|      1|        if magic_number != WASM_MAGIC_NUMBER {
 2116|      0|            return Err(BinaryReaderError::new(
 2117|      0|                "magic header not detected: bad magic number",
 2118|      0|                self.original_position() - 4,
 2119|      0|            ));
 2120|      1|        }
 2121|      1|        self.read_u32()
 2122|      1|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader15ensure_has_byte:
  167|     50|    fn ensure_has_byte(&self) -> Result<()> {
  168|     50|        if self.position < self.buffer.len() {
  169|     50|            Ok(())
  170|       |        } else {
  171|      0|            Err(BinaryReaderError::eof(self.original_position(), 1))
  172|       |        }
  173|     50|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader7read_u8:
 1011|     21|    pub fn read_u8(&mut self) -> Result<u8> {
 1012|     21|        let b = match self.buffer.get(self.position) {
 1013|     21|            Some(b) => *b,
 1014|      0|            None => return Err(self.eof_err()),
 1015|       |        };
 1016|     21|        self.position += 1;
 1017|     21|        Ok(b)
 1018|     21|    }
_RNvMs1_NtCs1pefSkL8zGS_10wasmparser13binary_readerNtB5_12BinaryReader18val_type_from_byte:
 1332|     50|    fn val_type_from_byte(byte: u8) -> Option<ValType> {
 1333|     50|        match byte {
 1334|     22|            0x7F => Some(ValType::I32),
 1335|      5|            0x7E => Some(ValType::I64),
 1336|      6|            0x7D => Some(ValType::F32),
 1337|      5|            0x7C => Some(ValType::F64),
 1338|      2|            0x7B => Some(ValType::V128),
 1339|      6|            0x70 => Some(ValType::FuncRef),
 1340|      4|            0x6F => Some(ValType::ExternRef),
 1341|      0|            _ => None,
 1342|       |        }
 1343|     50|    }

_RNCNvMNtCs1pefSkL8zGS_10wasmparser6parserNtB4_6Parser12parse_reader0B6_:
  530|      1|                    .and_then(|s| s.checked_sub(len.into()))
_RNvMNtCs1pefSkL8zGS_10wasmparser6parserNtB2_6Parser3new:
  289|      1|    pub fn new(offset: u64) -> Parser {
  290|      1|        Parser {
  291|      1|            state: State::Header,
  292|      1|            offset,
  293|      1|            max_size: u64::MAX,
  294|      1|            // Assume the encoding is a module until we know otherwise
  295|      1|            encoding: Encoding::Module,
  296|      1|        }
  297|      1|    }
_RNvMNtCs1pefSkL8zGS_10wasmparser6parserNtB2_6Parser12parse_reader:
  478|      2|    fn parse_reader<'a>(
  479|      2|        &mut self,
  480|      2|        reader: &mut BinaryReader<'a>,
  481|      2|        eof: bool,
  482|      2|    ) -> Result<Payload<'a>> {
  483|      2|        use Payload::*;
  484|      2|
  485|      2|        match self.state {
  486|       |            State::Header => {
  487|      1|                let start = reader.original_position();
  488|      1|                let num = reader.read_header_version()?;
  489|      1|                self.encoding = match num {
  490|      1|                    WASM_EXPERIMENTAL_VERSION | WASM_MODULE_VERSION => Encoding::Module,
  491|      0|                    WASM_COMPONENT_VERSION => Encoding::Component,
  492|       |                    _ => {
  493|      0|                        return Err(BinaryReaderError::new(
  494|      0|                            "unknown binary version",
  495|      0|                            reader.original_position() - 4,
  496|      0|                        ))
  497|       |                    }
  498|       |                };
  499|      1|                self.state = State::SectionStart;
  500|      1|                Ok(Version {
  501|      1|                    num,
  502|      1|                    encoding: self.encoding,
  503|      1|                    range: start..reader.original_position(),
  504|      1|                })
  505|       |            }
  506|       |            State::SectionStart => {
  507|       |                // If we're at eof and there are no bytes in our buffer, then
  508|       |                // that means we reached the end of the data since it's
  509|       |                // just a bunch of sections concatenated after the header.
  510|      1|                if eof && reader.bytes_remaining() == 0 {
  511|      0|                    return Ok(Payload::End(reader.original_position()));
  512|      1|                }
  513|      1|
  514|      1|                let id_pos = reader.position;
  515|      1|                let id = reader.read_u8()?;
  516|      1|                if id & 0x80 != 0 {
  517|      0|                    return Err(BinaryReaderError::new("malformed section id", id_pos));
  518|      1|                }
  519|      1|                let len_pos = reader.position;
  520|      1|                let mut len = reader.read_var_u32()?;
  521|       |
  522|       |                // Test to make sure that this section actually fits within
  523|       |                // `Parser::max_size`. This doesn't matter for top-level modules
  524|       |                // but it is required for nested modules/components to correctly ensure
  525|       |                // that all sections live entirely within their section of the
  526|       |                // file.
  527|      1|                let section_overflow = self
  528|      1|                    .max_size
  529|      1|                    .checked_sub(usize_to_u64(reader.position))
  530|      1|                    .and_then(|s| s.checked_sub(len.into()))
  531|      1|                    .is_none();
  532|      1|                if section_overflow {
  533|      0|                    return Err(BinaryReaderError::new("section too large", len_pos));
  534|      1|                }
  535|      1|
  536|      1|                // Check for custom sections (supported by all encodings)
  537|      1|                if id == 0 {}
  538|       |
  539|      1|                match (self.encoding, id) {
  540|       |                    // Sections for both modules and components.
  541|      0|                    (_, 0) => section(reader, len, CustomSectionReader::new, CustomSection),
  542|       |
  543|       |                    // Module sections
  544|       |                    (Encoding::Module, 1) => {
  545|      1|                        section(reader, len, TypeSectionReader::new, TypeSection)
  546|       |                    }
  547|       |                    (Encoding::Module, 2) => {
  548|      0|                        section(reader, len, ImportSectionReader::new, ImportSection)
  549|       |                    }
  550|       |                    (Encoding::Module, 3) => {
  551|      0|                        section(reader, len, FunctionSectionReader::new, FunctionSection)
  552|       |                    }
  553|       |                    (Encoding::Module, 4) => {
  554|      0|                        section(reader, len, TableSectionReader::new, TableSection)
  555|       |                    }
  556|       |                    (Encoding::Module, 5) => {
  557|      0|                        section(reader, len, MemorySectionReader::new, MemorySection)
  558|       |                    }
  559|       |                    (Encoding::Module, 6) => {
  560|      0|                        section(reader, len, GlobalSectionReader::new, GlobalSection)
  561|       |                    }
  562|       |                    (Encoding::Module, 7) => {
  563|      0|                        section(reader, len, ExportSectionReader::new, ExportSection)
  564|       |                    }
  565|       |                    (Encoding::Module, 8) => {
  566|      0|                        let (func, range) = single_u32(reader, len, "start")?;
  567|      0|                        Ok(StartSection { func, range })
  568|       |                    }
  569|       |                    (Encoding::Module, 9) => {
  570|      0|                        section(reader, len, ElementSectionReader::new, ElementSection)
  571|       |                    }
  572|       |                    (Encoding::Module, 10) => {
  573|      0|                        let start = reader.original_position();
  574|      0|                        let count = delimited(reader, &mut len, |r| r.read_var_u32())?;
  575|      0|                        let range = start..reader.original_position() + len as usize;
  576|      0|                        self.state = State::FunctionBody {
  577|      0|                            remaining: count,
  578|      0|                            len,
  579|      0|                        };
  580|      0|                        Ok(CodeSectionStart {
  581|      0|                            count,
  582|      0|                            range,
  583|      0|                            size: len,
  584|      0|                        })
  585|       |                    }
  586|       |                    (Encoding::Module, 11) => {
  587|      0|                        section(reader, len, DataSectionReader::new, DataSection)
  588|       |                    }
  589|       |                    (Encoding::Module, 12) => {
  590|      0|                        let (count, range) = single_u32(reader, len, "data count")?;
  591|      0|                        Ok(DataCountSection { count, range })
  592|       |                    }
  593|       |                    (Encoding::Module, 13) => {
  594|      0|                        section(reader, len, TagSectionReader::new, TagSection)
  595|       |                    }
  596|       |
  597|       |                    // Component sections
  598|       |                    (Encoding::Component, 1 /* module */)
  599|       |                    | (Encoding::Component, 4 /* component */) => {
  600|      0|                        if len as usize > MAX_WASM_MODULE_SIZE {
  601|      0|                            bail!(
  602|      0|                                len_pos,
  603|      0|                                "{} section is too large",
  604|      0|                                if id == 1 { "module" } else { "component " }
  605|       |                            );
  606|      0|                        }
  607|      0|
  608|      0|                        let range =
  609|      0|                            reader.original_position()..reader.original_position() + len as usize;
  610|      0|                        self.max_size -= u64::from(len);
  611|      0|                        self.offset += u64::from(len);
  612|      0|                        let mut parser = Parser::new(usize_to_u64(reader.original_position()));
  613|      0|                        parser.max_size = len.into();
  614|      0|
  615|      0|                        Ok(match id {
  616|      0|                            1 => ModuleSection { parser, range },
  617|      0|                            4 => ComponentSection { parser, range },
  618|      0|                            _ => unreachable!(),
  619|       |                        })
  620|       |                    }
  621|       |                    (Encoding::Component, 2) => {
  622|      0|                        section(reader, len, InstanceSectionReader::new, InstanceSection)
  623|       |                    }
  624|       |                    (Encoding::Component, 3) => {
  625|      0|                        section(reader, len, CoreTypeSectionReader::new, CoreTypeSection)
  626|       |                    }
  627|       |                    // Section 5 handled above
  628|      0|                    (Encoding::Component, 5) => section(
  629|      0|                        reader,
  630|      0|                        len,
  631|      0|                        ComponentInstanceSectionReader::new,
  632|      0|                        ComponentInstanceSection,
  633|      0|                    ),
  634|      0|                    (Encoding::Component, 6) => section(
  635|      0|                        reader,
  636|      0|                        len,
  637|      0|                        ComponentAliasSectionReader::new,
  638|      0|                        ComponentAliasSection,
  639|      0|                    ),
  640|      0|                    (Encoding::Component, 7) => section(
  641|      0|                        reader,
  642|      0|                        len,
  643|      0|                        ComponentTypeSectionReader::new,
  644|      0|                        ComponentTypeSection,
  645|      0|                    ),
  646|      0|                    (Encoding::Component, 8) => section(
  647|      0|                        reader,
  648|      0|                        len,
  649|      0|                        ComponentCanonicalSectionReader::new,
  650|      0|                        ComponentCanonicalSection,
  651|      0|                    ),
  652|      0|                    (Encoding::Component, 9) => section(
  653|      0|                        reader,
  654|      0|                        len,
  655|      0|                        ComponentStartSectionReader::new,
  656|      0|                        ComponentStartSection,
  657|      0|                    ),
  658|      0|                    (Encoding::Component, 10) => section(
  659|      0|                        reader,
  660|      0|                        len,
  661|      0|                        ComponentImportSectionReader::new,
  662|      0|                        ComponentImportSection,
  663|      0|                    ),
  664|      0|                    (Encoding::Component, 11) => section(
  665|      0|                        reader,
  666|      0|                        len,
  667|      0|                        ComponentExportSectionReader::new,
  668|      0|                        ComponentExportSection,
  669|      0|                    ),
  670|      0|                    (_, id) => {
  671|      0|                        let offset = reader.original_position();
  672|      0|                        let contents = reader.read_bytes(len as usize)?;
  673|      0|                        let range = offset..offset + len as usize;
  674|      0|                        Ok(UnknownSection {
  675|      0|                            id,
  676|      0|                            contents,
  677|      0|                            range,
  678|      0|                        })
  679|       |                    }
  680|       |                }
  681|       |            }
  682|       |
  683|       |            // Once we hit 0 remaining incrementally parsed items, with 0
  684|       |            // remaining bytes in each section, we're done and can switch back
  685|       |            // to parsing sections.
  686|       |            State::FunctionBody {
  687|       |                remaining: 0,
  688|       |                len: 0,
  689|       |            } => {
  690|      0|                self.state = State::SectionStart;
  691|      0|                self.parse_reader(reader, eof)
  692|       |            }
  693|       |
  694|       |            // ... otherwise trailing bytes with no remaining entries in these
  695|       |            // sections indicates an error.
  696|      0|            State::FunctionBody { remaining: 0, len } => {
  697|      0|                debug_assert!(len > 0);
  698|      0|                let offset = reader.original_position();
  699|      0|                Err(BinaryReaderError::new(
  700|      0|                    "trailing bytes at end of section",
  701|      0|                    offset,
  702|      0|                ))
  703|       |            }
  704|       |
  705|       |            // Functions are relatively easy to parse when we know there's at
  706|       |            // least one remaining and at least one byte available to read
  707|       |            // things.
  708|       |            //
  709|       |            // We use the remaining length try to read a u32 size of the
  710|       |            // function, and using that size we require the entire function be
  711|       |            // resident in memory. This means that we're reading whole chunks of
  712|       |            // functions at a time.
  713|       |            //
  714|       |            // Limiting via `Parser::max_size` (nested parsing) happens above in
  715|       |            // `fn parse`, and limiting by our section size happens via
  716|       |            // `delimited`. Actual parsing of the function body is delegated to
  717|       |            // the caller to iterate over the `FunctionBody` structure.
  718|      0|            State::FunctionBody { remaining, mut len } => {
  719|      0|                let body = delimited(reader, &mut len, |r| {
  720|       |                    let size = r.read_var_u32()?;
  721|       |                    let offset = r.original_position();
  722|       |                    Ok(FunctionBody::new(offset, r.read_bytes(size as usize)?))
  723|      0|                })?;
  724|      0|                self.state = State::FunctionBody {
  725|      0|                    remaining: remaining - 1,
  726|      0|                    len,
  727|      0|                };
  728|      0|                Ok(CodeSectionEntry(body))
  729|       |            }
  730|       |        }
  731|      2|    }
_RINvNtCs1pefSkL8zGS_10wasmparser6parser7sectionNtNtNtNtB4_7readers4core5types17TypeSectionReaderEB4_:
  857|      1|fn section<'a, T>(
  858|      1|    reader: &mut BinaryReader<'a>,
  859|      1|    len: u32,
  860|      1|    ctor: fn(&'a [u8], usize) -> Result<T>,
  861|      1|    variant: fn(T) -> Payload<'a>,
  862|      1|) -> Result<Payload<'a>> {
  863|      1|    let offset = reader.original_position();
  864|      1|    let payload = reader.read_bytes(len as usize)?;
  865|       |    // clear the hint for "need this many more bytes" here because we already
  866|       |    // read all the bytes, so it's not possible to read more bytes if this
  867|       |    // fails.
  868|      1|    let reader = ctor(payload, offset).map_err(clear_hint)?;
  869|      1|    Ok(variant(reader))
  870|      1|}
_RNCNvMNtCs1pefSkL8zGS_10wasmparser6parserNtB4_6Parser9parse_all0B6_:
  746|      2|        iter::from_fn(move || {
  747|      2|            if done {
  748|      0|                return None;
  749|      2|            }
  750|      2|            let payload = match cur.parse(data, true) {
  751|       |                // Propagate all errors
  752|      0|                Err(e) => {
  753|      0|                    done = true;
  754|      0|                    return Some(Err(e));
  755|       |                }
  756|       |
  757|       |                // This isn't possible because `eof` is always true.
  758|      0|                Ok(Chunk::NeedMoreData(_)) => unreachable!(),
  759|       |
  760|      2|                Ok(Chunk::Parsed { payload, consumed }) => {
  761|      2|                    data = &data[consumed..];
  762|      2|                    payload
  763|      2|                }
  764|      2|            };
  765|      2|
  766|      2|            match &payload {
  767|      0|                Payload::ModuleSection { parser, .. }
  768|      0|                | Payload::ComponentSection { parser, .. } => {
  769|      0|                    stack.push(cur.clone());
  770|      0|                    cur = parser.clone();
  771|      0|                }
  772|      0|                Payload::End(_) => match stack.pop() {
  773|      0|                    Some(p) => cur = p,
  774|      0|                    None => done = true,
  775|       |                },
  776|       |
  777|      2|                _ => {}
  778|       |            }
  779|       |
  780|      2|            Some(Ok(payload))
  781|      2|        })
_RNvNtCs1pefSkL8zGS_10wasmparser6parser12usize_to_u64:
  849|      7|fn usize_to_u64(a: usize) -> u64 {
  850|      7|    a.try_into().unwrap()
  851|      7|}
_RNvMNtCs1pefSkL8zGS_10wasmparser6parserNtB2_6Parser5parse:
  440|      2|    pub fn parse<'a>(&mut self, data: &'a [u8], eof: bool) -> Result<Chunk<'a>> {
  441|      2|        let (data, eof) = if usize_to_u64(data.len()) > self.max_size {
  442|      0|            (&data[..(self.max_size as usize)], true)
  443|       |        } else {
  444|      2|            (data, eof)
  445|       |        };
  446|       |        // TODO: thread through `offset: u64` to `BinaryReader`, remove
  447|       |        // the cast here.
  448|      2|        let mut reader = BinaryReader::new_with_offset(data, self.offset as usize);
  449|      2|        match self.parse_reader(&mut reader, eof) {
  450|      2|            Ok(payload) => {
  451|      2|                // Be sure to update our offset with how far we got in the
  452|      2|                // reader
  453|      2|                self.offset += usize_to_u64(reader.position);
  454|      2|                self.max_size -= usize_to_u64(reader.position);
  455|      2|                Ok(Chunk::Parsed {
  456|      2|                    consumed: reader.position,
  457|      2|                    payload,
  458|      2|                })
  459|       |            }
  460|      0|            Err(e) => {
  461|      0|                // If we're at EOF then there's no way we can recover from any
  462|      0|                // error, so continue to propagate it.
  463|      0|                if eof {
  464|      0|                    return Err(e);
  465|      0|                }
  466|      0|
  467|      0|                // If our error doesn't look like it can be resolved with more
  468|      0|                // data being pulled down, then propagate it, otherwise switch
  469|      0|                // the error to "feed me please"
  470|      0|                match e.inner.needed_hint {
  471|      0|                    Some(hint) => Ok(Chunk::NeedMoreData(usize_to_u64(hint))),
  472|      0|                    None => Err(e),
  473|       |                }
  474|       |            }
  475|       |        }
  476|      2|    }
_RNvMNtCs1pefSkL8zGS_10wasmparser6parserNtB2_6Parser9parse_all:
  742|      1|    pub fn parse_all(self, mut data: &[u8]) -> impl Iterator<Item = Result<Payload>> {
  743|      1|        let mut stack = Vec::new();
  744|      1|        let mut cur = self;
  745|      1|        let mut done = false;
  746|      1|        iter::from_fn(move || {
  747|       |            if done {
  748|       |                return None;
  749|       |            }
  750|       |            let payload = match cur.parse(data, true) {
  751|       |                // Propagate all errors
  752|       |                Err(e) => {
  753|       |                    done = true;
  754|       |                    return Some(Err(e));
  755|       |                }
  756|       |
  757|       |                // This isn't possible because `eof` is always true.
  758|       |                Ok(Chunk::NeedMoreData(_)) => unreachable!(),
  759|       |
  760|       |                Ok(Chunk::Parsed { payload, consumed }) => {
  761|       |                    data = &data[consumed..];
  762|       |                    payload
  763|       |                }
  764|       |            };
  765|       |
  766|       |            match &payload {
  767|       |                Payload::ModuleSection { parser, .. }
  768|       |                | Payload::ComponentSection { parser, .. } => {
  769|       |                    stack.push(cur.clone());
  770|       |                    cur = parser.clone();
  771|       |                }
  772|       |                Payload::End(_) => match stack.pop() {
  773|       |                    Some(p) => cur = p,
  774|       |                    None => done = true,
  775|       |                },
  776|       |
  777|       |                _ => {}
  778|       |            }
  779|       |
  780|       |            Some(Ok(payload))
  781|      1|        })
  782|      1|    }

_RNvXs3_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReaderNtB9_13SectionReader4read:
  238|      6|    fn read(&mut self) -> Result<Self::Item> {
  239|      6|        Self::read(self)
  240|      6|    }
_RNvXs4_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReaderNtB9_23SectionWithLimitedItems9get_count:
  256|      2|    fn get_count(&self) -> u32 {
  257|      2|        Self::get_count(self)
  258|      2|    }
_RNvMs2_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReader3new:
  202|      1|    pub fn new(data: &'a [u8], offset: usize) -> Result<Self> {
  203|      1|        let mut reader = BinaryReader::new_with_offset(data, offset);
  204|      1|        let count = reader.read_var_u32()?;
  205|      1|        Ok(Self { reader, count })
  206|      1|    }
_RNvMs0_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_8FuncType6params:
  105|     11|    pub fn params(&self) -> &[ValType] {
  106|     11|        &self.params_results[..self.len_params]
  107|     11|    }
_RNvXs3_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReaderNtB9_13SectionReader5range:
  250|      1|    fn range(&self) -> Range<usize> {
  251|      1|        self.reader.range()
  252|      1|    }
_RNvMs0_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_8FuncType7results:
  111|     16|    pub fn results(&self) -> &[ValType] {
  112|     16|        &self.params_results[self.len_params..]
  113|     16|    }
_RNvMs0_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_8FuncType14from_raw_parts:
   95|      6|    pub(crate) fn from_raw_parts(params_results: Box<[ValType]>, len_params: usize) -> Self {
   96|      6|        assert!(len_params <= params_results.len());
   97|      6|        Self {
   98|      6|            params_results,
   99|      6|            len_params,
  100|      6|        }
  101|      6|    }
_RNvMs2_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReader9get_count:
  214|      2|    pub fn get_count(&self) -> u32 {
  215|      2|        self.count
  216|      2|    }
_RNvXsQ_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReaderNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
  194|      1|#[derive(Clone)]
_RNvXs3_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReaderNtB9_13SectionReader17original_position:
  246|      6|    fn original_position(&self) -> usize {
  247|      6|        Self::original_position(self)
  248|      6|    }
_RNvMs2_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReader17original_position:
  209|      6|    pub fn original_position(&self) -> usize {
  210|      6|        self.reader.original_position()
  211|      6|    }
_RNvMs2_NtNtNtCs1pefSkL8zGS_10wasmparser7readers4core5typesNtB5_17TypeSectionReader4read:
  230|      6|    pub fn read(&mut self) -> Result<Type> {
  231|      6|        self.reader.read_type()
  232|      6|    }

_RNvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_9Validator7payload:
  401|      2|    pub fn payload<'a>(&mut self, payload: &Payload<'a>) -> Result<ValidPayload<'a>> {
  402|      2|        use crate::Payload::*;
  403|      2|        match payload {
  404|       |            Version {
  405|      1|                num,
  406|      1|                encoding,
  407|      1|                range,
  408|      1|            } => self.version(*num, *encoding, range)?,
  409|       |
  410|       |            // Module sections
  411|      1|            TypeSection(s) => self.type_section(s)?,
  412|      0|            ImportSection(s) => self.import_section(s)?,
  413|      0|            FunctionSection(s) => self.function_section(s)?,
  414|      0|            TableSection(s) => self.table_section(s)?,
  415|      0|            MemorySection(s) => self.memory_section(s)?,
  416|      0|            TagSection(s) => self.tag_section(s)?,
  417|      0|            GlobalSection(s) => self.global_section(s)?,
  418|      0|            ExportSection(s) => self.export_section(s)?,
  419|      0|            StartSection { func, range } => self.start_section(*func, range)?,
  420|      0|            ElementSection(s) => self.element_section(s)?,
  421|      0|            DataCountSection { count, range } => self.data_count_section(*count, range)?,
  422|       |            CodeSectionStart {
  423|      0|                count,
  424|      0|                range,
  425|      0|                size: _,
  426|      0|            } => self.code_section_start(*count, range)?,
  427|      0|            CodeSectionEntry(body) => {
  428|      0|                let func_validator = self.code_section_entry(body)?;
  429|      0|                return Ok(ValidPayload::Func(func_validator, *body));
  430|       |            }
  431|      0|            DataSection(s) => self.data_section(s)?,
  432|       |
  433|       |            // Component sections
  434|      0|            ModuleSection { parser, range, .. } => {
  435|      0|                self.module_section(range)?;
  436|      0|                return Ok(ValidPayload::Parser(parser.clone()));
  437|       |            }
  438|      0|            InstanceSection(s) => self.instance_section(s)?,
  439|      0|            CoreTypeSection(s) => self.core_type_section(s)?,
  440|      0|            ComponentSection { parser, range, .. } => {
  441|      0|                self.component_section(range)?;
  442|      0|                return Ok(ValidPayload::Parser(parser.clone()));
  443|       |            }
  444|      0|            ComponentInstanceSection(s) => self.component_instance_section(s)?,
  445|      0|            ComponentAliasSection(s) => self.component_alias_section(s)?,
  446|      0|            ComponentTypeSection(s) => self.component_type_section(s)?,
  447|      0|            ComponentCanonicalSection(s) => self.component_canonical_section(s)?,
  448|      0|            ComponentStartSection(s) => self.component_start_section(s)?,
  449|      0|            ComponentImportSection(s) => self.component_import_section(s)?,
  450|      0|            ComponentExportSection(s) => self.component_export_section(s)?,
  451|       |
  452|      0|            End(offset) => return Ok(ValidPayload::End(self.end(*offset)?)),
  453|       |
  454|      0|            CustomSection { .. } => {} // no validation for custom sections
  455|      0|            UnknownSection { id, range, .. } => self.unknown_section(*id, range)?,
  456|       |        }
  457|      1|        Ok(ValidPayload::Ok)
  458|      2|    }
_RNvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_9Validator7version:
  461|      1|    pub fn version(&mut self, num: u32, encoding: Encoding, range: &Range<usize>) -> Result<()> {
  462|      1|        match &self.state {
  463|      1|            State::Unparsed(expected) => {
  464|      1|                if let Some(expected) = expected {
  465|      0|                    if *expected != encoding {
  466|      0|                        bail!(
  467|      0|                            range.start,
  468|      0|                            "expected a version header for a {}",
  469|      0|                            match expected {
  470|      0|                                Encoding::Module => "module",
  471|      0|                                Encoding::Component => "component",
  472|       |                            }
  473|       |                        );
  474|      0|                    }
  475|      1|                }
  476|       |            }
  477|       |            _ => {
  478|      0|                return Err(BinaryReaderError::new(
  479|      0|                    "wasm version header out of order",
  480|      0|                    range.start,
  481|      0|                ))
  482|       |            }
  483|       |        }
  484|       |
  485|      1|        self.state = match (encoding, num) {
  486|       |            (Encoding::Module, WASM_MODULE_VERSION) => {
  487|      1|                assert!(self.module.is_none());
  488|      1|                self.module = Some(ModuleState::default());
  489|      1|                State::Module
  490|       |            }
  491|       |            (Encoding::Component, WASM_COMPONENT_VERSION) => {
  492|      0|                if !self.features.component_model {
  493|      0|                    return Err(BinaryReaderError::new(
  494|      0|                        "WebAssembly component model feature not enabled",
  495|      0|                        range.start,
  496|      0|                    ));
  497|      0|                }
  498|      0|
  499|      0|                self.components.push(ComponentState::default());
  500|      0|                State::Component
  501|       |            }
  502|       |            _ => {
  503|      0|                return Err(BinaryReaderError::new(
  504|      0|                    "unknown binary version",
  505|      0|                    range.start,
  506|      0|                ));
  507|       |            }
  508|       |        };
  509|       |
  510|      1|        Ok(())
  511|      1|    }
_RINvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB6_9Validator22process_module_sectionNtNtNtNtB8_7readers4core5types17TypeSectionReaderNCNvB2_12type_section0NCB2a_s_0EB8_:
 1225|      1|    fn process_module_section<T>(
 1226|      1|        &mut self,
 1227|      1|        order: Order,
 1228|      1|        section: &T,
 1229|      1|        name: &str,
 1230|      1|        validate_section: impl FnOnce(
 1231|      1|            &mut ModuleState,
 1232|      1|            &WasmFeatures,
 1233|      1|            &mut TypeList,
 1234|      1|            u32,
 1235|      1|            usize,
 1236|      1|        ) -> Result<()>,
 1237|      1|        mut validate_item: impl FnMut(
 1238|      1|            &mut ModuleState,
 1239|      1|            &WasmFeatures,
 1240|      1|            &mut TypeList,
 1241|      1|            T::Item,
 1242|      1|            usize,
 1243|      1|        ) -> Result<()>,
 1244|      1|    ) -> Result<()>
 1245|      1|    where
 1246|      1|        T: SectionReader + Clone + SectionWithLimitedItems,
 1247|      1|    {
 1248|      1|        let offset = section.range().start;
 1249|      1|        self.state.ensure_module(name, offset)?;
 1250|       |
 1251|      1|        let state = self.module.as_mut().unwrap();
 1252|      1|        state.update_order(order, offset)?;
 1253|       |
 1254|      1|        validate_section(
 1255|      1|            state,
 1256|      1|            &self.features,
 1257|      1|            &mut self.types,
 1258|      1|            section.get_count(),
 1259|      1|            offset,
 1260|      1|        )?;
 1261|       |
 1262|      1|        let mut section = section.clone();
 1263|      1|        for _ in 0..section.get_count() {
 1264|      6|            let offset = section.original_position();
 1265|      6|            let item = section.read()?;
 1266|      6|            validate_item(state, &self.features, &mut self.types, item, offset)?;
 1267|       |        }
 1268|       |
 1269|      0|        section.ensure_end()?;
 1270|       |
 1271|      0|        Ok(())
 1272|      1|    }
_RNvMs0_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_12WasmFeatures16check_value_type:
  237|     24|    pub(crate) fn check_value_type(&self, ty: ValType) -> Result<(), &'static str> {
  238|     24|        match ty {
  239|     23|            ValType::I32 | ValType::I64 | ValType::F32 | ValType::F64 => Ok(()),
  240|       |            ValType::FuncRef | ValType::ExternRef => {
  241|      1|                if self.reference_types {
  242|      0|                    Ok(())
  243|       |                } else {
  244|      1|                    Err("reference types support is not enabled")
  245|       |                }
  246|       |            }
  247|       |            ValType::V128 => {
  248|      0|                if self.simd {
  249|      0|                    Ok(())
  250|       |                } else {
  251|      0|                    Err("SIMD support is not enabled")
  252|       |                }
  253|       |            }
  254|       |        }
  255|     24|    }
_RNCNvNtCs1pefSkL8zGS_10wasmparser9validator9check_max0B5_:
   64|      1|        .and_then(|amt| amt.checked_sub(amt_added as usize))
_RNvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_9Validator3new:
  308|      1|    pub fn new() -> Validator {
  309|      1|        Validator::default()
  310|      1|    }
_RNCNvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB7_9Validator12type_sections_0B9_:
  531|      6|            |state, features, types, def, offset| {
  532|      6|                state
  533|      6|                    .module
  534|      6|                    .assert_mut()
  535|      6|                    .add_type(def, features, types, offset, false /* checked above */)
  536|      6|            },
_RNvXs3_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_9ValidatorNtNtCsg994vJE3n1e_4core7default7Default7default:
  112|      1|#[derive(Default)]
_RNvNtCs1pefSkL8zGS_10wasmparser9validator9check_max:
   61|      1|fn check_max(cur_len: usize, amt_added: u32, max: usize, desc: &str, offset: usize) -> Result<()> {
   62|      1|    if max
   63|      1|        .checked_sub(cur_len)
   64|      1|        .and_then(|amt| amt.checked_sub(amt_added as usize))
   65|      1|        .is_none()
   66|       |    {
   67|      0|        if max == 1 {
   68|      0|            bail!(offset, "multiple {desc}");
   69|      0|        }
   70|      0|
   71|      0|        bail!(offset, "{desc} count exceeds limit of {max}");
   72|      1|    }
   73|      1|
   74|      1|    Ok(())
   75|      1|}
_RNvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_9Validator12validate_all:
  338|      1|    pub fn validate_all(&mut self, bytes: &[u8]) -> Result<Types> {
  339|      1|        let mut functions_to_validate = Vec::new();
  340|      1|        let mut last_types = None;
  341|      2|        for payload in Parser::new(0).parse_all(bytes) {
  342|      2|            match self.payload(&payload?)? {
  343|      0|                ValidPayload::Func(a, b) => {
  344|      0|                    functions_to_validate.push((a, b));
  345|      0|                }
  346|      0|                ValidPayload::End(types) => {
  347|      0|                    // Only the last (top-level) type information will be returned
  348|      0|                    last_types = Some(types);
  349|      0|                }
  350|      1|                _ => {}
  351|       |            }
  352|       |        }
  353|       |
  354|      0|        let mut allocs = FuncValidatorAllocations::default();
  355|      0|        for (func, body) in functions_to_validate {
  356|      0|            let mut validator = func.into_validator(allocs);
  357|      0|            validator.validate(&body)?;
  358|      0|            allocs = validator.into_allocations();
  359|       |        }
  360|       |
  361|      0|        Ok(last_types.unwrap())
  362|      1|    }
_RNCNvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB7_9Validator12type_section0B9_:
  520|      1|                check_max(
  521|      1|                    state.module.types.len(),
  522|      1|                    count,
  523|      1|                    MAX_WASM_TYPES,
  524|      1|                    "types",
  525|      1|                    offset,
  526|      1|                )?;
  527|      1|                types.reserve(count as usize);
  528|      1|                state.module.assert_mut().types.reserve(count as usize);
  529|      1|                Ok(())
  530|      1|            },
_RNvMNtCs1pefSkL8zGS_10wasmparser9validatorNtB2_5State13ensure_module:
  166|      1|    fn ensure_module(&self, section: &str, offset: usize) -> Result<()> {
  167|      1|        self.ensure_parsable(offset)?;
  168|       |
  169|      1|        match self {
  170|      1|            Self::Module => Ok(()),
  171|      0|            Self::Component => Err(format_err!(
  172|      0|                offset,
  173|      0|                "unexpected module {section} section while parsing a component",
  174|      0|            )),
  175|      0|            _ => unreachable!(),
  176|       |        }
  177|      1|    }
_RNvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_9Validator17new_with_features:
  319|      1|    pub fn new_with_features(features: WasmFeatures) -> Validator {
  320|      1|        let mut ret = Validator::new();
  321|      1|        ret.features = features;
  322|      1|        ret
  323|      1|    }
_RNvXs_NtCs1pefSkL8zGS_10wasmparser9validatorNtB4_5StateNtNtCsg994vJE3n1e_4core7default7Default7default:
  194|      1|    fn default() -> Self {
  195|      1|        Self::Unparsed(None)
  196|      1|    }
_RNvMs2_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_9Validator12type_section:
  514|      1|    pub fn type_section(&mut self, section: &crate::TypeSectionReader<'_>) -> Result<()> {
  515|      1|        self.process_module_section(
  516|      1|            Order::Type,
  517|      1|            section,
  518|      1|            "type",
  519|      1|            |state, _, types, count, offset| {
  520|       |                check_max(
  521|       |                    state.module.types.len(),
  522|       |                    count,
  523|       |                    MAX_WASM_TYPES,
  524|       |                    "types",
  525|       |                    offset,
  526|       |                )?;
  527|       |                types.reserve(count as usize);
  528|       |                state.module.assert_mut().types.reserve(count as usize);
  529|       |                Ok(())
  530|      1|            },
  531|      1|            |state, features, types, def, offset| {
  532|       |                state
  533|       |                    .module
  534|       |                    .assert_mut()
  535|       |                    .add_type(def, features, types, offset, false /* checked above */)
  536|      1|            },
  537|      1|        )
  538|      1|    }
_RNvXs1_NtCs1pefSkL8zGS_10wasmparser9validatorNtB5_12WasmFeaturesNtNtCsg994vJE3n1e_4core7default7Default7default:
  259|      2|    fn default() -> WasmFeatures {
  260|      2|        WasmFeatures {
  261|      2|            // off-by-default features
  262|      2|            relaxed_simd: false,
  263|      2|            threads: false,
  264|      2|            tail_call: false,
  265|      2|            multi_memory: false,
  266|      2|            exceptions: false,
  267|      2|            memory64: false,
  268|      2|            extended_const: false,
  269|      2|            component_model: false,
  270|      2|            deterministic_only: cfg!(feature = "deterministic"),
  271|      2|
  272|      2|            // on-by-default features
  273|      2|            mutable_global: true,
  274|      2|            saturating_float_to_int: true,
  275|      2|            sign_extension: true,
  276|      2|            bulk_memory: true,
  277|      2|            multi_value: true,
  278|      2|            reference_types: true,
  279|      2|            simd: true,
  280|      2|        }
  281|      2|    }
_RNvMNtCs1pefSkL8zGS_10wasmparser9validatorNtB2_5State15ensure_parsable:
  152|      1|    fn ensure_parsable(&self, offset: usize) -> Result<()> {
  153|      1|        match self {
  154|      1|            Self::Module | Self::Component => Ok(()),
  155|      0|            Self::Unparsed(_) => Err(BinaryReaderError::new(
  156|      0|                "unexpected section before header was parsed",
  157|      0|                offset,
  158|      0|            )),
  159|      0|            Self::End => Err(BinaryReaderError::new(
  160|      0|                "unexpected section after parsing has completed",
  161|      0|                offset,
  162|      0|            )),
  163|       |        }
  164|      1|    }

_RNvMNtNtNtCs1pefSkL8zGS_10wasmparser9validator4core3arcINtB2_10MaybeOwnedNtB4_6ModuleE6as_mutB8_:
 1075|      7|        fn as_mut(&mut self) -> Option<&mut T> {
 1076|      7|            match &mut self.inner {
 1077|      7|                Inner::Owned(x) => Some(x),
 1078|      0|                Inner::Shared(_) => None,
 1079|      0|                Inner::Empty => Self::unreachable(),
 1080|       |            }
 1081|      7|        }
_RNvMNtNtNtCs1pefSkL8zGS_10wasmparser9validator4core3arcINtB2_10MaybeOwnedNtB4_6ModuleE10assert_mutB8_:
 1084|      7|        pub fn assert_mut(&mut self) -> &mut T {
 1085|      7|            self.as_mut().unwrap()
 1086|      7|        }
_RNvXs1_NtNtCs1pefSkL8zGS_10wasmparser9validator4coreNtB5_6ModuleNtNtCsg994vJE3n1e_4core7default7Default7default:
  914|      1|    fn default() -> Self {
  915|      1|        Self {
  916|      1|            snapshot: Default::default(),
  917|      1|            types: Default::default(),
  918|      1|            tables: Default::default(),
  919|      1|            memories: Default::default(),
  920|      1|            globals: Default::default(),
  921|      1|            element_types: Default::default(),
  922|      1|            data_count: Default::default(),
  923|      1|            functions: Default::default(),
  924|      1|            tags: Default::default(),
  925|      1|            function_references: Default::default(),
  926|      1|            imports: Default::default(),
  927|      1|            exports: Default::default(),
  928|      1|            type_size: 1,
  929|      1|            num_imported_globals: Default::default(),
  930|      1|            num_imported_functions: Default::default(),
  931|      1|        }
  932|      1|    }
_RNvXs6_NtNtCs1pefSkL8zGS_10wasmparser9validator4coreNtB5_5OrderNtNtCsg994vJE3n1e_4core3cmp10PartialOrd11partial_cmp:
   29|      1|#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug)]
_RNvXs_NtNtNtCs1pefSkL8zGS_10wasmparser9validator4core3arcINtB4_10MaybeOwnedNtB6_6ModuleENtNtCsg994vJE3n1e_4core7default7Default7defaultBa_:
 1119|      1|        fn default() -> MaybeOwned<T> {
 1120|      1|            MaybeOwned {
 1121|      1|                inner: Inner::Owned(T::default()),
 1122|      1|            }
 1123|      1|        }
_RNvMs_NtNtCs1pefSkL8zGS_10wasmparser9validator4coreNtB4_11ModuleState12update_order:
   82|      1|    pub fn update_order(&mut self, order: Order, offset: usize) -> Result<()> {
   83|      1|        if self.order >= order {
   84|      0|            return Err(BinaryReaderError::new("section out of order", offset));
   85|      1|        }
   86|      1|
   87|      1|        self.order = order;
   88|      1|
   89|      1|        Ok(())
   90|      1|    }
_RNvMs0_NtNtCs1pefSkL8zGS_10wasmparser9validator4coreNtB5_6Module8add_type:
  454|      6|    pub fn add_type(
  455|      6|        &mut self,
  456|      6|        ty: crate::Type,
  457|      6|        features: &WasmFeatures,
  458|      6|        types: &mut TypeList,
  459|      6|        offset: usize,
  460|      6|        check_limit: bool,
  461|      6|    ) -> Result<()> {
  462|      6|        let ty = match ty {
  463|      6|            crate::Type::Func(t) => {
  464|     24|                for ty in t.params().iter().chain(t.results()) {
  465|     24|                    check_value_type(*ty, features, offset)?;
  466|       |                }
  467|      5|                if t.results().len() > 1 && !features.multi_value {
  468|      0|                    return Err(BinaryReaderError::new(
  469|      0|                        "func type returns multiple values but the multi-value feature is not enabled",
  470|      0|                        offset,
  471|      0|                    ));
  472|      5|                }
  473|      5|                Type::Func(t)
  474|      5|            }
  475|      5|        };
  476|      5|
  477|      5|        if check_limit {
  478|      0|            check_max(self.types.len(), 1, MAX_WASM_TYPES, "types", offset)?;
  479|      5|        }
  480|       |
  481|      5|        self.types.push(TypeId {
  482|      5|            type_size: ty.type_size(),
  483|      5|            index: types.len(),
  484|      5|            type_index: Some(self.types.len()),
  485|      5|            is_core: true,
  486|      5|        });
  487|      5|        types.push(ty);
  488|      5|        Ok(())
  489|      6|    }
_RNvXNtNtCs1pefSkL8zGS_10wasmparser9validator4coreNtB2_5OrderNtNtCsg994vJE3n1e_4core7default7Default7default:
   48|      1|    fn default() -> Order {
   49|      1|        Order::Initial
   50|      1|    }
_RNvXs0_NtNtNtCs1pefSkL8zGS_10wasmparser9validator4core3arcINtB5_10MaybeOwnedNtB7_6ModuleENtNtNtCsg994vJE3n1e_4core3ops5deref5Deref5derefBb_:
 1129|      1|        fn deref(&self) -> &T {
 1130|      1|            match &self.inner {
 1131|      1|                Inner::Owned(x) => x,
 1132|      0|                Inner::Shared(x) => x,
 1133|      0|                Inner::Empty => Self::unreachable(),
 1134|       |            }
 1135|      1|        }
_RNvXsd_NtNtCs1pefSkL8zGS_10wasmparser9validator4coreNtB5_11ModuleStateNtNtCsg994vJE3n1e_4core7default7Default7default:
   53|      1|#[derive(Default)]
_RNvNtNtCs1pefSkL8zGS_10wasmparser9validator4core16check_value_type:
   18|     24|fn check_value_type(ty: ValType, features: &WasmFeatures, offset: usize) -> Result<()> {
   19|     24|    match features.check_value_type(ty) {
   20|     23|        Ok(()) => Ok(()),
   21|      1|        Err(e) => Err(BinaryReaderError::new(e, offset)),
   22|       |    }
   23|     24|}

_RNvXsi_NtNtCs1pefSkL8zGS_10wasmparser9validator9operatorsNtB5_28OperatorValidatorAllocationsNtNtCsg994vJE3n1e_4core7default7Default7default:
  133|      1|#[derive(Default)]

_RNvXso_NtNtCs1pefSkL8zGS_10wasmparser9validator5typesINtB5_12SnapshotListNtB5_4TypeENtNtCsg994vJE3n1e_4core7default7Default7defaultB9_:
 1903|      1|    fn default() -> SnapshotList<T> {
 1904|      1|        SnapshotList {
 1905|      1|            snapshots: Vec::new(),
 1906|      1|            snapshots_total: 0,
 1907|      1|            cur: Vec::new(),
 1908|      1|        }
 1909|      1|    }
_RNvMsj_NtNtCs1pefSkL8zGS_10wasmparser9validator5typesINtB5_12SnapshotListNtB5_4TypeE3lenB9_:
 1835|      5|    pub(crate) fn len(&self) -> usize {
 1836|      5|        self.cur.len() + self.snapshots_total
 1837|      5|    }
_RNvMs1_NtNtCs1pefSkL8zGS_10wasmparser9validator5typesNtB5_4Type9type_size:
  242|      5|    pub(crate) fn type_size(&self) -> usize {
  243|      5|        match self {
  244|      5|            Self::Func(ty) => 1 + ty.params().len() + ty.results().len(),
  245|      0|            Self::Module(ty) => ty.type_size,
  246|      0|            Self::Instance(ty) => ty.type_size,
  247|      0|            Self::Component(ty) => ty.type_size,
  248|      0|            Self::ComponentInstance(ty) => ty.type_size,
  249|      0|            Self::ComponentFunc(ty) => ty.type_size,
  250|      0|            Self::Defined(ty) => ty.type_size(),
  251|       |        }
  252|      5|    }
_RNvMsj_NtNtCs1pefSkL8zGS_10wasmparser9validator5typesINtB5_12SnapshotListNtB5_4TypeE4pushB9_:
 1830|      5|    pub(crate) fn push(&mut self, val: T) {
 1831|      5|        self.cur.push(val);
 1832|      5|    }
_RNvMsj_NtNtCs1pefSkL8zGS_10wasmparser9validator5typesINtB5_12SnapshotListNtB5_4TypeE7reserveB9_:
 1840|      1|    pub(crate) fn reserve(&mut self, additional: usize) {
 1841|      1|        self.cur.reserve(additional);
 1842|      1|    }

_RNvNvNvXs0_CsgSpm5FkEyyU_10env_loggerNtB9_6LoggerNtCscNjeUWn5y3T_3log3Log3log9FORMATTER7___getit:
  319|    854|            unsafe fn __getit(
  320|    854|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    854|            ) -> $crate::option::Option<&'static $t> {
  322|    854|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    854|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    854|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    854|
  326|    854|                #[thread_local]
  327|    854|                #[cfg(all(
  328|    854|                    target_thread_local,
  329|    854|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    854|                ))]
  331|    854|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    854|                    $crate::thread::__FastLocalKeyInner::new();
  333|    854|
  334|    854|                #[cfg(all(
  335|    854|                    not(target_thread_local),
  336|    854|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    854|                ))]
  338|    854|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    854|                    $crate::thread::__OsLocalKeyInner::new();
  340|    854|
  341|    854|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    854|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    854|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    854|                #[allow(unused_unsafe)]
  345|    854|                unsafe {
  346|    854|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    854|                    })
  356|    854|                }
  357|    854|            }
_RNvNvNvXs0_CsgSpm5FkEyyU_10env_loggerNtB9_6LoggerNtCscNjeUWn5y3T_3log3Log3log9FORMATTER6___init:
  294|      1|            fn __init() -> $t { $init }

_RNCNvNvCs7xWdtGLRam0_22instrument_with_mutate1__3run0B5_:
   32|      1|        |bytes, _seed, _stackindex, _siblingindex| {
   33|      1|            // The same wasmtime features that the fvm uses for now
   34|      1|            // TODO, ideally this should come from the fvm, get_config or something similar
   35|      1|            log::debug!("Calling fvm for gas instrumentation");
   36|      1|            let features = get_wasmfeatures();
   37|      1|            // Finish config
   38|      1|
   39|      1|            // Validate before passing to fvm
   40|      1|            GENERATED_MUTATIONS.fetch_add(1, Ordering::SeqCst);
   41|      1|
   42|      1|            let validation_result =
   43|      1|                wasmparser::Validator::new_with_features(features).validate_all(&bytes);
   44|      1|            match validation_result {
   45|       |                Ok(_) => {
   46|       |                    // The code below is stressed during this pass
   47|       |                    // TODO, mutate the network version as well
   48|       |
   49|      0|                    let nc = NetworkConfig::new(NetworkVersion::V16);
   50|      0|                    let ec = EngineConfig::from(&nc);
   51|      0|
   52|      0|                    let engine = fvm::machine::Engine::new_default(ec).unwrap();
   53|      0|                    let cid = Cid::new_v1(0x55, Default::default());
   54|      0|
   55|      0|                    let instrumented = engine.prepare_wasm_bytecode(&cid, &bytes);
   56|      0|
   57|      0|                    // Debug info only
   58|      0|                    // How many mutations we are generaing and passing to the fvm
   59|      0|                    // This will give us hints about the tuning of the parameters for the fuzzing
   60|      0|                    PASSED_TO_FVM.fetch_add(1, Ordering::SeqCst);
   61|      0|
   62|      0|                    if GENERATED_MUTATIONS.load(Ordering::Relaxed) % 10 == 9 {
   63|      0|                        let passed = PASSED_TO_FVM.load(Ordering::Relaxed);
   64|      0|                        let generated = GENERATED_MUTATIONS.load(Ordering::Relaxed);
   65|      0|                        log::debug!(
   66|      0|                            "Generated mutations: {}/{} ({:.2}%)",
   67|      0|                            passed,
   68|      0|                            generated,
   69|      0|                            100.0 * (passed as f64) / (generated as f64)
   70|       |                        );
   71|      0|                    }
   72|       |
   73|      0|                    match instrumented {
   74|      0|                        Ok(_instrumented) => {
   75|      0|
   76|      0|                            // Compile and measure size
   77|      0|                            // M1: Producing unacceptably large machine code (with respect to the Wasm bytecode).
   78|      0|                            // If m' < m => s' < s, otherwise, error
   79|      0|
   80|      0|                            // TODO, do other operations
   81|      0|
   82|      0|                            // TODO, Measure execution time
   83|      0|                            // M1: Producing unacceptably slow code (with respect to the gas model).
   84|      0|                            // M1: Consuming an exorbitant amount of memory or time (on compile) with respect to the size of the Wasm bytecode.
   85|      0|                            // m' < m => t' < t, otherwise, error,
   86|      0|
   87|      0|                            // TODO, Gas spending
   88|      0|
   89|      0|                            // TODO, execute the Wasm to measure the gas
   90|      0|                        }
   91|      0|                        Err(e) => {
   92|      0|                            // Save the the mutated bin to file sys
   93|      0|                            fs::write("crash.wasm", &bytes).unwrap();
   94|      0|                            if let Ok(mutated_wat) = wasmprinter::print_bytes(&bytes) {
   95|      0|                                log::debug!("writing mutated WAT to `crash.wat`");
   96|      0|                                std::fs::write("crash.wat", mutated_wat)
   97|      0|                                    .expect("should write `crash.wat` okay");
   98|      0|                            }
   99|      0|                            panic!("Error: {e:?}");
  100|       |                        }
  101|       |                    }
  102|       |                }
  103|      1|                Err(e) => {
  104|      1|                    log::debug!("Validation error {}", e);
  105|      1|                    if GENERATED_MUTATIONS.load(Ordering::Relaxed) % 10 == 9 {
  106|      0|                        let passed = PASSED_TO_FVM.load(Ordering::Relaxed);
  107|      0|                        let generated = GENERATED_MUTATIONS.load(Ordering::Relaxed);
  108|      0|                        log::debug!(
  109|      0|                            "Generated mutations: {}/{} ({:.2}%)",
  110|      0|                            passed,
  111|      0|                            generated,
  112|      0|                            100.0 * (passed as f64) / (generated as f64)
  113|       |                        );
  114|      1|                    }
  115|       |                }
  116|       |            }
  117|      1|        },

_RINvCscXHlwnAguRK_8fvm_fuzz15stack_mutationsNCNvNvCs7xWdtGLRam0_22instrument_with_mutate1__3run0EBM_:
   94|    122|pub fn stack_mutations<'a>(
   95|    122|    bin: Vec<u8>,
   96|    122|    raw: &mut Unstructured<'a>,
   97|    122|    mut action: impl FnMut(Vec<u8>, u64, u32, u32),
   98|    122|    max_stacked_mutations: u32,
   99|    122|    max_siblings_exploration: u32,
  100|    122|) -> Vec<u8> {
  101|    122|    let preseed: u64 = raw.arbitrary().unwrap();
  102|    122|    let mut rng = SmallRng::seed_from_u64(preseed);
  103|    122|    let mut cp = bin;
  104|    122|
  105|    122|    log::debug!("Preseed {:?}", preseed);
  106|    122|    let stacked_mutations: u32 = rng.gen_range(1..max_stacked_mutations);
  107|    122|    log::debug!("stacked_mutations: {}", stacked_mutations);
  108|       |
  109|    244|    for i in 0..=stacked_mutations {
  110|    244|        let seed = rng.gen();
  111|    244|        let mut wasm_mutate = Box::<wasm_mutate::WasmMutate<'_>>::default();
  112|    244|        wasm_mutate.seed(seed);
  113|    244|        log::debug!("Seed: {}", seed);
  114|    244|        wasm_mutate.preserve_semantics(true);
  115|    244|
  116|    244|        // TODO, set fuel as a parameter of the fuzzer, lets the fuzzer to determine if more fuel is needed
  117|    244|        wasm_mutate.fuel(500);
  118|    244|        let tomutate = cp.clone();
  119|    244|        let mut_iterator = wasm_mutate.run(&tomutate);
  120|    244|
  121|    244|        match mut_iterator {
  122|      1|            Ok(mut it) => {
  123|      1|                // lateral traversing
  124|      1|                let check_siblings: u32 = rng.gen_range(1..max_siblings_exploration);
  125|      1|                log::debug!("check_siblings: {}", check_siblings);
  126|    100|                for j in 0..=check_siblings {
  127|    100|                    let mutated_bin = it.next();
  128|       |
  129|    100|                    if let Some(mutated_bin) = mutated_bin {
  130|      1|                        match mutated_bin {
  131|      1|                            Ok(mutated_bin) => {
  132|      1|                                action(mutated_bin.clone(), seed, i, j);
  133|      1|                                swap(&mut cp, mutated_bin);
  134|      1|                            }
  135|      0|                            Err(e) => {
  136|      0|                                // Do nothing
  137|      0|                                log::debug!("Error: {:?}", e);
  138|       |                            }
  139|       |                        }
  140|     99|                    }
  141|       |                }
  142|       |            }
  143|    243|            Err(e) => {
  144|    243|                // do nothing continue
  145|    243|                log::debug!("Error: {:?}", e);
  146|       |            }
  147|       |        }
  148|       |    }
  149|    122|    cp
  150|    122|}
_RNCNvCscXHlwnAguRK_8fvm_fuzz18get_random_fixture0B3_:
  172|  19.8k|        .map(|r| r.unwrap())
_RNvCscXHlwnAguRK_8fvm_fuzz16get_wasmfeatures:
   37|      1|pub fn get_wasmfeatures() -> WasmFeatures {
   38|      1|    let mut features = WasmFeatures::default();
   39|      1|    features.threads = false;
   40|      1|    features.simd = false;
   41|      1|    features.multi_memory = false;
   42|      1|    features.memory64 = false;
   43|      1|    features.bulk_memory = true;
   44|      1|    features.multi_value = false;
   45|      1|    features.reference_types = false;
   46|      1|    features
   47|      1|}
_RNvCscXHlwnAguRK_8fvm_fuzz12get_wasm_dir:
  152|    122|fn get_wasm_dir() -> PathBuf {
  153|    122|    match env::var("OUT") {
  154|    122|        Ok(out) => {
  155|    122|            let path: PathBuf = out.into();
  156|    122|            path
  157|       |        }
  158|      0|        Err(e) => {
  159|      0|            log::debug!("Error {:?}", e);
  160|       |            // gracefully exit
  161|      0|            std::process::exit(0)
  162|       |        }
  163|       |    }
  164|    122|}
_RNvCscXHlwnAguRK_8fvm_fuzz4swap:
   49|      1|fn swap(a: &mut Vec<u8>, b: Vec<u8>) {
   50|      1|    *a = b;
   51|      1|}
_RNvCscXHlwnAguRK_8fvm_fuzz18get_random_fixture:
  167|    122|pub fn get_random_fixture<'a>(raw: &mut Unstructured<'a>) -> AResult<(Vec<u8>, PathBuf)> {
  168|    122|    let files = get_wasm_dir()
  169|    122|        .read_dir()
  170|    122|        .unwrap()
  171|    122|        .into_iter()
  172|    122|        .map(|r| r.unwrap())
  173|    122|        .collect::<Vec<_>>();
  174|       |
  175|    122|    let idx = raw.choose_index(files.len())?;
  176|    122|    let random_file = files[idx].path();
  177|    122|    log::debug!("Random fixture: {:?}", random_file);
  178|       |
  179|    122|    let bytes = std::fs::read(&random_file)?;
  180|       |
  181|    122|    Ok((bytes, random_file))
  182|    122|}

_RNvXNtCskTcFVVikGfm_12wasm_encoder4corehINtNtCsg994vJE3n1e_4core7convert4FromNtB2_9SectionIdE4from:
   89|     17|    fn from(id: SectionId) -> u8 {
   90|     17|        id as u8
   91|     17|    }
_RINvMs0_NtCskTcFVVikGfm_12wasm_encoder4coreNtB6_6Module7sectionNtNtB6_9functions15FunctionSectionECsb6KoqmGnaUT_11wasm_mutate:
  132|      1|    pub fn section(&mut self, section: &impl Section) -> &mut Self {
  133|      1|        self.bytes.push(section.id());
  134|      1|        section.encode(&mut self.bytes);
  135|      1|        self
  136|      1|    }
_RINvMs0_NtCskTcFVVikGfm_12wasm_encoder4coreNtB6_6Module7sectionNtNtB6_5types11TypeSectionECsb6KoqmGnaUT_11wasm_mutate:
  132|      2|    pub fn section(&mut self, section: &impl Section) -> &mut Self {
  133|      2|        self.bytes.push(section.id());
  134|      2|        section.encode(&mut self.bytes);
  135|      2|        self
  136|      2|    }
_RINvMs0_NtCskTcFVVikGfm_12wasm_encoder4coreNtB6_6Module7sectionNtNtB6_8memories13MemorySectionECsb6KoqmGnaUT_11wasm_mutate:
  132|      1|    pub fn section(&mut self, section: &impl Section) -> &mut Self {
  133|      1|        self.bytes.push(section.id());
  134|      1|        section.encode(&mut self.bytes);
  135|      1|        self
  136|      1|    }
_RINvMs0_NtCskTcFVVikGfm_12wasm_encoder4coreNtB6_6Module7sectionNtNtB6_7imports13ImportSectionECsb6KoqmGnaUT_11wasm_mutate:
  132|      1|    pub fn section(&mut self, section: &impl Section) -> &mut Self {
  133|      1|        self.bytes.push(section.id());
  134|      1|        section.encode(&mut self.bytes);
  135|      1|        self
  136|      1|    }
_RINvMs0_NtCskTcFVVikGfm_12wasm_encoder4coreNtB6_6Module7sectionNtNtB8_3raw10RawSectionECsb6KoqmGnaUT_11wasm_mutate:
  132|      5|    pub fn section(&mut self, section: &impl Section) -> &mut Self {
  133|      5|        self.bytes.push(section.id());
  134|      5|        section.encode(&mut self.bytes);
  135|      5|        self
  136|      5|    }
_RNvMs0_NtCskTcFVVikGfm_12wasm_encoder4coreNtB5_6Module3new:
  113|      2|    pub fn new() -> Self {
  114|      2|        Module {
  115|      2|            bytes: vec![
  116|      2|                // Magic
  117|      2|                0x00, 0x61, 0x73, 0x6D,
  118|      2|                // Version
  119|      2|                0x01, 0x00, 0x00, 0x00,
  120|      2|            ],
  121|      2|        }
  122|      2|    }
_RNvMs0_NtCskTcFVVikGfm_12wasm_encoder4coreNtB5_6Module6finish:
  145|      1|    pub fn finish(self) -> Vec<u8> {
  146|      1|        self.bytes
  147|      1|    }

_RNvMs_NtNtCskTcFVVikGfm_12wasm_encoder4core7exportsNtB4_13ExportSection3new:
   56|      1|    pub fn new() -> Self {
   57|      1|        Self::default()
   58|      1|    }
_RNvXNtNtCskTcFVVikGfm_12wasm_encoder4core7exportsNtB2_10ExportKindNtB6_6Encode6encode:
   22|      1|    fn encode(&self, sink: &mut Vec<u8>) {
   23|      1|        sink.push(match self {
   24|      1|            Self::Func => CORE_FUNCTION_SORT,
   25|      0|            Self::Table => CORE_TABLE_SORT,
   26|      0|            Self::Memory => CORE_MEMORY_SORT,
   27|      0|            Self::Global => CORE_GLOBAL_SORT,
   28|      0|            Self::Tag => CORE_TAG_SORT,
   29|       |        });
   30|      1|    }
_RNvXsb_NtNtCskTcFVVikGfm_12wasm_encoder4core7exportsNtB5_13ExportSectionNtNtCsg994vJE3n1e_4core7default7Default7default:
   48|      1|#[derive(Clone, Debug, Default)]
_RNvMs_NtNtCskTcFVVikGfm_12wasm_encoder4core7exportsNtB4_13ExportSection6export:
   71|      1|    pub fn export(&mut self, name: &str, kind: ExportKind, index: u32) -> &mut Self {
   72|      1|        name.encode(&mut self.bytes);
   73|      1|        kind.encode(&mut self.bytes);
   74|      1|        index.encode(&mut self.bytes);
   75|      1|        self.num_added += 1;
   76|      1|        self
   77|      1|    }

_RNvXs3_NtNtCskTcFVVikGfm_12wasm_encoder4core9functionsNtB5_15FunctionSectionNtNtCsg994vJE3n1e_4core7default7Default7default:
   23|      1|#[derive(Clone, Debug, Default)]
_RNvXs_NtNtCskTcFVVikGfm_12wasm_encoder4core9functionsNtB4_15FunctionSectionNtB8_6Encode6encode:
   54|      1|    fn encode(&self, sink: &mut Vec<u8>) {
   55|      1|        encode_section(sink, self.num_added, &self.bytes);
   56|      1|    }
_RNvMNtNtCskTcFVVikGfm_12wasm_encoder4core9functionsNtB2_15FunctionSection8function:
   46|      6|    pub fn function(&mut self, type_index: u32) -> &mut Self {
   47|      6|        type_index.encode(&mut self.bytes);
   48|      6|        self.num_added += 1;
   49|      6|        self
   50|      6|    }
_RNvXs0_NtNtCskTcFVVikGfm_12wasm_encoder4core9functionsNtB5_15FunctionSectionNtB7_7Section2id:
   60|      1|    fn id(&self) -> u8 {
   61|      1|        SectionId::Function.into()
   62|      1|    }

_RINvMs3_NtNtCskTcFVVikGfm_12wasm_encoder4core7importsNtB6_13ImportSection6importNtB6_10EntityTypeECsb6KoqmGnaUT_11wasm_mutate:
  123|      6|    pub fn import(&mut self, module: &str, field: &str, ty: impl Into<EntityType>) -> &mut Self {
  124|      6|        module.encode(&mut self.bytes);
  125|      6|        field.encode(&mut self.bytes);
  126|      6|        ty.into().encode(&mut self.bytes);
  127|      6|        self.num_added += 1;
  128|      6|        self
  129|      6|    }
_RNvXNtNtCskTcFVVikGfm_12wasm_encoder4core7importsNtB2_10EntityTypeNtB6_6Encode6encode:
   26|      6|    fn encode(&self, sink: &mut Vec<u8>) {
   27|      6|        match self {
   28|      6|            Self::Function(i) => {
   29|      6|                sink.push(CORE_FUNCTION_SORT);
   30|      6|                i.encode(sink);
   31|      6|            }
   32|      0|            Self::Table(t) => {
   33|      0|                sink.push(CORE_TABLE_SORT);
   34|      0|                t.encode(sink);
   35|      0|            }
   36|      0|            Self::Memory(t) => {
   37|      0|                sink.push(CORE_MEMORY_SORT);
   38|      0|                t.encode(sink);
   39|      0|            }
   40|      0|            Self::Global(t) => {
   41|      0|                sink.push(CORE_GLOBAL_SORT);
   42|      0|                t.encode(sink);
   43|      0|            }
   44|      0|            Self::Tag(t) => {
   45|      0|                sink.push(CORE_TAG_SORT);
   46|      0|                t.encode(sink);
   47|      0|            }
   48|       |        }
   49|      6|    }
_RNvXs5_NtNtCskTcFVVikGfm_12wasm_encoder4core7importsNtB5_13ImportSectionNtB7_7Section2id:
  139|      1|    fn id(&self) -> u8 {
  140|      1|        SectionId::Import.into()
  141|      1|    }
_RNvXsf_NtNtCskTcFVVikGfm_12wasm_encoder4core7importsNtB5_13ImportSectionNtNtCsg994vJE3n1e_4core7default7Default7default:
  100|      1|#[derive(Clone, Debug, Default)]
_RNvMs3_NtNtCskTcFVVikGfm_12wasm_encoder4core7importsNtB5_13ImportSection3new:
  108|      1|    pub fn new() -> Self {
  109|      1|        Self::default()
  110|      1|    }
_RNvXs4_NtNtCskTcFVVikGfm_12wasm_encoder4core7importsNtB5_13ImportSectionNtB9_6Encode6encode:
  133|      1|    fn encode(&self, sink: &mut Vec<u8>) {
  134|      1|        encode_section(sink, self.num_added, &self.bytes);
  135|      1|    }

_RNvXs3_NtNtCskTcFVVikGfm_12wasm_encoder4core8memoriesNtB5_13MemorySectionNtNtCsg994vJE3n1e_4core7default7Default7default:
   25|      1|#[derive(Clone, Default, Debug)]
_RNvXs_NtNtCskTcFVVikGfm_12wasm_encoder4core8memoriesNtB4_13MemorySectionNtB8_6Encode6encode:
   56|      1|    fn encode(&self, sink: &mut Vec<u8>) {
   57|      1|        encode_section(sink, self.num_added, &self.bytes);
   58|      1|    }
_RNvXs0_NtNtCskTcFVVikGfm_12wasm_encoder4core8memoriesNtB5_13MemorySectionNtB7_7Section2id:
   62|      1|    fn id(&self) -> u8 {
   63|      1|        SectionId::Memory.into()
   64|      1|    }

_RNvXNtNtCskTcFVVikGfm_12wasm_encoder4core5typeshINtNtCsg994vJE3n1e_4core7convert4FromNtB2_7ValTypeE4from:
   32|     72|    fn from(t: ValType) -> u8 {
   33|     72|        t as u8
   34|     72|    }
_RINvMs0_NtNtCskTcFVVikGfm_12wasm_encoder4core5typesNtB6_11TypeSection8functionINtNtCskqQrqCZBh0M_5alloc3vec3VecNtB6_7ValTypeEB1e_ECsb6KoqmGnaUT_11wasm_mutate:
   82|     11|    pub fn function<P, R>(&mut self, params: P, results: R) -> &mut Self
   83|     11|    where
   84|     11|        P: IntoIterator<Item = ValType>,
   85|     11|        P::IntoIter: ExactSizeIterator,
   86|     11|        R: IntoIterator<Item = ValType>,
   87|     11|        R::IntoIter: ExactSizeIterator,
   88|     11|    {
   89|     11|        let params = params.into_iter();
   90|     11|        let results = results.into_iter();
   91|     11|
   92|     11|        self.bytes.push(0x60);
   93|     11|        params.len().encode(&mut self.bytes);
   94|     11|        self.bytes.extend(params.map(u8::from));
   95|     11|        results.len().encode(&mut self.bytes);
   96|     11|        self.bytes.extend(results.map(u8::from));
   97|     11|        self.num_added += 1;
   98|     11|        self
   99|     11|    }
_RNvXsf_NtNtCskTcFVVikGfm_12wasm_encoder4core5typesNtB5_11TypeSectionNtNtCsg994vJE3n1e_4core7default7Default7default:
   59|      2|#[derive(Clone, Debug, Default)]
_RNvXs1_NtNtCskTcFVVikGfm_12wasm_encoder4core5typesNtB5_11TypeSectionNtB9_6Encode6encode:
  103|      2|    fn encode(&self, sink: &mut Vec<u8>) {
  104|      2|        encode_section(sink, self.num_added, &self.bytes);
  105|      2|    }
_RNvMs0_NtNtCskTcFVVikGfm_12wasm_encoder4core5typesNtB5_11TypeSection3new:
   67|      1|    pub fn new() -> Self {
   68|      1|        Self::default()
   69|      1|    }
_RNvXs2_NtNtCskTcFVVikGfm_12wasm_encoder4core5typesNtB5_11TypeSectionNtB7_7Section2id:
  109|      2|    fn id(&self) -> u8 {
  110|      2|        SectionId::Type.into()
  111|      2|    }

_RNvCskTcFVVikGfm_12wasm_encoder14encode_section:
  167|      5|fn encode_section(sink: &mut Vec<u8>, count: u32, bytes: &[u8]) {
  168|      5|    (encoding_size(count) + bytes.len()).encode(sink);
  169|      5|    count.encode(sink);
  170|      5|    sink.extend(bytes);
  171|      5|}
_RNvXs0_CskTcFVVikGfm_12wasm_encoderShNtB5_6Encode6encode:
  103|      5|    fn encode(&self, sink: &mut Vec<u8>) {
  104|      5|        self.len().encode(sink);
  105|      5|        sink.extend(self);
  106|      5|    }
_RNvCskTcFVVikGfm_12wasm_encoder13encoding_size:
  162|      5|fn encoding_size(n: u32) -> usize {
  163|      5|    let mut buf = [0u8; 5];
  164|      5|    leb128::write::unsigned(&mut &mut buf[..], n.into()).unwrap()
  165|      5|}
_RNvXs3_CskTcFVVikGfm_12wasm_encodermNtB5_6Encode6encode:
  124|     63|    fn encode(&self, sink: &mut Vec<u8>) {
  125|     63|        leb128::write::unsigned(sink, (*self).into()).unwrap();
  126|     63|    }
_RNvXs1_CskTcFVVikGfm_12wasm_encodereNtB5_6Encode6encode:
  110|     13|    fn encode(&self, sink: &mut Vec<u8>) {
  111|     13|        self.len().encode(sink);
  112|     13|        sink.extend_from_slice(self.as_bytes());
  113|     13|    }
_RNvXs2_CskTcFVVikGfm_12wasm_encoderjNtB5_6Encode6encode:
  117|     45|    fn encode(&self, sink: &mut Vec<u8>) {
  118|     45|        assert!(*self <= u32::max_value() as usize);
  119|     45|        (*self as u32).encode(sink)
  120|     45|    }

_RNvXNtCskTcFVVikGfm_12wasm_encoder3rawNtB2_10RawSectionNtB4_6Encode6encode:
   15|      5|    fn encode(&self, sink: &mut Vec<u8>) {
   16|      5|        self.data.encode(sink);
   17|      5|    }
_RNvXs_NtCskTcFVVikGfm_12wasm_encoder3rawNtB4_10RawSectionNtNtB6_4core7Section2id:
   21|      5|    fn id(&self) -> u8 {
   22|      5|        self.id
   23|      5|    }

_RNvMNtCsb6KoqmGnaUT_11wasm_mutate5errorNtB2_5Error23no_mutations_applicable:
   20|      1|    pub fn no_mutations_applicable() -> Self {
   21|      1|        ErrorKind::NoMutationsApplicable.into()
   22|      1|    }
_RNvXs_NtCsb6KoqmGnaUT_11wasm_mutate5errorNtB4_5ErrorINtNtCsg994vJE3n1e_4core7convert4FromNtB4_9ErrorKindE4from:
   46|    243|    fn from(kind: ErrorKind) -> Self {
   47|    243|        Error {
   48|    243|            kind: Box::new(kind),
   49|    243|        }
   50|    243|    }
_RNvXs0_NtCsb6KoqmGnaUT_11wasm_mutate5errorNtB5_5ErrorINtNtCsg994vJE3n1e_4core7convert4FromNtNtCs9VFM4FqidCT_10wasmparser13binary_reader17BinaryReaderErrorE4from:
   54|    242|    fn from(e: wasmparser::BinaryReaderError) -> Self {
   55|    242|        ErrorKind::Parse(e).into()
   56|    242|    }
_RNvXs3_NtCsb6KoqmGnaUT_11wasm_mutate5errorNtB5_5ErrorNtNtCsg994vJE3n1e_4core3fmt5Debug3fmt:
    2|    243|#[derive(thiserror::Error, Debug)]
_RNvXs7_NtCsb6KoqmGnaUT_11wasm_mutate5errorNtB5_9ErrorKindNtNtCsg994vJE3n1e_4core3fmt5Debug3fmt:
   60|    243|#[derive(thiserror::Error, Debug)]

_RNvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB2_10ModuleInfo7section:
  253|     12|    pub fn section(&mut self, id: u8, range: Range<usize>, full_wasm: &'a [u8]) {
  254|     12|        self.raw_sections.push(RawSection {
  255|     12|            id,
  256|     12|            data: &full_wasm[range],
  257|     12|        });
  258|     12|    }
_RNCNvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB4_10ModuleInfo3new0B6_:
   96|     10|                        reader.read().map(|ty| {
   97|     10|                            let typeinfo = TypeInfo::try_from(ty).unwrap();
   98|     10|                            info.types_map.push(typeinfo);
   99|     10|                        })?;
_RNvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB2_10ModuleInfo21num_imported_memories:
  384|      1|    pub fn num_imported_memories(&self) -> u32 {
  385|      1|        self.imported_memories_count
  386|      1|    }
_RNvXs_NtCsb6KoqmGnaUT_11wasm_mutate4infoNtB4_10ModuleInfoNtNtCsg994vJE3n1e_4core7default7Default7default:
   13|    244|#[derive(Default, Clone, Debug)]
_RNvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB2_10ModuleInfo12num_memories:
  380|      2|    pub fn num_memories(&self) -> u32 {
  381|      2|        self.memory_count
  382|      2|    }
_RNvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB2_10ModuleInfo16get_type_section:
  260|      1|    pub fn get_type_section(&self) -> Option<RawSection<'a>> {
  261|      1|        let idx = self.types?;
  262|      1|        Some(self.raw_sections[idx])
  263|      1|    }
_RNvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB2_10ModuleInfo22num_imported_functions:
  368|      1|    pub fn num_imported_functions(&self) -> u32 {
  369|      1|        self.imported_functions_count
  370|      1|    }
_RNvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB2_10ModuleInfo3new:
   63|    244|    pub fn new(input_wasm: &[u8]) -> Result<ModuleInfo> {
   64|    244|        let mut parser = Parser::new(0);
   65|    244|        let mut info = ModuleInfo::default();
   66|    244|        let mut wasm = input_wasm;
   67|    244|        info.input_wasm = wasm;
   68|       |
   69|       |        loop {
   70|    258|            let (payload, consumed) = match parser.parse(wasm, true)? {
   71|      0|                Chunk::NeedMoreData(hint) => {
   72|      0|                    panic!("Invalid Wasm module {:?}", hint);
   73|       |                }
   74|     16|                Chunk::Parsed { consumed, payload } => (payload, consumed),
   75|     16|            };
   76|     16|            match payload {
   77|       |                Payload::CodeSectionStart {
   78|       |                    count: _,
   79|      2|                    range,
   80|      2|                    size: _,
   81|      2|                } => {
   82|      2|                    info.code = Some(info.raw_sections.len());
   83|      2|                    info.section(SectionId::Code.into(), range.clone(), input_wasm);
   84|      2|                    parser.skip_section();
   85|      2|                    // update slice, bypass the section
   86|      2|                    wasm = &input_wasm[range.end..];
   87|      2|
   88|      2|                    continue;
   89|       |                }
   90|      2|                Payload::TypeSection(mut reader) => {
   91|      2|                    info.types = Some(info.raw_sections.len());
   92|      2|                    info.section(SectionId::Type.into(), reader.range(), input_wasm);
   93|      2|
   94|      2|                    // Save function types
   95|      2|                    for _ in 0..reader.get_count() {
   96|     10|                        reader.read().map(|ty| {
   97|       |                            let typeinfo = TypeInfo::try_from(ty).unwrap();
   98|       |                            info.types_map.push(typeinfo);
   99|     10|                        })?;
  100|       |                    }
  101|       |                }
  102|      2|                Payload::ImportSection(mut reader) => {
  103|      2|                    info.imports = Some(info.raw_sections.len());
  104|      2|                    info.section(SectionId::Import.into(), reader.range(), input_wasm);
  105|      2|
  106|      2|                    for _ in 0..reader.get_count() {
  107|     12|                        let ty = reader.read()?;
  108|     12|                        match ty.ty {
  109|     12|                            wasmparser::TypeRef::Func(ty) => {
  110|     12|                                // Save imported functions
  111|     12|                                info.function_map.push(ty);
  112|     12|                                info.imported_functions_count += 1;
  113|     12|                            }
  114|      0|                            wasmparser::TypeRef::Global(ty) => {
  115|      0|                                let ty = PrimitiveTypeInfo::try_from(ty.content_type).unwrap();
  116|      0|                                info.global_types.push(ty);
  117|      0|                                info.imported_globals_count += 1;
  118|      0|                            }
  119|      0|                            wasmparser::TypeRef::Memory(ty) => {
  120|      0|                                info.memory_count += 1;
  121|      0|                                info.imported_memories_count += 1;
  122|      0|                                info.memory_types.push(ty);
  123|      0|                            }
  124|      0|                            wasmparser::TypeRef::Table(ty) => {
  125|      0|                                info.table_count += 1;
  126|      0|                                info.imported_tables_count += 1;
  127|      0|                                info.table_elem_types.push(ty.element_type.into());
  128|      0|                            }
  129|      0|                            wasmparser::TypeRef::Tag(_ty) => {
  130|      0|                                info.tag_count += 1;
  131|      0|                                info.imported_tags_count += 1;
  132|      0|                            }
  133|       |                        }
  134|       |                    }
  135|       |                }
  136|      2|                Payload::FunctionSection(mut reader) => {
  137|      2|                    info.functions = Some(info.raw_sections.len());
  138|      2|                    info.section(SectionId::Function.into(), reader.range(), input_wasm);
  139|      2|
  140|      2|                    for _ in 0..reader.get_count() {
  141|     12|                        reader.read().map(|ty| {
  142|       |                            info.function_map.push(ty);
  143|     12|                        })?;
  144|       |                    }
  145|       |                }
  146|      0|                Payload::TableSection(mut reader) => {
  147|      0|                    info.tables = Some(info.raw_sections.len());
  148|      0|                    info.table_count += reader.get_count();
  149|      0|                    info.section(SectionId::Table.into(), reader.range(), input_wasm);
  150|      0|
  151|      0|                    for _ in 0..reader.get_count() {
  152|      0|                        let ty = reader.read()?;
  153|      0|                        let ty = PrimitiveTypeInfo::try_from(ty.element_type).unwrap();
  154|      0|                        info.table_elem_types.push(ty);
  155|       |                    }
  156|       |                }
  157|      2|                Payload::MemorySection(mut reader) => {
  158|      2|                    info.memories = Some(info.raw_sections.len());
  159|      2|                    info.memory_count += reader.get_count();
  160|      2|                    info.section(SectionId::Memory.into(), reader.range(), input_wasm);
  161|      2|
  162|      2|                    for _ in 0..reader.get_count() {
  163|      2|                        let ty = reader.read()?;
  164|      2|                        info.memory_types.push(ty);
  165|       |                    }
  166|       |                }
  167|      0|                Payload::GlobalSection(mut reader) => {
  168|      0|                    info.globals = Some(info.raw_sections.len());
  169|      0|                    info.section(SectionId::Global.into(), reader.range(), input_wasm);
  170|      0|
  171|      0|                    for _ in 0..reader.get_count() {
  172|      0|                        let ty = reader.read()?;
  173|       |                        // We only need the type of the global, not necessarily if is mutable or not
  174|      0|                        let ty = PrimitiveTypeInfo::try_from(ty.ty.content_type).unwrap();
  175|      0|                        info.global_types.push(ty);
  176|       |                    }
  177|       |                }
  178|      2|                Payload::ExportSection(mut reader) => {
  179|      2|                    info.exports = Some(info.raw_sections.len());
  180|      2|                    info.exports_count = reader.get_count();
  181|      2|
  182|      4|                    for _ in 0..reader.get_count() {
  183|      4|                        let entry = reader.read()?;
  184|      4|                        info.export_names.insert(entry.name.into());
  185|       |                    }
  186|       |
  187|      2|                    info.section(SectionId::Export.into(), reader.range(), input_wasm);
  188|       |                }
  189|      0|                Payload::StartSection { func, range } => {
  190|      0|                    info.start = Some(info.raw_sections.len());
  191|      0|                    info.start_function = Some(func);
  192|      0|                    info.section(SectionId::Start.into(), range, input_wasm);
  193|      0|                }
  194|      0|                Payload::ElementSection(reader) => {
  195|      0|                    info.elements = Some(info.raw_sections.len());
  196|      0|                    info.elements_count = reader.get_count();
  197|      0|                    info.section(SectionId::Element.into(), reader.range(), input_wasm);
  198|      0|                }
  199|      0|                Payload::DataSection(reader) => {
  200|      0|                    info.data = Some(info.raw_sections.len());
  201|      0|                    info.data_segments_count = reader.get_count();
  202|      0|                    info.section(SectionId::Data.into(), reader.range(), input_wasm);
  203|      0|                }
  204|      0|                Payload::CustomSection(c) => {
  205|      0|                    info.section(SectionId::Custom.into(), c.range(), input_wasm);
  206|      0|                }
  207|       |                Payload::UnknownSection {
  208|      0|                    id,
  209|      0|                    contents: _,
  210|      0|                    range,
  211|      0|                } => {
  212|      0|                    info.section(id, range, input_wasm);
  213|      0|                }
  214|      0|                Payload::DataCountSection { count: _, range } => {
  215|      0|                    info.data_count = Some(info.raw_sections.len());
  216|      0|                    info.section(SectionId::DataCount.into(), range, input_wasm);
  217|      0|                }
  218|      2|                Payload::Version { .. } => {}
  219|       |                Payload::End(_) => {
  220|      2|                    break;
  221|       |                }
  222|      0|                _ => todo!("{:?} not implemented", payload),
  223|       |            }
  224|     12|            wasm = &wasm[consumed..];
  225|       |        }
  226|       |
  227|      2|        Ok(info)
  228|    244|    }
_RINvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB3_10ModuleInfo15replace_sectionNtNtNtCskTcFVVikGfm_12wasm_encoder4core5types11TypeSectionEB5_:
  320|      1|    pub fn replace_section(
  321|      1|        &self,
  322|      1|        i: usize,
  323|      1|        new_section: &impl wasm_encoder::Section,
  324|      1|    ) -> wasm_encoder::Module {
  325|      1|        log::trace!("replacing section {}", i);
  326|      1|        let mut module = wasm_encoder::Module::new();
  327|      6|        for (j, s) in self.raw_sections.iter().enumerate() {
  328|      6|            if i == j {
  329|      1|                module.section(new_section);
  330|      5|            } else {
  331|      5|                module.section(s);
  332|      5|            }
  333|       |        }
  334|      1|        module
  335|      1|    }
_RNCNvMNtCsb6KoqmGnaUT_11wasm_mutate4infoNtB4_10ModuleInfo3news_0B6_:
  141|     12|                        reader.read().map(|ty| {
  142|     12|                            info.function_map.push(ty);
  143|     12|                        })?;

_RNCNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB6_10WasmMutate3runs26_0B6_:
  289|      1|        define_mutators!(
_RNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB4_10WasmMutate5setup:
  325|    244|    fn setup(&mut self, input_wasm: &'wasm [u8]) -> Result<()> {
  326|    244|        self.info = Some(ModuleInfo::new(input_wasm)?);
  327|      2|        self.rng = Some(SmallRng::seed_from_u64(self.seed));
  328|      2|        Ok(())
  329|    244|    }
_RNCNCNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB8_10WasmMutate3runs26_00B8_:
  289|      1|        define_mutators!(
  290|      1|            self,
  291|      1|            (
  292|      1|                PeepholeMutator::new(2),
  293|      1|                RemoveExportMutator,
  294|      1|                RenameExportMutator { max_name_size: 100 },
  295|      1|                SnipMutator,
  296|      1|                CodemotionMutator,
  297|      1|                FunctionBodyUnreachable,
  298|      1|                AddTypeMutator {
  299|      1|                    max_params: 20,
  300|      1|                    max_results: 20,
  301|      1|                },
  302|      1|                AddFunctionMutator,
  303|      1|                RemoveSection::Custom,
  304|      1|                RemoveSection::Empty,
  305|      1|                ConstExpressionMutator::Global,
  306|      1|                ConstExpressionMutator::ElementOffset,
  307|      1|                ConstExpressionMutator::ElementFunc,
  308|      1|                RemoveItemMutator(Item::Function),
  309|      1|                RemoveItemMutator(Item::Global),
  310|      1|                RemoveItemMutator(Item::Memory),
  311|      1|                RemoveItemMutator(Item::Table),
  312|      1|                RemoveItemMutator(Item::Type),
  313|      1|                RemoveItemMutator(Item::Data),
  314|      1|                RemoveItemMutator(Item::Element),
  315|      1|                RemoveItemMutator(Item::Tag),
  316|      1|                ModifyDataMutator {
  317|      1|                    max_data_size: 10 << 20, // 10MB
  318|      1|                },
  319|      1|            )
  320|      1|        );
_RNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB4_10WasmMutate3run:
  280|    244|        self.setup(input_wasm)?;
  281|       |
  282|       |        // This macro just expands the logic to return an iterator form the
  283|       |        // mutators
  284|       |        // It simulates a circular checking of the mutators starting by a random
  285|       |        // one, returning the first one that can provides a mutation.
  286|       |        // All possible start indexes are calculated at compilation time, if N
  287|       |        // is the number of mutataros, N possible starting indexes are injected
  288|       |        // and compiled to the final code
  289|      2|        define_mutators!(
  290|       |            self,
  291|       |            (
  292|      0|                PeepholeMutator::new(2),
  293|      0|                RemoveExportMutator,
  294|      0|                RenameExportMutator { max_name_size: 100 },
  295|      0|                SnipMutator,
  296|      0|                CodemotionMutator,
  297|      0|                FunctionBodyUnreachable,
  298|      1|                AddTypeMutator {
  299|      1|                    max_params: 20,
  300|      1|                    max_results: 20,
  301|      1|                },
  302|      0|                AddFunctionMutator,
  303|      0|                RemoveSection::Custom,
  304|      0|                RemoveSection::Empty,
  305|      0|                ConstExpressionMutator::Global,
  306|      0|                ConstExpressionMutator::ElementOffset,
  307|      0|                ConstExpressionMutator::ElementFunc,
  308|      0|                RemoveItemMutator(Item::Function),
  309|      0|                RemoveItemMutator(Item::Global),
  310|      1|                RemoveItemMutator(Item::Memory),
  311|      0|                RemoveItemMutator(Item::Table),
  312|      0|                RemoveItemMutator(Item::Type),
  313|      0|                RemoveItemMutator(Item::Data),
  314|      0|                RemoveItemMutator(Item::Element),
  315|      0|                RemoveItemMutator(Item::Tag),
  316|       |                ModifyDataMutator {
  317|      0|                    max_data_size: 10 << 20, // 10MB
  318|       |                },
  319|       |            )
  320|       |        );
  321|       |
  322|      0|        Err(Error::no_mutations_applicable())
  323|    244|    }
_RNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB4_10WasmMutate3rng:
  331|     33|    pub(crate) fn rng(&mut self) -> &mut SmallRng {
  332|     33|        self.rng.as_mut().unwrap()
  333|     33|    }
_RNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB4_10WasmMutate4fuel:
  231|    244|    pub fn fuel(&mut self, fuel: u64) -> &mut Self {
  232|    244|        self.fuel = fuel;
  233|    244|        self
  234|    244|    }
_RNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB4_10WasmMutate4info:
  335|      6|    pub(crate) fn info(&self) -> &ModuleInfo<'wasm> {
  336|      6|        self.info.as_ref().unwrap()
  337|      6|    }
_RNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB4_10WasmMutate18preserve_semantics:
  225|    244|    pub fn preserve_semantics(&mut self, preserve_semantics: bool) -> &mut Self {
  226|    244|        self.preserve_semantics = preserve_semantics;
  227|    244|        self
  228|    244|    }
_RNvMs_Csb6KoqmGnaUT_11wasm_mutateNtB4_10WasmMutate4seed:
  218|    244|    pub fn seed(&mut self, seed: u64) -> &mut Self {
  219|    244|        self.seed = seed;
  220|    244|        self
  221|    244|    }
_RNvXCsb6KoqmGnaUT_11wasm_mutateNtB2_10WasmMutateNtNtCsg994vJE3n1e_4core7default7Default7default:
  199|    244|    fn default() -> Self {
  200|    244|        let seed = 3;
  201|    244|        WasmMutate {
  202|    244|            seed,
  203|    244|            preserve_semantics: false,
  204|    244|            reduce: false,
  205|    244|            raw_mutate_func: None,
  206|    244|            fuel: u64::MAX,
  207|    244|            rng: None,
  208|    244|            info: None,
  209|    244|        }
  210|    244|    }

_RNCNvXs_NtCsb6KoqmGnaUT_11wasm_mutate6moduleNtB6_8TypeInfoINtNtCsg994vJE3n1e_4core7convert7TryFromNtNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5types4TypeE8try_from0B8_:
   52|     34|                    .map(|&t| PrimitiveTypeInfo::from(t))
_RNCNvXs_NtCsb6KoqmGnaUT_11wasm_mutate6moduleNtB6_8TypeInfoINtNtCsg994vJE3n1e_4core7convert7TryFromNtNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5types4TypeE8try_froms_0B8_:
   57|     10|                    .map(|&t| PrimitiveTypeInfo::from(t))
_RNvXNtCsb6KoqmGnaUT_11wasm_mutate6moduleNtB2_17PrimitiveTypeInfoINtNtCsg994vJE3n1e_4core7convert4FromNtNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5types7ValTypeE4from:
   30|     44|    fn from(value: wasmparser::ValType) -> Self {
   31|     44|        match value {
   32|     38|            wasmparser::ValType::I32 => PrimitiveTypeInfo::I32,
   33|      6|            wasmparser::ValType::I64 => PrimitiveTypeInfo::I64,
   34|      0|            wasmparser::ValType::F32 => PrimitiveTypeInfo::F32,
   35|      0|            wasmparser::ValType::F64 => PrimitiveTypeInfo::F64,
   36|      0|            wasmparser::ValType::V128 => PrimitiveTypeInfo::V128,
   37|      0|            wasmparser::ValType::FuncRef => PrimitiveTypeInfo::FuncRef,
   38|      0|            wasmparser::ValType::ExternRef => PrimitiveTypeInfo::ExternRef,
   39|       |        }
   40|     44|    }
_RNvXs_NtCsb6KoqmGnaUT_11wasm_mutate6moduleNtB4_8TypeInfoINtNtCsg994vJE3n1e_4core7convert7TryFromNtNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5types4TypeE8try_from:
   46|     10|    fn try_from(value: wasmparser::Type) -> Result<Self> {
   47|     10|        match value {
   48|     10|            wasmparser::Type::Func(ft) => Ok(TypeInfo::Func(FuncInfo {
   49|     10|                params: ft
   50|     10|                    .params()
   51|     10|                    .iter()
   52|     10|                    .map(|&t| PrimitiveTypeInfo::from(t))
   53|     10|                    .collect(),
   54|     10|                returns: ft
   55|     10|                    .results()
   56|     10|                    .iter()
   57|     10|                    .map(|&t| PrimitiveTypeInfo::from(t))
   58|     10|                    .collect(),
   59|     10|            })),
   60|     10|        }
   61|     10|    }

_RNvYNtNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators8add_type14AddTypeMutatorNtB6_7Mutator4nameB8_:
  101|      3|    fn name(&self) -> Cow<'static, str> {
  102|      3|        return std::any::type_name::<Self>().into();
  103|      3|    }
_RNvYNtNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_item17RemoveItemMutatorNtB6_7Mutator4nameB8_:
  101|      3|    fn name(&self) -> Cow<'static, str> {
  102|      3|        return std::any::type_name::<Self>().into();
  103|      3|    }

_RNvNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators8add_type14translate_type:
   90|     22|fn translate_type(ty: &wasmparser::ValType) -> Result<wasm_encoder::ValType> {
   91|     22|    Ok(match ty {
   92|     19|        wasmparser::ValType::I32 => wasm_encoder::ValType::I32,
   93|      3|        wasmparser::ValType::I64 => wasm_encoder::ValType::I64,
   94|      0|        wasmparser::ValType::F32 => wasm_encoder::ValType::F32,
   95|      0|        wasmparser::ValType::F64 => wasm_encoder::ValType::F64,
   96|      0|        wasmparser::ValType::V128 => wasm_encoder::ValType::V128,
   97|      0|        wasmparser::ValType::FuncRef => wasm_encoder::ValType::FuncRef,
   98|      0|        wasmparser::ValType::ExternRef => wasm_encoder::ValType::ExternRef,
   99|       |    })
  100|     22|}
_RNvXs_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators8add_typeNtB4_14AddTypeMutatorNtB6_7Mutator10can_mutate:
   33|      1|    fn can_mutate(&self, config: &crate::WasmMutate) -> bool {
   34|      1|        !config.reduce
   35|      1|    }
_RINvMNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators8add_typeNtB3_14AddTypeMutator14random_valtypeNtNtNtCsjh8jLldxRdx_4rand4rngs5small8SmallRngEB7_:
   18|     28|    fn random_valtype(&self, rng: &mut impl Rng) -> wasm_encoder::ValType {
   19|     28|        match rng.gen_range(0..=6) {
   20|      3|            0 => wasm_encoder::ValType::I32,
   21|      2|            1 => wasm_encoder::ValType::I64,
   22|      6|            2 => wasm_encoder::ValType::F32,
   23|      5|            3 => wasm_encoder::ValType::F64,
   24|      2|            4 => wasm_encoder::ValType::V128,
   25|      4|            5 => wasm_encoder::ValType::ExternRef,
   26|      6|            6 => wasm_encoder::ValType::FuncRef,
   27|      0|            _ => unreachable!(),
   28|       |        }
   29|     28|    }
_RNvXs_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators8add_typeNtB4_14AddTypeMutatorNtB6_7Mutator6mutate:
   37|      1|    fn mutate<'a>(
   38|      1|        self,
   39|      1|        config: &'a mut crate::WasmMutate,
   40|      1|    ) -> crate::Result<Box<dyn Iterator<Item = crate::Result<wasm_encoder::Module>> + 'a>> {
   41|      1|        let count = config.rng().gen_range(0..=self.max_params);
   42|      1|        let mut params = Vec::with_capacity(count);
   43|     12|        for _ in 0..count {
   44|     12|            params.push(self.random_valtype(config.rng()));
   45|     12|        }
   46|       |
   47|      1|        let count = config.rng().gen_range(0..=self.max_results);
   48|      1|        let mut results = Vec::with_capacity(count);
   49|     16|        for _ in 0..count {
   50|     16|            results.push(self.random_valtype(config.rng()));
   51|     16|        }
   52|       |
   53|      1|        let mut types = wasm_encoder::TypeSection::new();
   54|      1|        if let Some(old_types) = config.info().get_type_section() {
   55|       |            // Copy the existing types section over into the encoder.
   56|      1|            let mut reader = wasmparser::TypeSectionReader::new(old_types.data, 0)?;
   57|      1|            for _ in 0..reader.get_count() {
   58|      5|                let ty = reader.read()?;
   59|      5|                match ty {
   60|      5|                    wasmparser::Type::Func(ty) => {
   61|      5|                        let params = ty
   62|      5|                            .params()
   63|      5|                            .iter()
   64|      5|                            .map(translate_type)
   65|      5|                            .collect::<Result<Vec<_>, _>>()?;
   66|      5|                        let results = ty
   67|      5|                            .results()
   68|      5|                            .iter()
   69|      5|                            .map(translate_type)
   70|      5|                            .collect::<Result<Vec<_>, _>>()?;
   71|      5|                        types.function(params, results);
   72|       |                    }
   73|       |                }
   74|       |            }
   75|       |            // And then add our new type.
   76|      1|            types.function(params, results);
   77|      1|            let types_section_index = config.info().types.unwrap();
   78|      1|            Ok(Box::new(iter::once(Ok(config
   79|      1|                .info()
   80|      1|                .replace_section(types_section_index, &types)))))
   81|       |        } else {
   82|      0|            types.function(params, results);
   83|      0|            Ok(Box::new(iter::once(Ok(config
   84|      0|                .info()
   85|      0|                .insert_section(0, &types)))))
   86|       |        }
   87|      1|    }
_RNvXs0_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators8add_typeNtB5_14AddTypeMutatorNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
   11|      1|#[derive(Clone, Copy)]

_RNvXNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB2_17RemoveItemMutatorNtB4_7Mutator6mutate:
   33|      1|    fn mutate<'a>(
   34|      1|        self,
   35|      1|        config: &'a mut WasmMutate,
   36|      1|    ) -> Result<Box<dyn Iterator<Item = Result<wasm_encoder::Module>> + 'a>>
   37|      1|    where
   38|      1|        Self: Copy,
   39|      1|    {
   40|      1|        let idx = self.0.choose_removal_index(config);
   41|      1|        log::trace!("attempting to remove {:?} index {}", self.0, idx);
   42|       |
   43|      1|        let result = RemoveItem {
   44|      1|            item: self.0,
   45|      1|            idx,
   46|      1|            referenced_functions: HashSet::new(),
   47|      1|            function_reference_action: Funcref::Save,
   48|      1|        }
   49|      1|        .remove(config.info());
   50|      1|        match result {
   51|      0|            Ok(result) => {
   52|      0|                log::debug!("removed {:?} index {}", self.0, idx);
   53|      0|                Ok(Box::new(std::iter::once(Ok(result))))
   54|       |            }
   55|      1|            Err(e) => {
   56|      1|                log::trace!("failed to remove {:?} index {}: {:?}", self.0, idx, e);
   57|      1|                Err(e)
   58|       |            }
   59|       |        }
   60|      1|    }
_RNCNvMs0_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB7_10RemoveItem6removes_0Bb_:
  205|      6|                        |me, idx, section: &mut FunctionSection| {
  206|      6|                            let idx = me.remap(Item::Type, idx)?;
  207|      6|                            section.function(idx);
  208|      6|                            Ok(())
  209|      6|                        },
_RNvMs_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtNtB6_9translate4Item10can_mutate:
   64|      1|    fn can_mutate(&self, config: &WasmMutate) -> bool {
   65|      1|        // This heuristic is a bit of a lie in that just because an item is
   66|      1|        // present doesn't mean that it's actually candidate for removal. The
   67|      1|        // alternative would be to build up some sort of precise liveness set of
   68|      1|        // all items which is a bit of a pain to do, so instead this mutator is
   69|      1|        // generally always applicable and then might just frequently return a
   70|      1|        // "no mutations applicable" error later
   71|      1|        let info = config.info();
   72|      1|        match self {
   73|      0|            Item::Function => info.num_functions() > 0,
   74|      0|            Item::Table => info.num_tables() > 0,
   75|      1|            Item::Memory => info.num_memories() > 0,
   76|      0|            Item::Global => info.num_globals() > 0,
   77|      0|            Item::Tag => info.num_tags() > 0,
   78|      0|            Item::Type => info.num_types() > 0,
   79|       |
   80|       |            // Note that data/elements can lead to traps and side-effectful
   81|       |            // initialization of imported tables/memories, so these are only
   82|       |            // considered for removal if we're not preserving semantics.
   83|      0|            Item::Data => !config.preserve_semantics && info.num_data() > 0,
   84|      0|            Item::Element => !config.preserve_semantics && info.num_elements() > 0,
   85|       |        }
   86|      1|    }
_RNvMs_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtNtB6_9translate4Item20choose_removal_index:
   88|      1|    fn choose_removal_index(&self, config: &mut WasmMutate) -> u32 {
   89|      1|        let info = config.info();
   90|      1|        let max = match self {
   91|      0|            Item::Function => info.num_functions(),
   92|      0|            Item::Table => info.num_tables(),
   93|      1|            Item::Memory => info.num_memories(),
   94|      0|            Item::Global => info.num_globals(),
   95|      0|            Item::Tag => info.num_tags(),
   96|      0|            Item::Type => info.num_types(),
   97|      0|            Item::Data => info.num_data(),
   98|      0|            Item::Element => info.num_elements(),
   99|       |        };
  100|      1|        config.rng().gen_range(0..max)
  101|      1|    }
_RNvMs0_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB5_10RemoveItem6remove:
  122|      1|    fn remove(&mut self, info: &ModuleInfo) -> Result<Module> {
  123|      1|        // This is the main workhorse loop of the module translation. This will
  124|      1|        // iterate over the original wasm sections, raw, and create the new
  125|      1|        // module section-by-section. Sections are rewritten on-the-fly.
  126|      1|        let mut module = Module::new();
  127|      5|        for section in info.raw_sections.iter() {
  128|      5|            crate::module::match_section_id! {
  129|      5|                match section.id;
  130|       |
  131|      0|                Custom => {
  132|      0|                    module.section(section);
  133|      0|                },
  134|       |
  135|       |                Type => {
  136|       |                    self.filter_out(
  137|      1|                        &mut module,
  138|      1|                        0,
  139|      1|                        TypeSectionReader::new(section.data, 0)?,
  140|      1|                        Item::Type,
  141|       |                        |me, ty, section| me.translate_type_def(ty, section),
  142|      0|                    )?;
  143|       |                },
  144|       |
  145|       |                Import => {
  146|       |                    // The import section is a little special because it defines
  147|       |                    // items in multiple index spaces. This means that the
  148|       |                    // `filter_out` helper can't be used and we have to process
  149|       |                    // everything manually here.
  150|      1|                    let mut result = ImportSection::new();
  151|      1|                    let mut function = 0;
  152|      1|                    let mut global = 0;
  153|      1|                    let mut table = 0;
  154|      1|                    let mut memory = 0;
  155|      1|                    let mut tag = 0;
  156|      6|                    for item in ImportSectionReader::new(section.data, 0)? {
  157|      6|                        let item = item?;
  158|      6|                        match &item.ty {
  159|      6|                            wasmparser::TypeRef::Func(ty) => {
  160|      6|                                if self.item != Item::Function || self.idx != function {
  161|      6|                                    let ty = self.remap(Item::Type, *ty)?;
  162|      6|                                    result.import(item.module, item.name, EntityType::Function(ty));
  163|      0|                                }
  164|      6|                                function += 1;
  165|       |                            }
  166|      0|                            wasmparser::TypeRef::Table(ty) => {
  167|      0|                                if self.item != Item::Table || self.idx != table {
  168|      0|                                    let ty = self.translate_table_type(ty)?;
  169|      0|                                    result.import(item.module, item.name, ty);
  170|      0|                                }
  171|      0|                                table += 1;
  172|       |                            }
  173|      0|                            wasmparser::TypeRef::Memory(ty) => {
  174|      0|                                if self.item != Item::Memory || self.idx != memory {
  175|      0|                                    let ty = self.translate_memory_type(ty)?;
  176|      0|                                    result.import(item.module, item.name, ty);
  177|      0|                                }
  178|      0|                                memory += 1;
  179|       |                            }
  180|      0|                            wasmparser::TypeRef::Global(ty) => {
  181|      0|                                if self.item != Item::Global || self.idx != global {
  182|      0|                                    let ty = self.translate_global_type(ty)?;
  183|      0|                                    result.import(item.module, item.name, ty);
  184|      0|                                }
  185|      0|                                global += 1;
  186|       |                            }
  187|      0|                            wasmparser::TypeRef::Tag(ty) => {
  188|      0|                                if self.item != Item::Tag || self.idx != tag {
  189|      0|                                    let ty = self.translate_tag_type(ty)?;
  190|      0|                                    result.import(item.module, item.name, ty);
  191|      0|                                }
  192|      0|                                tag += 1;
  193|       |                            }
  194|       |                        }
  195|       |                    }
  196|      1|                    module.section(&result);
  197|       |                },
  198|       |
  199|       |                Function => {
  200|       |                    self.filter_out(
  201|      1|                        &mut module,
  202|      1|                        info.num_imported_functions(),
  203|      1|                        FunctionSectionReader::new(section.data, 0)?,
  204|      1|                        Item::Function,
  205|       |                        |me, idx, section: &mut FunctionSection| {
  206|       |                            let idx = me.remap(Item::Type, idx)?;
  207|       |                            section.function(idx);
  208|       |                            Ok(())
  209|       |                        },
  210|      0|                    )?;
  211|       |                },
  212|       |
  213|       |                Table => {
  214|       |                    self.filter_out(
  215|      0|                        &mut module,
  216|      0|                        info.num_imported_tables(),
  217|      0|                        TableSectionReader::new(section.data, 0)?,
  218|      0|                        Item::Table,
  219|       |                        |me, ty, section: &mut TableSection| {
  220|       |                            let ty = me.translate_table_type(&ty)?;
  221|       |                            section.table(ty);
  222|       |                            Ok(())
  223|       |                        },
  224|      0|                    )?;
  225|       |                },
  226|       |
  227|       |                Memory => {
  228|       |                    self.filter_out(
  229|      1|                        &mut module,
  230|      1|                        info.num_imported_memories(),
  231|      1|                        MemorySectionReader::new(section.data, 0)?,
  232|      1|                        Item::Memory,
  233|       |                        |me, ty, section: &mut MemorySection| {
  234|       |                            let ty = me.translate_memory_type(&ty)?;
  235|       |                            section.memory(ty);
  236|       |                            Ok(())
  237|       |                        },
  238|      0|                    )?;
  239|       |                },
  240|       |
  241|       |                Global => {
  242|       |                    self.filter_out(
  243|      0|                        &mut module,
  244|      0|                        info.num_imported_globals(),
  245|      0|                        GlobalSectionReader::new(section.data, 0)?,
  246|      0|                        Item::Global,
  247|       |                        |me, ty, section| me.translate_global(ty, section),
  248|      0|                    )?;
  249|       |                },
  250|       |
  251|       |                Export => {
  252|      1|                    let mut result = ExportSection::new();
  253|      2|                    for item in ExportSectionReader::new(section.data, 0)? {
  254|      2|                        let item = item?;
  255|      2|                        let (kind, index) = match &item.kind {
  256|       |                            ExternalKind::Func => {
  257|      1|                                (ExportKind::Func, self.remap(Item::Function, item.index)?)
  258|       |                            }
  259|       |                            ExternalKind::Table => {
  260|      0|                                (ExportKind::Table, self.remap(Item::Table, item.index)?)
  261|       |                            }
  262|       |                            ExternalKind::Memory => {
  263|      1|                                (ExportKind::Memory, self.remap(Item::Memory, item.index)?)
  264|       |                            }
  265|      0|                            ExternalKind::Tag => (ExportKind::Tag, self.remap(Item::Tag, item.index)?),
  266|       |                            ExternalKind::Global => {
  267|      0|                                (ExportKind::Global, self.remap(Item::Global, item.index)?)
  268|       |                            }
  269|       |                        };
  270|      1|                        result.export(item.name, kind, index);
  271|       |                    }
  272|      0|                    module.section(&result);
  273|       |                },
  274|       |
  275|       |                Start => {
  276|      0|                    let function_index = BinaryReader::new(section.data).read_var_u32()?;
  277|      0|                    self.function_reference_action = Funcref::Skip;
  278|      0|                    let function_index = self.remap(Item::Function, function_index)?;
  279|      0|                    self.function_reference_action = Funcref::Save;
  280|      0|                    module.section(&StartSection { function_index });
  281|       |                },
  282|       |
  283|       |                Element => {
  284|       |                    self.filter_out(
  285|      0|                        &mut module,
  286|      0|                        0,
  287|      0|                        ElementSectionReader::new(section.data, 0)?,
  288|      0|                        Item::Element,
  289|       |                        |me, ty, section| me.translate_element(ty, section),
  290|      0|                    )?;
  291|       |                },
  292|       |
  293|       |                Code => {
  294|       |                    // In the code section we require that all functions
  295|       |                    // referenced in `ref.func` are referenced elsewhere in the
  296|       |                    // module, so indicate so in our internal state here.
  297|      0|                    self.function_reference_action = Funcref::RequireReferenced;
  298|      0|                    self.filter_out(
  299|      0|                        &mut module,
  300|      0|                        info.num_imported_functions(),
  301|      0|                        CodeSectionReader::new(section.data, 0)?,
  302|      0|                        Item::Function,
  303|       |                        |me, body, section| me.translate_code(body, section),
  304|      0|                    )?;
  305|       |                },
  306|       |
  307|       |                Data => {
  308|       |                    self.filter_out(
  309|      0|                        &mut module,
  310|      0|                        0,
  311|      0|                        DataSectionReader::new(section.data, 0)?,
  312|      0|                        Item::Data,
  313|       |                        |me, ty, section| me.translate_data(ty, section),
  314|      0|                    )?;
  315|       |                },
  316|       |
  317|       |                DataCount => {
  318|      0|                    let count = BinaryReader::new(section.data).read_var_u32()?;
  319|       |                    // Note that the data count section is decremented here if
  320|       |                    // we're removing a data item, otherwise it's preserved
  321|       |                    // as-is.
  322|      0|                    let count = if self.item == Item::Data {
  323|      0|                        count - 1
  324|       |                    } else {
  325|      0|                        count
  326|       |                    };
  327|      0|                    module.section(&DataCountSection { count });
  328|       |                },
  329|       |
  330|       |                Tag => {
  331|       |                    self.filter_out(
  332|      0|                        &mut module,
  333|      0|                        info.num_imported_tags(),
  334|      0|                        TagSectionReader::new(section.data, 0)?,
  335|      0|                        Item::Tag,
  336|       |                        |me, ty, section: &mut TagSection| {
  337|       |                            let ty = me.translate_tag_type(&ty)?;
  338|       |                            section.tag(ty);
  339|       |                            Ok(())
  340|       |                        },
  341|      0|                    )?;
  342|       |                },
  343|       |
  344|      0|                _ => panic!("unknown id: {}", section.id),
  345|       |            };
  346|       |        }
  347|      0|        Ok(module)
  348|      1|    }
_RINvMs0_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB6_10RemoveItem10filter_outNtNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5types17TypeSectionReaderNtNtNtCskTcFVVikGfm_12wasm_encoder4core5types11TypeSectionNCNvB2_6remove0EBa_:
  362|      1|    fn filter_out<S, T>(
  363|      1|        &mut self,
  364|      1|        module: &mut Module,
  365|      1|        offset: u32,
  366|      1|        mut section: S,
  367|      1|        section_item: Item,
  368|      1|        encode: impl Fn(&mut Self, S::Item, &mut T) -> Result<()>,
  369|      1|    ) -> Result<()>
  370|      1|    where
  371|      1|        S: SectionReader,
  372|      1|        T: Default + Section,
  373|      1|    {
  374|      1|        let mut result = T::default();
  375|      1|        let mut index = offset;
  376|      6|        while !section.eof() {
  377|      5|            let item = section.read()?;
  378|      5|            if index != self.idx || section_item != self.item {
  379|      5|                encode(self, item, &mut result)?;
  380|      0|            }
  381|      5|            index += 1;
  382|       |        }
  383|      1|        module.section(&result);
  384|      1|        Ok(())
  385|      1|    }
_RNvXNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB2_17RemoveItemMutatorNtB4_7Mutator10can_mutate:
   29|      1|    fn can_mutate(&self, config: &WasmMutate) -> bool {
   30|      1|        self.0.can_mutate(config)
   31|      1|    }
_RINvMs0_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB6_10RemoveItem10filter_outNtNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core9functions21FunctionSectionReaderNtNtNtCskTcFVVikGfm_12wasm_encoder4core9functions15FunctionSectionNCNvB2_6removes_0EBa_:
  362|      1|    fn filter_out<S, T>(
  363|      1|        &mut self,
  364|      1|        module: &mut Module,
  365|      1|        offset: u32,
  366|      1|        mut section: S,
  367|      1|        section_item: Item,
  368|      1|        encode: impl Fn(&mut Self, S::Item, &mut T) -> Result<()>,
  369|      1|    ) -> Result<()>
  370|      1|    where
  371|      1|        S: SectionReader,
  372|      1|        T: Default + Section,
  373|      1|    {
  374|      1|        let mut result = T::default();
  375|      1|        let mut index = offset;
  376|      7|        while !section.eof() {
  377|      6|            let item = section.read()?;
  378|      6|            if index != self.idx || section_item != self.item {
  379|      6|                encode(self, item, &mut result)?;
  380|      0|            }
  381|      6|            index += 1;
  382|       |        }
  383|      1|        module.section(&result);
  384|      1|        Ok(())
  385|      1|    }
_RINvMs0_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB6_10RemoveItem10filter_outNtNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core8memories19MemorySectionReaderNtNtNtCskTcFVVikGfm_12wasm_encoder4core8memories13MemorySectionNCNvB2_6removes1_0EBa_:
  362|      1|    fn filter_out<S, T>(
  363|      1|        &mut self,
  364|      1|        module: &mut Module,
  365|      1|        offset: u32,
  366|      1|        mut section: S,
  367|      1|        section_item: Item,
  368|      1|        encode: impl Fn(&mut Self, S::Item, &mut T) -> Result<()>,
  369|      1|    ) -> Result<()>
  370|      1|    where
  371|      1|        S: SectionReader,
  372|      1|        T: Default + Section,
  373|      1|    {
  374|      1|        let mut result = T::default();
  375|      1|        let mut index = offset;
  376|      2|        while !section.eof() {
  377|      1|            let item = section.read()?;
  378|      1|            if index != self.idx || section_item != self.item {
  379|      0|                encode(self, item, &mut result)?;
  380|      1|            }
  381|      1|            index += 1;
  382|       |        }
  383|      1|        module.section(&result);
  384|      1|        Ok(())
  385|      1|    }
_RNvXs1_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB5_10RemoveItemNtNtB7_9translate10Translator6as_obj:
  389|     27|    fn as_obj(&mut self) -> &mut dyn Translator {
  390|     27|        self
  391|     27|    }
_RNCNvMs0_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB7_10RemoveItem6remove0Bb_:
  141|      5|                        |me, ty, section| me.translate_type_def(ty, section),
_RNvXs1_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB5_10RemoveItemNtNtB7_9translate10Translator5remap:
  410|     14|    fn remap(&mut self, item: Item, idx: u32) -> Result<u32> {
  411|     14|        // If we're before the code section then all function references, no
  412|     14|        // matter where they are, are considered "referencing functions" so we
  413|     14|        // save the indices of that which is referenced.
  414|     14|        if item == Item::Function {
  415|      1|            if let Funcref::Save = self.function_reference_action {
  416|      1|                self.referenced_functions.insert(idx);
  417|      1|            }
  418|     13|        }
  419|       |
  420|     14|        if item != self.item {
  421|       |            // Different kind of item, no change
  422|     13|            Ok(idx)
  423|      1|        } else if idx < self.idx {
  424|       |            // A later item was removed, so this index doesn't change
  425|      0|            Ok(idx)
  426|      1|        } else if idx == self.idx {
  427|       |            // If we're removing a referenced item then that means that this
  428|       |            // mutation fails.
  429|      1|            Err(Error::no_mutations_applicable())
  430|       |        } else {
  431|       |            // Otherwise this item comes after the item being removed, so
  432|       |            // this item's index has decreased by one.
  433|      0|            Ok(idx - 1)
  434|       |        }
  435|     14|    }
_RNvXs3_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_itemNtB5_17RemoveItemMutatorNtNtCsg994vJE3n1e_4core5clone5Clone5clone:
   25|      1|#[derive(Copy, Clone)]

_RNvYNtNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_item10RemoveItemNtNtB6_9translate10Translator12translate_tyB8_:
   57|     22|    fn translate_ty(&mut self, t: &wasmparser::ValType) -> Result<ValType> {
   58|     22|        ty(self.as_obj(), t)
   59|     22|    }
_RNCNvNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators9translate8type_defs_0B7_:
  126|      5|                    .map(|ty| t.translate_ty(ty))
_RNCNvNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators9translate8type_def0B7_:
  122|     17|                    .map(|ty| t.translate_ty(ty))
_RNvNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators9translate2ty:
  174|     22|pub fn ty(_t: &mut dyn Translator, ty: &wasmparser::ValType) -> Result<ValType> {
  175|     22|    match ty {
  176|     19|        wasmparser::ValType::I32 => Ok(ValType::I32),
  177|      3|        wasmparser::ValType::I64 => Ok(ValType::I64),
  178|      0|        wasmparser::ValType::F32 => Ok(ValType::F32),
  179|      0|        wasmparser::ValType::F64 => Ok(ValType::F64),
  180|      0|        wasmparser::ValType::V128 => Ok(ValType::V128),
  181|      0|        wasmparser::ValType::FuncRef => Ok(ValType::FuncRef),
  182|      0|        wasmparser::ValType::ExternRef => Ok(ValType::ExternRef),
  183|       |    }
  184|     22|}
_RNvXs4_NtNtCsb6KoqmGnaUT_11wasm_mutate8mutators9translateNtB5_4ItemNtNtCsg994vJE3n1e_4core3cmp9PartialEq2eq:
    5|     36|#[derive(Debug, Hash, Eq, PartialEq, Copy, Clone)]
_RNvYNtNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators11remove_item10RemoveItemNtNtB6_9translate10Translator18translate_type_defB8_:
   28|      5|    fn translate_type_def(&mut self, ty: Type, s: &mut TypeSection) -> Result<()> {
   29|      5|        type_def(self.as_obj(), ty, s)
   30|      5|    }
_RNvNtNtCsb6KoqmGnaUT_11wasm_mutate8mutators9translate8type_def:
  116|      5|pub fn type_def(t: &mut dyn Translator, ty: Type, s: &mut TypeSection) -> Result<()> {
  117|      5|    match ty {
  118|      5|        Type::Func(f) => {
  119|      5|            s.function(
  120|      5|                f.params()
  121|      5|                    .iter()
  122|      5|                    .map(|ty| t.translate_ty(ty))
  123|      5|                    .collect::<Result<Vec<_>>>()?,
  124|      5|                f.results()
  125|      5|                    .iter()
  126|      5|                    .map(|ty| t.translate_ty(ty))
  127|      5|                    .collect::<Result<Vec<_>>>()?,
  128|       |            );
  129|      5|            Ok(())
  130|       |        }
  131|       |    }
  132|      5|}

_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader7read_u8:
 1012|    224|    pub fn read_u8(&mut self) -> Result<u8> {
 1013|    224|        let b = match self.buffer.get(self.position) {
 1014|    224|            Some(b) => *b,
 1015|      0|            None => return Err(self.eof_err()),
 1016|       |        };
 1017|    224|        self.position += 1;
 1018|    224|        Ok(b)
 1019|    224|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader12read_var_u32:
 1034|    160|    pub fn read_var_u32(&mut self) -> Result<u32> {
 1035|       |        // Optimization for single byte i32.
 1036|    160|        let byte = self.read_u8()?;
 1037|    160|        if (byte & 0x80) == 0 {
 1038|    155|            Ok(u32::from(byte))
 1039|       |        } else {
 1040|      5|            self.read_var_u32_big(byte)
 1041|       |        }
 1042|    160|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader15bytes_remaining:
  962|     14|    pub fn bytes_remaining(&self) -> usize {
  963|     14|        self.buffer.len() - self.position
  964|     14|    }
_RNvMs0_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_17BinaryReaderError3eof:
   83|     72|    pub(crate) fn eof(offset: usize, needed_hint: usize) -> Self {
   84|     72|        BinaryReaderError {
   85|     72|            inner: Box::new(BinaryReaderErrorInner {
   86|     72|                message: "unexpected end-of-file".to_string(),
   87|     72|                offset,
   88|     72|                needed_hint: Some(needed_hint),
   89|     72|            }),
   90|     72|        }
   91|     72|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader9read_size:
  856|     40|    fn read_size(&mut self, limit: usize, desc: &str) -> Result<usize> {
  857|     40|        let size = self.read_var_u32()? as usize;
  858|     40|        if size > limit {
  859|      0|            bail!(self.original_position() - 4, "{desc} size is out of bounds");
  860|     40|        }
  861|     40|        Ok(size)
  862|     40|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader17original_position:
  146|    531|    pub fn original_position(&self) -> usize {
  147|    531|        self.original_offset + self.position
  148|    531|    }
_RINvMs0_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB6_17BinaryReaderError3newReEB8_:
   66|    170|    pub(crate) fn new(message: impl Into<String>, offset: usize) -> Self {
   67|    170|        let message = message.into();
   68|    170|        BinaryReaderError {
   69|    170|            inner: Box::new(BinaryReaderErrorInner {
   70|    170|                message,
   71|    170|                offset,
   72|    170|                needed_hint: None,
   73|    170|            }),
   74|    170|        }
   75|    170|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader18read_external_kind:
  232|     24|    pub(crate) fn read_external_kind(&mut self) -> Result<ExternalKind> {
  233|     24|        let offset = self.original_position();
  234|     24|        Self::external_kind_from_byte(self.read_u8()?, offset)
  235|     24|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader3eof:
  950|     16|    pub fn eof(&self) -> bool {
  951|     16|        self.position >= self.buffer.len()
  952|     16|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader23external_kind_from_byte:
  221|     24|    fn external_kind_from_byte(byte: u8, offset: usize) -> Result<ExternalKind> {
  222|     24|        match byte {
  223|     21|            0x00 => Ok(ExternalKind::Func),
  224|      0|            0x01 => Ok(ExternalKind::Table),
  225|      3|            0x02 => Ok(ExternalKind::Memory),
  226|      0|            0x03 => Ok(ExternalKind::Global),
  227|      0|            0x04 => Ok(ExternalKind::Tag),
  228|      0|            x => Err(Self::invalid_leading_byte_error(x, "external kind", offset)),
  229|       |        }
  230|     24|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader16read_memory_type:
  789|      3|    pub(crate) fn read_memory_type(&mut self) -> Result<MemoryType> {
  790|      3|        let pos = self.original_position();
  791|      3|        let flags = self.read_u8()?;
  792|      3|        if (flags & !0b111) != 0 {
  793|      0|            return Err(BinaryReaderError::new("invalid memory limits flags", pos));
  794|      3|        }
  795|      3|
  796|      3|        let memory64 = flags & 0b100 != 0;
  797|      3|        let shared = flags & 0b010 != 0;
  798|      3|        let has_max = flags & 0b001 != 0;
  799|      3|        Ok(MemoryType {
  800|      3|            memory64,
  801|      3|            shared,
  802|      3|            // FIXME(WebAssembly/memory64#21) as currently specified if the
  803|      3|            // `shared` flag is set we should be reading a 32-bit limits field
  804|      3|            // here. That seems a bit odd to me at the time of this writing so
  805|      3|            // I've taken the liberty of reading a 64-bit limits field in those
  806|      3|            // situations. I suspect that this is a typo in the spec, but if not
  807|      3|            // we'll need to update this to read a 32-bit limits field when the
  808|      3|            // shared flag is set.
  809|      3|            initial: if memory64 {
  810|      0|                self.read_var_u64()?
  811|       |            } else {
  812|      3|                self.read_var_u32()?.into()
  813|       |            },
  814|      3|            maximum: if !has_max {
  815|      0|                None
  816|      3|            } else if memory64 {
  817|      0|                Some(self.read_var_u64()?)
  818|       |            } else {
  819|      3|                Some(self.read_var_u32()?.into())
  820|       |            },
  821|       |        })
  822|      3|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader16read_var_u32_big:
 1044|      5|    fn read_var_u32_big(&mut self, byte: u8) -> Result<u32> {
 1045|      5|        let mut result = (byte & 0x7F) as u32;
 1046|      5|        let mut shift = 7;
 1047|       |        loop {
 1048|      5|            let byte = self.read_u8()?;
 1049|      5|            result |= ((byte & 0x7F) as u32) << shift;
 1050|      5|            if shift >= 25 && (byte >> (32 - shift)) != 0 {
 1051|      0|                let msg = if byte & 0x80 != 0 {
 1052|      0|                    "invalid var_u32: integer representation too long"
 1053|       |                } else {
 1054|      0|                    "invalid var_u32: integer too large"
 1055|       |                };
 1056|       |                // The continuation bit or unused bits are set.
 1057|      0|                return Err(BinaryReaderError::new(msg, self.original_position() - 1));
 1058|      5|            }
 1059|      5|            shift += 7;
 1060|      5|            if (byte & 0x80) == 0 {
 1061|      5|                break;
 1062|      0|            }
 1063|       |        }
 1064|      5|        Ok(result)
 1065|      5|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader13read_type_ref:
  754|     18|    pub(crate) fn read_type_ref(&mut self) -> Result<TypeRef> {
  755|     18|        Ok(match self.read_external_kind()? {
  756|     18|            ExternalKind::Func => TypeRef::Func(self.read_var_u32()?),
  757|      0|            ExternalKind::Table => TypeRef::Table(self.read_table_type()?),
  758|      0|            ExternalKind::Memory => TypeRef::Memory(self.read_memory_type()?),
  759|      0|            ExternalKind::Global => TypeRef::Global(self.read_global_type()?),
  760|      0|            ExternalKind::Tag => TypeRef::Tag(self.read_tag_type()?),
  761|       |        })
  762|     18|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader14read_func_type:
  280|     20|    pub(crate) fn read_func_type(&mut self) -> Result<FuncType> {
  281|     20|        let len_params = self.read_size(MAX_WASM_FUNCTION_PARAMS, "function params")?;
  282|     20|        let mut params_results = Vec::with_capacity(len_params);
  283|     20|        for _ in 0..len_params {
  284|     68|            params_results.push(self.read_val_type()?);
  285|       |        }
  286|     20|        let len_results = self.read_size(MAX_WASM_FUNCTION_RETURNS, "function returns")?;
  287|     20|        params_results.reserve(len_results);
  288|     20|        for _ in 0..len_results {
  289|     20|            params_results.push(self.read_val_type()?);
  290|       |        }
  291|     20|        Ok(FuncType::from_raw_parts(params_results.into(), len_params))
  292|     20|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader13read_val_type:
  196|     88|    pub fn read_val_type(&mut self) -> Result<ValType> {
  197|     88|        match Self::val_type_from_byte(self.peek()?) {
  198|     88|            Some(ty) => {
  199|     88|                self.position += 1;
  200|     88|                Ok(ty)
  201|       |            }
  202|      0|            None => Err(BinaryReaderError::new(
  203|      0|                "invalid value type",
  204|      0|                self.original_position(),
  205|      0|            )),
  206|       |        }
  207|     88|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader10read_bytes:
  972|    296|        self.ensure_has_bytes(size)?;
  973|    224|        let start = self.position;
  974|    224|        self.position += size;
  975|    224|        Ok(&self.buffer[start..self.position])
  976|    296|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader8read_u32:
  982|      2|        self.ensure_has_bytes(4)?;
  983|      2|        let word = u32::from_le_bytes(
  984|      2|            self.buffer[self.position..self.position + 4]
  985|      2|                .try_into()
  986|      2|                .unwrap(),
  987|      2|        );
  988|      2|        self.position += 4;
  989|      2|        Ok(word)
  990|      2|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader4peek:
 1317|     88|        self.ensure_has_byte()?;
 1318|     88|        Ok(self.buffer[self.position])
 1319|     88|    }
_RNvXs7_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_17BinaryReaderErrorNtNtCsg994vJE3n1e_4core3fmt5Debug3fmt:
   34|    242|#[derive(Debug, Clone)]
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader11read_import:
  552|     18|    pub(crate) fn read_import(&mut self) -> Result<Import<'a>> {
  553|     18|        Ok(Import {
  554|     18|            module: self.read_string()?,
  555|     18|            name: self.read_string()?,
  556|     18|            ty: self.read_type_ref()?,
  557|       |        })
  558|     18|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader18val_type_from_byte:
 1321|     88|    fn val_type_from_byte(byte: u8) -> Option<ValType> {
 1322|     88|        match byte {
 1323|     76|            0x7F => Some(ValType::I32),
 1324|     12|            0x7E => Some(ValType::I64),
 1325|      0|            0x7D => Some(ValType::F32),
 1326|      0|            0x7C => Some(ValType::F64),
 1327|      0|            0x7B => Some(ValType::V128),
 1328|      0|            0x70 => Some(ValType::FuncRef),
 1329|      0|            0x6F => Some(ValType::ExternRef),
 1330|      0|            _ => None,
 1331|       |        }
 1332|     88|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader16ensure_has_bytes:
  175|    298|    pub(crate) fn ensure_has_bytes(&self, len: usize) -> Result<()> {
  176|    298|        if self.position + len <= self.buffer.len() {
  177|    226|            Ok(())
  178|       |        } else {
  179|     72|            let hint = self.position + len - self.buffer.len();
  180|     72|            Err(BinaryReaderError::eof(self.original_position(), hint))
  181|       |        }
  182|    298|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader11read_export:
  536|      6|    pub(crate) fn read_export(&mut self) -> Result<Export<'a>> {
  537|      6|        Ok(Export {
  538|      6|            name: self.read_string()?,
  539|      6|            kind: self.read_external_kind()?,
  540|      6|            index: self.read_var_u32()?,
  541|       |        })
  542|      6|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader5range:
  159|     10|    pub fn range(&self) -> Range<usize> {
  160|     10|        self.original_offset..self.original_offset + self.buffer.len()
  161|     10|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader9read_type:
  294|     20|    pub(crate) fn read_type(&mut self) -> Result<Type> {
  295|     20|        Ok(match self.read_u8()? {
  296|     20|            0x60 => Type::Func(self.read_func_type()?),
  297|      0|            x => return self.invalid_leading_byte(x, "type"),
  298|       |        })
  299|     20|    }
_RNvXs9_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_22BinaryReaderErrorInnerNtNtCsg994vJE3n1e_4core3fmt5Debug3fmt:
   42|    242|#[derive(Debug, Clone)]
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader15new_with_offset:
  135|    274|    pub fn new_with_offset(data: &[u8], original_offset: usize) -> BinaryReader {
  136|    274|        BinaryReader {
  137|    274|            buffer: data,
  138|    274|            position: 0,
  139|    274|            original_offset,
  140|    274|            allow_memarg64: false,
  141|    274|        }
  142|    274|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader11read_string:
 1281|     42|    pub fn read_string(&mut self) -> Result<&'a str> {
 1282|     42|        let len = self.read_var_u32()? as usize;
 1283|     42|        if len > MAX_WASM_STRING_SIZE {
 1284|      0|            return Err(BinaryReaderError::new(
 1285|      0|                "string size out of bounds",
 1286|      0|                self.original_position() - 1,
 1287|      0|            ));
 1288|     42|        }
 1289|     42|        let bytes = self.read_bytes(len)?;
 1290|     42|        str::from_utf8(bytes).map_err(|_| {
 1291|       |            BinaryReaderError::new("invalid UTF-8 encoding", self.original_position() - 1)
 1292|     42|        })
 1293|     42|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader15ensure_has_byte:
  167|     88|    fn ensure_has_byte(&self) -> Result<()> {
  168|     88|        if self.position < self.buffer.len() {
  169|     88|            Ok(())
  170|       |        } else {
  171|      0|            Err(BinaryReaderError::eof(self.original_position(), 1))
  172|       |        }
  173|     88|    }
_RNvMs1_NtCs9VFM4FqidCT_10wasmparser13binary_readerNtB5_12BinaryReader19read_header_version:
 2139|    244|    pub(crate) fn read_header_version(&mut self) -> Result<u32> {
 2140|    244|        let magic_number = self.read_bytes(4)?;
 2141|    172|        if magic_number != WASM_MAGIC_NUMBER {
 2142|    170|            return Err(BinaryReaderError::new(
 2143|    170|                "magic header not detected: bad magic number",
 2144|    170|                self.original_position() - 4,
 2145|    170|            ));
 2146|      2|        }
 2147|      2|        self.read_u32()
 2148|    244|    }

_RNvMNtCs9VFM4FqidCT_10wasmparser6parserNtB2_6Parser3new:
  316|    244|    pub fn new(offset: u64) -> Parser {
  317|    244|        Parser {
  318|    244|            state: State::Header,
  319|    244|            offset,
  320|    244|            max_size: u64::MAX,
  321|    244|            // Assume the encoding is a module until we know otherwise
  322|    244|            encoding: Encoding::Module,
  323|    244|        }
  324|    244|    }
_RINvNtCs9VFM4FqidCT_10wasmparser6parser9delimitedmNCNvMB2_NtB2_6Parser12parse_readers_0EB4_:
  935|      2|fn delimited<'a, T>(
  936|      2|    reader: &mut BinaryReader<'a>,
  937|      2|    len: &mut u32,
  938|      2|    f: impl FnOnce(&mut BinaryReader<'a>) -> Result<T>,
  939|      2|) -> Result<T> {
  940|      2|    let start = reader.position;
  941|      2|    let ret = f(reader)?;
  942|      2|    *len = match (reader.position - start)
  943|      2|        .try_into()
  944|      2|        .ok()
  945|      2|        .and_then(|i| len.checked_sub(i))
  946|       |    {
  947|      2|        Some(i) => i,
  948|      0|        None => return Err(BinaryReaderError::new("unexpected end-of-file", start)),
  949|       |    };
  950|      2|    Ok(ret)
  951|      2|}
_RNvMNtCs9VFM4FqidCT_10wasmparser6parserNtB2_6Parser5parse:
  467|    258|    pub fn parse<'a>(&mut self, data: &'a [u8], eof: bool) -> Result<Chunk<'a>> {
  468|    258|        let (data, eof) = if usize_to_u64(data.len()) > self.max_size {
  469|      0|            (&data[..(self.max_size as usize)], true)
  470|       |        } else {
  471|    258|            (data, eof)
  472|       |        };
  473|       |        // TODO: thread through `offset: u64` to `BinaryReader`, remove
  474|       |        // the cast here.
  475|    258|        let mut reader = BinaryReader::new_with_offset(data, self.offset as usize);
  476|    258|        match self.parse_reader(&mut reader, eof) {
  477|     16|            Ok(payload) => {
  478|     16|                // Be sure to update our offset with how far we got in the
  479|     16|                // reader
  480|     16|                self.offset += usize_to_u64(reader.position);
  481|     16|                self.max_size -= usize_to_u64(reader.position);
  482|     16|                Ok(Chunk::Parsed {
  483|     16|                    consumed: reader.position,
  484|     16|                    payload,
  485|     16|                })
  486|       |            }
  487|    242|            Err(e) => {
  488|    242|                // If we're at EOF then there's no way we can recover from any
  489|    242|                // error, so continue to propagate it.
  490|    242|                if eof {
  491|    242|                    return Err(e);
  492|      0|                }
  493|      0|
  494|      0|                // If our error doesn't look like it can be resolved with more
  495|      0|                // data being pulled down, then propagate it, otherwise switch
  496|      0|                // the error to "feed me please"
  497|      0|                match e.inner.needed_hint {
  498|      0|                    Some(hint) => Ok(Chunk::NeedMoreData(usize_to_u64(hint))),
  499|      0|                    None => Err(e),
  500|       |                }
  501|       |            }
  502|       |        }
  503|    258|    }
_RNvNtCs9VFM4FqidCT_10wasmparser6parser12usize_to_u64:
  875|    302|fn usize_to_u64(a: usize) -> u64 {
  876|    302|    a.try_into().unwrap()
  877|    302|}
_RINvNtCs9VFM4FqidCT_10wasmparser6parser7sectionNtNtNtNtB4_7readers4core7imports19ImportSectionReaderEB4_:
  883|      2|fn section<'a, T>(
  884|      2|    reader: &mut BinaryReader<'a>,
  885|      2|    len: u32,
  886|      2|    ctor: fn(&'a [u8], usize) -> Result<T>,
  887|      2|    variant: fn(T) -> Payload<'a>,
  888|      2|) -> Result<Payload<'a>> {
  889|      2|    let offset = reader.original_position();
  890|      2|    let payload = reader.read_bytes(len as usize)?;
  891|       |    // clear the hint for "need this many more bytes" here because we already
  892|       |    // read all the bytes, so it's not possible to read more bytes if this
  893|       |    // fails.
  894|      2|    let reader = ctor(payload, offset).map_err(clear_hint)?;
  895|      2|    Ok(variant(reader))
  896|      2|}
_RNvMNtCs9VFM4FqidCT_10wasmparser6parserNtB2_6Parser12parse_reader:
  505|    258|    fn parse_reader<'a>(
  506|    258|        &mut self,
  507|    258|        reader: &mut BinaryReader<'a>,
  508|    258|        eof: bool,
  509|    258|    ) -> Result<Payload<'a>> {
  510|    258|        use Payload::*;
  511|    258|
  512|    258|        match self.state {
  513|       |            State::Header => {
  514|    244|                let start = reader.original_position();
  515|    244|                let num = reader.read_header_version()?;
  516|      2|                self.encoding = match num {
  517|      2|                    WASM_EXPERIMENTAL_VERSION | WASM_MODULE_VERSION => Encoding::Module,
  518|      0|                    WASM_COMPONENT_VERSION => Encoding::Component,
  519|       |                    _ => {
  520|      0|                        return Err(BinaryReaderError::new(
  521|      0|                            "unknown binary version",
  522|      0|                            reader.original_position() - 4,
  523|      0|                        ))
  524|       |                    }
  525|       |                };
  526|      2|                self.state = State::SectionStart;
  527|      2|                Ok(Version {
  528|      2|                    num,
  529|      2|                    encoding: self.encoding,
  530|      2|                    range: start..reader.original_position(),
  531|      2|                })
  532|       |            }
  533|       |            State::SectionStart => {
  534|       |                // If we're at eof and there are no bytes in our buffer, then
  535|       |                // that means we reached the end of the data since it's
  536|       |                // just a bunch of sections concatenated after the header.
  537|     14|                if eof && reader.bytes_remaining() == 0 {
  538|      2|                    return Ok(Payload::End(reader.original_position()));
  539|     12|                }
  540|     12|
  541|     12|                let id_pos = reader.position;
  542|     12|                let id = reader.read_u8()?;
  543|     12|                if id & 0x80 != 0 {
  544|      0|                    return Err(BinaryReaderError::new("malformed section id", id_pos));
  545|     12|                }
  546|     12|                let len_pos = reader.position;
  547|     12|                let mut len = reader.read_var_u32()?;
  548|       |
  549|       |                // Test to make sure that this section actually fits within
  550|       |                // `Parser::max_size`. This doesn't matter for top-level modules
  551|       |                // but it is required for nested modules/components to correctly ensure
  552|       |                // that all sections live entirely within their section of the
  553|       |                // file.
  554|     12|                let section_overflow = self
  555|     12|                    .max_size
  556|     12|                    .checked_sub(usize_to_u64(reader.position))
  557|     12|                    .and_then(|s| s.checked_sub(len.into()))
  558|     12|                    .is_none();
  559|     12|                if section_overflow {
  560|      0|                    return Err(BinaryReaderError::new("section too large", len_pos));
  561|     12|                }
  562|     12|
  563|     12|                // Check for custom sections (supported by all encodings)
  564|     12|                if id == 0 {}
  565|       |
  566|     12|                match (self.encoding, id) {
  567|       |                    // Sections for both modules and components.
  568|      0|                    (_, 0) => section(reader, len, CustomSectionReader::new, CustomSection),
  569|       |
  570|       |                    // Module sections
  571|       |                    (Encoding::Module, TYPE_SECTION) => {
  572|      2|                        section(reader, len, TypeSectionReader::new, TypeSection)
  573|       |                    }
  574|       |                    (Encoding::Module, IMPORT_SECTION) => {
  575|      2|                        section(reader, len, ImportSectionReader::new, ImportSection)
  576|       |                    }
  577|       |                    (Encoding::Module, FUNCTION_SECTION) => {
  578|      2|                        section(reader, len, FunctionSectionReader::new, FunctionSection)
  579|       |                    }
  580|       |                    (Encoding::Module, TABLE_SECTION) => {
  581|      0|                        section(reader, len, TableSectionReader::new, TableSection)
  582|       |                    }
  583|       |                    (Encoding::Module, MEMORY_SECTION) => {
  584|      2|                        section(reader, len, MemorySectionReader::new, MemorySection)
  585|       |                    }
  586|       |                    (Encoding::Module, GLOBAL_SECTION) => {
  587|      0|                        section(reader, len, GlobalSectionReader::new, GlobalSection)
  588|       |                    }
  589|       |                    (Encoding::Module, EXPORT_SECTION) => {
  590|      2|                        section(reader, len, ExportSectionReader::new, ExportSection)
  591|       |                    }
  592|       |                    (Encoding::Module, START_SECTION) => {
  593|      0|                        let (func, range) = single_u32(reader, len, "start")?;
  594|      0|                        Ok(StartSection { func, range })
  595|       |                    }
  596|       |                    (Encoding::Module, ELEMENT_SECTION) => {
  597|      0|                        section(reader, len, ElementSectionReader::new, ElementSection)
  598|       |                    }
  599|       |                    (Encoding::Module, CODE_SECTION) => {
  600|      2|                        let start = reader.original_position();
  601|      2|                        let count = delimited(reader, &mut len, |r| r.read_var_u32())?;
  602|      2|                        let range = start..reader.original_position() + len as usize;
  603|      2|                        self.state = State::FunctionBody {
  604|      2|                            remaining: count,
  605|      2|                            len,
  606|      2|                        };
  607|      2|                        Ok(CodeSectionStart {
  608|      2|                            count,
  609|      2|                            range,
  610|      2|                            size: len,
  611|      2|                        })
  612|       |                    }
  613|       |                    (Encoding::Module, DATA_SECTION) => {
  614|      0|                        section(reader, len, DataSectionReader::new, DataSection)
  615|       |                    }
  616|       |                    (Encoding::Module, DATA_COUNT_SECTION) => {
  617|      0|                        let (count, range) = single_u32(reader, len, "data count")?;
  618|      0|                        Ok(DataCountSection { count, range })
  619|       |                    }
  620|       |                    (Encoding::Module, TAG_SECTION) => {
  621|      0|                        section(reader, len, TagSectionReader::new, TagSection)
  622|       |                    }
  623|       |
  624|       |                    // Component sections
  625|       |                    (Encoding::Component, COMPONENT_MODULE_SECTION)
  626|       |                    | (Encoding::Component, COMPONENT_SECTION) => {
  627|      0|                        if len as usize > MAX_WASM_MODULE_SIZE {
  628|      0|                            bail!(
  629|      0|                                len_pos,
  630|      0|                                "{} section is too large",
  631|      0|                                if id == 1 { "module" } else { "component " }
  632|       |                            );
  633|      0|                        }
  634|      0|
  635|      0|                        let range =
  636|      0|                            reader.original_position()..reader.original_position() + len as usize;
  637|      0|                        self.max_size -= u64::from(len);
  638|      0|                        self.offset += u64::from(len);
  639|      0|                        let mut parser = Parser::new(usize_to_u64(reader.original_position()));
  640|      0|                        parser.max_size = len.into();
  641|      0|
  642|      0|                        Ok(match id {
  643|      0|                            1 => ModuleSection { parser, range },
  644|      0|                            4 => ComponentSection { parser, range },
  645|      0|                            _ => unreachable!(),
  646|       |                        })
  647|       |                    }
  648|       |                    (Encoding::Component, COMPONENT_CORE_INSTANCE_SECTION) => {
  649|      0|                        section(reader, len, InstanceSectionReader::new, InstanceSection)
  650|       |                    }
  651|       |                    (Encoding::Component, COMPONENT_CORE_TYPE_SECTION) => {
  652|      0|                        section(reader, len, CoreTypeSectionReader::new, CoreTypeSection)
  653|       |                    }
  654|      0|                    (Encoding::Component, COMPONENT_INSTANCE_SECTION) => section(
  655|      0|                        reader,
  656|      0|                        len,
  657|      0|                        ComponentInstanceSectionReader::new,
  658|      0|                        ComponentInstanceSection,
  659|      0|                    ),
  660|      0|                    (Encoding::Component, COMPONENT_ALIAS_SECTION) => section(
  661|      0|                        reader,
  662|      0|                        len,
  663|      0|                        ComponentAliasSectionReader::new,
  664|      0|                        ComponentAliasSection,
  665|      0|                    ),
  666|      0|                    (Encoding::Component, COMPONENT_TYPE_SECTION) => section(
  667|      0|                        reader,
  668|      0|                        len,
  669|      0|                        ComponentTypeSectionReader::new,
  670|      0|                        ComponentTypeSection,
  671|      0|                    ),
  672|      0|                    (Encoding::Component, COMPONENT_CANONICAL_SECTION) => section(
  673|      0|                        reader,
  674|      0|                        len,
  675|      0|                        ComponentCanonicalSectionReader::new,
  676|      0|                        ComponentCanonicalSection,
  677|      0|                    ),
  678|      0|                    (Encoding::Component, COMPONENT_START_SECTION) => section(
  679|      0|                        reader,
  680|      0|                        len,
  681|      0|                        ComponentStartSectionReader::new,
  682|      0|                        ComponentStartSection,
  683|      0|                    ),
  684|      0|                    (Encoding::Component, COMPONENT_IMPORT_SECTION) => section(
  685|      0|                        reader,
  686|      0|                        len,
  687|      0|                        ComponentImportSectionReader::new,
  688|      0|                        ComponentImportSection,
  689|      0|                    ),
  690|      0|                    (Encoding::Component, COMPONENT_EXPORT_SECTION) => section(
  691|      0|                        reader,
  692|      0|                        len,
  693|      0|                        ComponentExportSectionReader::new,
  694|      0|                        ComponentExportSection,
  695|      0|                    ),
  696|      0|                    (_, id) => {
  697|      0|                        let offset = reader.original_position();
  698|      0|                        let contents = reader.read_bytes(len as usize)?;
  699|      0|                        let range = offset..offset + len as usize;
  700|      0|                        Ok(UnknownSection {
  701|      0|                            id,
  702|      0|                            contents,
  703|      0|                            range,
  704|      0|                        })
  705|       |                    }
  706|       |                }
  707|       |            }
  708|       |
  709|       |            // Once we hit 0 remaining incrementally parsed items, with 0
  710|       |            // remaining bytes in each section, we're done and can switch back
  711|       |            // to parsing sections.
  712|       |            State::FunctionBody {
  713|       |                remaining: 0,
  714|       |                len: 0,
  715|       |            } => {
  716|      0|                self.state = State::SectionStart;
  717|      0|                self.parse_reader(reader, eof)
  718|       |            }
  719|       |
  720|       |            // ... otherwise trailing bytes with no remaining entries in these
  721|       |            // sections indicates an error.
  722|      0|            State::FunctionBody { remaining: 0, len } => {
  723|      0|                debug_assert!(len > 0);
  724|      0|                let offset = reader.original_position();
  725|      0|                Err(BinaryReaderError::new(
  726|      0|                    "trailing bytes at end of section",
  727|      0|                    offset,
  728|      0|                ))
  729|       |            }
  730|       |
  731|       |            // Functions are relatively easy to parse when we know there's at
  732|       |            // least one remaining and at least one byte available to read
  733|       |            // things.
  734|       |            //
  735|       |            // We use the remaining length try to read a u32 size of the
  736|       |            // function, and using that size we require the entire function be
  737|       |            // resident in memory. This means that we're reading whole chunks of
  738|       |            // functions at a time.
  739|       |            //
  740|       |            // Limiting via `Parser::max_size` (nested parsing) happens above in
  741|       |            // `fn parse`, and limiting by our section size happens via
  742|       |            // `delimited`. Actual parsing of the function body is delegated to
  743|       |            // the caller to iterate over the `FunctionBody` structure.
  744|      0|            State::FunctionBody { remaining, mut len } => {
  745|      0|                let body = delimited(reader, &mut len, |r| {
  746|       |                    let size = r.read_var_u32()?;
  747|       |                    let offset = r.original_position();
  748|       |                    Ok(FunctionBody::new(offset, r.read_bytes(size as usize)?))
  749|      0|                })?;
  750|      0|                self.state = State::FunctionBody {
  751|      0|                    remaining: remaining - 1,
  752|      0|                    len,
  753|      0|                };
  754|      0|                Ok(CodeSectionEntry(body))
  755|       |            }
  756|       |        }
  757|    258|    }
_RINvNtCs9VFM4FqidCT_10wasmparser6parser7sectionNtNtNtNtB4_7readers4core8memories19MemorySectionReaderEB4_:
  883|      2|fn section<'a, T>(
  884|      2|    reader: &mut BinaryReader<'a>,
  885|      2|    len: u32,
  886|      2|    ctor: fn(&'a [u8], usize) -> Result<T>,
  887|      2|    variant: fn(T) -> Payload<'a>,
  888|      2|) -> Result<Payload<'a>> {
  889|      2|    let offset = reader.original_position();
  890|      2|    let payload = reader.read_bytes(len as usize)?;
  891|       |    // clear the hint for "need this many more bytes" here because we already
  892|       |    // read all the bytes, so it's not possible to read more bytes if this
  893|       |    // fails.
  894|      2|    let reader = ctor(payload, offset).map_err(clear_hint)?;
  895|      2|    Ok(variant(reader))
  896|      2|}
_RINvNtCs9VFM4FqidCT_10wasmparser6parser7sectionNtNtNtNtB4_7readers4core5types17TypeSectionReaderEB4_:
  883|      2|fn section<'a, T>(
  884|      2|    reader: &mut BinaryReader<'a>,
  885|      2|    len: u32,
  886|      2|    ctor: fn(&'a [u8], usize) -> Result<T>,
  887|      2|    variant: fn(T) -> Payload<'a>,
  888|      2|) -> Result<Payload<'a>> {
  889|      2|    let offset = reader.original_position();
  890|      2|    let payload = reader.read_bytes(len as usize)?;
  891|       |    // clear the hint for "need this many more bytes" here because we already
  892|       |    // read all the bytes, so it's not possible to read more bytes if this
  893|       |    // fails.
  894|      2|    let reader = ctor(payload, offset).map_err(clear_hint)?;
  895|      2|    Ok(variant(reader))
  896|      2|}
_RNCNvMNtCs9VFM4FqidCT_10wasmparser6parserNtB4_6Parser12parse_readers_0B6_:
  601|      2|                        let count = delimited(reader, &mut len, |r| r.read_var_u32())?;
_RNCINvNtCs9VFM4FqidCT_10wasmparser6parser9delimitedmNCNvMB4_NtB4_6Parser12parse_readers_0E0B6_:
  945|      2|        .and_then(|i| len.checked_sub(i))
_RNCNvMNtCs9VFM4FqidCT_10wasmparser6parserNtB4_6Parser12parse_reader0B6_:
  557|     12|                    .and_then(|s| s.checked_sub(len.into()))
_RINvNtCs9VFM4FqidCT_10wasmparser6parser7sectionNtNtNtNtB4_7readers4core9functions21FunctionSectionReaderEB4_:
  883|      2|fn section<'a, T>(
  884|      2|    reader: &mut BinaryReader<'a>,
  885|      2|    len: u32,
  886|      2|    ctor: fn(&'a [u8], usize) -> Result<T>,
  887|      2|    variant: fn(T) -> Payload<'a>,
  888|      2|) -> Result<Payload<'a>> {
  889|      2|    let offset = reader.original_position();
  890|      2|    let payload = reader.read_bytes(len as usize)?;
  891|       |    // clear the hint for "need this many more bytes" here because we already
  892|       |    // read all the bytes, so it's not possible to read more bytes if this
  893|       |    // fails.
  894|      2|    let reader = ctor(payload, offset).map_err(clear_hint)?;
  895|      2|    Ok(variant(reader))
  896|      2|}
_RNvMNtCs9VFM4FqidCT_10wasmparser6parserNtB2_6Parser12skip_section:
  864|      2|    pub fn skip_section(&mut self) {
  865|      2|        let skip = match self.state {
  866|      2|            State::FunctionBody { remaining: _, len } => len,
  867|      0|            _ => panic!("wrong state to call `skip_section`"),
  868|       |        };
  869|      2|        self.offset += u64::from(skip);
  870|      2|        self.max_size -= u64::from(skip);
  871|      2|        self.state = State::SectionStart;
  872|      2|    }
_RINvNtCs9VFM4FqidCT_10wasmparser6parser7sectionNtNtNtNtB4_7readers4core7exports19ExportSectionReaderEB4_:
  883|      2|fn section<'a, T>(
  884|      2|    reader: &mut BinaryReader<'a>,
  885|      2|    len: u32,
  886|      2|    ctor: fn(&'a [u8], usize) -> Result<T>,
  887|      2|    variant: fn(T) -> Payload<'a>,
  888|      2|) -> Result<Payload<'a>> {
  889|      2|    let offset = reader.original_position();
  890|      2|    let payload = reader.read_bytes(len as usize)?;
  891|       |    // clear the hint for "need this many more bytes" here because we already
  892|       |    // read all the bytes, so it's not possible to read more bytes if this
  893|       |    // fails.
  894|      2|    let reader = ctor(payload, offset).map_err(clear_hint)?;
  895|      2|    Ok(variant(reader))
  896|      2|}

_RNvYNtNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7imports19ImportSectionReaderNtB8_13SectionReader10ensure_endCsb6KoqmGnaUT_11wasm_mutate:
   46|      1|    fn ensure_end(&self) -> Result<()> {
   47|      1|        if self.eof() {
   48|      1|            return Ok(());
   49|      0|        }
   50|      0|        Err(BinaryReaderError::new(
   51|      0|            "section size mismatch: unexpected data at the end of the section",
   52|      0|            self.original_position(),
   53|      0|        ))
   54|      1|    }
_RNvXs1_NtCs9VFM4FqidCT_10wasmparser7readersINtB5_22SectionIteratorLimitedNtNtNtB5_4core7imports19ImportSectionReaderENtNtNtNtCsg994vJE3n1e_4core4iter6traits8iterator8Iterator4nextCsb6KoqmGnaUT_11wasm_mutate:
  137|      7|    fn next(&mut self) -> Option<Self::Item> {
  138|      7|        if self.end {
  139|      0|            return None;
  140|      7|        }
  141|      7|        if self.left == 0 {
  142|      1|            return match self.reader.ensure_end() {
  143|      1|                Ok(()) => None,
  144|      0|                Err(err) => {
  145|      0|                    self.end = true;
  146|      0|                    Some(Err(err))
  147|       |                }
  148|       |            };
  149|      6|        }
  150|      6|        let result = self.reader.read();
  151|      6|        self.end = result.is_err();
  152|      6|        self.left -= 1;
  153|      6|        Some(result)
  154|      7|    }
_RNvXs1_NtCs9VFM4FqidCT_10wasmparser7readersINtB5_22SectionIteratorLimitedNtNtNtB5_4core7exports19ExportSectionReaderENtNtNtNtCsg994vJE3n1e_4core4iter6traits8iterator8Iterator4nextCsb6KoqmGnaUT_11wasm_mutate:
  137|      2|    fn next(&mut self) -> Option<Self::Item> {
  138|      2|        if self.end {
  139|      0|            return None;
  140|      2|        }
  141|      2|        if self.left == 0 {
  142|      0|            return match self.reader.ensure_end() {
  143|      0|                Ok(()) => None,
  144|      0|                Err(err) => {
  145|      0|                    self.end = true;
  146|      0|                    Some(Err(err))
  147|       |                }
  148|       |            };
  149|      2|        }
  150|      2|        let result = self.reader.read();
  151|      2|        self.end = result.is_err();
  152|      2|        self.left -= 1;
  153|      2|        Some(result)
  154|      2|    }
_RNvMs0_NtCs9VFM4FqidCT_10wasmparser7readersINtB5_22SectionIteratorLimitedNtNtNtB5_4core7exports19ExportSectionReaderE3newB7_:
  121|      1|    pub fn new(reader: R) -> SectionIteratorLimited<R> {
  122|      1|        let left = reader.get_count();
  123|      1|        SectionIteratorLimited {
  124|      1|            reader,
  125|      1|            left,
  126|      1|            end: false,
  127|      1|        }
  128|      1|    }
_RNvMs0_NtCs9VFM4FqidCT_10wasmparser7readersINtB5_22SectionIteratorLimitedNtNtNtB5_4core7imports19ImportSectionReaderE3newB7_:
  121|      1|    pub fn new(reader: R) -> SectionIteratorLimited<R> {
  122|      1|        let left = reader.get_count();
  123|      1|        SectionIteratorLimited {
  124|      1|            reader,
  125|      1|            left,
  126|      1|            end: false,
  127|      1|        }
  128|      1|    }

_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7exportsNtB2_19ExportSectionReader9get_count:
   68|      5|    pub fn get_count(&self) -> u32 {
   69|      5|        self.count
   70|      5|    }
_RNvXs0_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7exportsNtB5_19ExportSectionReaderNtB9_23SectionWithLimitedItems9get_count:
  111|      1|    fn get_count(&self) -> u32 {
  112|      1|        Self::get_count(self)
  113|      1|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7exportsNtB4_19ExportSectionReaderNtB8_13SectionReader5range:
  105|      2|    fn range(&self) -> Range<usize> {
  106|      2|        self.reader.range()
  107|      2|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7exportsNtB2_19ExportSectionReader4read:
   85|      6|    pub fn read(&mut self) -> Result<Export<'a>> {
   86|      6|        self.reader.read_export()
   87|      6|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7exportsNtB4_19ExportSectionReaderNtB8_13SectionReader4read:
   93|      2|    fn read(&mut self) -> Result<Self::Item> {
   94|      2|        Self::read(self)
   95|      2|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7exportsNtB2_19ExportSectionReader3new:
   56|      3|    pub fn new(data: &'a [u8], offset: usize) -> Result<Self> {
   57|      3|        let mut reader = BinaryReader::new_with_offset(data, offset);
   58|      3|        let count = reader.read_var_u32()?;
   59|      3|        Ok(Self { reader, count })
   60|      3|    }
_RNvXs1_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7exportsNtB5_19ExportSectionReaderNtNtNtNtCsg994vJE3n1e_4core4iter6traits7collect12IntoIterator9into_iter:
  120|      1|    fn into_iter(self) -> Self::IntoIter {
  121|      1|        SectionIteratorLimited::new(self)
  122|      1|    }

_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core9functionsNtB4_21FunctionSectionReaderNtB8_13SectionReader3eof:
   69|      7|    fn eof(&self) -> bool {
   70|      7|        self.reader.eof()
   71|      7|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core9functionsNtB2_21FunctionSectionReader3new:
   28|      3|    pub fn new(data: &'a [u8], offset: usize) -> Result<Self> {
   29|      3|        let mut reader = BinaryReader::new_with_offset(data, offset);
   30|      3|        let count = reader.read_var_u32()?;
   31|      3|        Ok(Self { reader, count })
   32|      3|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core9functionsNtB4_21FunctionSectionReaderNtB8_13SectionReader4read:
   65|      6|    fn read(&mut self) -> Result<Self::Item> {
   66|      6|        Self::read(self)
   67|      6|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core9functionsNtB2_21FunctionSectionReader9get_count:
   40|      2|    pub fn get_count(&self) -> u32 {
   41|      2|        self.count
   42|      2|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core9functionsNtB4_21FunctionSectionReaderNtB8_13SectionReader5range:
   77|      2|    fn range(&self) -> Range<usize> {
   78|      2|        self.reader.range()
   79|      2|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core9functionsNtB2_21FunctionSectionReader4read:
   57|     18|    pub fn read(&mut self) -> Result<u32> {
   58|     18|        self.reader.read_var_u32()
   59|     18|    }

_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7importsNtB4_19ImportSectionReaderNtB8_13SectionReader3eof:
  103|      1|    fn eof(&self) -> bool {
  104|      1|        self.reader.eof()
  105|      1|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7importsNtB2_19ImportSectionReader3new:
   63|      3|    pub fn new(data: &'a [u8], offset: usize) -> Result<Self> {
   64|      3|        let mut reader = BinaryReader::new_with_offset(data, offset);
   65|      3|        let count = reader.read_var_u32()?;
   66|      3|        Ok(Self { reader, count })
   67|      3|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7importsNtB2_19ImportSectionReader9get_count:
   75|      3|    pub fn get_count(&self) -> u32 {
   76|      3|        self.count
   77|      3|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7importsNtB2_19ImportSectionReader4read:
   91|     18|    pub fn read(&mut self) -> Result<Import<'a>> {
   92|     18|        self.reader.read_import()
   93|     18|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7importsNtB4_19ImportSectionReaderNtB8_13SectionReader5range:
  111|      2|    fn range(&self) -> Range<usize> {
  112|      2|        self.reader.range()
  113|      2|    }
_RNvXs1_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7importsNtB5_19ImportSectionReaderNtNtNtNtCsg994vJE3n1e_4core4iter6traits7collect12IntoIterator9into_iter:
  126|      1|    fn into_iter(self) -> Self::IntoIter {
  127|      1|        SectionIteratorLimited::new(self)
  128|      1|    }
_RNvXs0_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7importsNtB5_19ImportSectionReaderNtB9_23SectionWithLimitedItems9get_count:
  117|      1|    fn get_count(&self) -> u32 {
  118|      1|        Self::get_count(self)
  119|      1|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core7importsNtB4_19ImportSectionReaderNtB8_13SectionReader4read:
   99|      6|    fn read(&mut self) -> Result<Self::Item> {
  100|      6|        Self::read(self)
  101|      6|    }

_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core8memoriesNtB2_19MemorySectionReader3new:
   31|      3|    pub fn new(data: &'a [u8], offset: usize) -> Result<MemorySectionReader<'a>> {
   32|      3|        let mut reader = BinaryReader::new_with_offset(data, offset);
   33|      3|        let count = reader.read_var_u32()?;
   34|      3|        Ok(MemorySectionReader { reader, count })
   35|      3|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core8memoriesNtB4_19MemorySectionReaderNtB8_13SectionReader3eof:
   69|      2|    fn eof(&self) -> bool {
   70|      2|        self.reader.eof()
   71|      2|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core8memoriesNtB2_19MemorySectionReader9get_count:
   43|      4|    pub fn get_count(&self) -> u32 {
   44|      4|        self.count
   45|      4|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core8memoriesNtB4_19MemorySectionReaderNtB8_13SectionReader5range:
   75|      2|    fn range(&self) -> Range<usize> {
   76|      2|        self.reader.range()
   77|      2|    }
_RNvMNtNtNtCs9VFM4FqidCT_10wasmparser7readers4core8memoriesNtB2_19MemorySectionReader4read:
   59|      3|    pub fn read(&mut self) -> Result<MemoryType> {
   60|      3|        self.reader.read_memory_type()
   61|      3|    }
_RNvXs_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core8memoriesNtB4_19MemorySectionReaderNtB8_13SectionReader4read:
   66|      1|    fn read(&mut self) -> Result<Self::Item> {
   67|      1|        MemorySectionReader::read(self)
   68|      1|    }

_RNvMs0_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_8FuncType7results:
  111|     20|    pub fn results(&self) -> &[ValType] {
  112|     20|        &self.params_results[self.len_params..]
  113|     20|    }
_RNvMs0_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_8FuncType6params:
  105|     20|    pub fn params(&self) -> &[ValType] {
  106|     20|        &self.params_results[..self.len_params]
  107|     20|    }
_RNvXs3_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_17TypeSectionReaderNtB9_13SectionReader4read:
  238|      5|    fn read(&mut self) -> Result<Self::Item> {
  239|      5|        Self::read(self)
  240|      5|    }
_RNvMs2_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_17TypeSectionReader4read:
  230|     20|    pub fn read(&mut self) -> Result<Type> {
  231|     20|        self.reader.read_type()
  232|     20|    }
_RNvMs0_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_8FuncType14from_raw_parts:
   95|     20|    pub(crate) fn from_raw_parts(params_results: Box<[ValType]>, len_params: usize) -> Self {
   96|     20|        assert!(len_params <= params_results.len());
   97|     20|        Self {
   98|     20|            params_results,
   99|     20|            len_params,
  100|     20|        }
  101|     20|    }
_RNvMs2_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_17TypeSectionReader3new:
  202|      4|    pub fn new(data: &'a [u8], offset: usize) -> Result<Self> {
  203|      4|        let mut reader = BinaryReader::new_with_offset(data, offset);
  204|      4|        let count = reader.read_var_u32()?;
  205|      4|        Ok(Self { reader, count })
  206|      4|    }
_RNvXs3_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_17TypeSectionReaderNtB9_13SectionReader5range:
  250|      2|    fn range(&self) -> Range<usize> {
  251|      2|        self.reader.range()
  252|      2|    }
_RNvXs3_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_17TypeSectionReaderNtB9_13SectionReader3eof:
  242|      6|    fn eof(&self) -> bool {
  243|      6|        self.reader.eof()
  244|      6|    }
_RNvMs2_NtNtNtCs9VFM4FqidCT_10wasmparser7readers4core5typesNtB5_17TypeSectionReader9get_count:
  214|      3|    pub fn get_count(&self) -> u32 {
  215|      3|        self.count
  216|      3|    }

